--- a/aclocal.m4
+++ b/aclocal.m4
@@ -13,445 +13,57 @@
 
 m4_ifndef([AC_AUTOCONF_VERSION],
   [m4_copy([m4_PACKAGE_VERSION], [AC_AUTOCONF_VERSION])])dnl
-m4_if(m4_defn([AC_AUTOCONF_VERSION]), [2.63],,
-[m4_warning([this file was generated for autoconf 2.63.
+m4_if(m4_defn([AC_AUTOCONF_VERSION]), [2.64],,
+[m4_warning([this file was generated for autoconf 2.64.
 You have another version of autoconf.  It may work, but is not guaranteed to.
 If you have problems, you may need to regenerate the build system entirely.
 To do so, use the procedure documented by the package, typically `autoreconf'.])])
 
-# Copyright (C) 1995-2002 Free Software Foundation, Inc.
-# Copyright (C) 2001-2003,2004 Red Hat, Inc.
-#
-# This file is free software, distributed under the terms of the GNU
-# General Public License.  As a special exception to the GNU General
-# Public License, this file may be distributed as part of a program
-# that contains a configuration script generated by Autoconf, under
-# the same distribution terms as the rest of that program.
-#
-# This file can be copied and used freely without restrictions.  It can
-# be used in projects which are not available under the GNU Public License
-# but which still want to provide support for the GNU gettext functionality.
-#
-# Macro to add for using GNU gettext.
-# Ulrich Drepper <drepper@cygnus.com>, 1995, 1996
-#
-# Modified to never use included libintl. 
-# Owen Taylor <otaylor@redhat.com>, 12/15/1998
-#
-# Major rework to remove unused code
-# Owen Taylor <otaylor@redhat.com>, 12/11/2002
-#
-# Added better handling of ALL_LINGUAS from GNU gettext version 
-# written by Bruno Haible, Owen Taylor <otaylor.redhat.com> 5/30/3002
-#
-# Modified to require ngettext
-# Matthias Clasen <mclasen@redhat.com> 08/06/2004
-#
-# We need this here as well, since someone might use autoconf-2.5x
-# to configure GLib then an older version to configure a package
-# using AM_GLIB_GNU_GETTEXT
-AC_PREREQ(2.53)
-
-dnl
-dnl We go to great lengths to make sure that aclocal won't 
-dnl try to pull in the installed version of these macros
-dnl when running aclocal in the glib directory.
-dnl
-m4_copy([AC_DEFUN],[glib_DEFUN])
-m4_copy([AC_REQUIRE],[glib_REQUIRE])
+dnl AM_GCONF_SOURCE_2
+dnl Defines GCONF_SCHEMA_CONFIG_SOURCE which is where you should install schemas
+dnl  (i.e. pass to gconftool-2
+dnl Defines GCONF_SCHEMA_FILE_DIR which is a filesystem directory where
+dnl  you should install foo.schemas files
 dnl
-dnl At the end, if we're not within glib, we'll define the public
-dnl definitions in terms of our private definitions.
-dnl
-
-# GLIB_LC_MESSAGES
-#--------------------
-glib_DEFUN([GLIB_LC_MESSAGES],
-  [AC_CHECK_HEADERS([locale.h])
-    if test $ac_cv_header_locale_h = yes; then
-    AC_CACHE_CHECK([for LC_MESSAGES], am_cv_val_LC_MESSAGES,
-      [AC_TRY_LINK([#include <locale.h>], [return LC_MESSAGES],
-       am_cv_val_LC_MESSAGES=yes, am_cv_val_LC_MESSAGES=no)])
-    if test $am_cv_val_LC_MESSAGES = yes; then
-      AC_DEFINE(HAVE_LC_MESSAGES, 1,
-        [Define if your <locale.h> file defines LC_MESSAGES.])
-    fi
-  fi])
 
-# GLIB_PATH_PROG_WITH_TEST
-#----------------------------
-dnl GLIB_PATH_PROG_WITH_TEST(VARIABLE, PROG-TO-CHECK-FOR,
-dnl   TEST-PERFORMED-ON-FOUND_PROGRAM [, VALUE-IF-NOT-FOUND [, PATH]])
-glib_DEFUN([GLIB_PATH_PROG_WITH_TEST],
-[# Extract the first word of "$2", so it can be a program name with args.
-set dummy $2; ac_word=[$]2
-AC_MSG_CHECKING([for $ac_word])
-AC_CACHE_VAL(ac_cv_path_$1,
-[case "[$]$1" in
-  /*)
-  ac_cv_path_$1="[$]$1" # Let the user override the test with a path.
-  ;;
-  *)
-  IFS="${IFS= 	}"; ac_save_ifs="$IFS"; IFS="${IFS}:"
-  for ac_dir in ifelse([$5], , $PATH, [$5]); do
-    test -z "$ac_dir" && ac_dir=.
-    if test -f $ac_dir/$ac_word; then
-      if [$3]; then
-	ac_cv_path_$1="$ac_dir/$ac_word"
-	break
-      fi
-    fi
-  done
-  IFS="$ac_save_ifs"
-dnl If no 4th arg is given, leave the cache variable unset,
-dnl so AC_PATH_PROGS will keep looking.
-ifelse([$4], , , [  test -z "[$]ac_cv_path_$1" && ac_cv_path_$1="$4"
-])dnl
-  ;;
-esac])dnl
-$1="$ac_cv_path_$1"
-if test ifelse([$4], , [-n "[$]$1"], ["[$]$1" != "$4"]); then
-  AC_MSG_RESULT([$]$1)
-else
-  AC_MSG_RESULT(no)
-fi
-AC_SUBST($1)dnl
-])
-
-# GLIB_WITH_NLS
-#-----------------
-glib_DEFUN([GLIB_WITH_NLS],
-  dnl NLS is obligatory
-  [USE_NLS=yes
-    AC_SUBST(USE_NLS)
-
-    gt_cv_have_gettext=no
-
-    CATOBJEXT=NONE
-    XGETTEXT=:
-    INTLLIBS=
-
-    AC_CHECK_HEADER(libintl.h,
-     [gt_cv_func_dgettext_libintl="no"
-      libintl_extra_libs=""
-
-      #
-      # First check in libc
-      #
-      AC_CACHE_CHECK([for ngettext in libc], gt_cv_func_ngettext_libc,
-        [AC_TRY_LINK([
-#include <libintl.h>
-],
-         [return !ngettext ("","", 1)],
-	  gt_cv_func_ngettext_libc=yes,
-          gt_cv_func_ngettext_libc=no)
-        ])
-  
-      if test "$gt_cv_func_ngettext_libc" = "yes" ; then
-	      AC_CACHE_CHECK([for dgettext in libc], gt_cv_func_dgettext_libc,
-        	[AC_TRY_LINK([
-#include <libintl.h>
-],
-	          [return !dgettext ("","")],
-		  gt_cv_func_dgettext_libc=yes,
-	          gt_cv_func_dgettext_libc=no)
-        	])
-      fi
-  
-      if test "$gt_cv_func_ngettext_libc" = "yes" ; then
-        AC_CHECK_FUNCS(bind_textdomain_codeset)
-      fi
-
-      #
-      # If we don't have everything we want, check in libintl
-      #
-      if test "$gt_cv_func_dgettext_libc" != "yes" \
-	 || test "$gt_cv_func_ngettext_libc" != "yes" \
-         || test "$ac_cv_func_bind_textdomain_codeset" != "yes" ; then
-        
-        AC_CHECK_LIB(intl, bindtextdomain,
-	    [AC_CHECK_LIB(intl, ngettext,
-		    [AC_CHECK_LIB(intl, dgettext,
-			          gt_cv_func_dgettext_libintl=yes)])])
-
-	if test "$gt_cv_func_dgettext_libintl" != "yes" ; then
-	  AC_MSG_CHECKING([if -liconv is needed to use gettext])
-	  AC_MSG_RESULT([])
-  	  AC_CHECK_LIB(intl, ngettext,
-          	[AC_CHECK_LIB(intl, dcgettext,
-		       [gt_cv_func_dgettext_libintl=yes
-			libintl_extra_libs=-liconv],
-			:,-liconv)],
-		:,-liconv)
-        fi
-
-        #
-        # If we found libintl, then check in it for bind_textdomain_codeset();
-        # we'll prefer libc if neither have bind_textdomain_codeset(),
-        # and both have dgettext and ngettext
-        #
-        if test "$gt_cv_func_dgettext_libintl" = "yes" ; then
-          glib_save_LIBS="$LIBS"
-          LIBS="$LIBS -lintl $libintl_extra_libs"
-          unset ac_cv_func_bind_textdomain_codeset
-          AC_CHECK_FUNCS(bind_textdomain_codeset)
-          LIBS="$glib_save_LIBS"
-
-          if test "$ac_cv_func_bind_textdomain_codeset" = "yes" ; then
-            gt_cv_func_dgettext_libc=no
-          else
-            if test "$gt_cv_func_dgettext_libc" = "yes" \
-		&& test "$gt_cv_func_ngettext_libc" = "yes"; then
-              gt_cv_func_dgettext_libintl=no
-            fi
-          fi
-        fi
-      fi
-
-      if test "$gt_cv_func_dgettext_libc" = "yes" \
-	|| test "$gt_cv_func_dgettext_libintl" = "yes"; then
-        gt_cv_have_gettext=yes
-      fi
-  
-      if test "$gt_cv_func_dgettext_libintl" = "yes"; then
-        INTLLIBS="-lintl $libintl_extra_libs"
-      fi
-  
-      if test "$gt_cv_have_gettext" = "yes"; then
-	AC_DEFINE(HAVE_GETTEXT,1,
-	  [Define if the GNU gettext() function is already present or preinstalled.])
-	GLIB_PATH_PROG_WITH_TEST(MSGFMT, msgfmt,
-	  [test -z "`$ac_dir/$ac_word -h 2>&1 | grep 'dv '`"], no)dnl
-	if test "$MSGFMT" != "no"; then
-          glib_save_LIBS="$LIBS"
-          LIBS="$LIBS $INTLLIBS"
-	  AC_CHECK_FUNCS(dcgettext)
-	  MSGFMT_OPTS=
-	  AC_MSG_CHECKING([if msgfmt accepts -c])
-	  GLIB_RUN_PROG([$MSGFMT -c -o /dev/null],[
-msgid ""
-msgstr ""
-"Content-Type: text/plain; charset=UTF-8\n"
-"Project-Id-Version: test 1.0\n"
-"PO-Revision-Date: 2007-02-15 12:01+0100\n"
-"Last-Translator: test <foo@bar.xx>\n"
-"Language-Team: C <LL@li.org>\n"
-"MIME-Version: 1.0\n"
-"Content-Transfer-Encoding: 8bit\n"
-], [MSGFMT_OPTS=-c; AC_MSG_RESULT([yes])], [AC_MSG_RESULT([no])])
-	  AC_SUBST(MSGFMT_OPTS)
-	  AC_PATH_PROG(GMSGFMT, gmsgfmt, $MSGFMT)
-	  GLIB_PATH_PROG_WITH_TEST(XGETTEXT, xgettext,
-	    [test -z "`$ac_dir/$ac_word -h 2>&1 | grep '(HELP)'`"], :)
-	  AC_TRY_LINK(, [extern int _nl_msg_cat_cntr;
-			 return _nl_msg_cat_cntr],
-	    [CATOBJEXT=.gmo 
-             DATADIRNAME=share],
-	    [case $host in
-	    *-*-solaris*)
-	    dnl On Solaris, if bind_textdomain_codeset is in libc,
-	    dnl GNU format message catalog is always supported,
-            dnl since both are added to the libc all together.
-	    dnl Hence, we'd like to go with DATADIRNAME=share and
-	    dnl and CATOBJEXT=.gmo in this case.
-            AC_CHECK_FUNC(bind_textdomain_codeset,
-	      [CATOBJEXT=.gmo 
-               DATADIRNAME=share],
-	      [CATOBJEXT=.mo
-               DATADIRNAME=lib])
-	    ;;
-	    *)
-	    CATOBJEXT=.mo
-            DATADIRNAME=lib
-	    ;;
-	    esac])
-          LIBS="$glib_save_LIBS"
-	  INSTOBJEXT=.mo
-	else
-	  gt_cv_have_gettext=no
-	fi
-      fi
-    ])
+AC_DEFUN([AM_GCONF_SOURCE_2],
+[
+  if test "x$GCONF_SCHEMA_INSTALL_SOURCE" = "x"; then
+    GCONF_SCHEMA_CONFIG_SOURCE=`gconftool-2 --get-default-source`
+  else
+    GCONF_SCHEMA_CONFIG_SOURCE=$GCONF_SCHEMA_INSTALL_SOURCE
+  fi
 
-    if test "$gt_cv_have_gettext" = "yes" ; then
-      AC_DEFINE(ENABLE_NLS, 1,
-        [always defined to indicate that i18n is enabled])
-    fi
+  AC_ARG_WITH([gconf-source],
+	      AC_HELP_STRING([--with-gconf-source=sourceaddress],
+			     [Config database for installing schema files.]),
+	      [GCONF_SCHEMA_CONFIG_SOURCE="$withval"],)
 
-    dnl Test whether we really found GNU xgettext.
-    if test "$XGETTEXT" != ":"; then
-      dnl If it is not GNU xgettext we define it as : so that the
-      dnl Makefiles still can work.
-      if $XGETTEXT --omit-header /dev/null 2> /dev/null; then
-        : ;
-      else
-        AC_MSG_RESULT(
-	  [found xgettext program is not GNU xgettext; ignore it])
-        XGETTEXT=":"
-      fi
-    fi
+  AC_SUBST(GCONF_SCHEMA_CONFIG_SOURCE)
+  AC_MSG_RESULT([Using config source $GCONF_SCHEMA_CONFIG_SOURCE for schema installation])
 
-    # We need to process the po/ directory.
-    POSUB=po
+  if test "x$GCONF_SCHEMA_FILE_DIR" = "x"; then
+    GCONF_SCHEMA_FILE_DIR='$(sysconfdir)/gconf/schemas'
+  fi
 
-    AC_OUTPUT_COMMANDS(
-      [case "$CONFIG_FILES" in *po/Makefile.in*)
-        sed -e "/POTFILES =/r po/POTFILES" po/Makefile.in > po/Makefile
+  AC_ARG_WITH([gconf-schema-file-dir],
+	      AC_HELP_STRING([--with-gconf-schema-file-dir=dir],
+			     [Directory for installing schema files.]),
+	      [GCONF_SCHEMA_FILE_DIR="$withval"],)
+
+  AC_SUBST(GCONF_SCHEMA_FILE_DIR)
+  AC_MSG_RESULT([Using $GCONF_SCHEMA_FILE_DIR as install directory for schema files])
+
+  AC_ARG_ENABLE(schemas-install,
+  	AC_HELP_STRING([--disable-schemas-install],
+		       [Disable the schemas installation]),
+     [case ${enableval} in
+       yes|no) ;;
+       *) AC_MSG_ERROR([bad value ${enableval} for --enable-schemas-install]) ;;
       esac])
-
-    dnl These rules are solely for the distribution goal.  While doing this
-    dnl we only have to keep exactly one list of the available catalogs
-    dnl in configure.in.
-    for lang in $ALL_LINGUAS; do
-      GMOFILES="$GMOFILES $lang.gmo"
-      POFILES="$POFILES $lang.po"
-    done
-
-    dnl Make all variables we use known to autoconf.
-    AC_SUBST(CATALOGS)
-    AC_SUBST(CATOBJEXT)
-    AC_SUBST(DATADIRNAME)
-    AC_SUBST(GMOFILES)
-    AC_SUBST(INSTOBJEXT)
-    AC_SUBST(INTLLIBS)
-    AC_SUBST(PO_IN_DATADIR_TRUE)
-    AC_SUBST(PO_IN_DATADIR_FALSE)
-    AC_SUBST(POFILES)
-    AC_SUBST(POSUB)
-  ])
-
-# AM_GLIB_GNU_GETTEXT
-# -------------------
-# Do checks necessary for use of gettext. If a suitable implementation 
-# of gettext is found in either in libintl or in the C library,
-# it will set INTLLIBS to the libraries needed for use of gettext
-# and AC_DEFINE() HAVE_GETTEXT and ENABLE_NLS. (The shell variable
-# gt_cv_have_gettext will be set to "yes".) It will also call AC_SUBST()
-# on various variables needed by the Makefile.in.in installed by 
-# glib-gettextize.
-dnl
-glib_DEFUN([GLIB_GNU_GETTEXT],
-  [AC_REQUIRE([AC_PROG_CC])dnl
-   AC_REQUIRE([AC_HEADER_STDC])dnl
-   
-   GLIB_LC_MESSAGES
-   GLIB_WITH_NLS
-
-   if test "$gt_cv_have_gettext" = "yes"; then
-     if test "x$ALL_LINGUAS" = "x"; then
-       LINGUAS=
-     else
-       AC_MSG_CHECKING(for catalogs to be installed)
-       NEW_LINGUAS=
-       for presentlang in $ALL_LINGUAS; do
-         useit=no
-         if test "%UNSET%" != "${LINGUAS-%UNSET%}"; then
-           desiredlanguages="$LINGUAS"
-         else
-           desiredlanguages="$ALL_LINGUAS"
-         fi
-         for desiredlang in $desiredlanguages; do
- 	   # Use the presentlang catalog if desiredlang is
-           #   a. equal to presentlang, or
-           #   b. a variant of presentlang (because in this case,
-           #      presentlang can be used as a fallback for messages
-           #      which are not translated in the desiredlang catalog).
-           case "$desiredlang" in
-             "$presentlang"*) useit=yes;;
-           esac
-         done
-         if test $useit = yes; then
-           NEW_LINGUAS="$NEW_LINGUAS $presentlang"
-         fi
-       done
-       LINGUAS=$NEW_LINGUAS
-       AC_MSG_RESULT($LINGUAS)
-     fi
-
-     dnl Construct list of names of catalog files to be constructed.
-     if test -n "$LINGUAS"; then
-       for lang in $LINGUAS; do CATALOGS="$CATALOGS $lang$CATOBJEXT"; done
-     fi
-   fi
-
-   dnl If the AC_CONFIG_AUX_DIR macro for autoconf is used we possibly
-   dnl find the mkinstalldirs script in another subdir but ($top_srcdir).
-   dnl Try to locate is.
-   MKINSTALLDIRS=
-   if test -n "$ac_aux_dir"; then
-     MKINSTALLDIRS="$ac_aux_dir/mkinstalldirs"
-   fi
-   if test -z "$MKINSTALLDIRS"; then
-     MKINSTALLDIRS="\$(top_srcdir)/mkinstalldirs"
-   fi
-   AC_SUBST(MKINSTALLDIRS)
-
-   dnl Generate list of files to be processed by xgettext which will
-   dnl be included in po/Makefile.
-   test -d po || mkdir po
-   if test "x$srcdir" != "x."; then
-     if test "x`echo $srcdir | sed 's@/.*@@'`" = "x"; then
-       posrcprefix="$srcdir/"
-     else
-       posrcprefix="../$srcdir/"
-     fi
-   else
-     posrcprefix="../"
-   fi
-   rm -f po/POTFILES
-   sed -e "/^#/d" -e "/^\$/d" -e "s,.*,	$posrcprefix& \\\\," -e "\$s/\(.*\) \\\\/\1/" \
-	< $srcdir/po/POTFILES.in > po/POTFILES
-  ])
-
-# AM_GLIB_DEFINE_LOCALEDIR(VARIABLE)
-# -------------------------------
-# Define VARIABLE to the location where catalog files will
-# be installed by po/Makefile.
-glib_DEFUN([GLIB_DEFINE_LOCALEDIR],
-[glib_REQUIRE([GLIB_GNU_GETTEXT])dnl
-glib_save_prefix="$prefix"
-glib_save_exec_prefix="$exec_prefix"
-glib_save_datarootdir="$datarootdir"
-test "x$prefix" = xNONE && prefix=$ac_default_prefix
-test "x$exec_prefix" = xNONE && exec_prefix=$prefix
-datarootdir=`eval echo "${datarootdir}"`
-if test "x$CATOBJEXT" = "x.mo" ; then
-  localedir=`eval echo "${libdir}/locale"`
-else
-  localedir=`eval echo "${datadir}/locale"`
-fi
-prefix="$glib_save_prefix"
-exec_prefix="$glib_save_exec_prefix"
-datarootdir="$glib_save_datarootdir"
-AC_DEFINE_UNQUOTED($1, "$localedir",
-  [Define the location where the catalogs will be installed])
+  AM_CONDITIONAL([GCONF_SCHEMAS_INSTALL], [test "$enable_schemas_install" != no])
 ])
 
-dnl
-dnl Now the definitions that aclocal will find
-dnl
-ifdef(glib_configure_in,[],[
-AC_DEFUN([AM_GLIB_GNU_GETTEXT],[GLIB_GNU_GETTEXT($@)])
-AC_DEFUN([AM_GLIB_DEFINE_LOCALEDIR],[GLIB_DEFINE_LOCALEDIR($@)])
-])dnl
-
-# GLIB_RUN_PROG(PROGRAM, TEST-FILE, [ACTION-IF-PASS], [ACTION-IF-FAIL])
-# 
-# Create a temporary file with TEST-FILE as its contents and pass the
-# file name to PROGRAM.  Perform ACTION-IF-PASS if PROGRAM exits with
-# 0 and perform ACTION-IF-FAIL for any other exit status.
-AC_DEFUN([GLIB_RUN_PROG],
-[cat >conftest.foo <<_ACEOF
-$2
-_ACEOF
-if AC_RUN_LOG([$1 conftest.foo]); then
-  m4_ifval([$3], [$3], [:])
-m4_ifvaln([$4], [else $4])dnl
-echo "$as_me: failed input was:" >&AS_MESSAGE_LOG_FD
-sed 's/^/| /' conftest.foo >&AS_MESSAGE_LOG_FD
-fi])
-
-
 # pkg.m4 - Macros to locate and utilise pkg-config.            -*- Autoconf -*-
 # 
 # Copyright © 2004 Scott James Remnant <scott@netsplit.com>.
@@ -520,16 +132,14 @@ fi])
 # _PKG_CONFIG([VARIABLE], [COMMAND], [MODULES])
 # ---------------------------------------------
 m4_define([_PKG_CONFIG],
-[if test -n "$PKG_CONFIG"; then
-    if test -n "$$1"; then
-        pkg_cv_[]$1="$$1"
-    else
-        PKG_CHECK_EXISTS([$3],
-                         [pkg_cv_[]$1=`$PKG_CONFIG --[]$2 "$3" 2>/dev/null`],
-			 [pkg_failed=yes])
-    fi
-else
-	pkg_failed=untried
+[if test -n "$$1"; then
+    pkg_cv_[]$1="$$1"
+ elif test -n "$PKG_CONFIG"; then
+    PKG_CHECK_EXISTS([$3],
+                     [pkg_cv_[]$1=`$PKG_CONFIG --[]$2 "$3" 2>/dev/null`],
+		     [pkg_failed=yes])
+ else
+    pkg_failed=untried
 fi[]dnl
 ])# _PKG_CONFIG
 
@@ -573,9 +183,9 @@ See the pkg-config man page for more det
 if test $pkg_failed = yes; then
         _PKG_SHORT_ERRORS_SUPPORTED
         if test $_pkg_short_errors_supported = yes; then
-	        $1[]_PKG_ERRORS=`$PKG_CONFIG --short-errors --errors-to-stdout --print-errors "$2"`
+	        $1[]_PKG_ERRORS=`$PKG_CONFIG --short-errors --print-errors "$2" 2>&1`
         else 
-	        $1[]_PKG_ERRORS=`$PKG_CONFIG --errors-to-stdout --print-errors "$2"`
+	        $1[]_PKG_ERRORS=`$PKG_CONFIG --print-errors "$2" 2>&1`
         fi
 	# Put the nasty error message in config.log where it belongs
 	echo "$$1[]_PKG_ERRORS" >&AS_MESSAGE_LOG_FD
@@ -610,7 +220,7 @@ else
 fi[]dnl
 ])# PKG_CHECK_MODULES
 
-# Copyright (C) 2002, 2003, 2005, 2006, 2007, 2008  Free Software Foundation, Inc.
+# Copyright (C) 2002, 2003, 2005, 2006, 2007  Free Software Foundation, Inc.
 #
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
@@ -1649,6 +1259,8 @@ AC_DEFUN([AM_PROG_VALAC],
           AC_MSG_ERROR([Vala $1 not found.])])])])
 ])
 
+m4_include([m4/glib-gettext.m4])
+m4_include([m4/isc-posix.m4])
 m4_include([m4/libtool.m4])
 m4_include([m4/ltoptions.m4])
 m4_include([m4/ltsugar.m4])
--- a/configure.ac
+++ b/configure.ac
@@ -21,11 +21,12 @@ AC_PROG_LIBTOOL
 AC_FUNC_MMAP
 
 VALA_REQUIRED=0.7.7
+GLIB_REQUIRED=2.21.3
 GUPNP_REQUIRED=0.13
 GUPNP_AV_REQUIRED=0.5
 GUPNP_VALA_REQUIRED=0.6
 DBUS_GLIB_REQUIRED=0.74
-GSTREAMER_REQUIRED=0.10.23
+VLC_REQUIRED=0.9.9
 GIO_REQUIRED=2.16
 GEE_REQUIRED=0.3.0
 UUID_REQUIRED=1.41.3
@@ -36,10 +37,11 @@ LIBSQLITE3_REQUIRED=3.5
 PKG_CHECK_MODULES(LIBGUPNP, gupnp-1.0 >= $GUPNP_REQUIRED)
 PKG_CHECK_MODULES(LIBGUPNP_AV, gupnp-av-1.0 >= $GUPNP_AV_REQUIRED)
 PKG_CHECK_MODULES(LIBDBUS_GLIB, dbus-glib-1 >= $DBUS_GLIB_REQUIRED)
-PKG_CHECK_MODULES(LIBGSTREAMER, gstreamer-0.10 >= $GSTREAMER_REQUIRED)
+PKG_CHECK_MODULES(LIBVLC, libvlc >= $VLC_REQUIRED) 
+PKG_CHECK_MODULES(LIBGLIB, glib-2.0 >= $GLIB_REQUIRED)
 PKG_CHECK_MODULES(LIBGIO, gio-2.0 >= $GIO_REQUIRED)
 PKG_CHECK_MODULES(GEE, gee-1.0 >= $GEE_REQUIRED)
-PKG_CHECK_MODULES(UUID, uuid >= $UUID_REQUIRED)
+#PKG_CHECK_MODULES(UUID, uuid >= $UUID_REQUIRED)
 PKG_CHECK_MODULES(LIBSOUP, libsoup-2.4 >= $LIBSOUP_REQUIRED)
 PKG_CHECK_MODULES(LIBSQLITE3, sqlite3 >= $LIBSQLITE3_REQUIRED)
 
@@ -60,37 +62,37 @@ if test x$enable_vala = xyes ; then
         AC_MSG_ERROR([Cannot find the "valac" compiler in your PATH])
     fi
 
-    PKG_CHECK_MODULES(GUPNP_VALA, gupnp-vala-1.0 >= $GUPNP_VALA_REQUIRED)
+#    PKG_CHECK_MODULES(GUPNP_VALA, gupnp-vala-1.0 >= $GUPNP_VALA_REQUIRED)
     VAPIDIR=`pkg-config --variable=vapidir vala-1.0`
 
     # FIXME: Whats the proper way for checking for particular Vala bindings
-    AC_CHECK_FILE("${VAPIDIR}/gupnp-1.0.vapi",
-                  true,
-                  [AC_MSG_ERROR("Unable to find Vala bindings for gupnp-1.0")])
-
-    AC_CHECK_FILE("${VAPIDIR}/gupnp-av-1.0.vapi",
-                  true,
-                  [AC_MSG_ERROR("Unable to find Vala bindings for gupnp-av-1.0")])
-
-    AC_CHECK_FILE("${VAPIDIR}/dbus-glib-1.vapi",
-                  true,
-                  [AC_MSG_ERROR("Unable to find Vala bindings for dbus-glib-1")])
-
-    AC_CHECK_FILE("${VAPIDIR}/gstreamer-0.10.vapi",
-                  true,
-                  [AC_MSG_ERROR("Unable to find Vala bindings for gstreamer-0.10")])
-
-    AC_CHECK_FILE("${VAPIDIR}/gio-2.0.vapi",
-                  true,
-                  [AC_MSG_ERROR("Unable to find Vala bindings for gio-2.0")])
-
-    AC_CHECK_FILE("${VAPIDIR}/gee-1.0.vapi",
-                  true,
-                  [AC_MSG_ERROR("Unable to find Vala bindings for gee-1.0")])
-
-    AC_CHECK_FILE("${VAPIDIR}/sqlite3.vapi",
-                  true,
-                  [AC_MSG_ERROR("Unable to find Vala bindings for sqlite3")])
+#    AC_CHECK_FILE("${VAPIDIR}/gupnp-1.0.vapi",
+#                  true,
+#                  [AC_MSG_ERROR("Unable to find Vala bindings for gupnp-1.0")])
+#
+#    AC_CHECK_FILE("${VAPIDIR}/gupnp-av-1.0.vapi",
+#                  true,
+#                  [AC_MSG_ERROR("Unable to find Vala bindings for gupnp-av-1.0")])
+#
+#    AC_CHECK_FILE("${VAPIDIR}/dbus-glib-1.vapi",
+#                  true,
+#                  [AC_MSG_ERROR("Unable to find Vala bindings for dbus-glib-1")])
+#
+#    AC_CHECK_FILE("${VAPIDIR}/gstreamer-0.10.vapi",
+#                  true,
+#                  [AC_MSG_ERROR("Unable to find Vala bindings for gstreamer-0.10")])
+#
+#    AC_CHECK_FILE("${VAPIDIR}/gio-2.0.vapi",
+#                  true,
+#                  [AC_MSG_ERROR("Unable to find Vala bindings for gio-2.0")])
+#
+#    AC_CHECK_FILE("${VAPIDIR}/gee-1.0.vapi",
+#                  true,
+#                  [AC_MSG_ERROR("Unable to find Vala bindings for gee-1.0")])
+#
+#    AC_CHECK_FILE("${VAPIDIR}/sqlite3.vapi",
+#                  true,
+#                  [AC_MSG_ERROR("Unable to find Vala bindings for sqlite3")])
 else
     VAPIDIR=`echo ${datadir}/vala/vapi`
 fi
@@ -202,6 +204,11 @@ AC_ARG_ENABLE(gstlaunch-plugin,
 	[  --enable-gstlaunch-plugin          build Gstreamer launchline plugin],,
         enable_gstlaunch_plugin=no)
 
+# Build GstRenderer plugin
+AC_ARG_ENABLE(gst-renderer-plugin,
+	[  --enable-gst-renderer-plugin       build renderer plugin],,
+        enable_gst_renderer_plugin=no)
+
 
 AC_SUBST(abs_top_builddir)
 
@@ -214,6 +221,7 @@ AM_CONDITIONAL([BUILD_MEDIATHEK_PLUGIN],
 AM_CONDITIONAL([BUILD_MEDIA_EXPORT_PLUGIN], [test "x$enable_media_export_plugin" = "xyes"])
 AM_CONDITIONAL([BUILD_EXTERNAL_PLUGIN], [test "x$enable_external_plugin" = "xyes"])
 AM_CONDITIONAL([BUILD_GSTLAUNCH_PLUGIN], [test "x$enable_gstlaunch_plugin" = "xyes"])
+AM_CONDITIONAL([BUILD_GST_RENDERER_PLUGIN], [test "x$enable_gst_renderer_plugin" = "xyes"])
 
 # Gettext
 GETTEXT_PACKAGE=rygel
@@ -239,6 +247,7 @@ src/plugins/external/Makefile
 src/plugins/gstlaunch/Makefile
 src/plugins/mediathek/Makefile
 src/plugins/tracker/Makefile
+src/plugins/gst-renderer/Makefile
 src/plugins/test/Makefile
 data/Makefile
 data/xml/Makefile
@@ -265,4 +274,5 @@ echo "
         media-export            ${enable_media_export_plugin}
         external:               ${enable_external_plugin}
         gstlaunch:              ${enable_gstlaunch_plugin}
+        gst-renderer:           ${enable_gst_renderer_plugin}
 "
--- /dev/null
+++ b/data/xml/AVTransport.xml
@@ -0,0 +1,483 @@
+<?xml version="1.0" encoding="utf-8"?>
+<scpd xmlns="urn:schemas-upnp-org:service-1-0">
+<specVersion>
+<major>1</major>
+<minor>0</minor>
+</specVersion>
+	<serviceStateTable>
+		<stateVariable sendEvents="no">
+			<name>TransportState</name>
+			<dataType>string</dataType>
+			<defaultValue>NO_MEDIA_PRESENT</defaultValue>
+			<allowedValueList>
+				<allowedValue>STOPPED</allowedValue>
+				<allowedValue>PLAYING</allowedValue>
+				<allowedValue>PAUSED_PLAYBACK</allowedValue>
+				<allowedValue>TRANSITIONING</allowedValue>
+				<allowedValue>NO_MEDIA_PRESENT</allowedValue>
+			</allowedValueList>
+		</stateVariable>
+		<stateVariable sendEvents="no">
+			<name>TransportStatus</name>
+			<dataType>string</dataType>
+			<defaultValue>OK</defaultValue>
+			<allowedValueList>
+				<allowedValue>OK</allowedValue>
+				<allowedValue>ERROR_OCCURRED</allowedValue>
+			</allowedValueList>
+		</stateVariable>
+		<stateVariable sendEvents="no">
+			<name>CurrentTransportActions</name>
+			<dataType>string</dataType>
+			<defaultValue></defaultValue>
+		</stateVariable>
+		<stateVariable sendEvents="no">
+			<name>PlaybackStorageMedium</name>
+			<dataType>string</dataType>
+			<defaultValue></defaultValue>
+		</stateVariable>
+		<stateVariable sendEvents="no">
+			<name>RecordStorageMedium</name>
+			<dataType>string</dataType>
+			<defaultValue></defaultValue>
+		</stateVariable>
+		<stateVariable sendEvents="no">
+			<name>PossiblePlaybackStorageMedia</name>
+			<dataType>string</dataType>
+			<defaultValue></defaultValue>
+		</stateVariable>
+		<stateVariable sendEvents="no">
+			<name>PossibleRecordStorageMedia</name>
+			<dataType>string</dataType>
+			<defaultValue></defaultValue>
+		</stateVariable>
+		<stateVariable sendEvents="no">
+			<name>CurrentPlayMode</name>
+			<dataType>string</dataType>
+			<defaultValue>NORMAL</defaultValue>
+			<allowedValueList>
+				<allowedValue>NORMAL</allowedValue>
+			</allowedValueList>
+			<defaultValue>NORMAL</defaultValue>
+		</stateVariable>
+		<stateVariable sendEvents="no">
+			<name>TransportPlaySpeed</name>
+			<dataType>string</dataType>
+			<defaultValue>1</defaultValue>
+			<allowedValueList>
+				<allowedValue>1</allowedValue>
+			</allowedValueList>
+			<defaultValue>1</defaultValue>
+		</stateVariable>
+		<stateVariable sendEvents="no">
+			<name>RecordMediumWriteStatus</name>
+			<dataType>string</dataType>
+			<defaultValue>NOT_IMPLEMENTED</defaultValue>
+			<allowedValueList>
+				<allowedValue>NOT_IMPLEMENTED</allowedValue>
+			</allowedValueList>
+		</stateVariable>
+		<stateVariable sendEvents="no">
+			<name>CurrentRecordQualityMode</name>
+			<dataType>string</dataType>
+			<defaultValue></defaultValue>
+		</stateVariable>
+		<stateVariable sendEvents="no">
+			<name>PossibleRecordQualityModes</name>
+			<dataType>string</dataType>
+			<defaultValue></defaultValue>
+		</stateVariable>
+		<stateVariable sendEvents="no">
+			<name>NumberOfTracks</name>
+			<dataType>ui4</dataType>
+			<defaultValue>0</defaultValue>
+			<allowedValueRange>
+				<minimum>0</minimum>
+				<maximum>1</maximum>
+			</allowedValueRange>
+		</stateVariable>
+		<stateVariable sendEvents="no">
+			<name>CurrentTrack</name>
+			<dataType>ui4</dataType>
+			<defaultValue>0</defaultValue>
+			<allowedValueRange>
+				<minimum>0</minimum>
+				<maximum>1</maximum>
+				<step>1</step>
+			</allowedValueRange>
+		</stateVariable>
+		<stateVariable sendEvents="no">
+			<name>CurrentTrackDuration</name>
+			<dataType>string</dataType>
+			<defaultValue>00:00:00</defaultValue>
+		</stateVariable>
+		<stateVariable sendEvents="no">
+			<name>CurrentMediaDuration</name>
+			<dataType>string</dataType>
+			<defaultValue>00:00:00</defaultValue>
+		</stateVariable>
+		<stateVariable sendEvents="no">
+			<name>CurrentTrackMetaData</name>
+			<dataType>string</dataType>
+			<defaultValue></defaultValue>
+		</stateVariable>
+		<stateVariable sendEvents="no">
+			<name>AVTransportURIMetaData</name>
+			<dataType>string</dataType>
+			<defaultValue></defaultValue>
+		</stateVariable>
+		<stateVariable sendEvents="no">
+			<name>CurrentTrackURI</name>
+			<dataType>string</dataType>
+			<defaultValue></defaultValue>
+		</stateVariable>
+		<stateVariable sendEvents="no">
+			<name>AVTransportURI</name>
+			<dataType>string</dataType>
+			<defaultValue></defaultValue>
+		</stateVariable>
+		<stateVariable sendEvents="no">
+			<name>NextAVTransportURI</name>
+			<dataType>string</dataType>
+			<defaultValue></defaultValue>
+		</stateVariable>
+		<stateVariable sendEvents="no">
+			<name>NextAVTransportURIMetaData</name>
+			<dataType>string</dataType>
+			<defaultValue></defaultValue>
+		</stateVariable>
+		<stateVariable sendEvents="no">
+			<name>RelativeTimePosition</name>
+			<dataType>string</dataType>
+			<defaultValue>00:00:00</defaultValue>
+		</stateVariable>
+		<stateVariable sendEvents="no">
+			<name>AbsoluteTimePosition</name>
+			<dataType>string</dataType>
+			<defaultValue>00:00:00</defaultValue>
+		</stateVariable>
+		<stateVariable sendEvents="no">
+			<name>RelativeCounterPosition</name>
+			<dataType>i4</dataType>
+			<defaultValue>0</defaultValue>
+		</stateVariable>
+		<stateVariable sendEvents="no">
+			<name>AbsoluteCounterPosition</name>
+			<dataType>i4</dataType>
+			<defaultValue>0</defaultValue>
+		</stateVariable>
+		<stateVariable sendEvents="yes">
+			<name>LastChange</name>
+			<dataType>string</dataType>
+			<defaultValue></defaultValue>
+		</stateVariable>
+		<stateVariable sendEvents="no">
+			<name>A_ARG_TYPE_SeekMode</name>
+			<dataType>string</dataType>
+			<defaultValue>ABS_TIME</defaultValue>
+			<allowedValueList>
+				<allowedValue>ABS_TIME</allowedValue>
+				<allowedValue>REL_TIME</allowedValue>
+				<allowedValue>TRACK_NR</allowedValue>
+			</allowedValueList>
+		</stateVariable>
+		<stateVariable sendEvents="no">
+			<name>A_ARG_TYPE_SeekTarget</name>
+			<dataType>string</dataType>
+			<defaultValue></defaultValue>
+		</stateVariable>
+		<stateVariable sendEvents="no">
+			<name>A_ARG_TYPE_InstanceID</name>
+			<dataType>ui4</dataType>
+			<defaultValue>0</defaultValue>
+		</stateVariable>
+	</serviceStateTable>
+	<actionList>
+		<action>
+			<name>SetAVTransportURI</name>
+			<argumentList>
+				<argument>
+					<name>InstanceID</name>
+					<direction>in</direction>
+					<relatedStateVariable>A_ARG_TYPE_InstanceID</relatedStateVariable>
+				</argument>
+				<argument>
+					<name>CurrentURI</name>
+					<direction>in</direction>
+					<relatedStateVariable>AVTransportURI</relatedStateVariable>
+				</argument>
+				<argument>
+					<name>CurrentURIMetaData</name>
+					<direction>in</direction>
+					<relatedStateVariable>AVTransportURIMetaData</relatedStateVariable>
+				</argument>
+			</argumentList>
+		</action>
+		<action>
+			<name>GetCurrentTransportActions</name>
+			<argumentList>
+				<argument>
+					<name>InstanceID</name>
+					<direction>in</direction>
+					<relatedStateVariable>A_ARG_TYPE_InstanceID</relatedStateVariable>
+				</argument>
+				<argument>
+					<name>Actions</name>
+					<direction>out</direction>
+					<relatedStateVariable>CurrentTransportActions</relatedStateVariable>
+				</argument>
+			</argumentList>
+		</action>
+		<action>
+			<name>GetMediaInfo</name>
+			<argumentList>
+				<argument>
+					<name>InstanceID</name>
+					<direction>in</direction>
+					<relatedStateVariable>A_ARG_TYPE_InstanceID</relatedStateVariable>
+				</argument>
+				<argument>
+					<name>NrTracks</name>
+					<direction>out</direction>
+					<relatedStateVariable>NumberOfTracks</relatedStateVariable>
+				</argument>
+				<argument>
+					<name>MediaDuration</name>
+					<direction>out</direction>
+					<relatedStateVariable>CurrentMediaDuration</relatedStateVariable>
+				</argument>
+				<argument>
+					<name>CurrentURI</name>
+					<direction>out</direction>
+					<relatedStateVariable>AVTransportURI</relatedStateVariable>
+				</argument>
+				<argument>
+					<name>CurrentURIMetaData</name>
+					<direction>out</direction>
+					<relatedStateVariable>AVTransportURIMetaData</relatedStateVariable>
+				</argument>
+				<argument>
+					<name>NextURI</name>
+					<direction>out</direction>
+					<relatedStateVariable>NextAVTransportURI</relatedStateVariable>
+				</argument>
+				<argument>
+					<name>NextURIMetaData</name>
+					<direction>out</direction>
+					<relatedStateVariable>NextAVTransportURIMetaData</relatedStateVariable>
+				</argument>
+				<argument>
+					<name>PlayMedium</name>
+					<direction>out</direction>
+					<relatedStateVariable>PlaybackStorageMedium</relatedStateVariable>
+				</argument>
+				<argument>
+					<name>RecordMedium</name>
+					<direction>out</direction>
+					<relatedStateVariable>RecordStorageMedium</relatedStateVariable>
+				</argument>
+				<argument>
+					<name>WriteStatus</name>
+					<direction>out</direction>
+					<relatedStateVariable>RecordMediumWriteStatus</relatedStateVariable>
+				</argument>
+			</argumentList>
+		</action>
+		<action>
+			<name>GetTransportInfo</name>
+			<argumentList>
+				<argument>
+					<name>InstanceID</name>
+					<direction>in</direction>
+					<relatedStateVariable>A_ARG_TYPE_InstanceID</relatedStateVariable>
+				</argument>
+				<argument>
+					<name>CurrentTransportState</name>
+					<direction>out</direction>
+					<relatedStateVariable>TransportState</relatedStateVariable>
+				</argument>
+				<argument>
+					<name>CurrentTransportStatus</name>
+					<direction>out</direction>
+					<relatedStateVariable>TransportStatus</relatedStateVariable>
+				</argument>
+				<argument>
+					<name>CurrentSpeed</name>
+					<direction>out</direction>
+					<relatedStateVariable>TransportPlaySpeed</relatedStateVariable>
+				</argument>
+			</argumentList>
+		</action>
+		<action>
+			<name>GetPositionInfo</name>
+			<argumentList>
+				<argument>
+					<name>InstanceID</name>
+					<direction>in</direction>
+					<relatedStateVariable>A_ARG_TYPE_InstanceID</relatedStateVariable>
+				</argument>
+				<argument>
+					<name>Track</name>
+					<direction>out</direction>
+					<relatedStateVariable>CurrentTrack</relatedStateVariable>
+				</argument>
+				<argument>
+					<name>TrackDuration</name>
+					<direction>out</direction>
+					<relatedStateVariable>CurrentTrackDuration</relatedStateVariable>
+				</argument>
+				<argument>
+					<name>TrackMetaData</name>
+					<direction>out</direction>
+					<relatedStateVariable>CurrentTrackMetaData</relatedStateVariable>
+				</argument>
+				<argument>
+					<name>TrackURI</name>
+					<direction>out</direction>
+					<relatedStateVariable>CurrentTrackURI</relatedStateVariable>
+				</argument>
+				<argument>
+					<name>RelTime</name>
+					<direction>out</direction>
+					<relatedStateVariable>RelativeTimePosition</relatedStateVariable>
+				</argument>
+				<argument>
+					<name>AbsTime</name>
+					<direction>out</direction>
+					<relatedStateVariable>AbsoluteTimePosition</relatedStateVariable>
+				</argument>
+				<argument>
+					<name>RelCount</name>
+					<direction>out</direction>
+					<relatedStateVariable>RelativeCounterPosition</relatedStateVariable>
+				</argument>
+				<argument>
+					<name>AbsCount</name>
+					<direction>out</direction>
+					<relatedStateVariable>AbsoluteCounterPosition</relatedStateVariable>
+				</argument>
+			</argumentList>
+		</action>
+		<action>
+			<name>GetDeviceCapabilities</name>
+			<argumentList>
+				<argument>
+					<name>InstanceID</name>
+					<direction>in</direction>
+					<relatedStateVariable>A_ARG_TYPE_InstanceID</relatedStateVariable>
+				</argument>
+				<argument>
+					<name>PlayMedia</name>
+					<direction>out</direction>
+					<relatedStateVariable>PossiblePlaybackStorageMedia</relatedStateVariable>
+				</argument>
+				<argument>
+					<name>RecMedia</name>
+					<direction>out</direction>
+					<relatedStateVariable>PossibleRecordStorageMedia</relatedStateVariable>
+				</argument>
+				<argument>
+					<name>RecQualityModes</name>
+					<direction>out</direction>
+					<relatedStateVariable>PossibleRecordQualityModes</relatedStateVariable>
+				</argument>
+			</argumentList>
+		</action>
+		<action>
+			<name>GetTransportSettings</name>
+			<argumentList>
+				<argument>
+					<name>InstanceID</name>
+					<direction>in</direction>
+					<relatedStateVariable>A_ARG_TYPE_InstanceID</relatedStateVariable>
+				</argument>
+				<argument>
+					<name>PlayMode</name>
+					<direction>out</direction>
+					<relatedStateVariable>CurrentPlayMode</relatedStateVariable>
+				</argument>
+				<argument>
+					<name>RecQualityMode</name>
+					<direction>out</direction>
+					<relatedStateVariable>CurrentRecordQualityMode</relatedStateVariable>
+				</argument>
+			</argumentList>
+		</action>
+		<action>
+			<name>Stop</name>
+			<argumentList>
+				<argument>
+					<name>InstanceID</name>
+					<direction>in</direction>
+					<relatedStateVariable>A_ARG_TYPE_InstanceID</relatedStateVariable>
+				</argument>
+			</argumentList>
+		</action>
+		<action>
+			<name>Play</name>
+			<argumentList>
+				<argument>
+					<name>InstanceID</name>
+					<direction>in</direction>
+					<relatedStateVariable>A_ARG_TYPE_InstanceID</relatedStateVariable>
+				</argument>
+				<argument>
+					<name>Speed</name>
+					<direction>in</direction>
+					<relatedStateVariable>TransportPlaySpeed</relatedStateVariable>
+				</argument>
+			</argumentList>
+		</action>
+		<action>
+			<name>Pause</name>
+			<argumentList>
+				<argument>
+					<name>InstanceID</name>
+					<direction>in</direction>
+					<relatedStateVariable>A_ARG_TYPE_InstanceID</relatedStateVariable>
+				</argument>
+			</argumentList>
+		</action>
+		<action>
+			<name>Seek</name>
+			<argumentList>
+				<argument>
+					<name>InstanceID</name>
+					<direction>in</direction>
+					<relatedStateVariable>A_ARG_TYPE_InstanceID</relatedStateVariable>
+				</argument>
+				<argument>
+					<name>Unit</name>
+					<direction>in</direction>
+					<relatedStateVariable>A_ARG_TYPE_SeekMode</relatedStateVariable>
+				</argument>
+				<argument>
+					<name>Target</name>
+					<direction>in</direction>
+					<relatedStateVariable>A_ARG_TYPE_SeekTarget</relatedStateVariable>
+				</argument>
+			</argumentList>
+		</action>
+		<action>
+			<name>Next</name>
+			<argumentList>
+				<argument>
+					<name>InstanceID</name>
+					<direction>in</direction>
+					<relatedStateVariable>A_ARG_TYPE_InstanceID</relatedStateVariable>
+				</argument>
+			</argumentList>
+		</action>
+		<action>
+			<name>Previous</name>
+			<argumentList>
+				<argument>
+					<name>InstanceID</name>
+					<direction>in</direction>
+					<relatedStateVariable>A_ARG_TYPE_InstanceID</relatedStateVariable>
+				</argument>
+			</argumentList>
+		</action>
+	</actionList>
+</scpd>
+
--- a/data/xml/ConnectionManager.xml
+++ b/data/xml/ConnectionManager.xml
@@ -1,217 +1,142 @@
-<?xml version="1.0"?>
-<!--============================================================
-Title: UPnP AV Connection Manager Service (CM) Template
-
-Purpose:
-To identify the required/optional actions and state variables
-and the required allowed values defined by this service type.
-
-Note:
-This file uses tabs (not spaces) for block indentation.
-Any updates to this file should maintain this convention.
-This includes disabling any automatic tab-to-space conversion
-feature provided by your editor.
-================================================================-->
+<?xml version="1.0" encoding="utf-8"?>
 <scpd xmlns="urn:schemas-upnp-org:service-1-0">
-	<serviceStateTable>
-		<stateVariable>
-			<name>SourceProtocolInfo</name>
-			<sendEventsAttribute>yes</sendEventsAttribute>
-			<dataType>string</dataType>
-		</stateVariable>
-
-		<stateVariable>
-			<name>SinkProtocolInfo</name>
-			<sendEventsAttribute>yes</sendEventsAttribute>
-			<dataType>string</dataType>
-		</stateVariable>
-
-		<stateVariable>
-			<name>CurrentConnectionIDs</name>
-			<sendEventsAttribute>yes</sendEventsAttribute>
-			<dataType>string</dataType>
-		</stateVariable>
-
-		<stateVariable>
-			<name>A_ARG_TYPE_ConnectionStatus</name>
-			<sendEventsAttribute>no</sendEventsAttribute>
-			<dataType>string</dataType>
-			<allowedValueList>
-				<allowedValue>OK</allowedValue>
-				<allowedValue>ContentFormatMismatch</allowedValue>
-				<allowedValue>InsufficientBandwidth</allowedValue>
-				<allowedValue>UnreliableChannel</allowedValue>
-				<allowedValue>Unknown</allowedValue>
-			</allowedValueList>
-		</stateVariable>
-
-		<stateVariable>
-			<name>A_ARG_TYPE_ConnectionManager</name>
-			<sendEventsAttribute>no</sendEventsAttribute>
-			<dataType>string</dataType>
-		</stateVariable>
-
-		<stateVariable>
-			<name>A_ARG_TYPE_Direction</name>
-			<sendEventsAttribute>no</sendEventsAttribute>
-			<dataType>string</dataType>
-			<allowedValueList>
-				<allowedValue>Input</allowedValue>
-				<allowedValue>Output</allowedValue>
-			</allowedValueList>
-		</stateVariable>
-
-		<stateVariable>
-			<name>A_ARG_TYPE_ProtocolInfo</name>
-			<sendEventsAttribute>no</sendEventsAttribute>
-			<dataType>string</dataType>
-		</stateVariable>
-
-		<stateVariable>
-			<name>A_ARG_TYPE_ConnectionID</name>
-			<sendEventsAttribute>no</sendEventsAttribute>
-			<dataType>i4</dataType>
-		</stateVariable>
-
-		<stateVariable>
-			<name>A_ARG_TYPE_AVTransportID</name>
-			<sendEventsAttribute>no</sendEventsAttribute>
-			<dataType>i4</dataType>
-		</stateVariable>
-
-		<stateVariable>
-			<name>A_ARG_TYPE_RcsID</name>
-			<sendEventsAttribute>no</sendEventsAttribute>
-			<dataType>i4</dataType>
-		</stateVariable>
-	</serviceStateTable>
-
-	<actionList>
-		<action>
-			<name>GetProtocolInfo</name>
-			<argumentList>
-				<argument>
-					<name>Source</name>
-					<direction>out</direction>
-					<relatedStateVariable>SourceProtocolInfo</relatedStateVariable>
-				</argument>
-				<argument>
-					<name>Sink</name>
-					<direction>out</direction>
-					<relatedStateVariable>SinkProtocolInfo</relatedStateVariable>
-				</argument>
-			</argumentList>
-		</action>
-
-		<action>
-			<Optional/>
-			<name>PrepareForConnection</name>
-			<argumentList>
-				<argument>
-					<name>RemoteProtocolInfo</name>
-					<direction>in</direction>
-					<relatedStateVariable>A_ARG_TYPE_ProtocolInfo</relatedStateVariable>
-				</argument>
-				<argument>
-					<name>PeerConnectionManager</name>
-					<direction>in</direction>
-					<relatedStateVariable>A_ARG_TYPE_ConnectionManager</relatedStateVariable>
-				</argument>
-				<argument>
-					<name>PeerConnectionID</name>
-					<direction>in</direction>
-					<relatedStateVariable>A_ARG_TYPE_ConnectionID</relatedStateVariable>
-				</argument>
-				<argument>
-					<name>Direction</name>
-					<direction>in</direction>
-					<relatedStateVariable>A_ARG_TYPE_Direction</relatedStateVariable>
-				</argument>
-				<argument>
-					<name>ConnectionID</name>
-					<direction>out</direction>
-					<relatedStateVariable>A_ARG_TYPE_ConnectionID</relatedStateVariable>
-				</argument>
-				<argument>
-					<name>AVTransportID</name>
-					<direction>out</direction>
-					<relatedStateVariable>A_ARG_TYPE_AVTransportID</relatedStateVariable>
-				</argument>
-				<argument>
-					<name>RcsID</name>
-					<direction>out</direction>
-					<relatedStateVariable>A_ARG_TYPE_RcsID</relatedStateVariable>
-				</argument>
-			</argumentList>
-		</action>
-
-		<action>
-			<Optional/>
-			<name>ConnectionComplete</name>
-			<argumentList>
-				<argument>
-					<name>ConnectionID</name>
-					<direction>in</direction>
-					<relatedStateVariable>A_ARG_TYPE_ConnectionID</relatedStateVariable>
-				</argument>
-			</argumentList>
-		</action>
-
-		<action>
-			<name>GetCurrentConnectionIDs</name>
-			<argumentList>
-				<argument>
-					<name>ConnectionIDs</name>
-					<direction>out</direction>
-					<relatedStateVariable>CurrentConnectionIDs</relatedStateVariable>
-				</argument>
-			</argumentList>
-		</action>
-
-		<action>
-			<name>GetCurrentConnectionInfo</name>
-			<argumentList>
-				<argument>
-					<name>ConnectionID</name>
-					<direction>in</direction>
-					<relatedStateVariable>A_ARG_TYPE_ConnectionID</relatedStateVariable>
-				</argument>
-				<argument>
-					<name>RcsID</name>
-					<direction>out</direction>
-					<relatedStateVariable>A_ARG_TYPE_RcsID</relatedStateVariable>
-				</argument>
-				<argument>
-					<name>AVTransportID</name>
-					<direction>out</direction>
-					<relatedStateVariable>A_ARG_TYPE_AVTransportID</relatedStateVariable>
-				</argument>
-				<argument>
-					<name>ProtocolInfo</name>
-					<direction>out</direction>
-					<relatedStateVariable>A_ARG_TYPE_ProtocolInfo</relatedStateVariable>
-				</argument>
-				<argument>
-					<name>PeerConnectionManager</name>
-					<direction>out</direction>
-					<relatedStateVariable>A_ARG_TYPE_ConnectionManager</relatedStateVariable>
-				</argument>
-				<argument>
-					<name>PeerConnectionID</name>
-					<direction>out</direction>
-					<relatedStateVariable>A_ARG_TYPE_ConnectionID</relatedStateVariable>
-				</argument>
-				<argument>
-					<name>Direction</name>
-					<direction>out</direction>
-					<relatedStateVariable>A_ARG_TYPE_Direction</relatedStateVariable>
-				</argument>
-				<argument>
-					<name>Status</name>
-					<direction>out</direction>
-					<relatedStateVariable>A_ARG_TYPE_ConnectionStatus</relatedStateVariable>
-				</argument>
-			</argumentList>
-		</action>
-	</actionList>
+<specVersion>
+<major>1</major>
+<minor>0</minor>
+</specVersion>
+	<serviceStateTable>
+		<stateVariable sendEvents="yes">
+			<name>SourceProtocolInfo</name>
+			<dataType>string</dataType>
+			<defaultValue></defaultValue>
+		</stateVariable>
+		<stateVariable sendEvents="yes">
+			<name>SinkProtocolInfo</name>
+			<dataType>string</dataType>
+			<defaultValue></defaultValue>
+		</stateVariable>
+		<stateVariable sendEvents="yes">
+			<name>CurrentConnectionIDs</name>
+			<dataType>string</dataType>
+			<defaultValue></defaultValue>
+		</stateVariable>
+		<stateVariable sendEvents="no">
+			<name>A_ARG_TYPE_ConnectionStatus</name>
+			<dataType>string</dataType>
+			<defaultValue>Unknown</defaultValue>
+			<allowedValueList>
+				<allowedValue>OK</allowedValue>
+				<allowedValue>ContentFormatMismatch</allowedValue>
+				<allowedValue>InsufficientBandwidth</allowedValue>
+				<allowedValue>UnreliableChannel</allowedValue>
+				<allowedValue>Unknown</allowedValue>
+			</allowedValueList>
+		</stateVariable>
+		<stateVariable sendEvents="no">
+			<name>A_ARG_TYPE_ConnectionManager</name>
+			<dataType>string</dataType>
+			<defaultValue></defaultValue>
+		</stateVariable>
+		<stateVariable sendEvents="no">
+			<name>A_ARG_TYPE_Direction</name>
+			<dataType>string</dataType>
+			<defaultValue></defaultValue>
+			<allowedValueList>
+				<allowedValue>Input</allowedValue>
+				<allowedValue>Output</allowedValue>
+			</allowedValueList>
+		</stateVariable>
+		<stateVariable sendEvents="no">
+			<name>A_ARG_TYPE_ProtocolInfo</name>
+			<dataType>string</dataType>
+			<defaultValue></defaultValue>
+		</stateVariable>
+		<stateVariable sendEvents="no">
+			<name>A_ARG_TYPE_ConnectionID</name>
+			<dataType>i4</dataType>
+			<defaultValue>0</defaultValue>
+		</stateVariable>
+		<stateVariable sendEvents="no">
+			<name>A_ARG_TYPE_AVTransportID</name>
+			<dataType>i4</dataType>
+			<defaultValue>0</defaultValue>
+		</stateVariable>
+		<stateVariable sendEvents="no">
+			<name>A_ARG_TYPE_RcsID</name>
+			<dataType>i4</dataType>
+			<defaultValue>0</defaultValue>
+		</stateVariable>
+	</serviceStateTable>
+	<actionList>
+		<action>
+			<name>GetProtocolInfo</name>
+			<argumentList>
+				<argument>
+					<name>Source</name>
+					<direction>out</direction>
+					<relatedStateVariable>SourceProtocolInfo</relatedStateVariable>
+				</argument>
+				<argument>
+					<name>Sink</name>
+					<direction>out</direction>
+					<relatedStateVariable>SinkProtocolInfo</relatedStateVariable>
+				</argument>
+			</argumentList>
+		</action>
+		<action>
+			<name>GetCurrentConnectionIDs</name>
+			<argumentList>
+				<argument>
+					<name>ConnectionIDs</name>
+					<direction>out</direction>
+					<relatedStateVariable>CurrentConnectionIDs</relatedStateVariable>
+				</argument>
+			</argumentList>
+		</action>
+		<action>
+			<name>GetCurrentConnectionInfo</name>
+			<argumentList>
+				<argument>
+					<name>ConnectionID</name>
+					<direction>in</direction>
+					<relatedStateVariable>A_ARG_TYPE_ConnectionID</relatedStateVariable>
+				</argument>
+				<argument>
+					<name>RcsID</name>
+					<direction>out</direction>
+					<relatedStateVariable>A_ARG_TYPE_RcsID</relatedStateVariable>
+				</argument>
+				<argument>
+					<name>AVTransportID</name>
+					<direction>out</direction>
+					<relatedStateVariable>A_ARG_TYPE_AVTransportID</relatedStateVariable>
+				</argument>
+				<argument>
+					<name>ProtocolInfo</name>
+					<direction>out</direction>
+					<relatedStateVariable>A_ARG_TYPE_ProtocolInfo</relatedStateVariable>
+				</argument>
+				<argument>
+					<name>PeerConnectionManager</name>
+					<direction>out</direction>
+					<relatedStateVariable>A_ARG_TYPE_ConnectionManager</relatedStateVariable>
+				</argument>
+				<argument>
+					<name>PeerConnectionID</name>
+					<direction>out</direction>
+					<relatedStateVariable>A_ARG_TYPE_ConnectionID</relatedStateVariable>
+				</argument>
+				<argument>
+					<name>Direction</name>
+					<direction>out</direction>
+					<relatedStateVariable>A_ARG_TYPE_Direction</relatedStateVariable>
+				</argument>
+				<argument>
+					<name>Status</name>
+					<direction>out</direction>
+					<relatedStateVariable>A_ARG_TYPE_ConnectionStatus</relatedStateVariable>
+				</argument>
+			</argumentList>
+		</action>
+	</actionList>
 </scpd>
--- a/data/xml/Makefile.am
+++ b/data/xml/Makefile.am
@@ -1,6 +1,9 @@
 xml_DATA = MediaServer2.xml \
+	   MediaRenderer.xml \
 	   ContentDirectory.xml \
-	   ConnectionManager.xml
+	   ConnectionManager.xml \
+	   AVTransport.xml \
+	   RenderingControl.xml
 
 xmldir = $(datadir)/rygel/xml
 
--- /dev/null
+++ b/data/xml/MediaRenderer.xml
@@ -0,0 +1,59 @@
+<?xml version="1.0" encoding="utf-8"?>
+<root xmlns="urn:schemas-upnp-org:device-1-0" xmlns:dlna="urn:schemas-dlna-org:device-1-0"
+      xmlns:pnpx="http://schemas.microsoft.com/windows/pnpx/2005/11" 
+      xmlns:df="http://schemas.microsoft.com/windows/2008/09/devicefoundation">
+	<specVersion>
+		<major>1</major>
+		<minor>0</minor>
+	</specVersion>
+	<device>
+		<presentationURL></presentationURL>
+		<deviceType>urn:schemas-upnp-org:device:MediaRenderer:1</deviceType>
+		<friendlyName>Skifta Audio Module</friendlyName>
+		<manufacturer>Qualcomm Atheros</manufacturer>
+		<manufacturerURL>http://www.atheros.com</manufacturerURL>
+		<modelName>Skifta Audio Module</modelName>
+		<modelNumber>1.0</modelNumber>
+		<modelDescription>Skifta Audio Module</modelDescription>
+		<modelURL>http://www.atheros.com</modelURL>
+		<UDN></UDN>
+		<serviceList>
+		</serviceList>
+		<dlna:X_DLNADOC>DMR-1.50</dlna:X_DLNADOC>
+		<dlna:X_DLNACAP></dlna:X_DLNACAP>
+		<pnpx:X_compatibleId>MS_DigitalMediaDeviceClass_DMR_V001</pnpx:X_compatibleId>
+		<pnpx:X_deviceCategory>MediaDevices MediaDevices.Speakers</pnpx:X_deviceCategory>
+		<pnpx:X_hardwareId>VEN_0033&amp;DEV_0003&amp;REV_10</pnpx:X_hardwareId>
+		<df:X_deviceCategory>Multimedia.DMR Audio.Speakers.Wireless</df:X_deviceCategory>
+		<iconList>
+			<icon>
+				<mimetype>image/jpeg</mimetype>
+				<width>48</width>
+				<height>48</height>
+				<depth>24</depth>
+				<url>xml/Skifta_icon_SM.jpg</url>
+			</icon>
+			<icon>
+				<mimetype>image/jpeg</mimetype>
+				<width>120</width>
+				<height>120</height>
+				<depth>24</depth>
+				<url>xml/Skifta_icon_LRG.jpg</url>
+			</icon>
+			<icon>
+				<mimetype>image/png</mimetype>
+				<width>48</width>
+				<height>48</height>
+				<depth>24</depth>
+				<url>xml/Skifta_icon_SM.png</url>
+			</icon>
+			<icon>
+				<mimetype>image/png</mimetype>
+				<width>120</width>
+				<height>120</height>
+				<depth>24</depth>
+				<url>xml/Skifta_icon_LRG.png</url>
+			</icon>
+		</iconList>
+	</device>
+</root>
--- /dev/null
+++ b/data/xml/RenderingControl.xml
@@ -0,0 +1,167 @@
+<?xml version="1.0" encoding="utf-8"?>
+<scpd xmlns="urn:schemas-upnp-org:service-1-0">
+<specVersion>
+<major>1</major>
+<minor>0</minor>
+</specVersion>
+	<serviceStateTable>
+		<stateVariable sendEvents="yes">
+			<name>LastChange</name>
+			<dataType>string</dataType>
+			<defaultValue></defaultValue>
+		</stateVariable>
+		<stateVariable sendEvents="no">
+			<name>PresetNameList</name>
+			<dataType>string</dataType>
+			<defaultValue></defaultValue>
+		</stateVariable>
+		<stateVariable sendEvents="no">
+			<name>Mute</name>
+			<dataType>boolean</dataType>
+			<defaultValue>0</defaultValue>
+		</stateVariable>
+		<stateVariable sendEvents="no">
+			<name>Volume</name>
+			<dataType>ui2</dataType>
+			<defaultValue>50</defaultValue>
+			<allowedValueRange>
+				<minimum>0</minimum>
+				<maximum>100</maximum>
+				<step>1</step>
+			</allowedValueRange>
+		</stateVariable>
+		<stateVariable sendEvents="no">
+			<name>A_ARG_TYPE_Channel</name>
+			<dataType>string</dataType>
+			<defaultValue>Master</defaultValue>
+			<allowedValueList>
+				<allowedValue>Master</allowedValue>
+			</allowedValueList>
+		</stateVariable>
+		<stateVariable sendEvents="no">
+			<name>A_ARG_TYPE_InstanceID</name>
+			<dataType>ui4</dataType>
+			<defaultValue>0</defaultValue>
+		</stateVariable>
+		<stateVariable sendEvents="no">
+			<name>A_ARG_TYPE_PresetName</name>
+			<dataType>string</dataType>
+			<defaultValue>FactoryDefaults</defaultValue>
+			<allowedValueList>
+				<allowedValue>FactoryDefaults</allowedValue>
+			</allowedValueList>
+		</stateVariable>
+	</serviceStateTable>
+	<actionList>
+		<action>
+			<name>ListPresets</name>
+			<argumentList>
+				<argument>
+					<name>InstanceID</name>
+					<direction>in</direction>
+					<relatedStateVariable>A_ARG_TYPE_InstanceID</relatedStateVariable>
+				</argument>
+				<argument>
+					<name>CurrentPresetNameList</name>
+					<direction>out</direction>
+					<relatedStateVariable>PresetNameList</relatedStateVariable>
+				</argument>
+			</argumentList>
+		</action>
+		<action>
+			<name>SelectPreset</name>
+			<argumentList>
+				<argument>
+					<name>InstanceID</name>
+					<direction>in</direction>
+					<relatedStateVariable>A_ARG_TYPE_InstanceID</relatedStateVariable>
+				</argument>
+				<argument>
+					<name>PresetName</name>
+					<direction>in</direction>
+					<relatedStateVariable>A_ARG_TYPE_PresetName</relatedStateVariable>
+				</argument>
+			</argumentList>
+		</action>
+		<action>
+			<name>GetMute</name>
+			<argumentList>
+				<argument>
+					<name>InstanceID</name>
+					<direction>in</direction>
+					<relatedStateVariable>A_ARG_TYPE_InstanceID</relatedStateVariable>
+				</argument>
+				<argument>
+					<name>Channel</name>
+					<direction>in</direction>
+					<relatedStateVariable>A_ARG_TYPE_Channel</relatedStateVariable>
+				</argument>
+				<argument>
+					<name>CurrentMute</name>
+					<direction>out</direction>
+					<relatedStateVariable>Mute</relatedStateVariable>
+				</argument>
+			</argumentList>
+		</action>
+		<action>
+			<name>SetMute</name>
+			<argumentList>
+				<argument>
+					<name>InstanceID</name>
+					<direction>in</direction>
+					<relatedStateVariable>A_ARG_TYPE_InstanceID</relatedStateVariable>
+				</argument>
+				<argument>
+					<name>Channel</name>
+					<direction>in</direction>
+					<relatedStateVariable>A_ARG_TYPE_Channel</relatedStateVariable>
+				</argument>
+				<argument>
+					<name>DesiredMute</name>
+					<direction>in</direction>
+					<relatedStateVariable>Mute</relatedStateVariable>
+				</argument>
+			</argumentList>
+		</action>
+		<action>
+			<name>GetVolume</name>
+			<argumentList>
+				<argument>
+					<name>InstanceID</name>
+					<direction>in</direction>
+					<relatedStateVariable>A_ARG_TYPE_InstanceID</relatedStateVariable>
+				</argument>
+				<argument>
+					<name>Channel</name>
+					<direction>in</direction>
+					<relatedStateVariable>A_ARG_TYPE_Channel</relatedStateVariable>
+				</argument>
+				<argument>
+					<name>CurrentVolume</name>
+					<direction>out</direction>
+					<relatedStateVariable>Volume</relatedStateVariable>
+				</argument>
+			</argumentList>
+		</action>
+		<action>
+			<name>SetVolume</name>
+			<argumentList>
+				<argument>
+					<name>InstanceID</name>
+					<direction>in</direction>
+					<relatedStateVariable>A_ARG_TYPE_InstanceID</relatedStateVariable>
+				</argument>
+				<argument>
+					<name>Channel</name>
+					<direction>in</direction>
+					<relatedStateVariable>A_ARG_TYPE_Channel</relatedStateVariable>
+				</argument>
+				<argument>
+					<name>DesiredVolume</name>
+					<direction>in</direction>
+					<relatedStateVariable>Volume</relatedStateVariable>
+				</argument>
+			</argumentList>
+		</action>
+	</actionList>
+</scpd>
--- a/src/plugins/Makefile.am
+++ b/src/plugins/Makefile.am
@@ -22,11 +22,16 @@ if BUILD_GSTLAUNCH_PLUGIN
 GSTLAUNCH_PLUGIN = gstlaunch
 endif
 
+if BUILD_GST_RENDERER_PLUGIN
+GST_RENDERER = gst-renderer
+endif
+
 SUBDIRS = $(TEST_PLUGIN) \
 	  $(TRACKER_PLUGIN) \
 	  $(MEDIATHEK_PLUGIN) \
 	  $(MEDIA_EXPORT_PLUGIN) \
 	  $(EXTERNAL_PLUGIN) \
-	  $(GSTLAUNCH_PLUGIN)
+	  $(GSTLAUNCH_PLUGIN) \
+          $(GST_RENDERER)
 
 MAINTAINERCLEANFILES = Makefile.in
--- /dev/null
+++ b/src/plugins/gst-renderer/Makefile.am
@@ -0,0 +1,56 @@
+if UNINSTALLED
+shareddir = $(abs_top_builddir)/data
+else
+shareddir = $(datadir)/rygel
+endif
+
+plugindir = $(libdir)/rygel-1.0
+
+plugin_LTLIBRARIES = librygel-gst.la
+
+DATA_DIR=$(shareddir:$(prefix)%=%)
+
+AM_CFLAGS = $(LIBGUPNP_CFLAGS) \
+	    $(LIBGUPNP_AV_CFLAGS) \
+	    $(GEE_CFLAGS) \
+	    $(GTK_CFLAGS) \
+	    $(LIBVLC_CFLAGS) \
+	    $(LIBDBUS_GLIB_CFLAGS) \
+	    -I$(top_srcdir)/src/rygel -DDATA_DIR='"$(DATA_DIR)"'
+
+librygel_gst_la_SOURCES = rygel-gst-connection-manager.vala \
+			  rygel-gst-rendering-control.vala \
+			  rygel-gst-av-transport.vala \
+			  rygel-gst-changelog.vala \
+			  rygel-gst-plugin.vala \
+			  rygel-gst-audio-player-instance.vala \
+			  rygel-helper-gst-time.vala \
+			  rygel-gst-metadata-parser.vala \
+			  rygel-gst-player-states.vala \
+			  owl-audio-player.c
+
+librygel_gst_la_VALAFLAGS = 	--vapidir=$(srcdir) \
+				--vapidir=$(top_srcdir)/src/rygel \
+				--vapidir=$(top_srcdir)/vapi \
+				--pkg rygel-1.0 \
+				--pkg cstuff \
+				--pkg gupnp-1.0 \
+				--pkg gupnp-av-1.0 \
+				--pkg owl-audio-player \
+				--pkg gee-1.0 \
+				--pkg gconf-2.0 \
+				--pkg gtk+-2.0
+
+librygel_gst_la_LIBADD = $(LIBGUPNP_LIBS) \
+			 $(LIBGUPNP_AV_LIBS) \
+			 $(LIBVLC_LIBS) \
+			 $(GEE_LIBS) \
+			 $(GTK_LIBS) \
+			 $(LIBDBUS_GLIB_LIBS) \
+			 $(LIBGCONF_LIBS)
+
+librygel_gst_la_LDFLAGS = -shared -fPIC -module -avoid-version
+
+CLEANFILES = $(BUILT_SOURCES)
+MAINTAINERCLEANFILES = Makefile.in
+EXTRA_DIST = $(BUILT_SOURCES) owl-audio-player.vapi
--- /dev/null
+++ b/src/plugins/gst-renderer/owl-audio-player.c
@@ -0,0 +1,906 @@
+/*
+ * owl-audio-player.c
+ *   A GObject based wrapper for vlc media player
+ *
+ * (C) Copyright 2010, Ubicom, Inc.
+ *
+ * This file is part of the Ubicom32 Rygel.
+ *
+ * This program is free software: you can redistribute
+ * it and/or modify it under the terms of the GNU Lesser General Public 
+ * License (LGPL) as published by the Free Software Foundation, either version 2.1
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it
+ * will be useful, but WITHOUT ANY WARRANTY; without even the implied
+ * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+ * the GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program.  If not,
+ * see <http://www.gnu.org/licenses/>.
+ *
+ * Ubicom32 implementation derived from (with many thanks):
+ *   OpenedHand's owl-audio-player.c file by Jorn Baayen <jorn@openedhand.com>
+ */
+
+#include <vlc/vlc.h>
+
+#include "owl-audio-player.h"
+
+G_DEFINE_TYPE (OwlAudioPlayer,
+               owl_audio_player,
+               G_TYPE_OBJECT);
+
+struct _OwlAudioPlayerPrivate {
+	libvlc_instance_t * pVLCInstance;
+	libvlc_media_player_t * pMediaPlayer;
+	libvlc_event_manager_t * pEvtManager;
+	libvlc_exception_t VLCex;
+
+	char *uri;
+	char *protocol_info;
+
+	int duration;
+	gboolean can_seek;
+};
+
+enum {
+        PROP_0,
+        PROP_URI,
+        PROP_PROTOCOL_INFO,
+        PROP_STATE,
+        PROP_POSITION,
+        PROP_VOLUME,
+        PROP_MUTE,
+        PROP_CAN_SEEK,
+        PROP_DURATION
+};
+
+enum {
+        PLAYING,
+        PAUSED,
+        EOS,
+        ERROR,
+        LAST_SIGNAL
+};
+
+static guint signals[LAST_SIGNAL];
+
+#define TICK_TIMEOUT 0.5
+
+/* TODO: Possibly retrieve these through introspection. The problem is that we
+ * need them in class_init already. */
+#define VLC_VOL_DEFAULT 50.0
+#define VLC_VOL_MAX     200.0
+#define VLC_VOL_MUTE_DEFAULT FALSE
+
+static void 
+process_vlc_exception(libvlc_exception_t* ex)
+{
+	if(libvlc_exception_raised(ex))
+	{
+		g_warning("vlc exception: %s", libvlc_exception_get_message(ex));
+		libvlc_exception_clear(ex);
+	}
+}
+
+/**
+ * Player playing media.
+ **/
+static void
+vlc_media_player_playing_cb( const libvlc_event_t *event, void *app_data )
+{
+	OwlAudioPlayer *audio_player = app_data;
+	g_return_if_fail (OWL_IS_AUDIO_PLAYER (audio_player));
+        /**
+         * Emit PLAYING signal.
+         **/
+        g_signal_emit (audio_player,
+                       signals[PLAYING],
+                       0);
+}
+
+/**
+ * Player paused playing media.
+ **/
+static void
+vlc_media_player_paused_cb( const libvlc_event_t *event, void *app_data )
+{
+	OwlAudioPlayer *audio_player = app_data;
+	g_return_if_fail (OWL_IS_AUDIO_PLAYER (audio_player));
+        /**
+         * Emit PAUSED signal.
+         **/
+        g_signal_emit (audio_player,
+                       signals[PAUSED],
+                       0);
+}
+
+/**
+ * End of stream reached.
+ **/
+static void
+vlc_eos_cb( const libvlc_event_t *event, void *app_data )
+{
+	OwlAudioPlayer *audio_player = app_data;
+	g_return_if_fail (OWL_IS_AUDIO_PLAYER (audio_player));
+        /**
+         * Emit EOS signal.
+         **/
+        g_signal_emit (audio_player,
+                       signals[EOS],
+                       0);
+}
+
+/**
+ * Error occured.
+ **/
+static void
+vlc_error_cb( const libvlc_event_t *event, void *app_data )
+{
+	OwlAudioPlayer *audio_player = app_data;
+	g_return_if_fail (OWL_IS_AUDIO_PLAYER (audio_player));
+
+        /**
+         * Emit ERROR signal.
+         **/
+        g_signal_emit (audio_player,
+                       signals[ERROR],
+                       0);
+}
+
+/**
+ * Duration/length changed.
+ **/
+static void
+vlc_media_player_duration_changed_cb( const libvlc_event_t *event, void *app_data )
+{
+	OwlAudioPlayer *audio_player = app_data;
+	g_return_if_fail (OWL_IS_AUDIO_PLAYER (audio_player));
+
+	if (audio_player->priv->duration == -1) {
+		audio_player->priv->duration = (event->u.media_duration_changed.new_duration + 500LL) / 1000000LL;
+		g_object_notify(audio_player, "duration");
+	}
+}
+
+static void
+owl_audio_player_init (OwlAudioPlayer *audio_player)
+{
+        /**
+         * Create pointer to private data.
+         **/
+        audio_player->priv =
+                G_TYPE_INSTANCE_GET_PRIVATE (audio_player,
+                                             OWL_TYPE_AUDIO_PLAYER,
+                                             OwlAudioPlayerPrivate);
+
+	const char * const vlc_args[] = {
+		"-I", "dummy", "--ipv4-timeout=60000",     // No special interface
+		"--http-dlna",     // Enable dlna in HTTP
+		"--http-reconnect",// Try to reconnect when connection is lost
+		"--ignore-config", // Don't use VLC's config
+		"--plugin-path=./plugins" };
+	
+	libvlc_instance_t * pVLCInstance = NULL;
+	libvlc_media_player_t * pMediaPlayer = NULL;
+	libvlc_event_manager_t * pEvtManager = NULL;
+	libvlc_exception_t *pVLCex = &audio_player->priv->VLCex;
+
+	// init the exception object.
+	libvlc_exception_init (pVLCex);
+	
+	// init vlc modules, should be done only once
+	pVLCInstance = libvlc_new (sizeof(vlc_args) / sizeof(vlc_args[0]), vlc_args, pVLCex);
+	process_vlc_exception(pVLCex);
+	 
+	// Create a media player playing environement
+	pMediaPlayer = libvlc_media_player_new(pVLCInstance, pVLCex);
+	process_vlc_exception(pVLCex);
+	
+	// Create an event manager for the player for handling e.g. time change events
+	pEvtManager = libvlc_media_player_event_manager(pMediaPlayer, pVLCex);
+	process_vlc_exception(pVLCex);
+	
+	libvlc_event_attach(pEvtManager,
+	                    libvlc_MediaPlayerEndReached,
+	                    vlc_eos_cb,
+	                    audio_player,
+	                    pVLCex);
+	process_vlc_exception(pVLCex);
+	libvlc_event_attach(pEvtManager,
+	                    libvlc_MediaPlayerEncounteredError,
+	                    vlc_error_cb,
+	                    audio_player,
+	                    pVLCex);
+	process_vlc_exception(pVLCex);
+	libvlc_event_attach(pEvtManager,
+	                    libvlc_MediaPlayerPaused,
+	                    vlc_media_player_paused_cb,
+	                    audio_player,
+	                    pVLCex);
+	process_vlc_exception(pVLCex);
+	libvlc_event_attach(pEvtManager,
+	                    libvlc_MediaPlayerPlaying,
+	                    vlc_media_player_playing_cb,
+	                    audio_player,
+	                    pVLCex);
+	process_vlc_exception(pVLCex);
+
+	audio_player->priv->pVLCInstance = pVLCInstance;
+	audio_player->priv->pMediaPlayer = pMediaPlayer;
+	audio_player->priv->pEvtManager = pEvtManager;
+}
+
+static void
+owl_audio_player_set_property (GObject      *object,
+                               guint         property_id,
+                               const GValue *value,
+                               GParamSpec   *pspec)
+{
+        OwlAudioPlayer *audio_player;
+
+        audio_player = OWL_AUDIO_PLAYER (object);
+
+        switch (property_id) {
+        case PROP_PROTOCOL_INFO:
+                owl_audio_player_set_protocol_info (audio_player,
+                                                    g_value_get_string (value));
+                break;
+        case PROP_POSITION:
+                owl_audio_player_set_position (audio_player,
+                                               g_value_get_int (value));
+                break;
+        case PROP_VOLUME:
+                owl_audio_player_set_volume (audio_player,
+                                             g_value_get_uint (value));
+                break;
+        case PROP_MUTE:
+                owl_audio_player_set_mute (audio_player,
+                                           g_value_get_uint (value));
+                break;
+        default:
+                G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
+                break;
+        }
+}
+
+static void
+owl_audio_player_get_property (GObject    *object,
+                               guint       property_id,
+                               GValue     *value,
+                               GParamSpec *pspec)
+{
+	OwlAudioPlayer *audio_player;
+	
+	audio_player = OWL_AUDIO_PLAYER (object);
+	
+	switch (property_id) {
+	case PROP_URI:
+	        g_value_set_string
+	                (value,
+	                 owl_audio_player_get_uri (audio_player));
+	        break;
+	case PROP_PROTOCOL_INFO:
+	        g_value_set_string
+	                (value,
+	                 owl_audio_player_get_protocol_info (audio_player));
+	        break;
+	case PROP_STATE:
+	        g_value_set_enum
+	                (value,
+	                 owl_audio_player_get_state (audio_player));
+	        break;
+	case PROP_POSITION:
+	        g_value_set_int
+	                (value,
+	                 owl_audio_player_get_position (audio_player));
+	        break;
+	case PROP_VOLUME:
+	        g_value_set_double
+	                (value,
+	                 owl_audio_player_get_volume (audio_player));
+	        break;
+	case PROP_MUTE:
+	        g_value_set_double
+	                (value,
+	                 owl_audio_player_get_mute (audio_player));
+	        break;
+	case PROP_CAN_SEEK:
+	        g_value_set_boolean
+	                (value,
+	                 owl_audio_player_get_can_seek (audio_player));
+	        break;
+	case PROP_DURATION:
+	        g_value_set_int
+	                (value,
+	                 owl_audio_player_get_duration (audio_player));
+	        break;
+	default:
+	        G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
+	        break;
+	}
+}
+
+static void
+owl_audio_player_dispose (GObject *object)
+{
+	OwlAudioPlayer *audio_player;
+	GObjectClass *object_class;
+	
+	audio_player = OWL_AUDIO_PLAYER (object);
+	
+	if (audio_player->priv->pMediaPlayer) {
+		libvlc_media_player_release (audio_player->priv->pMediaPlayer);
+	        audio_player->priv->pMediaPlayer = NULL;
+	}
+	
+	if (audio_player->priv->pVLCInstance) {
+		libvlc_release (audio_player->priv->pVLCInstance);
+	        audio_player->priv->pVLCInstance = NULL;
+	}
+	
+	
+	object_class = G_OBJECT_CLASS (owl_audio_player_parent_class);
+	object_class->dispose (object);
+}
+
+static void
+owl_audio_player_finalize (GObject *object)
+{
+	OwlAudioPlayer *audio_player;
+	GObjectClass *object_class;
+	
+	audio_player = OWL_AUDIO_PLAYER (object);
+	
+	g_free (audio_player->priv->uri);
+	g_free (audio_player->priv->protocol_info);
+	
+	object_class = G_OBJECT_CLASS (owl_audio_player_parent_class);
+	object_class->finalize (object);
+}
+
+static void
+owl_audio_player_class_init (OwlAudioPlayerClass *klass)
+{
+	GObjectClass *object_class;
+	
+	object_class = G_OBJECT_CLASS (klass);
+	
+	object_class->set_property = owl_audio_player_set_property;
+	object_class->get_property = owl_audio_player_get_property;
+	object_class->dispose      = owl_audio_player_dispose;
+	object_class->finalize     = owl_audio_player_finalize;
+	
+	g_type_class_add_private (klass, sizeof (OwlAudioPlayerPrivate));
+	
+	g_object_class_install_property
+	        (object_class,
+	         PROP_URI,
+	         g_param_spec_string
+	                 ("uri",
+	                  "URI",
+	                  "The loaded URI.",
+	                  NULL,
+	                  G_PARAM_READWRITE |
+	                  G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK |
+	                  G_PARAM_STATIC_BLURB));
+	
+	g_object_class_install_property
+	        (object_class,
+	         PROP_PROTOCOL_INFO,
+	         g_param_spec_string
+	                 ("protocol-info",
+	                  "PROTOCOL_INFO",
+	                  "The DLNA protocolInfo.",
+	                  NULL,
+	                  G_PARAM_READWRITE |
+	                  G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK |
+	                  G_PARAM_STATIC_BLURB));
+
+	g_object_class_install_property
+	        (object_class,
+	         PROP_STATE,
+	         g_param_spec_boolean
+	                 ("state",
+	                  "Playing State",
+	                  "Returns playing state.",
+	                  FALSE,
+	                  G_PARAM_READWRITE |
+	                  G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK |
+	                  G_PARAM_STATIC_BLURB));
+	
+	g_object_class_install_property
+	        (object_class,
+	         PROP_POSITION,
+	         g_param_spec_int
+	                 ("position",
+	                  "Position",
+	                  "The position in the current stream in seconds.",
+	                  0, G_MAXINT, 0,
+	                  G_PARAM_READWRITE |
+	                  G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK |
+	                  G_PARAM_STATIC_BLURB));
+	
+	g_object_class_install_property
+	        (object_class,
+	         PROP_VOLUME,
+	         g_param_spec_uint
+	                 ("volume",
+	                  "Volume",
+	                  "The audio volume.",
+	                  0, VLC_VOL_MAX, VLC_VOL_DEFAULT,
+	                  G_PARAM_READWRITE |
+	                  G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK |
+	                  G_PARAM_STATIC_BLURB));
+	
+	g_object_class_install_property
+	        (object_class,
+	         PROP_MUTE,
+	         g_param_spec_uint
+	                 ("mute",
+	                  "Mute",
+	                  "The audio mute.",
+	                  0, 1, VLC_VOL_MUTE_DEFAULT,
+	                  G_PARAM_READWRITE |
+	                  G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK |
+	                  G_PARAM_STATIC_BLURB));
+
+	g_object_class_install_property
+	        (object_class,
+	         PROP_CAN_SEEK,
+	         g_param_spec_boolean
+	                 ("can-seek",
+	                  "Can seek",
+	                  "TRUE if the current stream is seekable.",
+	                  FALSE,
+	                  G_PARAM_READABLE |
+	                  G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK |
+	                  G_PARAM_STATIC_BLURB));
+	
+	g_object_class_install_property
+	        (object_class,
+	         PROP_DURATION,
+	         g_param_spec_int
+	                 ("duration",
+	                  "Duration",
+	                  "The duration of the current stream in seconds.",
+	                  0, G_MAXINT, 0,
+	                  G_PARAM_READABLE |
+	                  G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK |
+	                  G_PARAM_STATIC_BLURB));
+
+	signals[PLAYING] =
+	        g_signal_new ("playing",
+	                      OWL_TYPE_AUDIO_PLAYER,
+	                      G_SIGNAL_RUN_LAST,
+	                      G_STRUCT_OFFSET (OwlAudioPlayerClass,
+	                                       playing),
+	                      NULL, NULL,
+	                      g_cclosure_marshal_VOID__VOID,
+	                      G_TYPE_NONE, 0);
+
+	signals[PAUSED] =
+	        g_signal_new ("paused",
+	                      OWL_TYPE_AUDIO_PLAYER,
+	                      G_SIGNAL_RUN_LAST,
+	                      G_STRUCT_OFFSET (OwlAudioPlayerClass,
+	                                       paused),
+	                      NULL, NULL,
+	                      g_cclosure_marshal_VOID__VOID,
+	                      G_TYPE_NONE, 0);
+
+	signals[EOS] =
+	        g_signal_new ("eos",
+	                      OWL_TYPE_AUDIO_PLAYER,
+	                      G_SIGNAL_RUN_LAST,
+	                      G_STRUCT_OFFSET (OwlAudioPlayerClass,
+	                                       eos),
+	                      NULL, NULL,
+	                      g_cclosure_marshal_VOID__VOID,
+	                      G_TYPE_NONE, 0);
+
+	signals[ERROR] =
+	        g_signal_new ("error",
+	                      OWL_TYPE_AUDIO_PLAYER,
+	                      G_SIGNAL_RUN_LAST,
+	                      G_STRUCT_OFFSET (OwlAudioPlayerClass,
+	                                       error),
+	                      NULL, NULL,
+	                      g_cclosure_marshal_VOID__POINTER,
+	                      G_TYPE_NONE, 1, G_TYPE_POINTER);
+}
+
+/**
+ * owl_audio_player_construct
+ *
+ * Return value: A new #OwlAudioPlayer.
+ **/
+OwlAudioPlayer *
+owl_audio_player_construct (GType object_type)
+{
+	return g_object_new (OWL_TYPE_AUDIO_PLAYER, NULL);
+}
+
+/**
+ * owl_audio_player_new
+ *
+ * Return value: A new #OwlAudioPlayer.
+ **/
+OwlAudioPlayer *
+owl_audio_player_new (void)
+{
+	return owl_audio_player_construct (OWL_TYPE_AUDIO_PLAYER);
+}
+
+/**
+ * owl_audio_player_set_protocol_info
+ * @audio_player: A #OwlAudioPlayer
+ * @protocol_info: A PROTOCOL_INFO
+ *
+ * Loads @protocol_info.
+ **/
+void
+owl_audio_player_set_protocol_info (OwlAudioPlayer *audio_player,
+                                    const char     *protocol_info)
+{
+	g_return_if_fail (OWL_IS_AUDIO_PLAYER (audio_player));
+
+	if (!audio_player->priv->pMediaPlayer)
+	        return;
+
+	if (protocol_info && audio_player->priv->protocol_info && !strcmp(protocol_info, audio_player->priv->protocol_info)) {
+		return;
+	}
+
+	g_free (audio_player->priv->protocol_info);
+
+	if (protocol_info) {
+	        audio_player->priv->protocol_info = g_strdup (protocol_info);
+	} else {
+	        audio_player->priv->protocol_info = NULL;
+	}
+}
+
+/**
+ * owl_audio_player_get_protocol_info
+ * @audio_player: A #OwlAudioPlayer
+ *
+ * Return value: The DLNA protocolInfo, or NULL if none set.
+ **/
+const char *
+owl_audio_player_get_protocol_info (OwlAudioPlayer *audio_player)
+{
+	g_return_val_if_fail (OWL_IS_AUDIO_PLAYER (audio_player), NULL);
+
+	return audio_player->priv->protocol_info;
+}
+
+/**
+ * owl_audio_player_get_uri
+ * @audio_player: A #OwlAudioPlayer
+ *
+ * Return value: The loaded URI, or NULL if none set.
+ **/
+const char *
+owl_audio_player_get_uri (OwlAudioPlayer *audio_player)
+{
+	g_return_val_if_fail (OWL_IS_AUDIO_PLAYER (audio_player), NULL);
+	
+	return audio_player->priv->uri;
+}
+
+/**
+ * owl_audio_player_pause
+ * @audio_player: A #OwlAudioPlayer
+ *
+ * Pauses playing media.
+ **/
+void
+owl_audio_player_pause (OwlAudioPlayer *audio_player)
+{
+	g_return_if_fail (OWL_IS_AUDIO_PLAYER (audio_player));
+
+	if (!audio_player->priv->pMediaPlayer)
+	        return;
+
+	if (owl_audio_player_get_state(audio_player) != OWL_PLAYING_STATE_PLAYING) {
+		return;
+	}
+
+	libvlc_media_player_pause(audio_player->priv->pMediaPlayer, &audio_player->priv->VLCex);
+	process_vlc_exception(&audio_player->priv->VLCex);
+}
+
+/**
+ * owl_audio_player_resume
+ * @audio_player: A #OwlAudioPlayer
+ *
+ * Resumes paused media.
+ **/
+void
+owl_audio_player_resume (OwlAudioPlayer *audio_player)
+{
+	g_return_if_fail (OWL_IS_AUDIO_PLAYER (audio_player));
+
+	if (!audio_player->priv->pMediaPlayer)
+	        return;
+
+	if (owl_audio_player_get_state(audio_player) != OWL_PLAYING_STATE_PAUSED_PLAYBACK) {
+		return;
+	}
+
+	libvlc_media_player_pause(audio_player->priv->pMediaPlayer, &audio_player->priv->VLCex);
+	process_vlc_exception(&audio_player->priv->VLCex);
+}
+
+/**
+ * owl_audio_player_stop
+ * @audio_player: A #OwlAudioPlayer
+ *
+ * Stops playing media.
+ **/
+void
+owl_audio_player_stop (OwlAudioPlayer *audio_player)
+{
+	g_return_if_fail (OWL_IS_AUDIO_PLAYER (audio_player));
+
+	if (!audio_player->priv->pMediaPlayer)
+	        return;
+
+	libvlc_media_player_stop(audio_player->priv->pMediaPlayer, &audio_player->priv->VLCex);
+	process_vlc_exception(&audio_player->priv->VLCex);
+}
+
+/**
+ * owl_audio_player_play
+ * @audio_player: A #OwlAudioPlayer
+ * @uri: A URI
+ *
+ * Plays the media at @uri.
+ **/
+void
+owl_audio_player_play (OwlAudioPlayer *audio_player,
+                       const char *uri)
+{
+	g_return_if_fail (OWL_IS_AUDIO_PLAYER (audio_player));
+
+	if (!audio_player->priv->pMediaPlayer)
+	        return;
+
+	if (!uri) {
+		return;
+	}
+
+	g_free (audio_player->priv->uri);
+    audio_player->priv->uri = g_strdup (uri);
+
+    /**
+	 * Set new media.
+	 **/
+	libvlc_media_t * pMedia = libvlc_media_new (audio_player->priv->pVLCInstance, uri, &audio_player->priv->VLCex);
+	process_vlc_exception(&audio_player->priv->VLCex);
+	libvlc_event_attach(libvlc_media_event_manager(pMedia, &audio_player->priv->VLCex),
+	                    libvlc_MediaDurationChanged,
+	                    vlc_media_player_duration_changed_cb,
+	                    audio_player,
+	                    &audio_player->priv->VLCex);
+	process_vlc_exception(&audio_player->priv->VLCex);
+	libvlc_media_player_set_media (audio_player->priv->pMediaPlayer, pMedia, &audio_player->priv->VLCex);
+	process_vlc_exception(&audio_player->priv->VLCex);
+
+	/**
+	 * Set DLNA protocolInfo of the media item
+	 **/
+	if (audio_player->priv->protocol_info) {
+		libvlc_media_player_set_protocol_info(audio_player->priv->pMediaPlayer, audio_player->priv->protocol_info, &audio_player->priv->VLCex);
+		process_vlc_exception(&audio_player->priv->VLCex);
+	}
+
+	/**
+	 * Play media
+	 **/
+	libvlc_media_player_play(audio_player->priv->pMediaPlayer, &audio_player->priv->VLCex);
+	process_vlc_exception(&audio_player->priv->VLCex);
+
+	/**
+	 * Reset properties.
+	 **/
+	audio_player->priv->can_seek = 0;
+	audio_player->priv->duration = -1;
+}
+
+/**
+ * owl_audio_player_get_state
+ * @audio_player: A #OwlAudioPlayer
+ *
+ * Return value: Playing state of @audio_player.
+ **/
+owl_playing_state
+owl_audio_player_get_state (OwlAudioPlayer *audio_player)
+{
+	g_return_val_if_fail (OWL_IS_AUDIO_PLAYER (audio_player), FALSE);
+	
+	if (!audio_player->priv->pMediaPlayer)
+	        return FALSE;
+	
+	libvlc_state_t state = libvlc_media_player_get_state(audio_player->priv->pMediaPlayer, &audio_player->priv->VLCex);
+	process_vlc_exception(&audio_player->priv->VLCex);
+	
+	switch (state) {
+	case libvlc_Opening:
+	case libvlc_Buffering:
+		return OWL_PLAYING_STATE_TRANSITIONING;
+	case libvlc_Playing:
+		return OWL_PLAYING_STATE_PLAYING;
+	case libvlc_Stopped:
+	case libvlc_Ended:
+	case libvlc_Error:
+	case libvlc_NothingSpecial:
+		return OWL_PLAYING_STATE_STOPPED;
+	case libvlc_Paused:
+		return OWL_PLAYING_STATE_PAUSED_PLAYBACK;
+	}
+}
+
+/**
+ * owl_audio_player_set_position
+ * @audio_player: A #OwlAudioPlayer
+ * @time_in_seconds: The position in the current stream in seconds.
+ *
+ * Sets the position in the current stream to @time_in_seconds.
+ **/
+void
+owl_audio_player_set_position (OwlAudioPlayer *audio_player,
+                               int time_in_seconds)
+{
+	g_return_if_fail (OWL_IS_AUDIO_PLAYER (audio_player));
+	
+	if (!audio_player->priv->pVLCInstance)
+		return;
+
+	if (time_in_seconds < 0) {
+		return;
+	}
+
+	libvlc_time_t time_in_mseconds = time_in_seconds * 1000;
+	libvlc_media_player_set_time(audio_player->priv->pMediaPlayer, time_in_mseconds, &audio_player->priv->VLCex);
+	process_vlc_exception(&audio_player->priv->VLCex);
+	g_debug("%p: New time is %lld", audio_player, time_in_mseconds);
+}
+
+/**
+ * owl_audio_player_get_position
+ * @audio_player: A #OwlAudioPlayer
+ *
+ * Return value: The position in the current file in seconds.
+ **/
+int
+owl_audio_player_get_position (OwlAudioPlayer *audio_player)
+{
+	g_return_val_if_fail (OWL_IS_AUDIO_PLAYER (audio_player), -1);
+	
+	if (!audio_player->priv->pMediaPlayer)
+	        return -1;
+
+	libvlc_time_t time_in_mseconds = libvlc_media_player_get_time(audio_player->priv->pMediaPlayer, &audio_player->priv->VLCex);
+	process_vlc_exception(&audio_player->priv->VLCex);
+
+	return time_in_mseconds / 1000;
+}
+
+/**
+ * owl_audio_player_set_volume
+ * @audio_player: A #OwlAudioPlayer
+ * @volume: The audio volume to set, in the range 0.0 - 4.0.
+ *
+ * Sets the current audio volume to @volume.
+ **/
+void
+owl_audio_player_set_volume (OwlAudioPlayer *audio_player,
+                             unsigned int          volume)
+{
+	g_return_if_fail (OWL_IS_AUDIO_PLAYER (audio_player));
+	g_return_if_fail (volume >= 0.0 && volume <= VLC_VOL_MAX);
+	
+	if (!audio_player->priv->pVLCInstance)
+	        return;
+		
+	libvlc_audio_set_volume(audio_player->priv->pVLCInstance, volume, &audio_player->priv->VLCex);
+	process_vlc_exception(&audio_player->priv->VLCex);
+}
+
+/**
+ * owl_audio_player_get_volume
+ * @audio_player: A #OwlAudioPlayer
+ *
+ * Return value: The current audio volume, in the range 0.0 - 4.0.
+ **/
+unsigned int
+owl_audio_player_get_volume (OwlAudioPlayer *audio_player)
+{
+	unsigned int volume;
+	
+	g_return_val_if_fail (OWL_IS_AUDIO_PLAYER (audio_player), 0);
+	
+	if (!audio_player->priv->pVLCInstance)
+	        return 0.0;
+	
+	volume = libvlc_audio_get_volume(audio_player->priv->pVLCInstance, &audio_player->priv->VLCex);
+	process_vlc_exception(&audio_player->priv->VLCex);
+	
+	return volume;
+}
+
+/**
+ * owl_audio_player_set_mute
+ * @audio_player: A #OwlAudioPlayer
+ * @mute: TRUE if volume should be muted, FALSE otherwise
+ *
+ * Sets the current audio mute to @mute.
+ **/
+void
+owl_audio_player_set_mute (OwlAudioPlayer *audio_player,
+                           gboolean                mute)
+{
+	g_return_if_fail (OWL_IS_AUDIO_PLAYER (audio_player));
+
+	if (!audio_player->priv->pVLCInstance)
+	        return;
+
+	libvlc_audio_set_mute(audio_player->priv->pVLCInstance, mute, &audio_player->priv->VLCex);
+	process_vlc_exception(&audio_player->priv->VLCex);
+}
+
+/**
+ * owl_audio_player_get_mute
+ * @audio_player: A #OwlAudioPlayer
+ *
+ * Return value: TRUE if the current volume is muted.
+ **/
+gboolean
+owl_audio_player_get_mute (OwlAudioPlayer *audio_player)
+{
+	gboolean mute;
+
+	g_return_val_if_fail (OWL_IS_AUDIO_PLAYER (audio_player), 0);
+
+	if (!audio_player->priv->pVLCInstance)
+	        return FALSE;
+
+	mute = libvlc_audio_get_mute(audio_player->priv->pVLCInstance, &audio_player->priv->VLCex);
+	process_vlc_exception(&audio_player->priv->VLCex);
+
+	return mute;
+}
+
+/**
+ * owl_audio_player_get_can_seek
+ * @audio_player: A #OwlAudioPlayer
+ *
+ * Return value: TRUE if the current stream is seekable.
+ **/
+gboolean
+owl_audio_player_get_can_seek (OwlAudioPlayer *audio_player)
+{
+	g_return_val_if_fail (OWL_IS_AUDIO_PLAYER (audio_player), FALSE);
+	
+	int is_seekable = libvlc_media_player_is_seekable(audio_player->priv->pMediaPlayer, &audio_player->priv->VLCex);
+	process_vlc_exception(&audio_player->priv->VLCex);
+	return is_seekable;
+}
+
+/**
+ * owl_audio_player_get_duration
+ * @audio_player: A #OwlAudioPlayer
+ *
+ * Return value: The duration of the current stream in seconds.
+ **/
+int
+owl_audio_player_get_duration (OwlAudioPlayer *audio_player)
+{
+	g_return_val_if_fail (OWL_IS_AUDIO_PLAYER (audio_player), -1);
+	
+	return audio_player->priv->duration;
+}
--- /dev/null
+++ b/src/plugins/gst-renderer/owl-audio-player.c_202
@@ -0,0 +1,879 @@
+/*
+ * owl-audio-player.c
+ *   A GObject based wrapper for vlc media player
+ *
+ * (C) Copyright 2010, Ubicom, Inc.
+ *
+ * This file is part of the Ubicom32 Rygel.
+ *
+ * This program is free software: you can redistribute
+ * it and/or modify it under the terms of the GNU Lesser General Public 
+ * License (LGPL) as published by the Free Software Foundation, either version 2.1
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it
+ * will be useful, but WITHOUT ANY WARRANTY; without even the implied
+ * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+ * the GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program.  If not,
+ * see <http://www.gnu.org/licenses/>.
+ *
+ * Ubicom32 implementation derived from (with many thanks):
+ *   OpenedHand's owl-audio-player.c file by Jorn Baayen <jorn@openedhand.com>
+ */
+
+#include <vlc/vlc.h>
+
+#include "owl-audio-player.h"
+
+G_DEFINE_TYPE (OwlAudioPlayer,
+               owl_audio_player,
+               G_TYPE_OBJECT);
+
+struct _OwlAudioPlayerPrivate {
+	libvlc_instance_t * pVLCInstance;
+	libvlc_media_player_t * pMediaPlayer;
+	libvlc_event_manager_t * pEvtManager;
+
+	char *uri;
+	char *protocol_info;
+
+	int duration;
+	gboolean can_seek;
+};
+
+enum {
+        PROP_0,
+        PROP_URI,
+        PROP_PROTOCOL_INFO,
+        PROP_STATE,
+        PROP_POSITION,
+        PROP_VOLUME,
+        PROP_MUTE,
+        PROP_CAN_SEEK,
+        PROP_DURATION
+};
+
+enum {
+        PLAYING,
+        PAUSED,
+        EOS,
+        ERROR,
+        LAST_SIGNAL
+};
+
+static guint signals[LAST_SIGNAL];
+
+#define TICK_TIMEOUT 0.5
+
+/* TODO: Possibly retrieve these through introspection. The problem is that we
+ * need them in class_init already. */
+#define VLC_VOL_DEFAULT 50.0
+#define VLC_VOL_MAX     200.0
+#define VLC_VOL_MUTE_DEFAULT FALSE
+
+/**
+ * Player playing media.
+ **/
+static void
+vlc_media_player_playing_cb( const libvlc_event_t *event, void *app_data )
+{
+	OwlAudioPlayer *audio_player = app_data;
+	g_return_if_fail (OWL_IS_AUDIO_PLAYER (audio_player));
+        /**
+         * Emit PLAYING signal.
+         **/
+        g_signal_emit (audio_player,
+                       signals[PLAYING],
+                       0);
+}
+
+/**
+ * Player paused playing media.
+ **/
+static void
+vlc_media_player_paused_cb( const libvlc_event_t *event, void *app_data )
+{
+	OwlAudioPlayer *audio_player = app_data;
+	g_return_if_fail (OWL_IS_AUDIO_PLAYER (audio_player));
+        /**
+         * Emit PAUSED signal.
+         **/
+        g_signal_emit (audio_player,
+                       signals[PAUSED],
+                       0);
+}
+
+/**
+ * End of stream reached.
+ **/
+static void
+vlc_eos_cb( const libvlc_event_t *event, void *app_data )
+{
+	OwlAudioPlayer *audio_player = app_data;
+	g_return_if_fail (OWL_IS_AUDIO_PLAYER (audio_player));
+        /**
+         * Emit EOS signal.
+         **/
+        g_signal_emit (audio_player,
+                       signals[EOS],
+                       0);
+}
+
+/**
+ * Error occured.
+ **/
+static void
+vlc_error_cb( const libvlc_event_t *event, void *app_data )
+{
+	OwlAudioPlayer *audio_player = app_data;
+	g_return_if_fail (OWL_IS_AUDIO_PLAYER (audio_player));
+
+        /**
+         * Emit ERROR signal.
+         **/
+        g_signal_emit (audio_player,
+                       signals[ERROR],
+                       0);
+}
+
+/**
+ * Duration/length changed.
+ **/
+static void
+vlc_media_player_duration_changed_cb( const libvlc_event_t *event, void *app_data )
+{
+	OwlAudioPlayer *audio_player = app_data;
+	g_return_if_fail (OWL_IS_AUDIO_PLAYER (audio_player));
+
+	if (audio_player->priv->duration == -1) {
+		audio_player->priv->duration = (event->u.media_duration_changed.new_duration + 500LL) / 1000000LL;
+		g_object_notify(audio_player, "duration");
+	}
+}
+
+static void
+owl_audio_player_init (OwlAudioPlayer *audio_player)
+{
+        /**
+         * Create pointer to private data.
+         **/
+        audio_player->priv =
+                G_TYPE_INSTANCE_GET_PRIVATE (audio_player,
+                                             OWL_TYPE_AUDIO_PLAYER,
+                                             OwlAudioPlayerPrivate);
+
+	const char * const vlc_args[] = {
+		"-v",
+		"--http-dlna",     // Enable dlna in HTTP
+		"--http-reconnect",// Try to reconnect when connection is lost
+		"--ignore-config"}; // Don't use VLC's config
+	
+	libvlc_instance_t * pVLCInstance = NULL;
+	libvlc_media_player_t * pMediaPlayer = NULL;
+	libvlc_event_manager_t * pEvtManager = NULL;
+
+	// init vlc modules, should be done only once
+	pVLCInstance = libvlc_new (sizeof(vlc_args) / sizeof(vlc_args[0]), vlc_args);
+	if(!pVLCInstance) {
+		printf("%s: libvlc_new failed\n",__func__);
+	}	
+ 
+	// Create a media player playing environement
+	pMediaPlayer = libvlc_media_player_new(pVLCInstance);
+	if(!pMediaPlayer) {
+		printf("%s: libvlc_media_player_new failed\n",__func__);
+	}
+	
+	// Create an event manager for the player for handling e.g. time change events
+	pEvtManager = libvlc_media_player_event_manager(pMediaPlayer);
+	if(!pEvtManager) {
+		printf("%s: libvlc_media_player_event_manager failed\n",__func__);
+	}
+	
+	libvlc_event_attach(pEvtManager,
+	                    libvlc_MediaPlayerEndReached,
+	                    vlc_eos_cb,
+	                    audio_player);
+	libvlc_event_attach(pEvtManager,
+	                    libvlc_MediaPlayerEncounteredError,
+	                    vlc_error_cb,
+	                    audio_player);
+	libvlc_event_attach(pEvtManager,
+	                    libvlc_MediaPlayerPaused,
+	                    vlc_media_player_paused_cb,
+	                    audio_player);
+	libvlc_event_attach(pEvtManager,
+	                    libvlc_MediaPlayerPlaying,
+	                    vlc_media_player_playing_cb,
+	                    audio_player);
+
+	audio_player->priv->pVLCInstance = pVLCInstance;
+	audio_player->priv->pMediaPlayer = pMediaPlayer;
+	audio_player->priv->pEvtManager = pEvtManager;
+	printf("%s: exit\n",__func__);
+}
+
+static void
+owl_audio_player_set_property (GObject      *object,
+                               guint         property_id,
+                               const GValue *value,
+                               GParamSpec   *pspec)
+{
+        OwlAudioPlayer *audio_player;
+
+        audio_player = OWL_AUDIO_PLAYER (object);
+	
+        switch (property_id) {
+        case PROP_PROTOCOL_INFO:
+                owl_audio_player_set_protocol_info (audio_player,
+                                                    g_value_get_string (value));
+                break;
+        case PROP_POSITION:
+                owl_audio_player_set_position (audio_player,
+                                               g_value_get_int (value));
+                break;
+        case PROP_VOLUME:
+                owl_audio_player_set_volume (audio_player,
+                                             g_value_get_uint (value));
+                break;
+        case PROP_MUTE:
+                owl_audio_player_set_mute (audio_player,
+                                           g_value_get_uint (value));
+                break;
+        default:
+                G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
+                break;
+        }
+}
+
+static void
+owl_audio_player_get_property (GObject    *object,
+                               guint       property_id,
+                               GValue     *value,
+                               GParamSpec *pspec)
+{
+	OwlAudioPlayer *audio_player;
+	
+	audio_player = OWL_AUDIO_PLAYER (object);
+	
+	switch (property_id) {
+	case PROP_URI:
+	        g_value_set_string
+	                (value,
+	                 owl_audio_player_get_uri (audio_player));
+	        break;
+	case PROP_PROTOCOL_INFO:
+	        g_value_set_string
+	                (value,
+	                 owl_audio_player_get_protocol_info (audio_player));
+	        break;
+	case PROP_STATE:
+	        g_value_set_enum
+	                (value,
+	                 owl_audio_player_get_state (audio_player));
+	        break;
+	case PROP_POSITION:
+	        g_value_set_int
+	                (value,
+	                 owl_audio_player_get_position (audio_player));
+	        break;
+	case PROP_VOLUME:
+	        g_value_set_double
+	                (value,
+	                 owl_audio_player_get_volume (audio_player));
+	        break;
+	case PROP_MUTE:
+	        g_value_set_double
+	                (value,
+	                 owl_audio_player_get_mute (audio_player));
+	        break;
+	case PROP_CAN_SEEK:
+	        g_value_set_boolean
+	                (value,
+	                 owl_audio_player_get_can_seek (audio_player));
+	        break;
+	case PROP_DURATION:
+	        g_value_set_int
+	                (value,
+	                 owl_audio_player_get_duration (audio_player));
+	        break;
+	default:
+	        G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
+	        break;
+	}
+}
+
+static void
+owl_audio_player_dispose (GObject *object)
+{
+	OwlAudioPlayer *audio_player;
+	GObjectClass *object_class;
+	
+	audio_player = OWL_AUDIO_PLAYER (object);
+	
+	if (audio_player->priv->pMediaPlayer) {
+		libvlc_media_player_release (audio_player->priv->pMediaPlayer);
+	        audio_player->priv->pMediaPlayer = NULL;
+	}
+	
+	if (audio_player->priv->pVLCInstance) {
+		libvlc_release (audio_player->priv->pVLCInstance);
+	        audio_player->priv->pVLCInstance = NULL;
+	}
+	
+	
+	object_class = G_OBJECT_CLASS (owl_audio_player_parent_class);
+	object_class->dispose (object);
+}
+
+static void
+owl_audio_player_finalize (GObject *object)
+{
+	OwlAudioPlayer *audio_player;
+	GObjectClass *object_class;
+	
+	audio_player = OWL_AUDIO_PLAYER (object);
+	
+	g_free (audio_player->priv->uri);
+	g_free (audio_player->priv->protocol_info);
+	
+	object_class = G_OBJECT_CLASS (owl_audio_player_parent_class);
+	object_class->finalize (object);
+}
+
+static void
+owl_audio_player_class_init (OwlAudioPlayerClass *klass)
+{
+	GObjectClass *object_class;
+	
+	object_class = G_OBJECT_CLASS (klass);
+	
+	object_class->set_property = owl_audio_player_set_property;
+	object_class->get_property = owl_audio_player_get_property;
+	object_class->dispose      = owl_audio_player_dispose;
+	object_class->finalize     = owl_audio_player_finalize;
+	
+	g_type_class_add_private (klass, sizeof (OwlAudioPlayerPrivate));
+	
+	g_object_class_install_property
+	        (object_class,
+	         PROP_URI,
+	         g_param_spec_string
+	                 ("uri",
+	                  "URI",
+	                  "The loaded URI.",
+	                  NULL,
+	                  G_PARAM_READWRITE |
+	                  G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK |
+	                  G_PARAM_STATIC_BLURB));
+	
+	g_object_class_install_property
+	        (object_class,
+	         PROP_PROTOCOL_INFO,
+	         g_param_spec_string
+	                 ("protocol-info",
+	                  "PROTOCOL_INFO",
+	                  "The DLNA protocolInfo.",
+	                  NULL,
+	                  G_PARAM_READWRITE |
+	                  G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK |
+	                  G_PARAM_STATIC_BLURB));
+
+	g_object_class_install_property
+	        (object_class,
+	         PROP_STATE,
+	         g_param_spec_boolean
+	                 ("state",
+	                  "Playing State",
+	                  "Returns playing state.",
+	                  FALSE,
+	                  G_PARAM_READWRITE |
+	                  G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK |
+	                  G_PARAM_STATIC_BLURB));
+	
+	g_object_class_install_property
+	        (object_class,
+	         PROP_POSITION,
+	         g_param_spec_int
+	                 ("position",
+	                  "Position",
+	                  "The position in the current stream in seconds.",
+	                  0, G_MAXINT, 0,
+	                  G_PARAM_READWRITE |
+	                  G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK |
+	                  G_PARAM_STATIC_BLURB));
+	
+	g_object_class_install_property
+	        (object_class,
+	         PROP_VOLUME,
+	         g_param_spec_uint
+	                 ("volume",
+	                  "Volume",
+	                  "The audio volume.",
+	                  0, VLC_VOL_MAX, VLC_VOL_DEFAULT,
+	                  G_PARAM_READWRITE |
+	                  G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK |
+	                  G_PARAM_STATIC_BLURB));
+	
+	g_object_class_install_property
+	        (object_class,
+	         PROP_MUTE,
+	         g_param_spec_uint
+	                 ("mute",
+	                  "Mute",
+	                  "The audio mute.",
+	                  0, 1, VLC_VOL_MUTE_DEFAULT,
+	                  G_PARAM_READWRITE |
+	                  G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK |
+	                  G_PARAM_STATIC_BLURB));
+
+	g_object_class_install_property
+	        (object_class,
+	         PROP_CAN_SEEK,
+	         g_param_spec_boolean
+	                 ("can-seek",
+	                  "Can seek",
+	                  "TRUE if the current stream is seekable.",
+	                  FALSE,
+	                  G_PARAM_READABLE |
+	                  G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK |
+	                  G_PARAM_STATIC_BLURB));
+	
+	g_object_class_install_property
+	        (object_class,
+	         PROP_DURATION,
+	         g_param_spec_int
+	                 ("duration",
+	                  "Duration",
+	                  "The duration of the current stream in seconds.",
+	                  0, G_MAXINT, 0,
+	                  G_PARAM_READABLE |
+	                  G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK |
+	                  G_PARAM_STATIC_BLURB));
+
+	signals[PLAYING] =
+	        g_signal_new ("playing",
+	                      OWL_TYPE_AUDIO_PLAYER,
+	                      G_SIGNAL_RUN_LAST,
+	                      G_STRUCT_OFFSET (OwlAudioPlayerClass,
+	                                       playing),
+	                      NULL, NULL,
+	                      g_cclosure_marshal_VOID__VOID,
+	                      G_TYPE_NONE, 0);
+
+	signals[PAUSED] =
+	        g_signal_new ("paused",
+	                      OWL_TYPE_AUDIO_PLAYER,
+	                      G_SIGNAL_RUN_LAST,
+	                      G_STRUCT_OFFSET (OwlAudioPlayerClass,
+	                                       paused),
+	                      NULL, NULL,
+	                      g_cclosure_marshal_VOID__VOID,
+	                      G_TYPE_NONE, 0);
+
+	signals[EOS] =
+	        g_signal_new ("eos",
+	                      OWL_TYPE_AUDIO_PLAYER,
+	                      G_SIGNAL_RUN_LAST,
+	                      G_STRUCT_OFFSET (OwlAudioPlayerClass,
+	                                       eos),
+	                      NULL, NULL,
+	                      g_cclosure_marshal_VOID__VOID,
+	                      G_TYPE_NONE, 0);
+
+	signals[ERROR] =
+	        g_signal_new ("error",
+	                      OWL_TYPE_AUDIO_PLAYER,
+	                      G_SIGNAL_RUN_LAST,
+	                      G_STRUCT_OFFSET (OwlAudioPlayerClass,
+	                                       error),
+	                      NULL, NULL,
+	                      g_cclosure_marshal_VOID__POINTER,
+	                      G_TYPE_NONE, 1, G_TYPE_POINTER);
+}
+
+/**
+ * owl_audio_player_construct
+ *
+ * Return value: A new #OwlAudioPlayer.
+ **/
+OwlAudioPlayer *
+owl_audio_player_construct (GType object_type)
+{
+	return g_object_new (OWL_TYPE_AUDIO_PLAYER, NULL);
+}
+
+/**
+ * owl_audio_player_new
+ *
+ * Return value: A new #OwlAudioPlayer.
+ **/
+OwlAudioPlayer *
+owl_audio_player_new (void)
+{
+	return owl_audio_player_construct (OWL_TYPE_AUDIO_PLAYER);
+}
+
+/**
+ * owl_audio_player_set_protocol_info
+ * @audio_player: A #OwlAudioPlayer
+ * @protocol_info: A PROTOCOL_INFO
+ *
+ * Loads @protocol_info.
+ **/
+void
+owl_audio_player_set_protocol_info (OwlAudioPlayer *audio_player,
+                                    const char     *protocol_info)
+{
+	g_return_if_fail (OWL_IS_AUDIO_PLAYER (audio_player));
+
+	if (!audio_player->priv->pMediaPlayer)
+	        return;
+
+	if (protocol_info && audio_player->priv->protocol_info && !strcmp(protocol_info, audio_player->priv->protocol_info)) {
+		return;
+	}
+
+	g_free (audio_player->priv->protocol_info);
+
+	if (protocol_info) {
+	        audio_player->priv->protocol_info = g_strdup (protocol_info);
+	} else {
+	        audio_player->priv->protocol_info = NULL;
+	}
+}
+
+/**
+ * owl_audio_player_get_protocol_info
+ * @audio_player: A #OwlAudioPlayer
+ *
+ * Return value: The DLNA protocolInfo, or NULL if none set.
+ **/
+const char *
+owl_audio_player_get_protocol_info (OwlAudioPlayer *audio_player)
+{
+	g_return_val_if_fail (OWL_IS_AUDIO_PLAYER (audio_player), NULL);
+
+	return audio_player->priv->protocol_info;
+}
+
+/**
+ * owl_audio_player_get_uri
+ * @audio_player: A #OwlAudioPlayer
+ *
+ * Return value: The loaded URI, or NULL if none set.
+ **/
+const char *
+owl_audio_player_get_uri (OwlAudioPlayer *audio_player)
+{
+	g_return_val_if_fail (OWL_IS_AUDIO_PLAYER (audio_player), NULL);
+	
+	return audio_player->priv->uri;
+}
+
+/**
+ * owl_audio_player_pause
+ * @audio_player: A #OwlAudioPlayer
+ *
+ * Pauses playing media.
+ **/
+void
+owl_audio_player_pause (OwlAudioPlayer *audio_player)
+{
+	g_return_if_fail (OWL_IS_AUDIO_PLAYER (audio_player));
+
+	if (!audio_player->priv->pMediaPlayer)
+	        return;
+
+	if (owl_audio_player_get_state(audio_player) != OWL_PLAYING_STATE_PLAYING) {
+		return;
+	}
+
+	libvlc_media_player_pause(audio_player->priv->pMediaPlayer);
+}
+
+/**
+ * owl_audio_player_resume
+ * @audio_player: A #OwlAudioPlayer
+ *
+ * Resumes paused media.
+ **/
+void
+owl_audio_player_resume (OwlAudioPlayer *audio_player)
+{
+	g_return_if_fail (OWL_IS_AUDIO_PLAYER (audio_player));
+
+	if (!audio_player->priv->pMediaPlayer)
+	        return;
+
+	if (owl_audio_player_get_state(audio_player) != OWL_PLAYING_STATE_PAUSED_PLAYBACK) {
+		return;
+	}
+
+	libvlc_media_player_pause(audio_player->priv->pMediaPlayer);
+}
+
+/**
+ * owl_audio_player_stop
+ * @audio_player: A #OwlAudioPlayer
+ *
+ * Stops playing media.
+ **/
+void
+owl_audio_player_stop (OwlAudioPlayer *audio_player)
+{
+	g_return_if_fail (OWL_IS_AUDIO_PLAYER (audio_player));
+
+	if (!audio_player->priv->pMediaPlayer)
+	        return;
+
+	libvlc_media_player_stop(audio_player->priv->pMediaPlayer);
+}
+
+/**
+ * owl_audio_player_play
+ * @audio_player: A #OwlAudioPlayer
+ * @uri: A URI
+ *
+ * Plays the media at @uri.
+ **/
+void
+owl_audio_player_play (OwlAudioPlayer *audio_player,
+                       const char *uri)
+{
+	g_return_if_fail (OWL_IS_AUDIO_PLAYER (audio_player));
+
+	if (!audio_player->priv->pMediaPlayer)
+	        return;
+
+	if (!uri) {
+		return;
+	}
+
+	g_free (audio_player->priv->uri);
+    	audio_player->priv->uri = g_strdup (uri);
+
+    	/**
+	 * Set new media.
+	 **/
+	libvlc_media_t * pMedia = libvlc_media_new_location (audio_player->priv->pVLCInstance, uri);
+	if(!pMedia) {
+		printf("%s: libvlc_media_new_location failed\n",__func__);
+	}
+	libvlc_event_attach(libvlc_media_event_manager(pMedia),
+	                    libvlc_MediaDurationChanged,
+	                    vlc_media_player_duration_changed_cb,
+	                    audio_player);
+	libvlc_media_player_set_media (audio_player->priv->pMediaPlayer, pMedia);
+
+	/**
+	 * Set DLNA protocolInfo of the media item
+	 **/
+	if (audio_player->priv->protocol_info) {
+		libvlc_media_player_set_protocol_info(audio_player->priv->pMediaPlayer, audio_player->priv->protocol_info);
+	}
+
+	/**
+	 * Play media
+	 **/
+	printf("%s: before libvlc_media_player_play\n",__func__);
+	libvlc_media_player_play(audio_player->priv->pMediaPlayer);
+	printf("%s: after libvlc_media_player_play\n",__func__);
+
+	libvlc_media_release(pMedia);
+
+	/**
+	 * Reset properties.
+	 **/
+	audio_player->priv->can_seek = 0;
+	audio_player->priv->duration = -1;
+}
+
+/**
+ * owl_audio_player_get_state
+ * @audio_player: A #OwlAudioPlayer
+ *
+ * Return value: Playing state of @audio_player.
+ **/
+owl_playing_state
+owl_audio_player_get_state (OwlAudioPlayer *audio_player)
+{
+	g_return_val_if_fail (OWL_IS_AUDIO_PLAYER (audio_player), FALSE);
+	
+	if (!audio_player->priv->pMediaPlayer)
+	        return FALSE;
+	
+	libvlc_state_t state = libvlc_media_player_get_state(audio_player->priv->pMediaPlayer);
+	
+	switch (state) {
+	case libvlc_Opening:
+	case libvlc_Buffering:
+		return OWL_PLAYING_STATE_TRANSITIONING;
+	case libvlc_Playing:
+		return OWL_PLAYING_STATE_PLAYING;
+	case libvlc_Stopped:
+	case libvlc_Ended:
+	case libvlc_Error:
+	case libvlc_NothingSpecial:
+		return OWL_PLAYING_STATE_STOPPED;
+	case libvlc_Paused:
+		return OWL_PLAYING_STATE_PAUSED_PLAYBACK;
+	}
+}
+
+/**
+ * owl_audio_player_set_position
+ * @audio_player: A #OwlAudioPlayer
+ * @time_in_seconds: The position in the current stream in seconds.
+ *
+ * Sets the position in the current stream to @time_in_seconds.
+ **/
+void
+owl_audio_player_set_position (OwlAudioPlayer *audio_player,
+                               int time_in_seconds)
+{
+	g_return_if_fail (OWL_IS_AUDIO_PLAYER (audio_player));
+	
+	if (!audio_player->priv->pVLCInstance)
+		return;
+
+	if (time_in_seconds < 0) {
+		return;
+	}
+
+	libvlc_time_t time_in_mseconds = time_in_seconds * 1000;
+	libvlc_media_player_set_time(audio_player->priv->pMediaPlayer, time_in_mseconds);
+	g_debug("%p: New time is %lld", audio_player, time_in_mseconds);
+}
+
+/**
+ * owl_audio_player_get_position
+ * @audio_player: A #OwlAudioPlayer
+ *
+ * Return value: The position in the current file in seconds.
+ **/
+int
+owl_audio_player_get_position (OwlAudioPlayer *audio_player)
+{
+	g_return_val_if_fail (OWL_IS_AUDIO_PLAYER (audio_player), -1);
+	
+	if (!audio_player->priv->pMediaPlayer)
+	        return -1;
+
+	libvlc_time_t time_in_mseconds = libvlc_media_player_get_time(audio_player->priv->pMediaPlayer);
+
+	return time_in_mseconds / 1000;
+}
+
+/**
+ * owl_audio_player_set_volume
+ * @audio_player: A #OwlAudioPlayer
+ * @volume: The audio volume to set, in the range 0.0 - 4.0.
+ *
+ * Sets the current audio volume to @volume.
+ **/
+void
+owl_audio_player_set_volume (OwlAudioPlayer *audio_player,
+                             unsigned int          volume)
+{
+	g_return_if_fail (OWL_IS_AUDIO_PLAYER (audio_player));
+	g_return_if_fail (volume >= 0.0 && volume <= VLC_VOL_MAX);
+	
+	if (!audio_player->priv->pVLCInstance)
+	        return;
+		
+	libvlc_audio_set_volume(audio_player->priv->pVLCInstance, volume);
+}
+
+/**
+ * owl_audio_player_get_volume
+ * @audio_player: A #OwlAudioPlayer
+ *
+ * Return value: The current audio volume, in the range 0.0 - 4.0.
+ **/
+unsigned int
+owl_audio_player_get_volume (OwlAudioPlayer *audio_player)
+{
+	unsigned int volume;
+	
+	g_return_val_if_fail (OWL_IS_AUDIO_PLAYER (audio_player), 0);
+	
+	if (!audio_player->priv->pVLCInstance)
+	        return 0.0;
+	
+	volume = libvlc_audio_get_volume(audio_player->priv->pVLCInstance);
+	
+	return volume;
+}
+
+/**
+ * owl_audio_player_set_mute
+ * @audio_player: A #OwlAudioPlayer
+ * @mute: TRUE if volume should be muted, FALSE otherwise
+ *
+ * Sets the current audio mute to @mute.
+ **/
+void
+owl_audio_player_set_mute (OwlAudioPlayer *audio_player,
+                           gboolean                mute)
+{
+	g_return_if_fail (OWL_IS_AUDIO_PLAYER (audio_player));
+
+	if (!audio_player->priv->pVLCInstance)
+	        return;
+
+	libvlc_audio_set_mute(audio_player->priv->pVLCInstance, mute);
+}
+
+/**
+ * owl_audio_player_get_mute
+ * @audio_player: A #OwlAudioPlayer
+ *
+ * Return value: TRUE if the current volume is muted.
+ **/
+gboolean
+owl_audio_player_get_mute (OwlAudioPlayer *audio_player)
+{
+	gboolean mute;
+
+	g_return_val_if_fail (OWL_IS_AUDIO_PLAYER (audio_player), 0);
+
+	if (!audio_player->priv->pVLCInstance)
+	        return FALSE;
+
+	mute = libvlc_audio_get_mute(audio_player->priv->pVLCInstance);
+
+	return mute;
+}
+
+/**
+ * owl_audio_player_get_can_seek
+ * @audio_player: A #OwlAudioPlayer
+ *
+ * Return value: TRUE if the current stream is seekable.
+ **/
+gboolean
+owl_audio_player_get_can_seek (OwlAudioPlayer *audio_player)
+{
+	g_return_val_if_fail (OWL_IS_AUDIO_PLAYER (audio_player), FALSE);
+	
+	int is_seekable = libvlc_media_player_is_seekable(audio_player->priv->pMediaPlayer);
+	return is_seekable;
+}
+
+/**
+ * owl_audio_player_get_duration
+ * @audio_player: A #OwlAudioPlayer
+ *
+ * Return value: The duration of the current stream in seconds.
+ **/
+int
+owl_audio_player_get_duration (OwlAudioPlayer *audio_player)
+{
+	g_return_val_if_fail (OWL_IS_AUDIO_PLAYER (audio_player), -1);
+	
+	return audio_player->priv->duration;
+}
--- /dev/null
+++ b/src/plugins/gst-renderer/owl-audio-player.h
@@ -0,0 +1,147 @@
+/*
+ * owl-audio-player.h
+ *   A GObject based wrapper for vlc media player
+ *
+ * (C) Copyright 2010, Ubicom, Inc.
+ *
+ * This file is part of the Ubicom32 Rygel.
+ *
+ * This program is free software: you can redistribute
+ * it and/or modify it under the terms of the GNU Lesser General Public 
+ * License (LGPL) as published by the Free Software Foundation, either version 2.1
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it
+ * will be useful, but WITHOUT ANY WARRANTY; without even the implied
+ * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+ * the GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program.  If not,
+ * see <http://www.gnu.org/licenses/>.
+ *
+ * Ubicom32 implementation derived from (with many thanks):
+ *   OpenedHand's owl-audio-player.h file by Jorn Baayen <jorn@openedhand.com>
+ */
+
+#ifndef __OWL_AUDIO_PLAYER_H__
+#define __OWL_AUDIO_PLAYER_H__
+
+#include <glib-object.h>
+
+G_BEGIN_DECLS
+
+#define OWL_TYPE_AUDIO_PLAYER \
+                (owl_audio_player_get_type ())
+#define OWL_AUDIO_PLAYER(obj) \
+                (G_TYPE_CHECK_INSTANCE_CAST ((obj), \
+                 OWL_TYPE_AUDIO_PLAYER, \
+                 OwlAudioPlayer))
+#define OWL_AUDIO_PLAYER_CLASS(klass) \
+                (G_TYPE_CHECK_CLASS_CAST ((klass), \
+                 OWL_TYPE_AUDIO_PLAYER, \
+                 OwlAudioPlayerClass))
+#define OWL_IS_AUDIO_PLAYER(obj) \
+                (G_TYPE_CHECK_INSTANCE_TYPE ((obj), \
+                 OWL_TYPE_AUDIO_PLAYER))
+#define OWL_IS_AUDIO_PLAYER_CLASS(klass) \
+                (G_TYPE_CHECK_CLASS_TYPE ((klass), \
+                 OWL_TYPE_AUDIO_PLAYER))
+#define OWL_AUDIO_PLAYER_GET_CLASS(obj) \
+                (G_TYPE_INSTANCE_GET_CLASS ((obj), \
+                 OWL_TYPE_AUDIO_PLAYER, \
+                 OwlAudioPlayerClass))
+
+typedef enum _owl_playing_state{
+        OWL_PLAYING_STATE_PLAYING,
+        OWL_PLAYING_STATE_PAUSED_PLAYBACK,
+        OWL_PLAYING_STATE_STOPPED,
+	 OWL_PLAYING_STATE_TRANSITIONING
+} owl_playing_state;
+
+typedef struct _OwlAudioPlayerPrivate OwlAudioPlayerPrivate;
+
+typedef struct {
+        GObject parent;
+
+        OwlAudioPlayerPrivate *priv;
+} OwlAudioPlayer;
+
+typedef struct {
+        GObjectClass parent_class;
+
+        /* Signals */
+        void (* playing)            (OwlAudioPlayer *audio_player);
+        void (* paused)             (OwlAudioPlayer *audio_player);
+        void (* eos)                (OwlAudioPlayer *audio_player);
+        void (* error)              (OwlAudioPlayer *audio_player,
+                                     GError         *error);
+        
+        /* Future padding */
+        void (* _reserved1) (void);
+        void (* _reserved2) (void);
+        void (* _reserved3) (void);
+        void (* _reserved4) (void);
+} OwlAudioPlayerClass;
+
+GType
+owl_audio_player_get_type           (void) G_GNUC_CONST;
+
+OwlAudioPlayer *
+owl_audio_player_new                (void);
+
+const char *
+owl_audio_player_get_uri            (OwlAudioPlayer *audio_player);
+
+void
+owl_audio_player_set_protocol_info  (OwlAudioPlayer *audio_player,
+                                     const char     *protocol_info);
+
+const char *
+owl_audio_player_get_protocol_info  (OwlAudioPlayer *audio_player);
+
+void
+owl_audio_player_play               (OwlAudioPlayer *audio_player,
+                                     const char     *uri);
+
+void
+owl_audio_player_pause              (OwlAudioPlayer *audio_player);
+
+void
+owl_audio_player_resume             (OwlAudioPlayer *audio_player);
+
+void
+owl_audio_player_stop               (OwlAudioPlayer *audio_player);
+
+owl_playing_state
+owl_audio_player_get_state        (OwlAudioPlayer *audio_player);
+
+void
+owl_audio_player_set_position       (OwlAudioPlayer *audio_player,
+                                     int             time_in_seconds);
+
+int
+owl_audio_player_get_position       (OwlAudioPlayer *audio_player);
+
+void
+owl_audio_player_set_volume         (OwlAudioPlayer *audio_player,
+                                     unsigned int          volume);
+
+unsigned int
+owl_audio_player_get_volume         (OwlAudioPlayer *audio_player);
+
+void
+owl_audio_player_set_mute           (OwlAudioPlayer *audio_player,
+                                     gboolean                mute);
+gboolean
+owl_audio_player_get_mute           (OwlAudioPlayer *audio_player);
+
+gboolean
+owl_audio_player_get_can_seek       (OwlAudioPlayer *audio_player);
+
+int
+owl_audio_player_get_duration       (OwlAudioPlayer *audio_player);
+
+G_END_DECLS
+
+#endif /* __OWL_AUDIO_PLAYER_H__ */
--- /dev/null
+++ b/src/plugins/gst-renderer/owl-audio-player.vapi
@@ -0,0 +1,69 @@
+/*
+ * owl-audio-player.vapi
+ *   A GObject based wrapper for vlc media player
+ *
+ * (C) Copyright 2010, Ubicom, Inc.
+ *
+ * This file is part of the Ubicom32 Rygel.
+ *
+ * This program is free software: you can redistribute
+ * it and/or modify it under the terms of the GNU Lesser General Public 
+ * License (LGPL) as published by the Free Software Foundation, either version 2.1
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it
+ * will be useful, but WITHOUT ANY WARRANTY; without even the implied
+ * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+ * the GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program.  If not,
+ * see <http://www.gnu.org/licenses/>.
+ *
+ * Ubicom32 implementation derived from (with many thanks):
+ *   OpenedHand's owl-audio-player.vapi file by Jorn Baayen <jorn@openedhand.com>
+ */
+
+[CCode (cprefix = "Owl", lower_case_cprefix = "owl_")]
+namespace Owl {
+	[CCode (cname = "owl_playing_state", has_type_id = false)]
+	public enum PlayingState {
+		PLAYING,
+		PAUSED_PLAYBACK,
+		STOPPED,
+		TRANSITIONING
+	}
+
+	[CCode (cheader_filename = "owl-audio-player.h")]
+	public class AudioPlayer : GLib.Object {
+		public bool get_can_seek ();
+		public int get_duration ();
+		public bool get_mute ();
+		public PlayingState get_state ();
+		public int get_position ();
+		public weak string get_uri ();
+		public weak string get_protocol_info ();
+		public uint get_volume ();
+		public AudioPlayer ();
+		public void set_mute (bool mute);
+		public void play (string uri);
+		public void pause ();
+		public void resume ();
+		public void stop ();
+		public void set_position (int time_in_seconds);
+		public void set_protocol_info (string protocol_info);
+		public void set_volume (uint volume);
+		public bool can_seek { get; }
+		public int duration { get; }
+		public bool mute { get; set; }
+		public PlayingState state { get; }
+		public int position { get; set; }
+		public string uri { get; }
+		public string protocol_info { get; set; }
+		public uint volume { get; set; }
+		public virtual signal void playing ();
+		public virtual signal void paused ();
+		public virtual signal void eos ();
+		public virtual signal void error (GLib.Error error);
+	}
+}
--- /dev/null
+++ b/src/plugins/gst-renderer/owl-video-widget.h
@@ -0,0 +1,128 @@
+/*
+ * Copyright (C) 2006 OpenedHand Ltd.
+ *
+ * OpenedHand Widget Library Video Widget - A GStreamer video GTK+ widget
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ * Author: Jorn Baayen <jorn@openedhand.com>
+ */
+
+#ifndef __OWL_VIDEO_WIDGET_H__
+#define __OWL_VIDEO_WIDGET_H__
+
+#include <gtk/gtkbin.h>
+#include <gst/gsttaglist.h>
+
+G_BEGIN_DECLS
+
+#define OWL_TYPE_VIDEO_WIDGET \
+                (owl_video_widget_get_type ())
+#define OWL_VIDEO_WIDGET(obj) \
+                (G_TYPE_CHECK_INSTANCE_CAST ((obj), \
+                 OWL_TYPE_VIDEO_WIDGET, \
+                 OwlVideoWidget))
+#define OWL_VIDEO_WIDGET_CLASS(klass) \
+                (G_TYPE_CHECK_CLASS_CAST ((klass), \
+                 OWL_TYPE_VIDEO_WIDGET, \
+                 OwlVideoWidgetClass))
+#define OWL_IS_VIDEO_WIDGET(obj) \
+                (G_TYPE_CHECK_INSTANCE_TYPE ((obj), \
+                 OWL_TYPE_VIDEO_WIDGET))
+#define OWL_IS_VIDEO_WIDGET_CLASS(klass) \
+                (G_TYPE_CHECK_CLASS_TYPE ((klass), \
+                 OWL_TYPE_VIDEO_WIDGET))
+#define OWL_VIDEO_WIDGET_GET_CLASS(obj) \
+                (G_TYPE_INSTANCE_GET_CLASS ((obj), \
+                 OWL_TYPE_VIDEO_WIDGET, \
+                 OwlVideoWidgetClass))
+
+typedef struct _OwlVideoWidgetPrivate OwlVideoWidgetPrivate;
+
+typedef struct {
+        GtkBin parent;
+
+        OwlVideoWidgetPrivate *priv;
+} OwlVideoWidget;
+
+typedef struct {
+        GtkBinClass parent_class;
+
+        /* Signals */
+        void (* tag_list_available) (OwlVideoWidget *video_widget,
+                                     GstTagList     *tag_list);
+        void (* eos)                (OwlVideoWidget *video_widget);
+        void (* error)              (OwlVideoWidget *video_widget,
+                                     GError         *error);
+        
+        /* Future padding */
+        void (* _owl_reserved1) (void);
+        void (* _owl_reserved2) (void);
+        void (* _owl_reserved3) (void);
+        void (* _owl_reserved4) (void);
+} OwlVideoWidgetClass;
+
+GType
+owl_video_widget_get_type               (void) G_GNUC_CONST;
+
+GtkWidget *
+owl_video_widget_new                    (void);
+
+void
+owl_video_widget_set_uri                (OwlVideoWidget *video_widget,
+                                         const char     *uri);
+
+const char *
+owl_video_widget_get_uri                (OwlVideoWidget *video_widget);
+
+void
+owl_video_widget_set_playing            (OwlVideoWidget *video_widget,
+                                         gboolean        playing);
+
+gboolean
+owl_video_widget_get_playing            (OwlVideoWidget *video_widget);
+
+void
+owl_video_widget_set_position           (OwlVideoWidget *video_widget,
+                                         int             position);
+
+int
+owl_video_widget_get_position           (OwlVideoWidget *video_widget);
+
+void
+owl_video_widget_set_volume             (OwlVideoWidget *video_widget,
+                                         double          volume);
+
+double
+owl_video_widget_get_volume             (OwlVideoWidget *video_widget);
+
+gboolean
+owl_video_widget_get_can_seek           (OwlVideoWidget *video_widget);
+
+int
+owl_video_widget_get_buffer_percent     (OwlVideoWidget *video_widget);
+
+int
+owl_video_widget_get_duration           (OwlVideoWidget *video_widget);
+
+void
+owl_video_widget_set_force_aspect_ratio (OwlVideoWidget *video_widget,
+                                         gboolean        force_aspect_ratio);
+
+gboolean
+owl_video_widget_get_force_aspect_ratio (OwlVideoWidget *video_widget);
+
+G_END_DECLS
+
+#endif /* __OWL_VIDEO_WIDGET_H__ */
--- /dev/null
+++ b/src/plugins/gst-renderer/owl-video-widget.vapi
@@ -0,0 +1,31 @@
+[CCode (cprefix = "Owl", lower_case_cprefix = "owl_")]
+namespace Owl {
+	[CCode (cheader_filename = "owl-video-widget.h")]
+	public class VideoWidget : Gtk.Bin, Atk.Implementor, Gtk.Buildable {
+		public int get_buffer_percent ();
+		public bool get_can_seek ();
+		public int get_duration ();
+		public bool get_force_aspect_ratio ();
+		public bool get_playing ();
+		public int get_position ();
+		public weak string get_uri ();
+		public double get_volume ();
+		public VideoWidget ();
+		public void set_force_aspect_ratio (bool force_aspect_ratio);
+		public void set_playing (bool playing);
+		public void set_position (int position);
+		public void set_uri (string uri);
+		public void set_volume (double volume);
+		public int buffer_percent { get; }
+		public bool can_seek { get; }
+		public int duration { get; }
+		public bool force_aspect_ratio { get; set; }
+		public bool playing { get; set; }
+		public int position { get; set; }
+		public string uri { get; set; }
+		public double volume { get; set; }
+		public virtual signal void eos ();
+		public virtual signal void error (GLib.Error error);
+		public virtual signal void tag_list_available (Gst.TagList tag_list);
+	}
+}
--- /dev/null
+++ b/src/plugins/gst-renderer/rygel-gst-audio-player-instance.vala
@@ -0,0 +1,37 @@
+/*
+ * rygel-gst-audio-player-instance.vala
+ *   Singleton implementation for audio player
+ *
+ * (C) Copyright 2010, Ubicom, Inc.
+ *
+ * This file is part of the Ubicom32 Rygel.
+ *
+ * This program is free software: you can redistribute
+ * it and/or modify it under the terms of the GNU Lesser General Public 
+ * License (LGPL) as published by the Free Software Foundation, either version 2.1
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it
+ * will be useful, but WITHOUT ANY WARRANTY; without even the implied
+ * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+ * the GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program.  If not,
+ * see <http://www.gnu.org/licenses/>.
+ */
+
+using Owl;
+
+public class Rygel.GstAudioPlayerInstance : AudioPlayer {
+	
+  	private static GstAudioPlayerInstance audio_player = null;
+	
+  	public static GstAudioPlayerInstance instance() {
+		if (audio_player == null) {
+			audio_player = new GstAudioPlayerInstance();
+		}
+		
+		return audio_player;
+	}
+}
\ No newline at end of file
--- /dev/null
+++ b/src/plugins/gst-renderer/rygel-gst-av-transport.vala
@@ -0,0 +1,592 @@
+/*
+ * Copyright (C) 2008 OpenedHand Ltd.
+ * Copyright (C) 2009 Nokia Corporation.
+ *
+ * Author: Jorn Baayen <jorn@openedhand.com>
+ *         Zeeshan Ali (Khattak) <zeeshanak@gnome.org>
+ *                               <zeeshan.ali@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ */
+
+using GUPnP;
+using Rygel.Helper;
+using CStuff;
+using Owl;
+
+public class Rygel.GstAVTransport : Service {
+    public const string UPNP_ID = "urn:upnp-org:serviceId:AVTransport";
+    public const string UPNP_TYPE =
+                    "urn:schemas-upnp-org:service:AVTransport:1";
+    public const string DESCRIPTION_PATH = "xml/AVTransport.xml";
+    public const string LAST_CHANGE_NS =
+                    "urn:schemas-upnp-org:metadata-1-0/AVT/";
+
+    public  static string PLAY_SPEED = "1";
+    private static string PLAY_MODE = "NORMAL";
+    private static string PLAYBACK_MEDIA = "NONE,NETWORK";
+    private static string TRANSPORT_STATUS = "OK";
+
+    public MetadataParser metadataParser;
+    private DBusService dbus_service;
+
+    private PlayerPlaying           state_playing           = new PlayerPlaying();
+    private PlayerNoMediaPresent    state_no_media_present  = new PlayerNoMediaPresent();
+    private PlayerStopped           state_stopped           = new PlayerStopped();
+    private PlayerTransitioning     state_transitioning     = new PlayerTransitioning();
+    private PlayerPausedPlayback    state_paused_playback   = new PlayerPausedPlayback();
+    private PlayerState             cur_state;
+
+    // The setters below update the LastChange message
+    private uint _n_tracks = 0;
+    public uint n_tracks {
+        get {
+            return this._n_tracks;
+        }
+
+        set {
+            this._n_tracks = value;
+
+            this.changelog.log ("NumberOfTracks", this._n_tracks.to_string ());
+        }
+    }
+
+    private uint _track = 0;
+    public uint track {
+        get {
+            return this._track;
+        }
+
+        set {
+            this._track = value;
+
+            this.changelog.log ("CurrentTrack", this._track.to_string ());
+        }
+    }
+
+    private string _metadata = "";
+    public string metadata {
+        get {
+            return this._metadata;
+        }
+
+        set {
+            this._metadata = value;
+
+            string escaped = Markup.escape_text (this._metadata, -1);
+
+            this.changelog.log ("CurrentTrackMetaData", escaped);
+            this.changelog.log ("AVTransportURIMetaData", escaped);
+        }
+    }
+
+    public string playback_state {
+        owned get {
+            return this.cur_state.get_name ();
+        }
+
+        set {
+            if (value == this.playback_state) {
+                /*Ignore the state change request*/
+                debug("Already in " + value + ". Ignoring state change request.");
+                return;
+            }
+
+            switch (value) {
+                case "STOPPED":
+                    if (dbus_service != null) {
+                        dbus_service.PlayerStopped();
+                    }
+                    this.cur_state = this.state_stopped;
+                    break;
+                case "PAUSED_PLAYBACK":
+                    this.cur_state = this.state_paused_playback;
+                    break;
+                case "PLAYING":
+                    if (dbus_service != null) {
+                        string artist = (this.metadataParser == null || this.metadataParser.artist == null) ? "" : this.metadataParser.artist;
+                        string title = (this.metadataParser == null || this.metadataParser.title == null) ? "" : this.metadataParser.title;
+                        dbus_service.PlayerPlaying(artist, title);
+                    }
+                    this.cur_state = this.state_playing;
+                    break;
+                case "NO_MEDIA_PRESENT":
+                    this.cur_state = this.state_no_media_present;
+                    break;
+                case "TRANSITIONING":
+                    this.cur_state = this.state_transitioning;
+                    break;
+                default:
+                    break;
+            }
+            this.cur_state.enter (this);
+        }
+    }
+
+    private string _uri = "";
+    public string uri {
+        //transfer ownership by owned
+        owned get {
+                return _uri;
+        }
+
+        set {
+            this._uri = Markup.escape_text (value);
+
+            this.n_tracks = 1;
+            this.track = 1;
+            this.position = "00:00:00";
+            if (this._uri == "") {
+                this.playback_state = "NO_MEDIA_PRESENT";
+                this.n_tracks = 0;
+                this.track = 0;
+                this.metadataParser = null;
+            } else {
+                if (this.playback_state == "NO_MEDIA_PRESENT") {
+                    this.playback_state = "STOPPED";
+                }
+            }
+
+            this.changelog.log ("CurrentTrackURI", this._uri);
+            this.changelog.log ("AVTransportURI", this._uri);
+        }
+    }
+
+    public string duration {
+        //transfer ownership by owned
+        owned get {
+            if (this.metadataParser != null && this.metadataParser.duration != -1) {
+                return GstTime.to_string((int)this.metadataParser.duration);
+            }
+            if (this.uri != "") {
+                debug("%p: duration get %s", this, GstTime.to_string(this.audio_player.duration));
+                return GstTime.to_string(this.audio_player.duration);
+            } else {
+                return "00:00:00";
+            }
+        }
+    }
+
+    private void notify_duration_cb (Object audio_player, ParamSpec p) {
+        this.changelog.log ("CurrentTrackDuration", this.duration);
+        this.changelog.log ("CurrentMediaDuration", this.duration);
+        Timeout.add (1, this.change_state);
+    }
+
+    public string position {
+        //transfer ownership by owned
+        owned get {
+            if (this.uri == "") {
+                return "00:00:00";
+            }
+            return GstTime.to_string(this.audio_player.position);
+        }
+
+        set {
+            this.audio_player.position = GstTime.from_string (value);
+            debug("%p: position set %s", this, value);
+        }
+    }
+
+    public string protocol_info {
+        //transfer ownership by owned
+        owned get {
+                if (this.metadataParser != null && this.metadataParser.protocol_info != null) {
+                    return this.metadataParser.protocol_info.to_string();
+                }
+                return "";
+        }
+    }
+
+    private bool change_state () {
+        PlayingState new_state = audio_player.state;
+        if (this.playback_state == "STOPPED" && new_state != PlayingState.TRANSITIONING) {
+            debug("Possibly invalid transition callback from player");
+            return false;
+        }
+
+        switch(new_state) {
+        case PlayingState.PLAYING:
+            this.playback_state = "PLAYING";
+            break;
+        case PlayingState.PAUSED_PLAYBACK:
+            this.playback_state = "PAUSED_PLAYBACK";
+            break;
+        case PlayingState.STOPPED:
+            this.playback_state = "STOPPED";
+            break;
+        case PlayingState.TRANSITIONING:
+            this.playback_state = "TRANSITIONING";
+            break;
+        }
+
+        return false;
+    }
+
+    private void playing_cb () {
+        debug("%p: playing callback from player", this);
+        if (this.audio_player.duration == -1) {
+            debug("Duration is not computed yet");
+            Timeout.add_seconds (3, this.change_state);
+            return;
+        }
+        Timeout.add (1, this.change_state);
+    }
+
+    private void paused_cb () {
+        debug("%p: paused callback from player", this);
+        Timeout.add (1, this.change_state);
+    }
+
+    private bool eos_cb_timeout () {
+        this.playback_state = "STOPPED";
+        return false;
+    }
+
+    private void eos_cb () {
+        debug("%p: eos callback from player", this);
+        Timeout.add (1, this.eos_cb_timeout);
+    }
+
+    private void player_error_cb () {
+        /*
+         * An error might occur at the player side for several reasons.
+         * One common reason is the player might not be supporting the
+         * requested media format. In such a case we stop the player.
+         */
+        debug("%p: Error received from media player", this);
+        Timeout.add (1, this.change_state);
+    }
+
+    public GstChangeLog changelog;
+    private GstAudioPlayerInstance audio_player;
+
+    public override void constructed () {
+
+        this.changelog = new GstChangeLog (this, LAST_CHANGE_NS);
+        this.audio_player = GstAudioPlayerInstance.instance();
+        this.cur_state = this.state_no_media_present;
+
+        query_variable["LastChange"]            += this.query_last_change_cb;
+
+        action_invoked["SetAVTransportURI"]     += this.set_av_transport_uri_cb;
+        action_invoked["GetMediaInfo"]          += this.get_media_info_cb;
+        action_invoked["GetTransportInfo"]      += this.get_transport_info_cb;
+        action_invoked["GetCurrentTransportActions"]
+                                                += this.get_current_current_transport_actions_cb;
+        action_invoked["GetPositionInfo"]       += this.get_position_info_cb;
+        action_invoked["GetDeviceCapabilities"] += this.get_device_capabilities_cb;
+        action_invoked["GetTransportSettings"]  += this.get_transport_settings_cb;
+        action_invoked["Stop"]                  += this.stop_cb;
+        action_invoked["Play"]                  += this.play_cb;
+        action_invoked["Pause"]                 += this.pause_cb;
+        action_invoked["Seek"]                  += this.seek_cb;
+        action_invoked["Next"]                  += this.next_cb;
+        action_invoked["Previous"]              += this.previous_cb;
+
+        this.audio_player.notify["duration"]    += notify_duration_cb;
+        this.audio_player.playing               += this.playing_cb;
+        this.audio_player.paused                += this.paused_cb;
+        this.audio_player.eos                   += this.eos_cb;
+        this.audio_player.error                 += this.player_error_cb;
+
+        dbus_service = DBusService.get_default();
+        if (dbus_service == null) {
+            warning("%p: DBus service instance not created.", this);
+            return;
+        }
+    }
+
+    private void query_last_change_cb (GstAVTransport s,
+                                       string         variable,
+                                       ref Value      val) {
+
+        debug("%p: Initial Event Notification was sent for AVTransport", this);
+
+        // Send current state
+        GstChangeLog log = new GstChangeLog (null, LAST_CHANGE_NS);
+
+        string escaped;
+
+        /*
+            AVTransport.xml <serviceStateTable>
+            <stateVariable>
+        */
+
+        log.log ("TransportState",               this.playback_state);
+        log.log ("TransportStatus",              this.TRANSPORT_STATUS);
+        log.log ("CurrentTransportActions",      this.cur_state.get_current_transport_actions ());
+        log.log ("PlaybackStorageMedium",        "NOT_IMPLEMENTED");
+        log.log ("RecordStorageMedium",          "NOT_IMPLEMENTED");
+        log.log ("PossiblePlaybackStorageMedia", this.PLAYBACK_MEDIA);
+        log.log ("PossibleRecordStorageMedia",   "NOT_IMPLEMENTED");
+        log.log ("CurrentPlayMode",              this.PLAY_MODE);
+        log.log ("TransportPlaySpeed",           this.PLAY_SPEED);
+        log.log ("RecordMediumWriteStatus",      "NOT_IMPLEMENTED");
+        log.log ("CurrentRecordQualityMode",     "NOT_IMPLEMENTED");
+        log.log ("PossibleRecordQualityModes",   "NOT_IMPLEMENTED");
+        log.log ("NumberOfTracks",               this.n_tracks.to_string ());
+        log.log ("CurrentTrack",                 this.track.to_string ());
+        log.log ("CurrentTrackDuration",         this.duration);
+        log.log ("CurrentMediaDuration",         this.duration);
+        escaped = Markup.escape_text (this.metadata, -1);
+        log.log ("CurrentTrackMetaData",         escaped);
+        log.log ("AVTransportURIMetaData",       escaped);
+        log.log ("CurrentTrackURI",              this.uri);
+        log.log ("AVTransportURI",               this.uri);
+        log.log ("NextAVTransportURI",           "NOT_IMPLEMENTED");
+        log.log ("NextAVTransportURIMetaData",   "NOT_IMPLEMENTED");
+
+        val.init (typeof (string));
+        val.set_string (log.finish ());
+    }
+
+    // Error out if InstanceID is not 0
+    private bool check_instance_id (ServiceAction action) {
+        uint instance_id;
+
+        action.get ("InstanceID", typeof (uint), out instance_id);
+        if (instance_id != 0) {
+            action.return_error (718, "Invalid InstanceID");
+
+            return false;
+        }
+
+        return true;
+    }
+
+    private void set_av_transport_uri_cb (GstAVTransport      s,
+                                          owned ServiceAction action) {
+        if (!this.check_instance_id (action)) {
+            return;
+        }
+
+        string _uri, _metadata;
+
+        action.get ("CurrentURI",         typeof (string), out _uri,
+                    "CurrentURIMetaData", typeof (string), out _metadata);
+
+        this.uri = _uri;
+
+        this.metadataParser = new MetadataParser(_uri);
+        try {
+                this.metadataParser.parse_didl(_metadata);
+
+                debug("%p: Artist        : %s",  this, this.metadataParser.artist);
+                debug("%p: Song          : %s",  this, this.metadataParser.title);
+                debug("%p: Bitrate       : %d",  this, this.metadataParser.bitrate);
+                debug("%p: # Audio chans : %d",  this, this.metadataParser.audio_channels);
+                debug("%p: Sampling rate : %d",  this, this.metadataParser.sample_freq);
+                debug("%p: Duration      : %ld", this, this.metadataParser.duration);
+                debug("%p: Size          : %ld", this, this.metadataParser.size);
+        } catch (GLib.Error e) {
+                warning("%p: Couldn't parse metadata!", this);
+        }
+
+        this.metadata = _metadata;
+        if (this.metadataParser != null && this.metadataParser.protocol_info != null) {
+            this.audio_player.protocol_info = this.metadataParser.protocol_info.to_string ();
+        } else {
+            this.audio_player.protocol_info = null;
+        }
+
+        debug("%p: Set AVTransport URI: %s", this, this.uri);
+
+        action.return ();
+    }
+
+    private void get_media_info_cb (GstAVTransport      s,
+                                    owned ServiceAction action) {
+        if (!this.check_instance_id (action)) {
+            return;
+        }
+
+        action.set ("NrTracks",
+                        typeof (uint),
+                        this.n_tracks,
+                    "MediaDuration",
+                        typeof (string),
+                        this.duration,
+                    "CurrentURI",
+                        typeof (string),
+                        this.uri,
+                    "CurrentURIMetaData",
+                        typeof (string),
+                        this.metadata,
+                    "NextURI",
+                        typeof (string),
+                        "NOT_IMPLEMENTED",
+                    "NextURIMetaData",
+                        typeof (string),
+                        "NOT_IMPLEMENTED",
+                    "PlayMedium",
+                        typeof (string),
+                        "NOT_IMPLEMENTED",
+                    "RecordMedium",
+                        typeof (string),
+                        "NOT_IMPLEMENTED",
+                    "WriteStatus",
+                        typeof (string),
+                        "NOT_IMPLEMENTED");
+
+        action.return ();
+    }
+
+    private void get_transport_info_cb (GstAVTransport      s,
+                                        owned ServiceAction action) {
+        if (!this.check_instance_id (action)) {
+            return;
+        }
+
+        action.set ("CurrentTransportState",
+                        typeof (string),
+                        this.playback_state,
+                    "CurrentTransportStatus",
+                        typeof (string),
+                        this.TRANSPORT_STATUS,
+                    "CurrentSpeed",
+                        typeof (string),
+                        this.PLAY_SPEED);
+
+        action.return ();
+    }
+
+    private void get_current_current_transport_actions_cb (GstAVTransport      s,
+                                                           owned ServiceAction action) {
+        if (!this.check_instance_id (action)) {
+            return;
+        }
+
+        action.set ("Actions",
+                        typeof (string),
+                        this.cur_state.get_current_transport_actions ());
+
+        debug("%p: Get Current Transport Actions: %s", this, this.cur_state.get_current_transport_actions ());
+
+        action.return ();
+
+    }
+
+    private void get_position_info_cb (GstAVTransport      s,
+                                       owned ServiceAction action) {
+        if (!this.check_instance_id (action)) {
+            return;
+        }
+
+        action.set ("Track",
+                        typeof (uint),
+                        this.track,
+                    "TrackDuration",
+                        typeof (string),
+                        this.duration,
+                    "TrackMetaData",
+                        typeof (string),
+                        this.metadata,
+                    "TrackURI",
+                        typeof (string),
+                        this.uri,
+                    "RelTime",
+                        typeof (string),
+                        this.position,
+                    "AbsTime",
+                        typeof (string),
+                        this.position,
+                    "RelCount",
+                        typeof (int),
+                        int.MAX,
+                    "AbsCount",
+                        typeof (int),
+                        int.MAX);
+
+        action.return ();
+    }
+
+    private void get_device_capabilities_cb (GstAVTransport      s,
+                                             owned ServiceAction action) {
+        if (!this.check_instance_id (action)) {
+            return;
+        }
+
+        action.set ("PlayMedia",       typeof (string), this.PLAYBACK_MEDIA,
+                    "RecMedia",        typeof (string), "NOT_IMPLEMENTED",
+                    "RecQualityModes", typeof (string), "NOT_IMPLEMENTED");
+
+        action.return ();
+    }
+
+    private void get_transport_settings_cb (GstAVTransport      s,
+                                            owned ServiceAction action) {
+        if (!this.check_instance_id (action)) {
+            return;
+        }
+
+        action.set ("PlayMode",       typeof (string), this.PLAY_MODE,
+                    "RecQualityMode", typeof (string), "NOT_IMPLEMENTED");
+
+        action.return ();
+    }
+
+    private void stop_cb (GstAVTransport s, owned ServiceAction action) {
+        if (!this.check_instance_id (action)) {
+            return;
+        }
+
+        this.cur_state.stop (s, action);
+    }
+
+    private void play_cb (GstAVTransport s, owned ServiceAction action) {
+        if (!this.check_instance_id (action)) {
+            return;
+        }
+
+        this.cur_state.play (s, action, this.uri);
+    }
+
+    private void pause_cb (GstAVTransport s, owned ServiceAction action) {
+        if (!this.check_instance_id (action)) {
+            return;
+        }
+
+        this.cur_state.pause (s, action);
+    }
+
+    private void seek_cb (GstAVTransport s, owned ServiceAction action) {
+        if (!check_instance_id (action)) {
+            return;
+        }
+
+        this.cur_state.seek (s, action);
+    }
+
+    public virtual void next_cb (GstAVTransport s, owned ServiceAction action) {
+        if (!check_instance_id (action)) {
+            return;
+        }
+
+        this.cur_state.next (s, action);
+    }
+
+    public virtual void previous_cb (GstAVTransport s, owned ServiceAction action) {
+        if (!check_instance_id (action)) {
+            return;
+        }
+
+        this.cur_state.previous (s, action);
+    }
+}
--- /dev/null
+++ b/src/plugins/gst-renderer/rygel-gst-changelog.vala
@@ -0,0 +1,144 @@
+/*
+ * Copyright (C) 2008 OpenedHand Ltd.
+ * Copyright (C) 2009 Nokia Corporation.
+ *
+ * Author: Jorn Baayen <jorn@openedhand.com>
+ *         Zeeshan Ali (Khattak) <zeeshanak@gnome.org>
+ *                               <zeeshan.ali@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ */
+
+using GUPnP;
+using Gee;
+
+// Helper class for building LastChange messages
+public class Rygel.GstChangeLog : Object {
+    public unowned Service service { get; set; }
+
+    private string service_ns;
+
+    private StringBuilder str;
+
+    private HashMap<string, string> hash;
+    private Mutex hash_mutex;
+
+    private uint timeout_id = 0;
+
+    public GstChangeLog (Service? service, string service_ns) {
+        this.service = service;
+        this.service_ns = service_ns;
+        this.str = new StringBuilder ();
+        this.hash = new HashMap<string, string> ();
+        this.hash_mutex = new Mutex();
+    }
+
+    ~GstChangeLog () {
+        if (this.timeout_id != 0) {
+            Source.remove (this.timeout_id);
+        }
+    }
+
+    private bool timeout () {
+        if(this.hash.size != 0) {
+            // Emit notification
+            this.notify_change ();
+
+            return true;
+        }
+
+        this.timeout_id = 0;
+
+        return false;
+    }
+
+    private void ensure_timeout () {
+        /*
+         * Get into the moderation period,
+         * accumulate updates of any state variables and sent out them when period expires.
+         */
+        this.timeout_id = Timeout.add (400, this.timeout);
+    }
+
+    private void notify_change () {
+        string notify_message;
+        notify_message = this.finish ();
+        this.service.notify ("LastChange",
+                             typeof (string),
+                             notify_message);
+        //debug("%p: LastChange Event Notification Message was Sent: %s\n", this, notify_message);
+
+        // Reset
+        hash_mutex.lock();
+        this.hash.clear ();
+        hash_mutex.unlock();
+        this.str.erase (0, -1);	
+    }
+
+    public void log (string variable,
+                     string value) {
+        hash_mutex.lock();
+        this.hash.set (variable,
+                       "<%s val=\"%s\"/>".printf (variable,value));
+        hash_mutex.unlock();
+
+        if (this.service != null && this.timeout_id == 0) {
+            /*
+             * It's an itinial LastChange event and should be sent out immediately, 
+             * for followings events get into moderation period 
+             */
+            this.notify_change ();
+            this.ensure_timeout ();
+        }
+    }
+
+    public void log_with_channel (string variable,
+                                  string value,
+                                  string channel) {
+        hash_mutex.lock();
+        this.hash.set (variable,
+                       "<%s val=\"%s\" channel=\"%s\"/>".printf (variable,
+                       value,
+                       channel));
+        hash_mutex.unlock();
+
+        if (this.service != null && this.timeout_id == 0) {
+            /*
+             * It's an itinial LastChange event and should be sent out immediately,
+             * for followings events get into moderation period
+             */
+            this.notify_change ();
+            this.ensure_timeout ();
+        }
+    }
+
+    public string finish () {
+        this.str.append ("<Event xmlns=\"" +
+                         this.service_ns +
+                         "\"><InstanceID val=\"0\">");
+        hash_mutex.lock();
+        foreach (string line in this.hash.values) {
+            this.str.append (line);
+        }
+        hash_mutex.unlock();
+        this.str.append ("</InstanceID></Event>");
+
+        return this.str.str;
+    }
+}
--- /dev/null
+++ b/src/plugins/gst-renderer/rygel-gst-connection-manager.vala
@@ -0,0 +1,97 @@
+/*
+ * Copyright (C) 2008 OpenedHand Ltd.
+ *
+ * Author: Jorn Baayen <jorn@openedhand.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ */
+
+using GUPnP;
+
+public class Rygel.GstConnectionManager : Rygel.ConnectionManager {
+    public override void constructed () {
+        base.constructed ();
+
+        this.connection_ids       = "0";
+        this.sink_protocol_info   = "http-get:*:audio/L16:DLNA.ORG_PN=LPCM;DLNA.ORG_FLAGS=AD300000000000000000000000000000," +
+                                    "http-get:*:audio/mpeg:DLNA.ORG_PN=MP3;DLNA.ORG_FLAGS=AD300000000000000000000000000000," +
+                                    "http-get:*:audio/vnd.dlna.adts:DLNA.ORG_PN=AAC_ADTS;DLNA.ORG_FLAGS=AD300000000000000000000000000000," +
+                                    "http-get:*:audio/mp4:DLNA.ORG_PN=AAC_ISO;DLNA.ORG_FLAGS=AD300000000000000000000000000000," +
+                                    "http-get:*:audio/3gpp:DLNA.ORG_PN=AAC_ISO;DLNA.ORG_FLAGS=AD300000000000000000000000000000," +
+                                    "http-get:*:audio/mp4:DLNA.ORG_PN=AAC_ISO_320;DLNA.ORG_FLAGS=AD300000000000000000000000000000," +
+                                    "http-get:*:audio/3gpp:DLNA.ORG_PN=AAC_ISO_320;DLNA.ORG_FLAGS=AD300000000000000000000000000000," +
+                                    "http-get:*:audio/vnd.dlna.adts:DLNA.ORG_PN=AAC_ADTS_320;DLNA.ORG_FLAGS=AD300000000000000000000000000000," +
+                                    "http-get:*:audio/mp4:DLNA.ORG_PN=AAC_LTP_ISO;DLNA.ORG_FLAGS=AD300000000000000000000000000000," +
+                                    "http-get:*:audio/L16:*," +
+                                    "http-get:*:audio/mpeg:*," +
+                                    "http-get:*:audio/mp4:*," +
+                                    "http-get:*:audio/3gpp:*," +
+                                    "http-get:*:audio/x-m4a:*," +
+                                    "http-get:*:audio/x-wav:*," +
+									"http-get:*:audio/x-vorbis:*," +
+                                    "http-get:*:audio/x-vorbis+ogg:*," +
+									"http-get:*:audio/x-ms-wma:*," +
+                                    "http-get:*:audio/x-ms-asf:*," +
+                                    "http-get:*:audio/x-flac:*," +
+                                    "http-get:*:audio/x-mod:*," +
+									"http-get:*:audio/x-ac3:*," +
+                                    "http-get:*:audio/x-m4a:*";
+    }
+
+    private override void get_current_connection_info_cb (ConnectionManager   cm,
+                                                 owned ServiceAction action) {
+
+        int connection_id;
+
+        /* We support single connection at a time, which must have ConnectionID=0 */
+        action.get ("ConnectionID", typeof (int), out connection_id);
+        if (connection_id != 0) {
+            action.return_error (706, "Invalid connection reference");
+
+            return;
+        }
+
+        RootDevice root_device = (Rygel.RootDevice) this.root_device;
+        GstAVTransport avt = null;
+
+        /* Find the AVTransport service attached to this root device. */
+        foreach (var service in root_device.services) {
+            if (service.get_type().is_a (typeof (Rygel.GstAVTransport))) {
+                avt = (Rygel.GstAVTransport) service;
+                break;
+            }
+        }
+
+        if (avt == null) {
+            /* This should never happen in fact! */
+            action.return_error (501, "Action Failed");
+            return;
+        }
+
+        action.set ("RcsID",                 typeof (int),    0,
+                    "AVTransportID",         typeof (int),    0,
+                    "ProtocolInfo",          typeof (string), avt.protocol_info,
+                    "PeerConnectionManager", typeof (string), "",
+                    "PeerConnectionID",      typeof (int),    -1,
+                    "Direction",             typeof (string), "Input",
+                    "Status",                typeof (string), "Unknown");
+
+        action.return ();
+    }
+}
--- /dev/null
+++ b/src/plugins/gst-renderer/rygel-gst-metadata-parser.vala
@@ -0,0 +1,131 @@
+/*
+ * rygel-gst-metadata-parser.vala
+ *   Metadata parser implementation
+ *
+ * (C) Copyright 2010, Ubicom, Inc.
+ *
+ * This file is part of the Ubicom32 Rygel.
+ *
+ * This program is free software: you can redistribute
+ * it and/or modify it under the terms of the GNU Lesser General Public 
+ * License (LGPL) as published by the Free Software Foundation, either version 2.1
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it
+ * will be useful, but WITHOUT ANY WARRANTY; without even the implied
+ * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+ * the GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program.  If not,
+ * see <http://www.gnu.org/licenses/>.
+ */
+
+using GUPnP;
+using CStuff;
+
+public class Rygel.MetadataParser : GUPnP.DIDLLiteParser {
+
+       private DIDLLiteObject object;
+       private DIDLLiteResource resource;
+       private string resourceURI;
+
+       public MetadataParser (string resourceURI) {
+               this.resourceURI        = resourceURI;
+               this.object_available   += this.object_available_cb;
+       }
+
+       private void object_available_cb(DIDLLiteObject object)
+       {
+               debug("object_available_cb");
+               this.object = object;
+
+               foreach(var resource in object.get_resources()){
+                       if (this.resourceURI == resource.uri) {
+                               this.resource = resource;
+                               break;
+                       }
+               }
+       }
+
+       public string title {
+               get {
+                       if (object != null) {
+                               return object.title;
+                       }
+                       return "";
+               }
+       }
+
+       public string artist {
+               get {
+                       if (object != null) {
+                               return object.artist;
+                       }
+                       return "";
+               }
+       }
+
+       public int bitrate {
+               get {
+                       if (resource != null) {
+                               return resource.bitrate;
+                       }
+                       return -1;
+               }
+       }
+
+       public int sample_freq {
+               get {
+                       if (resource != null) {
+                               return resource.sample_freq;
+                       }
+                       return -1;
+               }
+       }
+
+       public int audio_channels {
+               get {
+                       if (resource != null) {
+                               return resource.audio_channels;
+                       }
+                       return -1;
+               }
+       }
+
+       public long duration {
+               get {
+                       if (resource != null) {
+                               return resource.duration;
+                       }
+                       return -1;
+               }
+       }
+
+       public long size {
+               get {
+                       if (resource != null) {
+                               return resource.size;
+                       }
+                       return -1;
+               }
+       }
+
+       public string uri {
+               get {
+                       if (resource != null) {
+                               return resource.uri;
+                       }
+                       return "";
+               }
+       }
+
+       public ProtocolInfo? protocol_info {
+               get {
+                       if (resource != null) {
+                               return resource.protocol_info;
+                       }
+                       return null;
+               }
+       }
+}
--- /dev/null
+++ b/src/plugins/gst-renderer/rygel-gst-player-states.vala
@@ -0,0 +1,249 @@
+/*
+ * rygel-gst-audio-player-instance.vala
+ *   Singleton implementation for audio player
+ *
+ * (C) Copyright 2010, Ubicom, Inc.
+ *
+ * This file is part of the Ubicom32 Rygel.
+ *
+ * This program is free software: you can redistribute
+ * it and/or modify it under the terms of the GNU Lesser General Public 
+ * License (LGPL) as published by the Free Software Foundation, either version 2.1
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it
+ * will be useful, but WITHOUT ANY WARRANTY; without even the implied
+ * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+ * the GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program.  If not,
+ * see <http://www.gnu.org/licenses/>.
+ */
+
+using Owl;
+using GUPnP;
+using Rygel.Helper;
+
+public class Rygel.PlayerState {
+    private string state_name;
+    private string current_transport_actions;
+
+    public PlayerState(string state_name, string current_transport_actions) {
+        this.state_name = state_name;
+        this.current_transport_actions = current_transport_actions;
+    }
+
+    public virtual void enter (GstAVTransport s) {
+        debug("%p: Changing playback state to %s", this, this.state_name);
+        s.changelog.log ("TransportState", this.state_name);
+        s.changelog.log ("CurrentTransportActions", this.current_transport_actions);
+    }
+
+    public virtual string get_name () {
+        return this.state_name;
+    }
+
+    public virtual string get_current_transport_actions () {
+        return this.current_transport_actions;
+    }
+
+    public virtual void play (GstAVTransport s, owned ServiceAction action, string uri) {
+        debug("%p: %s: Play Action Requested, Transition not available", this, this.get_name());
+        action.return_error (701, "Transition not available");
+    }
+
+    public virtual void pause (GstAVTransport s, owned ServiceAction action) {
+        debug("%p: %s: Pause Action Requested, Transition not available", this, this.get_name());
+        action.return_error (701, "Transition not available");
+    }
+
+    public virtual void stop (GstAVTransport s, owned ServiceAction action) {
+        debug("%p: %s: Stop Action Requested, Transition not available", this, this.get_name());
+        action.return_error (701, "Transition not available");
+    }
+
+    public virtual void seek (GstAVTransport s, owned ServiceAction action) {
+        debug("%p: Seek Action Requested, Transition not available", this);
+        action.return_error (701, "Transition not available");
+    }
+
+    protected virtual void default_seek (GstAVTransport s, owned ServiceAction action) {
+        string unit, target;
+        action.get ("Unit",   typeof (string), out unit,
+                    "Target", typeof (string), out target);
+
+        switch (unit) {
+        case "ABS_TIME":
+        case "REL_TIME":
+                ProtocolInfo pinfo = s.metadataParser.protocol_info;
+                if (pinfo != null) {
+                    if ((pinfo.dlna_flags & DLNAFlags.BYTE_BASED_SEEK) != 0) {
+                        debug("%p: Server supports byte-based seek under LRADA mode", this);
+                    } else if ((pinfo.dlna_operation & DLNAOperation.RANGE) != 0) {
+                        debug("%p: Server supports byte-based seek under FRADA mode", this);
+                    } else {
+                        /* Currently, we only support byte-based seek in transport. */
+                        debug("%p: Time-based seek not supported!", this);
+                        action.return_error (710, "Seek mode not supported");
+                        return;
+                    }
+                } else {
+                        /*
+                         * Looks like we received a non-dlna content. However,
+                         * the Control Point might be non-dlna, hence does not provide
+                         * any DLNA info even if the server provides it. In such a case,
+                         * the transport layer is responsible to check that information.
+                         */
+                        debug("%p: No DLNA info found for the resource.", this);
+                }
+
+                if(GstTime.from_string (target) >= GstTime.from_string (s.duration)) {
+                        debug("%p:Seek Target value greater than or equal to TrackDuration !", this);
+                        action.return_error (711, "Illegal Seek Target");
+                        return;
+                }
+
+                s.position = target;
+                debug("%p: Seek Action Requested with Position: %s", this, s.position);
+                action.return ();
+
+                return;
+        default:
+            action.return_error (710, "Seek mode not supported");
+
+            return;
+        }
+    }
+
+    public virtual void next (GstAVTransport s, owned ServiceAction action) {
+        debug("%p: Next Action Requested, Illegal Seek Target", this);
+        action.return_error (711, "Illegal Seek Target");
+    }
+
+    public virtual void previous (GstAVTransport s, owned ServiceAction action) {
+        debug("%p: Previous Action Requested, Illegal Seek Target", this);
+        action.return_error (711, "Illegal Seek Target");
+    }
+}
+
+public class Rygel.PlayerNoMediaPresent : PlayerState {
+
+    public PlayerNoMediaPresent() {
+        base("NO_MEDIA_PRESENT", "");
+    }
+}
+
+public class Rygel.PlayerTransitioning : PlayerState {
+
+    public PlayerTransitioning() {
+        base("TRANSITIONING", "");
+    }
+}
+
+public class Rygel.PlayerStopped : PlayerState {
+
+    public PlayerStopped() {
+        base("STOPPED", "Play,Seek,X_DLNA_SeekTime");
+    }
+
+    public override void play (GstAVTransport s, owned ServiceAction action, string uri) {
+        string speed;
+        action.get ("Speed", typeof (string), out speed);
+        if (speed != s.PLAY_SPEED) {
+            action.return_error (717, "Play speed not supported");
+
+            return;
+        }
+
+        GstAudioPlayerInstance.instance().play (uri);
+        s.playback_state = "TRANSITIONING";
+
+        action.return ();
+    }
+
+    public override void seek (GstAVTransport s, owned ServiceAction action) {
+        default_seek(s, action);
+    }
+
+    public override void stop (GstAVTransport s, owned ServiceAction action) {
+        GstAudioPlayerInstance.instance().stop ();
+
+        action.return ();
+    }
+}
+
+public class Rygel.PlayerPlaying : PlayerState {
+
+    public PlayerPlaying() {
+        base("PLAYING", "Stop,Pause,Seek,X_DLNA_SeekTime");
+    }
+
+    public override void play (GstAVTransport s, owned ServiceAction action, string uri) {
+        string speed;
+        action.get ("Speed", typeof (string), out speed);
+        if (speed != s.PLAY_SPEED) {
+            action.return_error (717, "Play speed not supported");
+
+            return;
+        }
+
+        if (uri != GstAudioPlayerInstance.instance().uri) {
+            GstAudioPlayerInstance.instance().play (uri);
+            s.playback_state = "TRANSITIONING";
+        }
+
+        action.return ();
+    }
+
+    public override void pause (GstAVTransport s, owned ServiceAction action) {
+        s.playback_state = "TRANSITIONING";
+        GstAudioPlayerInstance.instance().pause ();
+
+        action.return ();
+    }
+
+    public override void stop (GstAVTransport s, owned ServiceAction action) {
+        GstAudioPlayerInstance.instance().stop ();
+
+        action.return ();
+    }
+
+    public override void seek (GstAVTransport s, owned ServiceAction action) {
+        default_seek(s, action);
+    }
+}
+
+public class Rygel.PlayerPausedPlayback : PlayerState {
+
+    public PlayerPausedPlayback() {
+        base("PAUSED_PLAYBACK", "Stop,Play");
+    }
+
+    public override void play (GstAVTransport s, owned ServiceAction action, string uri) {
+        string speed;
+        action.get ("Speed", typeof (string), out speed);
+        if (speed != s.PLAY_SPEED) {
+            action.return_error (717, "Play speed not supported");
+
+            return;
+        }
+
+        if (uri != GstAudioPlayerInstance.instance().uri) {
+            GstAudioPlayerInstance.instance().play (uri);
+            s.playback_state = "TRANSITIONING";
+        } else {
+            GstAudioPlayerInstance.instance().resume ();
+            s.playback_state = "PLAYING";
+        }
+
+        action.return ();
+    }
+
+    public override void stop (GstAVTransport s, owned ServiceAction action) {
+        GstAudioPlayerInstance.instance().stop ();
+
+        action.return ();
+    }
+}
+
--- /dev/null
+++ b/src/plugins/gst-renderer/rygel-gst-plugin.vala
@@ -0,0 +1,53 @@
+/*
+ * Copyright (C) 2008 Zeeshan Ali (Khattak) <zeeshanak@gnome.org>.
+ * Copyright (C) 2008 Nokia Corporation, all rights reserved.
+ *
+ * Author: Zeeshan Ali (Khattak) <zeeshanak@gnome.org>
+ *                               <zeeshan.ali@nokia.com>
+ *
+ * This file is part of Rygel.
+ *
+ * Rygel is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * Rygel is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ */
+
+using Rygel;
+using Gee;
+using CStuff;
+
+[ModuleInit]
+public void module_init (PluginLoader loader) {
+    string MEDIA_RENDERER_DESC_PATH = BuildConfig.DATA_DIR +
+                                      "/xml/MediaRenderer.xml";
+
+    var plugin = new Plugin (MEDIA_RENDERER_DESC_PATH,
+                             "GstRenderer",
+                             "Ubicom Renderer");
+
+    plugin.add_resource (new ResourceInfo (ConnectionManager.UPNP_ID,
+                                           ConnectionManager.UPNP_TYPE,
+                                           ConnectionManager.DESCRIPTION_PATH,
+                                           typeof (GstConnectionManager)));
+    plugin.add_resource (new ResourceInfo (GstAVTransport.UPNP_ID,
+                                           GstAVTransport.UPNP_TYPE,
+                                           GstAVTransport.DESCRIPTION_PATH,
+                                           typeof (GstAVTransport)));
+    plugin.add_resource (new ResourceInfo (GstRenderingControl.UPNP_ID,
+                                           GstRenderingControl.UPNP_TYPE,
+                                           GstRenderingControl.DESCRIPTION_PATH,
+                                           typeof (GstRenderingControl)));
+
+    loader.add_plugin (plugin);
+}
+
--- /dev/null
+++ b/src/plugins/gst-renderer/rygel-gst-rendering-control.vala
@@ -0,0 +1,273 @@
+/*
+ * Copyright (C) 2008 OpenedHand Ltd.
+ * Copyright (C) 2009 Nokia Corporation.
+ *
+ * Author: Jorn Baayen <jorn@openedhand.com>
+ *         Zeeshan Ali (Khattak) <zeeshanak@gnome.org>
+ *                               <zeeshan.ali@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ */
+
+using GUPnP;
+using Rygel;
+
+public class Rygel.GstRenderingControl : Service {
+    public const string UPNP_ID = "urn:upnp-org:serviceId:RenderingControl";
+    public const string UPNP_TYPE =
+                    "urn:schemas-upnp-org:service:RenderingControl:1";
+    public const string DESCRIPTION_PATH = "xml/RenderingControl.xml";
+    public const string LAST_CHANGE_NS =
+                    "urn:schemas-upnp-org:metadata-1-0/RCS/";
+
+    private DBusService dbus_service;
+
+    public bool mute {
+        get {
+            return this.audio_player.mute;
+        }
+
+        set {
+            this.audio_player.mute = value;
+            this.changelog.log_with_channel ("Mute",
+                                             value ? "1" : "0",
+                                             "Master");
+            if (dbus_service != null) {
+                dbus_service.Volume (this.volume, value);
+            }
+        }
+    }
+
+    public uint volume {
+        get {
+            return this.audio_player.volume;
+        }
+
+        set {
+            this.audio_player.volume = value;
+            this.changelog.log_with_channel ("Volume",
+                                             value.to_string (),
+                                             "Master");
+            if (dbus_service != null) {
+                dbus_service.Volume (value, this.mute);
+            }
+        }
+    }
+
+    private string _preset_name_list = "FactoryDefaults, InstallationDefaults";
+    public string preset_name_list {
+        get {
+            return this._preset_name_list;
+        }
+
+        set {
+            this._preset_name_list = value;
+
+            if (_preset_name_list  == "FactoryDefaults") {
+                this.mute = false;
+                this.volume = 50;
+            }
+            else if (_preset_name_list == "InstallationDefaults") {
+                //a new preset configuration may be tuned later on for InstallationDefaults
+                this.mute = false;
+                this.volume = 50;
+            }
+
+            this.changelog.log("PresetNameList", this.preset_name_list);
+        }
+    }
+
+    private GstChangeLog changelog;
+    private GstAudioPlayerInstance audio_player;
+
+    public override void constructed () {
+        this.changelog = new GstChangeLog (this, LAST_CHANGE_NS);
+        this.audio_player = GstAudioPlayerInstance.instance ();
+
+        query_variable["LastChange"] += this.query_last_change_cb;
+
+        action_invoked["ListPresets"]  += this.list_presets_cb;
+        action_invoked["SelectPreset"] += this.select_preset_cb;
+        action_invoked["GetMute"]      += this.get_mute_cb;
+        action_invoked["SetMute"]      += this.set_mute_cb;
+        action_invoked["GetVolume"]    += this.get_volume_cb;
+        action_invoked["SetVolume"]    += this.set_volume_cb;
+
+        dbus_service = DBusService.get_default();
+        if (dbus_service == null) {
+            warning("%p: DBus service instance not created.", this);
+            return;
+        }
+    }
+
+    private void query_last_change_cb (GstRenderingControl s,
+                                       string              var,
+                                       ref GLib.Value      val) {
+        debug("%p: Initial Event Notification was sent for RenderingControl", this);
+        // Send current state
+        var log = new GstChangeLog (null, LAST_CHANGE_NS);
+
+        log.log_with_channel ("Mute", this.mute ? "1" : "0", "Master");
+        log.log_with_channel ("Volume", this.volume.to_string (), "Master");
+        log.log("PresetNameList", this.preset_name_list);
+
+        val.init (typeof (string));
+        val.set_string (log.finish ());
+    }
+
+    // Error out if InstanceID is not 0
+    private bool check_instance_id (ServiceAction action) {
+        uint instance_id;
+
+        action.get ("InstanceID", typeof (uint), out instance_id);
+        if (instance_id != 0) {
+            action.return_error (702, "Invalid InstanceID");
+
+            return false;
+        }
+
+        return true;
+    }
+
+    private void list_presets_cb (GstRenderingControl s,
+                                  owned ServiceAction action) {
+        if (!this.check_instance_id (action)) {
+            return;
+        }
+
+        action.set ("CurrentPresetNameList",
+                        typeof (string),
+                        this.preset_name_list);
+
+        action.return ();
+    }
+
+    private void select_preset_cb (GstRenderingControl s,
+                                   owned ServiceAction action) {
+        if (!check_instance_id (action)) {
+            return;
+        }
+
+        string preset_name;
+
+        action.get ("PresetName", typeof (string), out preset_name);
+
+        if (preset_name == "FactoryDefaults") {
+            this.preset_name_list = "FactoryDefaults";
+        }
+        else if (preset_name == "InstallationDefaults") {
+            this.preset_name_list = "InstallationDefaults";
+        }
+        else {
+            action.return_error (701, "Invalid Name");
+
+            return;
+        }
+
+        action.return ();
+    }
+
+    // Error out if 'Channel' is not 'Master'
+    private bool check_channel (ServiceAction action) {
+        string channel;
+
+        action.get ("Channel", typeof (string), out channel);
+        if (channel != "Master") {
+            action.return_error (501, "Action Failed");
+
+            return false;
+        }
+
+        return true;
+    }
+
+    private void get_mute_cb (GstRenderingControl s,
+                              owned ServiceAction action) {
+        if (!this.check_instance_id (action)) {
+            return;
+        }
+
+        if (!check_channel (action)) {
+            return;
+        }
+
+        action.set ("CurrentMute", typeof (bool), this.mute);
+
+        action.return ();
+    }
+
+    private void set_mute_cb (GstRenderingControl s,
+                              owned ServiceAction action) {
+        if (!check_instance_id (action)) {
+            return;
+        }
+
+        if (!check_channel (action)) {
+            return;
+        }
+
+        bool mute;
+
+        action.get ("DesiredMute", typeof (bool), out mute);
+
+        this.mute = mute;
+
+        action.return ();
+    }
+
+    private void get_volume_cb (GstRenderingControl s,
+                                owned ServiceAction action) {
+        if (!this.check_instance_id (action)) {
+            return;
+        }
+
+        if (!check_channel (action)) {
+            return;
+        }
+
+        action.set ("CurrentVolume", typeof (uint), this.volume);
+
+        action.return ();
+    }
+
+    private void set_volume_cb (GstRenderingControl s,
+                                owned ServiceAction action) {
+        if (!this.check_instance_id (action)) {
+            return;
+        }
+
+        if (!check_channel (action)) {
+            return;
+        }
+
+        uint volume;
+
+        action.get ("DesiredVolume", typeof (uint), out volume);
+        if (volume > 100) {
+            action.return_error (501, "Action Failed");
+
+            return;
+        }
+
+        this.volume = volume;
+
+        action.return ();
+    }
+}
+
--- /dev/null
+++ b/src/plugins/gst-renderer/rygel-gst-video-window.vala
@@ -0,0 +1,197 @@
+/*
+ * Copyright (C) 2008 OpenedHand Ltd.
+ *
+ * Author: Jorn Baayen <jorn@openedhand.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ */
+
+using Gtk;
+using Gst;
+using Owl;
+
+public class Rygel.GstVideoWindow : Window {
+    private static GstVideoWindow video_window;
+
+    private VideoWidget video_widget;
+
+    private string _playback_state = "STOPPED";
+    public string playback_state {
+        get {
+            return this._playback_state;
+        }
+
+        set {
+            this._playback_state = value;
+
+            switch (_playback_state) {
+                case "STOPPED":
+                    this.video_widget.playing = false;
+
+                if (this.video_widget.can_seek) {
+                    this.video_widget.position = 0;
+                }
+
+                break;
+                case "PAUSED_PLAYBACK":
+                    this.video_widget.playing = false;
+                break;
+                case "PLAYING":
+                    this.video_widget.playing = true;
+                break;
+                default:
+                break;
+            }
+        }
+    }
+
+    public string uri {
+        get {
+            return this.video_widget.uri;
+        }
+
+        set {
+            this.video_widget.uri = value;
+        }
+    }
+
+    public double volume {
+        get {
+            return this.video_widget.volume;
+        }
+
+        set {
+            this.video_widget.volume = value;
+        }
+    }
+
+    public string duration { get; private set; }
+    public string playback_position { get; private set; }
+
+    construct {
+        this.type = WindowType.TOPLEVEL;
+    }
+
+    private GstVideoWindow () {
+        this.fullscreen_state = true;
+
+        this.video_widget.eos += this.eos_cb;
+        this.video_widget.notify["duration"] += this.notify_duration_cb;
+        this.video_widget.notify["position"] += this.notify_position_cb;
+
+        // Show a video widget
+        this.video_widget = new VideoWidget ();
+        this.video_widget.show ();
+
+        this.add (video_widget);
+        this.show_all ();
+
+        this.key_press_event += this.key_press_callback;
+    }
+
+    public static GstVideoWindow get_default () {
+        if (video_window == null) {
+            video_window = new GstVideoWindow ();
+        }
+
+        return video_window;
+    }
+
+    public bool fullscreen_state {
+        get {
+            if (this.window != null) {
+                return (this.window.get_state () &
+                        Gdk.WindowState.FULLSCREEN) != 0;
+            }
+
+            return false;
+        }
+
+        set {
+            if (value)
+                this.fullscreen ();
+            else {
+                this.unfullscreen ();
+            }
+        }
+    }
+
+    private bool key_press_callback (GstVideoWindow window,
+                                     Gdk.EventKey   event) {
+        switch (event.keyval) {
+            case 0xffc8: /* Gdk.KeySyms.F11 */
+                this.fullscreen_state = ! fullscreen_state;
+                break;
+            case 0xff1b: /* Gdk.KeySyms.Escape */
+                this.fullscreen_state = false;
+                break;
+            default:
+                break;
+        }
+        return false;
+    }
+
+    private void eos_cb (VideoWidget video_widget) {
+        this.playback_state = "STOPPED";
+    }
+
+    private void notify_duration_cb (VideoWidget video_widget,
+                                     ParamSpec   p) {
+        this.duration = Time.to_string (video_widget.duration);
+    }
+
+    private void notify_position_cb (VideoWidget video_widget,
+                                     ParamSpec   p) {
+        this.playback_position = Time.to_string (video_widget.position);
+    }
+
+    public bool seek (string time) {
+        if (this.video_widget.can_seek) {
+            this.video_widget.position = Time.from_string (time);
+
+            return true;
+        } else {
+            return false;
+        }
+    }
+}
+
+// Helper class for converting between second and string representations
+// of time.
+private class Time {
+    public static int from_string (string str) {
+        int hours, minutes, seconds;
+
+        str.scanf ("%d:%2d:%2d%*s", out hours, out minutes, out seconds);
+
+        return hours * 3600 + minutes * 60 + seconds;
+    }
+
+    public static string to_string (int time) {
+        int hours, minutes, seconds;
+
+        hours   = time / 3600;
+        seconds = time % 3600;
+        minutes = seconds / 60;
+        seconds = seconds % 60;
+
+        return "%d:%.2d:%.2d".printf (hours, minutes, seconds);
+    }
+}
+
--- /dev/null
+++ b/src/plugins/gst-renderer/rygel-helper-gst-time.vala
@@ -0,0 +1,46 @@
+/*
+ * Copyright (C) 2008 OpenedHand Ltd.
+ *
+ * Author: Jorn Baayen <jorn@openedhand.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ */
+using CStuff;
+
+// Helper class for converting between second and string representations
+// of time.
+private class Rygel.Helper.GstTime {
+    public static int from_string (string str) {
+        int hours, minutes, seconds;
+
+        str.scanf ("%2d:%2d:%2d%*s", out hours, out minutes, out seconds);
+
+        return hours * 3600 + minutes * 60 + seconds;
+    }
+
+    public static string to_string (int time) {
+        int hours, minutes, seconds;
+
+        hours   = time / 3600;
+        seconds = time % 60;
+        minutes = (time / 60) % 60;
+
+        return "%.2d:%.2d:%.2d".printf (hours, minutes, seconds);
+    }
+}
--- a/src/rygel/Makefile.am
+++ b/src/rygel/Makefile.am
@@ -12,9 +12,14 @@ else
 plugindir = $(libdir)/rygel-1.0
 endif
 
+DATA_DIR=$(shareddir:$(prefix)%=%)
+SYS_CONFIG_DIR=$(sysconfdir:$(prefix)%=%)
+PLUGIN_DIR=$(plugindir:$(prefix)%=%)
+DESKTOP_DIR=$(desktopdir:$(prefix)%=%)
+
 AM_CFLAGS = $(LIBGUPNP_CFLAGS) \
 	    $(LIBGUPNP_AV_CFLAGS) \
-	    $(LIBGSTREAMER_CFLAGS) \
+	    $(LIBGLIB_CFLAGS) \
 	    $(GIO_CFLAGS) \
 	    $(GEE_CFLAGS) \
 	    $(UUID_CFLAGS) \
@@ -22,8 +27,8 @@ AM_CFLAGS = $(LIBGUPNP_CFLAGS) \
 	    $(LIBDBUS_GLIB_CFLAGS) \
 	    $(LIBSQLITE3_CFLAGS) \
 	    -I$(top_srcdir) \
-	    -DDATA_DIR='"$(shareddir)"' -DSYS_CONFIG_DIR='"$(sysconfdir)"'\
-	    -DPLUGIN_DIR='"$(plugindir)"' -DDESKTOP_DIR='"$(desktopdir)"'\
+	    -DDATA_DIR='"$(DATA_DIR)"' -DSYS_CONFIG_DIR='"$(SYS_CONFIG_DIR)"'\
+	    -DPLUGIN_DIR='"$(PLUGIN_DIR)"' -DDESKTOP_DIR='"$(DESKTOP_DIR)"'\
 	    -include config.h
 
 librygelincdir = $(includedir)/rygel-1.0
@@ -47,17 +52,12 @@ VAPI_SOURCE_FILES = rygel-configuration.
 		    rygel-cmdline-config.vala \
 		    rygel-content-directory.vala \
 		    rygel-connection-manager.vala \
-		    rygel-transcode-manager.vala \
 		    rygel-http-server.vala \
 		    rygel-state-machine.vala \
 		    rygel-http-request.vala \
 		    rygel-http-request-handler.vala \
 		    rygel-http-identity-handler.vala \
-		    rygel-http-transcode-handler.vala \
-		    rygel-http-seek.vala \
 		    rygel-http-response.vala \
-		    rygel-live-response.vala \
-		    rygel-seekable-response.vala \
 		    rygel-resource-info.vala \
 		    rygel-icon-info.vala \
 		    rygel-plugin.vala \
@@ -72,28 +72,20 @@ VAPI_SOURCE_FILES = rygel-configuration.
 		    rygel-thumbnailer.vala \
 		    rygel-browse.vala \
 		    rygel-didl-lite-writer.vala \
-		    rygel-transcoder.vala \
-		    rygel-mp2ts-transcoder.vala \
-		    rygel-mp3-transcoder.vala \
-		    rygel-l16-transcoder.vala \
-		    rygel-mp2ts-transcoder-bin.vala \
-		    rygel-mp3-transcoder-bin.vala \
-		    rygel-l16-transcoder-bin.vala \
-		    rygel-gst-utils.vala \
 		    rygel-media-db.vala \
-		    rygel-metadata-extractor.vala \
 		    rygel-media-db-container.vala \
 		    rygel-media-db-object-factory.vala \
-		    rygel-log-handler.vala
+		    rygel-log-handler.vala \
+		    rygel-network-manager.vala \
+		    rygel-network-device.c
 
 rygel_VALAFLAGS = \
-	-H rygel.h -C --library=rygel-1.0 --vapidir=$(srcdir) --thread \
+	-H rygel.h -C --library=rygel-1.0 --vapidir=$(srcdir) --vapidir=$(top_srcdir)/vapi --thread \
 	--pkg cstuff --pkg gupnp-1.0 --pkg gupnp-av-1.0 --pkg dbus-glib-1 \
-	--pkg gstreamer-0.10 --pkg gio-2.0 --pkg gee-1.0 --pkg sqlite3
+	--pkg gmodule-2.0 --pkg gio-2.0 --pkg gee-1.0 --pkg sqlite3 --pkg rygel-network-device
 
 rygel_LDADD = $(LIBGUPNP_LIBS) \
 	      $(LIBGUPNP_AV_LIBS) \
-	      $(LIBGSTREAMER_LIBS) \
 	      $(GIO_LIBS) \
 	      $(GEE_LIBS) \
 	      $(UUID_LIBS) \
@@ -107,7 +99,7 @@ VAPI_FILES = rygel-1.0.vapi
 DEPS_FILES = rygel-1.0.deps
 
 vapidir = $(VAPIDIR)
-vapi_DATA = $(VAPI_FILES) $(DEPS_FILES)
+#vapi_DATA = $(VAPI_FILES) $(DEPS_FILES)
 rygel-1.0.vapi rygel.h: $(VAPI_SOURCE_FILES)
 
 noinst_LIBRARIES = librygel-configuration.a
--- a/src/rygel/rygel-cmdline-config.vala
+++ b/src/rygel/rygel-cmdline-config.vala
@@ -103,7 +103,6 @@ public class Rygel.CmdlineConfig : GLib.
         var opt_context = new OptionContext (parameter_string);
         opt_context.set_help_enabled (true);
         opt_context.add_main_entries (options, null);
-        opt_context.add_group (Gst.init_get_option_group ());
         opt_context.parse (ref args);
 
 		if (version) {
--- a/src/rygel/rygel-connection-manager.vala
+++ b/src/rygel/rygel-connection-manager.vala
@@ -31,7 +31,7 @@ using GUPnP;
 public class Rygel.ConnectionManager : Service {
     public const string UPNP_ID = "urn:upnp-org:serviceId:ConnectionManager";
     public const string UPNP_TYPE =
-                    "urn:schemas-upnp-org:service:ConnectionManager:2";
+                    "urn:schemas-upnp-org:service:ConnectionManager:1";
     public const string DESCRIPTION_PATH = "xml/ConnectionManager.xml";
 
     protected string sink_protocol_info;
@@ -39,7 +39,11 @@ public class Rygel.ConnectionManager : S
 
     protected string source_protocol_info {
         owned get {
-            return this.get_http_server ().get_protocol_info ();
+            HTTPServer server = this.get_http_server ();
+            if (server != null) {
+                return server.get_protocol_info ();
+            }
+            return "";
         }
     }
 
@@ -97,7 +101,7 @@ public class Rygel.ConnectionManager : S
         action.return ();
     }
 
-    private void get_current_connection_info_cb (ConnectionManager   cm,
+    protected virtual void get_current_connection_info_cb (ConnectionManager   cm,
                                                  owned ServiceAction action) {
         int connection_id;
 
@@ -108,8 +112,8 @@ public class Rygel.ConnectionManager : S
             return;
         }
 
-        action.set ("ResID",                 typeof (int),    -1,
-                    "AVTransportID",         typeof (int),    -1,
+        action.set ("RcsID",                 typeof (int),    0,
+                    "AVTransportID",         typeof (int),    0,
                     "ProtocolInfo",          typeof (string), "",
                     "PeerConnectionManager", typeof (string), "",
                     "PeerConnectionID",      typeof (int),    -1,
--- a/src/rygel/rygel-dbus-service.vala
+++ b/src/rygel/rygel-dbus-service.vala
@@ -20,6 +20,8 @@
  * along with this program; if not, write to the Free Software Foundation,
  * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
  */
+using GUPnP;
+using CStuff;
 
 [DBus (name = "org.gnome.Rygel1")]
 public class Rygel.DBusService : Object {
@@ -28,8 +30,35 @@ public class Rygel.DBusService : Object
 
     private Main main;
 
-    public DBusService (Main main) throws DBus.Error {
-        this.main = main;
+    /* Signal emmitted to the bus in case of udn generated */
+    public signal void UdnChanged (string new_udn);
+
+    /* Signal emmitted to the bus in case of player stopped */
+    public signal void PlayerStopped ();
+
+    /* Signal emitted to the bus in case of player is in playing state */
+    public signal void PlayerPlaying (string artist, string title);
+
+    /* Signal emmitted to the bus in case of volume/mute changed */
+    public signal void Volume (uint volume, bool mute);
+
+    private static DBusService instance;
+
+    public static DBusService get_default() {
+        if (instance != null) {
+            return instance;
+        }
+        try {
+            instance = new DBusService();
+        } catch (DBus.Error err) {
+             warning ("Failed to create D-Bus service: %s", err.message);
+             return null;
+        }
+        return instance;
+    }
+
+    private DBusService () throws DBus.Error {
+        this.main = Main.get_default ();
 
         var conn = DBus.Bus.get (DBus.BusType. SESSION);
 
@@ -52,5 +81,61 @@ public class Rygel.DBusService : Object
     public void Shutdown () {
         this.main.exit (0);
     }
+
+    public int ChangeFriendlyName (string friendlyname) {
+	if (friendlyname == "") {
+            warning("%p: Received empty friendly name!", this);
+            return -1;
+	}
+
+        string device_desc_path = "/root/.config/Rygel/GstRenderer.xml";
+        RootDevice root_device = this.main.get_root_device_by_desc_path(device_desc_path);
+        if (root_device == null) {
+            warning("%p: No root device with description path %s", this, device_desc_path);
+            return -1;
+        }
+	
+        /*
+         * Read device description XML file and update the friendly name.
+         */
+        var doc = new XMLDoc.from_path (device_desc_path);
+	Xml.Node *device_element;
+        device_element = Utils.get_xml_element ((Xml.Node *) doc.doc, "root", "device", null);
+        if (device_element == null) {
+            warning ("%p: Element /root/device not found.", this);
+            return -1;
+        }
+
+        Xml.Node *element = Utils.get_xml_element (device_element, "friendlyName", null);
+        if (element == null) {
+            warning ("%p: Element /root/device/friendlyName not found.", this);
+            return -1;
+        }
+
+        string cur_name = element->get_content ();
+        debug("%p: current friendly name : %s New: %s", this, cur_name, friendlyname);
+        element->set_content (friendlyname);
+
+	/*
+	 * Save modified description file
+	 */
+        FileStream fs = FileStream.open (device_desc_path, "w+");
+        if (fs == null) {
+            warning("%p: Could not open file: %s.\n", this, device_desc_path);
+            return -1;
+        }
+
+        int res = Xml.Doc.dump (fs, doc.doc);
+        if (res == -1) {
+            warning("%p: Failed to write modified description to %s.\n", this, device_desc_path);
+            return -1;
+        }
+
+        debug("%p: Sending byebye messages", this);
+        root_device.available = false;
+        debug("%p: Sending alive messages", this);
+        root_device.available = true;
+        return 1;
+    }
 }
 
--- a/src/rygel/rygel-http-identity-handler.vala
+++ b/src/rygel/rygel-http-identity-handler.vala
@@ -49,15 +49,7 @@ internal class Rygel.HTTPIdentityHandler
         }
 
         if (request.thumbnail == null && request.item.should_stream ()) {
-            if (request.time_range != null) {
-                request.time_range.add_response_header (request.msg,
-                                                        request.item.duration);
-            }
         } else {
-            request.msg.response_headers.append ("Accept-Ranges", "bytes");
-            if (request.byte_range != null) {
-                request.byte_range.add_response_header (request.msg, size);
-            }
         }
 
         // Chain-up
@@ -67,28 +59,13 @@ internal class Rygel.HTTPIdentityHandler
     public override HTTPResponse render_body (HTTPRequest request)
                                               throws HTTPRequestError {
         if (request.thumbnail != null) {
-            return new SeekableResponse (request.server,
-                                         request.msg,
-                                         request.thumbnail.uri,
-                                         request.byte_range,
-                                         request.thumbnail.size,
-                                         this.cancellable);
+		throw new HTTPRequestError.NOT_FOUND ("Not found");
         }
 
         var item = request.item;
 
         if (item.should_stream ()) {
-            Gst.Element src = item.create_stream_source ();
-            if (src == null) {
-                throw new HTTPRequestError.NOT_FOUND ("Not found");
-            }
-
-            return new LiveResponse (request.server,
-                                     request.msg,
-                                     "RygelLiveResponse",
-                                     src,
-                                     request.time_range,
-                                     this.cancellable);
+		throw new HTTPRequestError.NOT_FOUND ("Not found");
         } else {
             if (item.uris.size == 0) {
                 throw new HTTPRequestError.NOT_FOUND (
@@ -96,12 +73,7 @@ internal class Rygel.HTTPIdentityHandler
                         item.id);
             }
 
-            return new SeekableResponse (request.server,
-                                         request.msg,
-                                         item.uris.get (0),
-                                         request.byte_range,
-                                         item.size,
-                                         this.cancellable);
+		throw new HTTPRequestError.NOT_FOUND ("Not found");
         }
     }
 
--- a/src/rygel/rygel-http-request.vala
+++ b/src/rygel/rygel-http-request.vala
@@ -23,7 +23,6 @@
  * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
  */
 
-using Gst;
 
 internal errordomain Rygel.HTTPRequestError {
     UNACCEPTABLE = Soup.KnownStatusCode.NOT_ACCEPTABLE,
@@ -49,8 +48,6 @@ internal class Rygel.HTTPRequest : GLib.
     private int thumbnail_index;
     public MediaItem item;
     public Thumbnail thumbnail;
-    public HTTPSeek byte_range;
-    public HTTPSeek time_range;
 
     private HTTPRequestHandler request_handler;
 
@@ -108,15 +105,8 @@ internal class Rygel.HTTPRequest : GLib.
 
     private void handle_item_request () {
         try {
-            this.byte_range = HTTPSeek.from_byte_range(this.msg);
-            this.time_range = HTTPSeek.from_time_range(this.msg);
-
             // Add headers
             this.request_handler.add_response_headers (this);
-            debug ("Following HTTP headers appended to response:");
-            this.msg.response_headers.foreach ((name, value) => {
-                    debug ("%s : %s", name, value);
-            });
 
             if (this.msg.method == "HEAD") {
                 // Only headers requested, no need to send contents
@@ -134,7 +124,7 @@ internal class Rygel.HTTPRequest : GLib.
     }
 
     private void on_item_found (GLib.Object? source_object,
-                                AsyncResult  res) {
+                                AsyncResult res) {
         var container = (MediaContainer) source_object;
 
         MediaObject media_object;
@@ -167,14 +157,6 @@ internal class Rygel.HTTPRequest : GLib.
         }
 
         this.item_id = this.query.lookup ("itemid");
-        var target = this.query.lookup ("transcode");
-        if (target != null) {
-            debug ("Transcoding target: %s", target);
-
-            var transcoder = this.http_server.get_transcoder (target);
-            this.request_handler = new HTTPTranscodeHandler (transcoder,
-                                                             this.cancellable);
-        }
 
         var index = this.query.lookup ("thumbnail");
         if (index != null) {
--- a/src/rygel/rygel-http-response.vala
+++ b/src/rygel/rygel-http-response.vala
@@ -21,7 +21,6 @@
  * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
  */
 
-using Gst;
 
 internal abstract class Rygel.HTTPResponse : GLib.Object, Rygel.StateMachine {
     public Soup.Server server { get; private set; }
--- a/src/rygel/rygel-http-server.vala
+++ b/src/rygel/rygel-http-server.vala
@@ -21,11 +21,10 @@
  * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
  */
 
-using Gst;
 using GUPnP;
 using Gee;
 
-internal class Rygel.HTTPServer : Rygel.TranscodeManager, Rygel.StateMachine {
+internal class Rygel.HTTPServer : GLib.Object, Rygel.StateMachine {
     private const string SERVER_PATH_PREFIX = "/RygelHTTPServer";
     private string path_root;
 
@@ -38,8 +37,6 @@ internal class Rygel.HTTPServer : Rygel.
 
     public HTTPServer (ContentDirectory content_dir,
                        string           name) throws GLib.Error {
-        base ();
-
         this.root_container = content_dir.root_container;
         this.context = content_dir.context;
         this.cancellable = content_dir.cancellable;
@@ -61,7 +58,7 @@ internal class Rygel.HTTPServer : Rygel.
      * implemenation out there just choose the first one in the list instead of
      * the one they can handle.
      */
-    internal override void add_resources (DIDLLiteItem didl_item,
+    internal void add_resources (DIDLLiteItem didl_item,
                                           MediaItem    item)
                                 throws Error {
         if (!this.http_uri_present (item)) {
@@ -71,8 +68,6 @@ internal class Rygel.HTTPServer : Rygel.
             item.add_resource (didl_item, uri, protocol);
         }
 
-        base.add_resources (didl_item, item);
-
         // Thumbnails comes in the end
         foreach (var thumbnail in item.thumbnails) {
             if (!is_http_uri (thumbnail.uri)) {
@@ -126,7 +121,7 @@ internal class Rygel.HTTPServer : Rygel.
                                           path);
     }
 
-    internal override string create_uri_for_item (MediaItem item,
+    internal string create_uri_for_item (MediaItem item,
                                                   int       thumbnail_index,
                                                   string?   transcode_target,
                                                   out string protocol) {
@@ -146,16 +141,12 @@ internal class Rygel.HTTPServer : Rygel.
         return create_uri_for_path (query);
     }
 
-    internal override string get_protocol () {
+    internal string get_protocol () {
         return "http-get";
     }
 
-    internal override string get_protocol_info () {
+    internal string get_protocol_info () {
         var protocol_info = this.get_protocol () + ":*:*:*";
-        var base_info = base.get_protocol_info ();
-
-        if (base_info != "")
-            protocol_info += "," + base_info;
 
         return protocol_info;
     }
--- a/src/rygel/rygel-main.vala
+++ b/src/rygel/rygel-main.vala
@@ -38,6 +38,16 @@ public class Rygel.Main : Object {
 
     private int exit_code;
 
+    private static Main instance;
+    public static Main get_default() {
+        if (instance == null) {
+            instance = new Main();
+        }
+
+        return instance;
+    }
+
+
     private Main () throws GLib.Error {
         Environment.set_application_name (_(BuildConfig.PACKAGE_NAME));
 
@@ -61,6 +71,21 @@ public class Rygel.Main : Object {
         this.main_loop.quit ();
     }
 
+    public RootDevice get_root_device_by_desc_path(string device_desc_path) {
+
+	debug("%p: requested device description path is %s", this, device_desc_path);
+	RootDevice root_device = null;
+	foreach(var _root_device in this.root_devices) {
+		debug("%p: device description path is %s", this, _root_device.description_path);
+		if (_root_device.description_path == device_desc_path) {
+			root_device = _root_device;
+			break;
+		}
+	}
+
+	return root_device;
+    }
+
     private int run () {
         this.plugin_loader.load_plugins ();
 
@@ -193,17 +218,20 @@ public class Rygel.Main : Object {
     private static int main (string[] args) {
         Main main;
         DBusService service;
+        NetworkManagerService nm_service;
+
+        try {
+            nm_service = new NetworkManagerService ();
+        } catch (DBus.Error err) {
+            warning ("Failed to start D-Bus service: %s", err.message);
+        }
 
         try {
             // Parse commandline options
             CmdlineConfig.parse_args (ref args);
 
-            // initialize gstreamer
-            var dummy_args = new string[0];
-            Gst.init (ref dummy_args);
-
-            main = new Main ();
-            service = new DBusService (main);
+            main = Main.get_default ();
+            service = DBusService.get_default ();
         } catch (DBus.Error err) {
             warning ("Failed to start D-Bus service: %s", err.message);
         } catch (CmdlineConfigError.VERSION_ONLY err) {
--- a/src/rygel/rygel-media-item.vala
+++ b/src/rygel/rygel-media-item.vala
@@ -22,7 +22,6 @@
 
 using GUPnP;
 using Gee;
-using Gst;
 
 private errordomain Rygel.MediaItemError {
     BAD_URI
@@ -77,24 +76,6 @@ public class Rygel.MediaItem : MediaObje
         this.thumbnails = new ArrayList<Thumbnail> ();
     }
 
-    // Live media items need to provide a nice working implementation of this
-    // method if they can/do not provide a valid URI
-    public virtual Element? create_stream_source () {
-        dynamic Element src = null;
-
-        if (this.uris.size != 0) {
-            src = Element.make_from_uri (URIType.SRC, this.uris.get (0), null);
-        }
-
-        if (src != null && src.get_type ().name () == "GstRTSPSrc") {
-            // For rtspsrc since some RTSP sources takes a while to start
-            // transmitting
-            src.tcp_timeout = (int64) 60000000;
-        }
-
-        return src;
-    }
-
     // Return true if item should be streamed as a live response with
     // time based seeking, or false to serve directly with byte range
     // seeking.
@@ -127,14 +108,6 @@ public class Rygel.MediaItem : MediaObje
         }
     }
 
-    internal int compare_transcoders (void *a, void *b) {
-        var transcoder1 = (Transcoder) a;
-        var transcoder2 = (Transcoder) b;
-
-        return (int) transcoder1.get_distance (this) -
-               (int) transcoder2.get_distance (this);
-    }
-
     internal void add_resources (DIDLLiteItem didl_item,
                                  bool         allow_internal)
                                  throws Error {
--- /dev/null
+++ b/src/rygel/rygel-network-manager.vala
@@ -0,0 +1,186 @@
+/*
+ * rygel-network-manager.vala
+ *   A simple NetworkManager implementation for Rygel
+ *
+ * (C) Copyright 2010, Ubicom, Inc.
+ *
+ * This file is part of the Ubicom32 Rygel.
+ *
+ * This program is free software: you can redistribute
+ * it and/or modify it under the terms of the GNU Lesser General Public 
+ * License (LGPL) as published by the Free Software Foundation, either version 2.1
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it
+ * will be useful, but WITHOUT ANY WARRANTY; without even the implied
+ * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+ * the GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program.  If not,
+ * see <http://www.gnu.org/licenses/>.
+ */
+
+using Rygel.NetworkDevice;
+
+ /*
+  * A very limited NetworkManager implementation designed to satisfy
+  * the requirements of GUPnP and Rygel
+  */
+[DBus (name = "org.freedesktop.NetworkManager")]
+public class Rygel.NetworkManagerService : Object {
+    private static string NM_SERVICE = "org.freedesktop.NetworkManager";
+    private static string NM_PATH = "/org/freedesktop/NetworkManager";
+    private static string DEVICE_PATH = "/a/b/";
+
+    private DBus.ObjectPath []device_paths;         /* Array of associated network device paths */
+
+    public NetworkManagerService () throws DBus.Error {
+
+        var conn = DBus.Bus.get (DBus.BusType.SYSTEM);
+
+        dynamic DBus.Object bus = conn.get_object ("org.freedesktop.DBus",
+                                                   "/org/freedesktop/DBus",
+                                                   "org.freedesktop.DBus");
+
+        /* try to register service in system bus */
+        uint request_name_result  = bus.request_name (NM_SERVICE, (uint) 0);
+
+        if (request_name_result != DBus.RequestNameReply.PRIMARY_OWNER) {
+            warning ("Failed to start D-Bus service, name '%s' already taken",
+                     NM_SERVICE);
+        }
+        conn.register_object (NM_PATH, this);
+
+        GLib.List<string> interface_list = NetworkDevice.get_interface_list ();
+        uint n_devices = interface_list.length ();
+        DBus.ObjectPath []device_paths = new DBus.ObjectPath[n_devices];
+        for (uint i = 0; i < n_devices; i++) {
+            string interface_name = interface_list.nth_data (i);
+            device_paths[i] = new DBus.ObjectPath (DEVICE_PATH + interface_name);
+            conn.register_object (device_paths[i], new NetworkManagerDevice (interface_name));
+        }
+        this.device_paths = device_paths;
+    }
+
+    /*
+     * Returns the paths of associated network devices to the bus
+     */
+    public DBus.ObjectPath []GetDevices () {
+        return this.device_paths;
+    }
+}
+
+/*
+ * Represents a network device
+ */
+[DBus (name = "org.freedesktop.NetworkManager.Device")]
+public class Rygel.NetworkManagerDevice : Object {
+
+    private static int NETWORK_STATUS_CHECK_INTERVAL = 4;
+    private string ip;              /* ip address of the device */
+    private string netmask;         /* netmask of the device */
+    private bool connection_is_up;  /* connection status of the device */
+
+    public NetworkManagerDevice (string interface_name) {
+        this.Interface = interface_name;
+        NetworkDevice.get_state (this.Interface, &this.State);
+        NetworkDevice.get_ip (interface_name, &this.ip);
+        NetworkDevice.get_netmask (interface_name, &this.netmask);
+        NetworkDevice.get_status(interface_name, &this.connection_is_up);
+
+        Timeout.add_seconds (NETWORK_STATUS_CHECK_INTERVAL, this.check_state);
+    }
+
+    public uint State { get; set; }
+
+    /* Name of the device */
+    public string Interface { get; set; }
+
+    /* Signal emmitted to the bus in case of state change */
+    public signal void StateChanged (uint new_state, uint old_state, uint reason);
+
+    /* Signal emitted to the bus in case of connection status changed */
+    public signal void ConnectionStatus (bool connection);
+
+    /*
+     * Checks the state of the device and emits the relevant signals to the bus
+     * Returns true most of the cases, if it returns false, it is removed from timeout queue
+     */
+    private bool check_state () {
+
+        /*
+         * This connection status of relevant interface (this.Interface)
+         * The function used below works for ralink only
+         * false stands for, connection is not available
+         * true stands for, conecction is available
+         */
+        bool connection_is_up = false;
+        int ret = NetworkDevice.get_status(this.Interface, &connection_is_up);
+        if (ret == -1) {
+            return true;
+        }
+
+        if (connection_is_up != this.connection_is_up) {
+            message(this.Interface + "connection status : " + (connection_is_up ? "Connected" : "Disconnected"));
+            ConnectionStatus (connection_is_up);
+            this.connection_is_up = connection_is_up;
+        }
+
+        if (!connection_is_up) {
+            if (this.State == NMDeviceState.NM_DEVICE_STATE_ACTIVATED) {
+                StateChanged (NMDeviceState.NM_DEVICE_STATE_DISCONNECTED, this.State, 0);
+                this.State = NMDeviceState.NM_DEVICE_STATE_DISCONNECTED;
+            }
+            return true;
+        }
+
+        var new_state = NMDeviceState.NM_DEVICE_STATE_UNKNOWN;
+        NetworkDevice.get_state (this.Interface, &new_state);
+        bool interface_is_up = (new_state == NMDeviceState.NM_DEVICE_STATE_ACTIVATED);
+
+        if (!interface_is_up) {
+            if (this.State == NMDeviceState.NM_DEVICE_STATE_ACTIVATED) {
+                StateChanged (NMDeviceState.NM_DEVICE_STATE_DISCONNECTED, this.State, 0);
+                this.State = NMDeviceState.NM_DEVICE_STATE_DISCONNECTED;
+            }
+            return true;
+        }
+
+        string ip = "";
+        ret = NetworkDevice.get_ip (this.Interface, &ip);
+        if (ret == -1) {
+            if (this.State == NMDeviceState.NM_DEVICE_STATE_ACTIVATED) {
+                StateChanged (NMDeviceState.NM_DEVICE_STATE_DISCONNECTED, this.State, 0);
+                this.State = NMDeviceState.NM_DEVICE_STATE_DISCONNECTED;
+            }
+            return true;
+        }
+
+        string netmask = "";
+        ret = NetworkDevice.get_netmask (this.Interface, &netmask);
+        if (ret == -1) {
+            if (this.State == NMDeviceState.NM_DEVICE_STATE_ACTIVATED) {
+                StateChanged (NMDeviceState.NM_DEVICE_STATE_DISCONNECTED, this.State, 0);
+                this.State = NMDeviceState.NM_DEVICE_STATE_DISCONNECTED;
+            }
+            return true;
+        }
+
+        if (this.State != NMDeviceState.NM_DEVICE_STATE_ACTIVATED) {
+            StateChanged (NMDeviceState.NM_DEVICE_STATE_ACTIVATED, this.State, 0);
+            this.State = NMDeviceState.NM_DEVICE_STATE_ACTIVATED;
+            return true;
+        }
+
+        if (ip != this.ip || netmask != this.netmask) {
+             StateChanged (NMDeviceState.NM_DEVICE_STATE_IP_CONFIG, this.State, 0);
+             StateChanged (NMDeviceState.NM_DEVICE_STATE_ACTIVATED, this.State, 0);
+             this.ip = ip;
+             this.netmask = netmask;
+         }
+
+         return true;
+    }
+}
+
--- a/src/rygel/rygel-plugin-loader.vala
+++ b/src/rygel/rygel-plugin-loader.vala
@@ -65,7 +65,7 @@ public class Rygel.PluginLoader : Object
     }
 
     public Collection<Plugin> list_plugins () {
-        return this.plugin_hash.get_values ();
+        return this.plugin_hash.values;
     }
 
     private void load_modules_from_dir (File dir) {
--- a/src/rygel/rygel-root-device-factory.vala
+++ b/src/rygel/rygel-root-device-factory.vala
@@ -24,6 +24,7 @@
 
 using GUPnP;
 using CStuff;
+using Rygel.NetworkDevice;
 
 public errordomain RootDeviceFactoryError {
     XML_PARSE,
@@ -115,6 +116,9 @@ public class Rygel.RootDeviceFactory {
                                         plugin.name,
                                         plugin.title);
 
+        /* Then set the presentation URL */
+        this.set_presentation_url (device_element);
+
         /* Then list each icon */
         this.add_icons_to_desc (device_element, plugin);
 
@@ -139,18 +143,21 @@ public class Rygel.RootDeviceFactory {
             return;
         }
 
-        string title;
-        try {
-            title = this.config.get_title (plugin_name);
-        } catch (GLib.Error err) {
-            title = plugin_title;
-        }
-
-        title = title.replace ("@REALNAME@", Environment.get_real_name ());
-        title = title.replace ("@USERNAME@", Environment.get_user_name ());
-        title = title.replace ("@HOSTNAME@", Environment.get_host_name ());
+        string friendlyname = element->get_content ();
+        if (friendlyname == null || friendlyname == "") {
+            string title;
+            try {
+                title = this.config.get_title (plugin_name);
+            } catch (GLib.Error err) {
+                title = plugin_title;
+            }
+
+            title = title.replace ("@REALNAME@", Environment.get_real_name ());
+            title = title.replace ("@USERNAME@", Environment.get_user_name ());
+            title = title.replace ("@HOSTNAME@", Environment.get_host_name ());
 
-        element->set_content (title);
+            element->set_content (title);
+	}
 
         /* UDN */
         element = Utils.get_xml_element (device_element, "UDN");
@@ -165,6 +172,44 @@ public class Rygel.RootDeviceFactory {
             udn = Utils.generate_random_udn ();
 
             element->set_content (udn);
+
+            DBusService dbus_service = DBusService.get_default();
+            if (dbus_service == null) {
+                warning("%p: DBus service instance not created.", this);
+                return;
+            }
+            dbus_service.UdnChanged(udn);
+        }
+    }
+
+    private void set_presentation_url (Xml.Node *device_element) {
+        Xml.Node *element = Utils.get_xml_element (device_element,
+                                                   "presentationURL",
+                                                   null);
+        if (element == null) {
+            warning ("Element /root/device/presentationURL not found.");
+
+            return;
+        }
+
+        string presentation_url = element->get_content ();
+        GLib.List<string> interface_list = NetworkDevice.get_interface_list ();
+        if (interface_list == null) {
+            warning ("%p: Interface list is NULL.", this);
+            return;
+        }
+        string interface_name = interface_list.nth_data (0);
+
+        string ip = "";
+        int ret = NetworkDevice.get_ip (interface_name, &ip);
+        if (ret == -1) {
+            warning ("%p: Could not get IP address.", this);
+            return;
+        }
+
+        string new_presentation_url = "http://" + ip + "/";
+        if (presentation_url != new_presentation_url) {
+            element->set_content (new_presentation_url);
         }
     }
 
--- a/src/rygel/rygel-root-device.vala
+++ b/src/rygel/rygel-root-device.vala
@@ -29,7 +29,7 @@ using Gee;
  * Represents a Root device.
  */
 public class Rygel.RootDevice: GUPnP.RootDevice {
-    internal ArrayList<ServiceInfo> services;   /* Services we implement */
+    protected ArrayList<ServiceInfo> services;   /* Services we implement */
 
     public RootDevice (GUPnP.Context context,
                        Plugin        plugin,
--- a/src/rygel/rygel-thumbnailer.vala
+++ b/src/rygel/rygel-thumbnailer.vala
@@ -20,7 +20,6 @@
  * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
  */
 
-using Gst;
 
 internal errordomain ThumbnailerError {
     NO_DIR,
--- a/.tarball-version
+++ /dev/null
@@ -1 +0,0 @@
-0.4.2
--- a/.version
+++ /dev/null
@@ -1 +0,0 @@
-0.4.2
--- /dev/null
+++ b/MAINTAINERS
@@ -0,0 +1,3 @@
+Zeeshan Ali (Khattak)
+E-mail: zeeshanak@gnome.org
+Userid: zeeshanak
--- a/Makefile.in
+++ b/Makefile.in
@@ -39,10 +39,12 @@ DIST_COMMON = README $(am__configure_dep
 	$(srcdir)/Makefile.in $(srcdir)/config.h.in \
 	$(srcdir)/rygel-1.0.pc.in $(top_srcdir)/configure AUTHORS \
 	COPYING ChangeLog INSTALL NEWS TODO build-aux/config.guess \
-	build-aux/config.sub build-aux/depcomp build-aux/install-sh \
-	build-aux/ltmain.sh build-aux/missing build-aux/mkinstalldirs
+	build-aux/config.rpath build-aux/config.sub build-aux/depcomp \
+	build-aux/install-sh build-aux/ltmain.sh build-aux/missing \
+	build-aux/mkinstalldirs
 ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
-am__aclocal_m4_deps = $(top_srcdir)/m4/libtool.m4 \
+am__aclocal_m4_deps = $(top_srcdir)/m4/glib-gettext.m4 \
+	$(top_srcdir)/m4/isc-posix.m4 $(top_srcdir)/m4/libtool.m4 \
 	$(top_srcdir)/m4/ltoptions.m4 $(top_srcdir)/m4/ltsugar.m4 \
 	$(top_srcdir)/m4/ltversion.m4 $(top_srcdir)/m4/lt~obsolete.m4 \
 	$(top_srcdir)/configure.ac
@@ -172,8 +174,6 @@ GMSGFMT = @GMSGFMT@
 GREP = @GREP@
 GTK_CFLAGS = @GTK_CFLAGS@
 GTK_LIBS = @GTK_LIBS@
-GUPNP_VALA_CFLAGS = @GUPNP_VALA_CFLAGS@
-GUPNP_VALA_LIBS = @GUPNP_VALA_LIBS@
 HAVE_GTK = @HAVE_GTK@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
@@ -188,8 +188,8 @@ LIBDBUS_GLIB_CFLAGS = @LIBDBUS_GLIB_CFLA
 LIBDBUS_GLIB_LIBS = @LIBDBUS_GLIB_LIBS@
 LIBGIO_CFLAGS = @LIBGIO_CFLAGS@
 LIBGIO_LIBS = @LIBGIO_LIBS@
-LIBGSTREAMER_CFLAGS = @LIBGSTREAMER_CFLAGS@
-LIBGSTREAMER_LIBS = @LIBGSTREAMER_LIBS@
+LIBGLIB_CFLAGS = @LIBGLIB_CFLAGS@
+LIBGLIB_LIBS = @LIBGLIB_LIBS@
 LIBGUPNP_AV_CFLAGS = @LIBGUPNP_AV_CFLAGS@
 LIBGUPNP_AV_LIBS = @LIBGUPNP_AV_LIBS@
 LIBGUPNP_CFLAGS = @LIBGUPNP_CFLAGS@
@@ -201,6 +201,8 @@ LIBSOUP_LIBS = @LIBSOUP_LIBS@
 LIBSQLITE3_CFLAGS = @LIBSQLITE3_CFLAGS@
 LIBSQLITE3_LIBS = @LIBSQLITE3_LIBS@
 LIBTOOL = @LIBTOOL@
+LIBVLC_CFLAGS = @LIBVLC_CFLAGS@
+LIBVLC_LIBS = @LIBVLC_LIBS@
 LIPO = @LIPO@
 LN_S = @LN_S@
 LTLIBOBJS = @LTLIBOBJS@
@@ -221,6 +223,7 @@ PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
 PACKAGE_NAME = @PACKAGE_NAME@
 PACKAGE_STRING = @PACKAGE_STRING@
 PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_URL = @PACKAGE_URL@
 PACKAGE_VERSION = @PACKAGE_VERSION@
 PATH_SEPARATOR = @PATH_SEPARATOR@
 PKG_CONFIG = @PKG_CONFIG@
@@ -234,8 +237,6 @@ SET_MAKE = @SET_MAKE@
 SHELL = @SHELL@
 STRIP = @STRIP@
 USE_NLS = @USE_NLS@
-UUID_CFLAGS = @UUID_CFLAGS@
-UUID_LIBS = @UUID_LIBS@
 VALAC = @VALAC@
 VAPIDIR = @VAPIDIR@
 VERSION = @VERSION@
--- /dev/null
+++ b/autogen.sh
@@ -0,0 +1,7 @@
+#! /bin/sh
+mkdir -p m4
+autoreconf -v --install || exit 1
+glib-gettextize --force --copy || exit 1
+./configure --enable-vala --enable-maintainer-mode --enable-debug \
+            --enable-test-plugin --enable-mediathek-plugin \
+	    --enable-gstlaunch-plugin "$@"
--- a/build-aux/config.guess
+++ b/build-aux/config.guess
@@ -4,7 +4,7 @@
 #   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008
 #   Free Software Foundation, Inc.
 
-timestamp='2008-01-08'
+timestamp='2008-01-23'
 
 # This file is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by
@@ -1484,9 +1484,9 @@ This script, last modified $timestamp, h
 the operating system you are using. It is advised that you
 download the most up to date version of the config scripts from
 
-  http://savannah.gnu.org/cgi-bin/viewcvs/*checkout*/config/config/config.guess
+  http://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.guess;hb=HEAD
 and
-  http://savannah.gnu.org/cgi-bin/viewcvs/*checkout*/config/config/config.sub
+  http://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.sub;hb=HEAD
 
 If the version you run ($0) is already up to date, please
 send the following data and any information you think might be
--- /dev/null
+++ b/build-aux/config.rpath
@@ -0,0 +1,666 @@
+#! /bin/sh
+# Output a system dependent set of variables, describing how to set the
+# run time search path of shared libraries in an executable.
+#
+#   Copyright 1996-2007 Free Software Foundation, Inc.
+#   Taken from GNU libtool, 2001
+#   Originally by Gordon Matzigkeit <gord@gnu.ai.mit.edu>, 1996
+#
+#   This file is free software; the Free Software Foundation gives
+#   unlimited permission to copy and/or distribute it, with or without
+#   modifications, as long as this notice is preserved.
+#
+# The first argument passed to this file is the canonical host specification,
+#    CPU_TYPE-MANUFACTURER-OPERATING_SYSTEM
+# or
+#    CPU_TYPE-MANUFACTURER-KERNEL-OPERATING_SYSTEM
+# The environment variables CC, GCC, LDFLAGS, LD, with_gnu_ld
+# should be set by the caller.
+#
+# The set of defined variables is at the end of this script.
+
+# Known limitations:
+# - On IRIX 6.5 with CC="cc", the run time search patch must not be longer
+#   than 256 bytes, otherwise the compiler driver will dump core. The only
+#   known workaround is to choose shorter directory names for the build
+#   directory and/or the installation directory.
+
+# All known linkers require a `.a' archive for static linking (except MSVC,
+# which needs '.lib').
+libext=a
+shrext=.so
+
+host="$1"
+host_cpu=`echo "$host" | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\1/'`
+host_vendor=`echo "$host" | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\2/'`
+host_os=`echo "$host" | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\3/'`
+
+# Code taken from libtool.m4's _LT_CC_BASENAME.
+
+for cc_temp in $CC""; do
+  case $cc_temp in
+    compile | *[\\/]compile | ccache | *[\\/]ccache ) ;;
+    distcc | *[\\/]distcc | purify | *[\\/]purify ) ;;
+    \-*) ;;
+    *) break;;
+  esac
+done
+cc_basename=`echo "$cc_temp" | sed -e 's%^.*/%%'`
+
+# Code taken from libtool.m4's AC_LIBTOOL_PROG_COMPILER_PIC.
+
+wl=
+if test "$GCC" = yes; then
+  wl='-Wl,'
+else
+  case "$host_os" in
+    aix*)
+      wl='-Wl,'
+      ;;
+    darwin*)
+      case $cc_basename in
+        xlc*)
+          wl='-Wl,'
+          ;;
+      esac
+      ;;
+    mingw* | cygwin* | pw32* | os2*)
+      ;;
+    hpux9* | hpux10* | hpux11*)
+      wl='-Wl,'
+      ;;
+    irix5* | irix6* | nonstopux*)
+      wl='-Wl,'
+      ;;
+    newsos6)
+      ;;
+    linux* | k*bsd*-gnu)
+      case $cc_basename in
+        icc* | ecc*)
+          wl='-Wl,'
+          ;;
+        pgcc | pgf77 | pgf90)
+          wl='-Wl,'
+          ;;
+        ccc*)
+          wl='-Wl,'
+          ;;
+        como)
+          wl='-lopt='
+          ;;
+        *)
+          case `$CC -V 2>&1 | sed 5q` in
+            *Sun\ C*)
+              wl='-Wl,'
+              ;;
+          esac
+          ;;
+      esac
+      ;;
+    osf3* | osf4* | osf5*)
+      wl='-Wl,'
+      ;;
+    rdos*)
+      ;;
+    solaris*)
+      wl='-Wl,'
+      ;;
+    sunos4*)
+      wl='-Qoption ld '
+      ;;
+    sysv4 | sysv4.2uw2* | sysv4.3*)
+      wl='-Wl,'
+      ;;
+    sysv4*MP*)
+      ;;
+    sysv5* | unixware* | sco3.2v5* | sco5v6* | OpenUNIX*)
+      wl='-Wl,'
+      ;;
+    unicos*)
+      wl='-Wl,'
+      ;;
+    uts4*)
+      ;;
+  esac
+fi
+
+# Code taken from libtool.m4's AC_LIBTOOL_PROG_LD_SHLIBS.
+
+hardcode_libdir_flag_spec=
+hardcode_libdir_separator=
+hardcode_direct=no
+hardcode_minus_L=no
+
+case "$host_os" in
+  cygwin* | mingw* | pw32*)
+    # FIXME: the MSVC++ port hasn't been tested in a loooong time
+    # When not using gcc, we currently assume that we are using
+    # Microsoft Visual C++.
+    if test "$GCC" != yes; then
+      with_gnu_ld=no
+    fi
+    ;;
+  interix*)
+    # we just hope/assume this is gcc and not c89 (= MSVC++)
+    with_gnu_ld=yes
+    ;;
+  openbsd*)
+    with_gnu_ld=no
+    ;;
+esac
+
+ld_shlibs=yes
+if test "$with_gnu_ld" = yes; then
+  # Set some defaults for GNU ld with shared library support. These
+  # are reset later if shared libraries are not supported. Putting them
+  # here allows them to be overridden if necessary.
+  # Unlike libtool, we use -rpath here, not --rpath, since the documented
+  # option of GNU ld is called -rpath, not --rpath.
+  hardcode_libdir_flag_spec='${wl}-rpath ${wl}$libdir'
+  case "$host_os" in
+    aix3* | aix4* | aix5*)
+      # On AIX/PPC, the GNU linker is very broken
+      if test "$host_cpu" != ia64; then
+        ld_shlibs=no
+      fi
+      ;;
+    amigaos*)
+      hardcode_libdir_flag_spec='-L$libdir'
+      hardcode_minus_L=yes
+      # Samuel A. Falvo II <kc5tja@dolphin.openprojects.net> reports
+      # that the semantics of dynamic libraries on AmigaOS, at least up
+      # to version 4, is to share data among multiple programs linked
+      # with the same dynamic library.  Since this doesn't match the
+      # behavior of shared libraries on other platforms, we cannot use
+      # them.
+      ld_shlibs=no
+      ;;
+    beos*)
+      if $LD --help 2>&1 | grep ': supported targets:.* elf' > /dev/null; then
+        :
+      else
+        ld_shlibs=no
+      fi
+      ;;
+    cygwin* | mingw* | pw32*)
+      # hardcode_libdir_flag_spec is actually meaningless, as there is
+      # no search path for DLLs.
+      hardcode_libdir_flag_spec='-L$libdir'
+      if $LD --help 2>&1 | grep 'auto-import' > /dev/null; then
+        :
+      else
+        ld_shlibs=no
+      fi
+      ;;
+    interix[3-9]*)
+      hardcode_direct=no
+      hardcode_libdir_flag_spec='${wl}-rpath,$libdir'
+      ;;
+    gnu* | linux* | k*bsd*-gnu)
+      if $LD --help 2>&1 | grep ': supported targets:.* elf' > /dev/null; then
+        :
+      else
+        ld_shlibs=no
+      fi
+      ;;
+    netbsd*)
+      ;;
+    solaris*)
+      if $LD -v 2>&1 | grep 'BFD 2\.8' > /dev/null; then
+        ld_shlibs=no
+      elif $LD --help 2>&1 | grep ': supported targets:.* elf' > /dev/null; then
+        :
+      else
+        ld_shlibs=no
+      fi
+      ;;
+    sysv5* | sco3.2v5* | sco5v6* | unixware* | OpenUNIX*)
+      case `$LD -v 2>&1` in
+        *\ [01].* | *\ 2.[0-9].* | *\ 2.1[0-5].*)
+          ld_shlibs=no
+          ;;
+        *)
+          if $LD --help 2>&1 | grep ': supported targets:.* elf' > /dev/null; then
+            hardcode_libdir_flag_spec='`test -z "$SCOABSPATH" && echo ${wl}-rpath,$libdir`'
+          else
+            ld_shlibs=no
+          fi
+          ;;
+      esac
+      ;;
+    sunos4*)
+      hardcode_direct=yes
+      ;;
+    *)
+      if $LD --help 2>&1 | grep ': supported targets:.* elf' > /dev/null; then
+        :
+      else
+        ld_shlibs=no
+      fi
+      ;;
+  esac
+  if test "$ld_shlibs" = no; then
+    hardcode_libdir_flag_spec=
+  fi
+else
+  case "$host_os" in
+    aix3*)
+      # Note: this linker hardcodes the directories in LIBPATH if there
+      # are no directories specified by -L.
+      hardcode_minus_L=yes
+      if test "$GCC" = yes; then
+        # Neither direct hardcoding nor static linking is supported with a
+        # broken collect2.
+        hardcode_direct=unsupported
+      fi
+      ;;
+    aix4* | aix5*)
+      if test "$host_cpu" = ia64; then
+        # On IA64, the linker does run time linking by default, so we don't
+        # have to do anything special.
+        aix_use_runtimelinking=no
+      else
+        aix_use_runtimelinking=no
+        # Test if we are trying to use run time linking or normal
+        # AIX style linking. If -brtl is somewhere in LDFLAGS, we
+        # need to do runtime linking.
+        case $host_os in aix4.[23]|aix4.[23].*|aix5*)
+          for ld_flag in $LDFLAGS; do
+            if (test $ld_flag = "-brtl" || test $ld_flag = "-Wl,-brtl"); then
+              aix_use_runtimelinking=yes
+              break
+            fi
+          done
+          ;;
+        esac
+      fi
+      hardcode_direct=yes
+      hardcode_libdir_separator=':'
+      if test "$GCC" = yes; then
+        case $host_os in aix4.[012]|aix4.[012].*)
+          collect2name=`${CC} -print-prog-name=collect2`
+          if test -f "$collect2name" && \
+            strings "$collect2name" | grep resolve_lib_name >/dev/null
+          then
+            # We have reworked collect2
+            :
+          else
+            # We have old collect2
+            hardcode_direct=unsupported
+            hardcode_minus_L=yes
+            hardcode_libdir_flag_spec='-L$libdir'
+            hardcode_libdir_separator=
+          fi
+          ;;
+        esac
+      fi
+      # Begin _LT_AC_SYS_LIBPATH_AIX.
+      echo 'int main () { return 0; }' > conftest.c
+      ${CC} ${LDFLAGS} conftest.c -o conftest
+      aix_libpath=`dump -H conftest 2>/dev/null | sed -n -e '/Import File Strings/,/^$/ { /^0/ { s/^0  *\(.*\)$/\1/; p; }
+}'`
+      if test -z "$aix_libpath"; then
+        aix_libpath=`dump -HX64 conftest 2>/dev/null | sed -n -e '/Import File Strings/,/^$/ { /^0/ { s/^0  *\(.*\)$/\1/; p; }
+}'`
+      fi
+      if test -z "$aix_libpath"; then
+        aix_libpath="/usr/lib:/lib"
+      fi
+      rm -f conftest.c conftest
+      # End _LT_AC_SYS_LIBPATH_AIX.
+      if test "$aix_use_runtimelinking" = yes; then
+        hardcode_libdir_flag_spec='${wl}-blibpath:$libdir:'"$aix_libpath"
+      else
+        if test "$host_cpu" = ia64; then
+          hardcode_libdir_flag_spec='${wl}-R $libdir:/usr/lib:/lib'
+        else
+          hardcode_libdir_flag_spec='${wl}-blibpath:$libdir:'"$aix_libpath"
+        fi
+      fi
+      ;;
+    amigaos*)
+      hardcode_libdir_flag_spec='-L$libdir'
+      hardcode_minus_L=yes
+      # see comment about different semantics on the GNU ld section
+      ld_shlibs=no
+      ;;
+    bsdi[45]*)
+      ;;
+    cygwin* | mingw* | pw32*)
+      # When not using gcc, we currently assume that we are using
+      # Microsoft Visual C++.
+      # hardcode_libdir_flag_spec is actually meaningless, as there is
+      # no search path for DLLs.
+      hardcode_libdir_flag_spec=' '
+      libext=lib
+      ;;
+    darwin* | rhapsody*)
+      hardcode_direct=no
+      if test "$GCC" = yes ; then
+        :
+      else
+        case $cc_basename in
+          xlc*)
+            ;;
+          *)
+            ld_shlibs=no
+            ;;
+        esac
+      fi
+      ;;
+    dgux*)
+      hardcode_libdir_flag_spec='-L$libdir'
+      ;;
+    freebsd1*)
+      ld_shlibs=no
+      ;;
+    freebsd2.2*)
+      hardcode_libdir_flag_spec='-R$libdir'
+      hardcode_direct=yes
+      ;;
+    freebsd2*)
+      hardcode_direct=yes
+      hardcode_minus_L=yes
+      ;;
+    freebsd* | dragonfly*)
+      hardcode_libdir_flag_spec='-R$libdir'
+      hardcode_direct=yes
+      ;;
+    hpux9*)
+      hardcode_libdir_flag_spec='${wl}+b ${wl}$libdir'
+      hardcode_libdir_separator=:
+      hardcode_direct=yes
+      # hardcode_minus_L: Not really in the search PATH,
+      # but as the default location of the library.
+      hardcode_minus_L=yes
+      ;;
+    hpux10*)
+      if test "$with_gnu_ld" = no; then
+        hardcode_libdir_flag_spec='${wl}+b ${wl}$libdir'
+        hardcode_libdir_separator=:
+        hardcode_direct=yes
+        # hardcode_minus_L: Not really in the search PATH,
+        # but as the default location of the library.
+        hardcode_minus_L=yes
+      fi
+      ;;
+    hpux11*)
+      if test "$with_gnu_ld" = no; then
+        hardcode_libdir_flag_spec='${wl}+b ${wl}$libdir'
+        hardcode_libdir_separator=:
+        case $host_cpu in
+          hppa*64*|ia64*)
+            hardcode_direct=no
+            ;;
+          *)
+            hardcode_direct=yes
+            # hardcode_minus_L: Not really in the search PATH,
+            # but as the default location of the library.
+            hardcode_minus_L=yes
+            ;;
+        esac
+      fi
+      ;;
+    irix5* | irix6* | nonstopux*)
+      hardcode_libdir_flag_spec='${wl}-rpath ${wl}$libdir'
+      hardcode_libdir_separator=:
+      ;;
+    netbsd*)
+      hardcode_libdir_flag_spec='-R$libdir'
+      hardcode_direct=yes
+      ;;
+    newsos6)
+      hardcode_direct=yes
+      hardcode_libdir_flag_spec='${wl}-rpath ${wl}$libdir'
+      hardcode_libdir_separator=:
+      ;;
+    openbsd*)
+      if test -f /usr/libexec/ld.so; then
+        hardcode_direct=yes
+        if test -z "`echo __ELF__ | $CC -E - | grep __ELF__`" || test "$host_os-$host_cpu" = "openbsd2.8-powerpc"; then
+          hardcode_libdir_flag_spec='${wl}-rpath,$libdir'
+        else
+          case "$host_os" in
+            openbsd[01].* | openbsd2.[0-7] | openbsd2.[0-7].*)
+              hardcode_libdir_flag_spec='-R$libdir'
+              ;;
+            *)
+              hardcode_libdir_flag_spec='${wl}-rpath,$libdir'
+              ;;
+          esac
+        fi
+      else
+        ld_shlibs=no
+      fi
+      ;;
+    os2*)
+      hardcode_libdir_flag_spec='-L$libdir'
+      hardcode_minus_L=yes
+      ;;
+    osf3*)
+      hardcode_libdir_flag_spec='${wl}-rpath ${wl}$libdir'
+      hardcode_libdir_separator=:
+      ;;
+    osf4* | osf5*)
+      if test "$GCC" = yes; then
+        hardcode_libdir_flag_spec='${wl}-rpath ${wl}$libdir'
+      else
+        # Both cc and cxx compiler support -rpath directly
+        hardcode_libdir_flag_spec='-rpath $libdir'
+      fi
+      hardcode_libdir_separator=:
+      ;;
+    solaris*)
+      hardcode_libdir_flag_spec='-R$libdir'
+      ;;
+    sunos4*)
+      hardcode_libdir_flag_spec='-L$libdir'
+      hardcode_direct=yes
+      hardcode_minus_L=yes
+      ;;
+    sysv4)
+      case $host_vendor in
+        sni)
+          hardcode_direct=yes # is this really true???
+          ;;
+        siemens)
+          hardcode_direct=no
+          ;;
+        motorola)
+          hardcode_direct=no #Motorola manual says yes, but my tests say they lie
+          ;;
+      esac
+      ;;
+    sysv4.3*)
+      ;;
+    sysv4*MP*)
+      if test -d /usr/nec; then
+        ld_shlibs=yes
+      fi
+      ;;
+    sysv4*uw2* | sysv5OpenUNIX* | sysv5UnixWare7.[01].[10]* | unixware7* | sco3.2v5.0.[024]*)
+      ;;
+    sysv5* | sco3.2v5* | sco5v6*)
+      hardcode_libdir_flag_spec='`test -z "$SCOABSPATH" && echo ${wl}-R,$libdir`'
+      hardcode_libdir_separator=':'
+      ;;
+    uts4*)
+      hardcode_libdir_flag_spec='-L$libdir'
+      ;;
+    *)
+      ld_shlibs=no
+      ;;
+  esac
+fi
+
+# Check dynamic linker characteristics
+# Code taken from libtool.m4's AC_LIBTOOL_SYS_DYNAMIC_LINKER.
+# Unlike libtool.m4, here we don't care about _all_ names of the library, but
+# only about the one the linker finds when passed -lNAME. This is the last
+# element of library_names_spec in libtool.m4, or possibly two of them if the
+# linker has special search rules.
+library_names_spec=      # the last element of library_names_spec in libtool.m4
+libname_spec='lib$name'
+case "$host_os" in
+  aix3*)
+    library_names_spec='$libname.a'
+    ;;
+  aix4* | aix5*)
+    library_names_spec='$libname$shrext'
+    ;;
+  amigaos*)
+    library_names_spec='$libname.a'
+    ;;
+  beos*)
+    library_names_spec='$libname$shrext'
+    ;;
+  bsdi[45]*)
+    library_names_spec='$libname$shrext'
+    ;;
+  cygwin* | mingw* | pw32*)
+    shrext=.dll
+    library_names_spec='$libname.dll.a $libname.lib'
+    ;;
+  darwin* | rhapsody*)
+    shrext=.dylib
+    library_names_spec='$libname$shrext'
+    ;;
+  dgux*)
+    library_names_spec='$libname$shrext'
+    ;;
+  freebsd1*)
+    ;;
+  freebsd* | dragonfly*)
+    case "$host_os" in
+      freebsd[123]*)
+        library_names_spec='$libname$shrext$versuffix' ;;
+      *)
+        library_names_spec='$libname$shrext' ;;
+    esac
+    ;;
+  gnu*)
+    library_names_spec='$libname$shrext'
+    ;;
+  hpux9* | hpux10* | hpux11*)
+    case $host_cpu in
+      ia64*)
+        shrext=.so
+        ;;
+      hppa*64*)
+        shrext=.sl
+        ;;
+      *)
+        shrext=.sl
+        ;;
+    esac
+    library_names_spec='$libname$shrext'
+    ;;
+  interix[3-9]*)
+    library_names_spec='$libname$shrext'
+    ;;
+  irix5* | irix6* | nonstopux*)
+    library_names_spec='$libname$shrext'
+    case "$host_os" in
+      irix5* | nonstopux*)
+        libsuff= shlibsuff=
+        ;;
+      *)
+        case $LD in
+          *-32|*"-32 "|*-melf32bsmip|*"-melf32bsmip ") libsuff= shlibsuff= ;;
+          *-n32|*"-n32 "|*-melf32bmipn32|*"-melf32bmipn32 ") libsuff=32 shlibsuff=N32 ;;
+          *-64|*"-64 "|*-melf64bmip|*"-melf64bmip ") libsuff=64 shlibsuff=64 ;;
+          *) libsuff= shlibsuff= ;;
+        esac
+        ;;
+    esac
+    ;;
+  linux*oldld* | linux*aout* | linux*coff*)
+    ;;
+  linux* | k*bsd*-gnu)
+    library_names_spec='$libname$shrext'
+    ;;
+  knetbsd*-gnu)
+    library_names_spec='$libname$shrext'
+    ;;
+  netbsd*)
+    library_names_spec='$libname$shrext'
+    ;;
+  newsos6)
+    library_names_spec='$libname$shrext'
+    ;;
+  nto-qnx*)
+    library_names_spec='$libname$shrext'
+    ;;
+  openbsd*)
+    library_names_spec='$libname$shrext$versuffix'
+    ;;
+  os2*)
+    libname_spec='$name'
+    shrext=.dll
+    library_names_spec='$libname.a'
+    ;;
+  osf3* | osf4* | osf5*)
+    library_names_spec='$libname$shrext'
+    ;;
+  rdos*)
+    ;;
+  solaris*)
+    library_names_spec='$libname$shrext'
+    ;;
+  sunos4*)
+    library_names_spec='$libname$shrext$versuffix'
+    ;;
+  sysv4 | sysv4.3*)
+    library_names_spec='$libname$shrext'
+    ;;
+  sysv4*MP*)
+    library_names_spec='$libname$shrext'
+    ;;
+  sysv5* | sco3.2v5* | sco5v6* | unixware* | OpenUNIX* | sysv4*uw2*)
+    library_names_spec='$libname$shrext'
+    ;;
+  uts4*)
+    library_names_spec='$libname$shrext'
+    ;;
+esac
+
+sed_quote_subst='s/\(["`$\\]\)/\\\1/g'
+escaped_wl=`echo "X$wl" | sed -e 's/^X//' -e "$sed_quote_subst"`
+shlibext=`echo "$shrext" | sed -e 's,^\.,,'`
+escaped_libname_spec=`echo "X$libname_spec" | sed -e 's/^X//' -e "$sed_quote_subst"`
+escaped_library_names_spec=`echo "X$library_names_spec" | sed -e 's/^X//' -e "$sed_quote_subst"`
+escaped_hardcode_libdir_flag_spec=`echo "X$hardcode_libdir_flag_spec" | sed -e 's/^X//' -e "$sed_quote_subst"`
+
+LC_ALL=C sed -e 's/^\([a-zA-Z0-9_]*\)=/acl_cv_\1=/' <<EOF
+
+# How to pass a linker flag through the compiler.
+wl="$escaped_wl"
+
+# Static library suffix (normally "a").
+libext="$libext"
+
+# Shared library suffix (normally "so").
+shlibext="$shlibext"
+
+# Format of library name prefix.
+libname_spec="$escaped_libname_spec"
+
+# Library names that the linker finds when passed -lNAME.
+library_names_spec="$escaped_library_names_spec"
+
+# Flag to hardcode \$libdir into a binary during linking.
+# This must work even if \$libdir does not exist.
+hardcode_libdir_flag_spec="$escaped_hardcode_libdir_flag_spec"
+
+# Whether we need a single -rpath flag with a separated argument.
+hardcode_libdir_separator="$hardcode_libdir_separator"
+
+# Set to yes if using DIR/libNAME.so during linking hardcodes DIR into the
+# resulting binary.
+hardcode_direct="$hardcode_direct"
+
+# Set to yes if using the -LDIR flag during linking hardcodes DIR into the
+# resulting binary.
+hardcode_minus_L="$hardcode_minus_L"
+
+EOF
--- /dev/null
+++ b/build-aux/git-version-gen
@@ -0,0 +1,154 @@
+#!/bin/sh
+# Print a version string.
+scriptversion=2009-05-11.16
+
+# Copyright (C) 2007-2008 Free Software Foundation
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 3, or (at your option)
+# any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+# 02110-1301, USA.
+
+# This script is derived from GIT-VERSION-GEN from GIT: http://git.or.cz/.
+# It may be run two ways:
+# - from a git repository in which the "git describe" command below
+#   produces useful output (thus requiring at least one signed tag)
+# - from a non-git-repo directory containing a .tarball-version file, which
+#   presumes this script is invoked like "./git-version-gen .tarball-version".
+
+# In order to use intra-version strings in your project, you will need two
+# separate generated version string files:
+#
+# .tarball-version - present only in a distribution tarball, and not in
+#   a checked-out repository.  Created with contents that were learned at
+#   the last time autoconf was run, and used by git-version-gen.  Must not
+#   be present in either $(srcdir) or $(builddir) for git-version-gen to
+#   give accurate answers during normal development with a checked out tree,
+#   but must be present in a tarball when there is no version control system.
+#   Therefore, it cannot be used in any dependencies.  GNUmakefile has
+#   hooks to force a reconfigure at distribution time to get the value
+#   correct, without penalizing normal development with extra reconfigures.
+#
+# .version - present in a checked-out repository and in a distribution
+#   tarball.  Usable in dependencies, particularly for files that don't
+#   want to depend on config.h but do want to track version changes.
+#   Delete this file prior to any autoconf run where you want to rebuild
+#   files to pick up a version string change; and leave it stale to
+#   minimize rebuild time after unrelated changes to configure sources.
+#
+# It is probably wise to add these two files to .gitignore, so that you
+# don't accidentally commit either generated file.
+#
+# Use the following line in your configure.ac, so that $(VERSION) will
+# automatically be up-to-date each time configure is run (and note that
+# since configure.ac no longer includes a version string, Makefile rules
+# should not depend on configure.ac for version updates).
+#
+# AC_INIT([GNU project],
+#         m4_esyscmd([build-aux/git-version-gen .tarball-version]),
+#         [bug-project@example])
+#
+# Then use the following lines in your Makefile.am, so that .version
+# will be present for dependencies, and so that .tarball-version will
+# exist in distribution tarballs.
+#
+# BUILT_SOURCES = $(top_srcdir)/.version
+# $(top_srcdir)/.version:
+#	echo $(VERSION) > $@-t && mv $@-t $@
+# dist-hook:
+#	echo $(VERSION) > $(distdir)/.tarball-version
+
+case $# in
+    1) ;;
+    *) echo 1>&2 "Usage: $0 \$srcdir/.tarball-version"; exit 1;;
+esac
+
+tarball_version_file=$1
+nl='
+'
+
+# First see if there is a tarball-only version file.
+# then try "git describe", then default.
+if test -f $tarball_version_file
+then
+    v=`cat $tarball_version_file` || exit 1
+    case $v in
+	*$nl*) v= ;; # reject multi-line output
+	[0-9]*) ;;
+	*) v= ;;
+    esac
+    test -z "$v" \
+	&& echo "$0: WARNING: $tarball_version_file seems to be damaged" 1>&2
+fi
+
+if test -n "$v"
+then
+    : # use $v
+elif test -d .git \
+    && v=`git describe --abbrev=4 --match='${GNOME_TAG_PATTERN}_*' HEAD 2>/dev/null \
+	  || git describe --abbrev=4 HEAD 2>/dev/null` \
+    && case $v in
+	 ${GNOME_TAG_PATTERN}_[0-9]*) ;;
+	 *) (exit 1) ;;
+       esac
+then
+    # Is this a new git that lists number of commits since the last
+    # tag or the previous older version that did not?
+    #   Newer: v6.10-77-g0f8faeb
+    #   Older: v6.10-g0f8faeb
+    case $v in
+	*-*-*) : git describe is okay three part flavor ;;
+	*-*)
+	    : git describe is older two part flavor
+	    # Recreate the number of commits and rewrite such that the
+	    # result is the same as if we were using the newer version
+	    # of git describe.
+	    vtag=`echo "$v" | sed 's/-.*//'`
+	    numcommits=`git rev-list "$vtag"..HEAD | wc -l`
+	    v=`echo "$v" | sed "s/\(.*\)-\(.*\)/\1-$numcommits-\2/"`;
+	    ;;
+    esac
+
+    # Change the first '-' to a '.', so version-comparing tools work properly.
+    # Remove the "g" in git describe's output string, to save a byte.
+    v=`echo "$v" | sed 's/-/./;s/\(.*\)-g/\1-/'`;
+else
+    v=UNKNOWN
+fi
+
+#v=`echo "$v" |sed 's/^v//'`
+
+v=`echo "$v" | sed "s/${GNOME_TAG_PATTERN}_//" | tr _ .`
+
+# Don't declare a version "dirty" merely because a time stamp has changed.
+git status > /dev/null 2>&1
+
+dirty=`sh -c 'git diff-index --name-only HEAD' 2>/dev/null` || dirty=
+case "$dirty" in
+    '') ;;
+    *) # Append the suffix only if there isn't one already.
+	case $v in
+	  *-dirty) ;;
+	  *) v="$v-dirty" ;;
+	esac ;;
+esac
+
+# Omit the trailing newline, so that m4_esyscmd can use the result directly.
+echo "$v" | tr -d '\012'
+
+# Local variables:
+# eval: (add-hook 'write-file-hooks 'time-stamp)
+# time-stamp-start: "scriptversion="
+# time-stamp-format: "%:y-%02m-%02d.%02H"
+# time-stamp-end: "$"
+# End:
--- a/build-aux/ltmain.sh
+++ b/build-aux/ltmain.sh
@@ -65,7 +65,7 @@
 #       compiler:		$LTCC
 #       compiler flags:		$LTCFLAGS
 #       linker:		$LD (gnu? $with_gnu_ld)
-#       $progname:		(GNU libtool) 2.2.6
+#       $progname:		(GNU libtool) 2.2.6 Debian-2.2.6a-1ubuntu1
 #       automake:		$automake_version
 #       autoconf:		$autoconf_version
 #
@@ -73,7 +73,7 @@
 
 PROGRAM=ltmain.sh
 PACKAGE=libtool
-VERSION=2.2.6
+VERSION="2.2.6 Debian-2.2.6a-1ubuntu1"
 TIMESTAMP=""
 package_revision=1.3012
 
@@ -116,15 +116,15 @@ $lt_unset CDPATH
 
 : ${CP="cp -f"}
 : ${ECHO="echo"}
-: ${EGREP="/usr/bin/grep -E"}
-: ${FGREP="/usr/bin/grep -F"}
-: ${GREP="/usr/bin/grep"}
+: ${EGREP="/bin/grep -E"}
+: ${FGREP="/bin/grep -F"}
+: ${GREP="/bin/grep"}
 : ${LN_S="ln -s"}
 : ${MAKE="make"}
 : ${MKDIR="mkdir"}
 : ${MV="mv -f"}
 : ${RM="rm -f"}
-: ${SED="/opt/local/bin/gsed"}
+: ${SED="/bin/sed"}
 : ${SHELL="${CONFIG_SHELL-/bin/sh}"}
 : ${Xsed="$SED -e 1s/^X//"}
 
@@ -5033,7 +5033,10 @@ func_mode_link ()
 	case $pass in
 	dlopen) libs="$dlfiles" ;;
 	dlpreopen) libs="$dlprefiles" ;;
-	link) libs="$deplibs %DEPLIBS% $dependency_libs" ;;
+	link)
+	  libs="$deplibs %DEPLIBS%"
+	  test "X$link_all_deplibs" != Xno && libs="$libs $dependency_libs"
+	  ;;
 	esac
       fi
       if test "$linkmode,$pass" = "lib,dlpreopen"; then
@@ -6206,6 +6209,9 @@ func_mode_link ()
 	    revision="$number_minor"
 	    lt_irix_increment=no
 	    ;;
+	  *)
+	    func_fatal_configuration "$modename: unknown library version type \`$version_type'"
+	    ;;
 	  esac
 	  ;;
 	no)
--- a/config.h.in
+++ b/config.h.in
@@ -82,6 +82,9 @@
 /* Define to the one symbol short name of this package. */
 #undef PACKAGE_TARNAME
 
+/* Define to the home page for this package. */
+#undef PACKAGE_URL
+
 /* Define to the version of this package. */
 #undef PACKAGE_VERSION
 
--- a/configure
+++ b/configure
@@ -1,20 +1,25 @@
 #! /bin/sh
 # Guess values for system-dependent variables and create Makefiles.
-# Generated by GNU Autoconf 2.63 for rygel 0.4.2.
+# Generated by GNU Autoconf 2.64 for rygel UNKNOWN-dirty.
 #
 # Report bugs to <http://live.gnome.org/Rygel>.
 #
 # Copyright (C) 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001,
-# 2002, 2003, 2004, 2005, 2006, 2007, 2008 Free Software Foundation, Inc.
+# 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009 Free Software
+# Foundation, Inc.
+#
 # This configure script is free software; the Free Software Foundation
 # gives unlimited permission to copy, distribute and modify it.
-## --------------------- ##
-## M4sh Initialization.  ##
-## --------------------- ##
+## -------------------- ##
+## M4sh Initialization. ##
+## -------------------- ##
+
+# Change git-version-gen mode to executable
+chmod +x ./build-aux/git-version-gen
 
 # Be more Bourne compatible
 DUALCASE=1; export DUALCASE # for MKS sh
-if test -n "${ZSH_VERSION+set}" && (emulate sh) >/dev/null 2>&1; then
+if test -n "${ZSH_VERSION+set}" && (emulate sh) >/dev/null 2>&1; then :
   emulate sh
   NULLCMD=:
   # Pre-4.2 versions of Zsh do word splitting on ${1+"$@"}, which
@@ -22,23 +27,15 @@ if test -n "${ZSH_VERSION+set}" && (emul
   alias -g '${1+"$@"}'='"$@"'
   setopt NO_GLOB_SUBST
 else
-  case `(set -o) 2>/dev/null` in
-  *posix*) set -o posix ;;
+  case `(set -o) 2>/dev/null` in #(
+  *posix*) :
+    set -o posix ;; #(
+  *) :
+     ;;
 esac
-
 fi
 
 
-
-
-# PATH needs CR
-# Avoid depending upon Character Ranges.
-as_cr_letters='abcdefghijklmnopqrstuvwxyz'
-as_cr_LETTERS='ABCDEFGHIJKLMNOPQRSTUVWXYZ'
-as_cr_Letters=$as_cr_letters$as_cr_LETTERS
-as_cr_digits='0123456789'
-as_cr_alnum=$as_cr_Letters$as_cr_digits
-
 as_nl='
 '
 export as_nl
@@ -46,7 +43,13 @@ export as_nl
 as_echo='\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'
 as_echo=$as_echo$as_echo$as_echo$as_echo$as_echo
 as_echo=$as_echo$as_echo$as_echo$as_echo$as_echo$as_echo
-if (test "X`printf %s $as_echo`" = "X$as_echo") 2>/dev/null; then
+# Prefer a ksh shell builtin over an external printf program on Solaris,
+# but without wasting forks for bash or zsh.
+if test -z "$BASH_VERSION$ZSH_VERSION" \
+    && (test "X`print -r -- $as_echo`" = "X$as_echo") 2>/dev/null; then
+  as_echo='print -r --'
+  as_echo_n='print -rn --'
+elif (test "X`printf %s $as_echo`" = "X$as_echo") 2>/dev/null; then
   as_echo='printf %s\n'
   as_echo_n='printf %s'
 else
@@ -57,7 +60,7 @@ else
     as_echo_body='eval expr "X$1" : "X\\(.*\\)"'
     as_echo_n_body='eval
       arg=$1;
-      case $arg in
+      case $arg in #(
       *"$as_nl"*)
 	expr "X$arg" : "X\\(.*\\)$as_nl";
 	arg=`expr "X$arg" : ".*$as_nl\\(.*\\)"`;;
@@ -80,13 +83,6 @@ if test "${PATH_SEPARATOR+set}" != set;
   }
 fi
 
-# Support unset when possible.
-if ( (MAIL=60; unset MAIL) || exit) >/dev/null 2>&1; then
-  as_unset=unset
-else
-  as_unset=false
-fi
-
 
 # IFS
 # We need space, tab and new line, in precisely that order.  Quoting is
@@ -96,15 +92,15 @@ fi
 IFS=" ""	$as_nl"
 
 # Find who we are.  Look in the path if we contain no directory separator.
-case $0 in
+case $0 in #((
   *[\\/]* ) as_myself=$0 ;;
   *) as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
 for as_dir in $PATH
 do
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
-  test -r "$as_dir/$0" && as_myself=$as_dir/$0 && break
-done
+    test -r "$as_dir/$0" && as_myself=$as_dir/$0 && break
+  done
 IFS=$as_save_IFS
 
      ;;
@@ -116,12 +112,16 @@ if test "x$as_myself" = x; then
 fi
 if test ! -f "$as_myself"; then
   $as_echo "$as_myself: error: cannot find myself; rerun with an absolute file name" >&2
-  { (exit 1); exit 1; }
+  exit 1
 fi
 
-# Work around bugs in pre-3.0 UWIN ksh.
-for as_var in ENV MAIL MAILPATH
-do ($as_unset $as_var) >/dev/null 2>&1 && $as_unset $as_var
+# Unset variables that we do not need and which cause bugs (e.g. in
+# pre-3.0 UWIN ksh).  But do not cause bugs in bash 2.01; the "|| exit 1"
+# suppresses any "Segmentation fault" message there.  '((' could
+# trigger a bug in pdksh 5.2.14.
+for as_var in BASH_ENV ENV MAIL MAILPATH
+do eval test x\${$as_var+set} = xset \
+  && ( (unset $as_var) || exit 1) >/dev/null 2>&1 && unset $as_var || :
 done
 PS1='$ '
 PS2='> '
@@ -133,330 +133,300 @@ export LC_ALL
 LANGUAGE=C
 export LANGUAGE
 
-# Required to use basename.
-if expr a : '\(a\)' >/dev/null 2>&1 &&
-   test "X`expr 00001 : '.*\(...\)'`" = X001; then
-  as_expr=expr
-else
-  as_expr=false
-fi
-
-if (basename -- /) >/dev/null 2>&1 && test "X`basename -- / 2>&1`" = "X/"; then
-  as_basename=basename
-else
-  as_basename=false
-fi
-
-
-# Name of the executable.
-as_me=`$as_basename -- "$0" ||
-$as_expr X/"$0" : '.*/\([^/][^/]*\)/*$' \| \
-	 X"$0" : 'X\(//\)$' \| \
-	 X"$0" : 'X\(/\)' \| . 2>/dev/null ||
-$as_echo X/"$0" |
-    sed '/^.*\/\([^/][^/]*\)\/*$/{
-	    s//\1/
-	    q
-	  }
-	  /^X\/\(\/\/\)$/{
-	    s//\1/
-	    q
-	  }
-	  /^X\/\(\/\).*/{
-	    s//\1/
-	    q
-	  }
-	  s/.*/./; q'`
-
 # CDPATH.
-$as_unset CDPATH
-
+(unset CDPATH) >/dev/null 2>&1 && unset CDPATH
 
 if test "x$CONFIG_SHELL" = x; then
-  if (eval ":") 2>/dev/null; then
-  as_have_required=yes
+  as_bourne_compatible="if test -n \"\${ZSH_VERSION+set}\" && (emulate sh) >/dev/null 2>&1; then :
+  emulate sh
+  NULLCMD=:
+  # Pre-4.2 versions of Zsh do word splitting on \${1+\"\$@\"}, which
+  # is contrary to our usage.  Disable this feature.
+  alias -g '\${1+\"\$@\"}'='\"\$@\"'
+  setopt NO_GLOB_SUBST
 else
-  as_have_required=no
+  case \`(set -o) 2>/dev/null\` in #(
+  *posix*) :
+    set -o posix ;; #(
+  *) :
+     ;;
+esac
 fi
-
-  if test $as_have_required = yes &&	 (eval ":
-(as_func_return () {
-  (exit \$1)
-}
-as_func_success () {
-  as_func_return 0
-}
-as_func_failure () {
-  as_func_return 1
-}
-as_func_ret_success () {
-  return 0
-}
-as_func_ret_failure () {
-  return 1
-}
+"
+  as_required="as_fn_return () { (exit \$1); }
+as_fn_success () { as_fn_return 0; }
+as_fn_failure () { as_fn_return 1; }
+as_fn_ret_success () { return 0; }
+as_fn_ret_failure () { return 1; }
 
 exitcode=0
-if as_func_success; then
-  :
-else
-  exitcode=1
-  echo as_func_success failed.
-fi
-
-if as_func_failure; then
-  exitcode=1
-  echo as_func_failure succeeded.
-fi
-
-if as_func_ret_success; then
-  :
-else
-  exitcode=1
-  echo as_func_ret_success failed.
-fi
-
-if as_func_ret_failure; then
-  exitcode=1
-  echo as_func_ret_failure succeeded.
-fi
-
-if ( set x; as_func_ret_success y && test x = \"\$1\" ); then
-  :
+as_fn_success || { exitcode=1; echo as_fn_success failed.; }
+as_fn_failure && { exitcode=1; echo as_fn_failure succeeded.; }
+as_fn_ret_success || { exitcode=1; echo as_fn_ret_success failed.; }
+as_fn_ret_failure && { exitcode=1; echo as_fn_ret_failure succeeded.; }
+if ( set x; as_fn_ret_success y && test x = \"\$1\" ); then :
+
+else
+  exitcode=1; echo positional parameters were not saved.
+fi
+test x\$exitcode = x0 || exit 1"
+  as_suggested="  as_lineno_1=";as_suggested=$as_suggested$LINENO;as_suggested=$as_suggested" as_lineno_1a=\$LINENO
+  as_lineno_2=";as_suggested=$as_suggested$LINENO;as_suggested=$as_suggested" as_lineno_2a=\$LINENO
+  eval 'test \"x\$as_lineno_1'\$as_run'\" != \"x\$as_lineno_2'\$as_run'\" &&
+  test \"x\`expr \$as_lineno_1'\$as_run' + 1\`\" = \"x\$as_lineno_2'\$as_run'\"' || exit 1
+test \$(( 1 + 1 )) = 2 || exit 1"
+  if (eval "$as_required") 2>/dev/null; then :
+  as_have_required=yes
 else
-  exitcode=1
-  echo positional parameters were not saved.
+  as_have_required=no
 fi
+  if test x$as_have_required = xyes && (eval "$as_suggested") 2>/dev/null; then :
 
-test \$exitcode = 0) || { (exit 1); exit 1; }
-
-(
-  as_lineno_1=\$LINENO
-  as_lineno_2=\$LINENO
-  test \"x\$as_lineno_1\" != \"x\$as_lineno_2\" &&
-  test \"x\`expr \$as_lineno_1 + 1\`\" = \"x\$as_lineno_2\") || { (exit 1); exit 1; }
-") 2> /dev/null; then
-  :
 else
-  as_candidate_shells=
-    as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+as_found=false
 for as_dir in /bin$PATH_SEPARATOR/usr/bin$PATH_SEPARATOR$PATH
 do
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
-  case $as_dir in
+  as_found=:
+  case $as_dir in #(
 	 /*)
 	   for as_base in sh bash ksh sh5; do
-	     as_candidate_shells="$as_candidate_shells $as_dir/$as_base"
+	     # Try only shells that exist, to save several forks.
+	     as_shell=$as_dir/$as_base
+	     if { test -f "$as_shell" || test -f "$as_shell.exe"; } &&
+		    { $as_echo "$as_bourne_compatible""$as_required" | as_run=a "$as_shell"; } 2>/dev/null; then :
+  CONFIG_SHELL=$as_shell as_have_required=yes
+		   if { $as_echo "$as_bourne_compatible""$as_suggested" | as_run=a "$as_shell"; } 2>/dev/null; then :
+  break 2
+fi
+fi
 	   done;;
        esac
+  as_found=false
 done
+$as_found || { if { test -f "$SHELL" || test -f "$SHELL.exe"; } &&
+	      { $as_echo "$as_bourne_compatible""$as_required" | as_run=a "$SHELL"; } 2>/dev/null; then :
+  CONFIG_SHELL=$SHELL as_have_required=yes
+fi; }
 IFS=$as_save_IFS
 
 
-      for as_shell in $as_candidate_shells $SHELL; do
-	 # Try only shells that exist, to save several forks.
-	 if { test -f "$as_shell" || test -f "$as_shell.exe"; } &&
-		{ ("$as_shell") 2> /dev/null <<\_ASEOF
-if test -n "${ZSH_VERSION+set}" && (emulate sh) >/dev/null 2>&1; then
-  emulate sh
-  NULLCMD=:
-  # Pre-4.2 versions of Zsh do word splitting on ${1+"$@"}, which
-  # is contrary to our usage.  Disable this feature.
-  alias -g '${1+"$@"}'='"$@"'
-  setopt NO_GLOB_SUBST
-else
-  case `(set -o) 2>/dev/null` in
-  *posix*) set -o posix ;;
-esac
-
-fi
-
-
-:
-_ASEOF
-}; then
-  CONFIG_SHELL=$as_shell
-	       as_have_required=yes
-	       if { "$as_shell" 2> /dev/null <<\_ASEOF
-if test -n "${ZSH_VERSION+set}" && (emulate sh) >/dev/null 2>&1; then
-  emulate sh
-  NULLCMD=:
-  # Pre-4.2 versions of Zsh do word splitting on ${1+"$@"}, which
-  # is contrary to our usage.  Disable this feature.
-  alias -g '${1+"$@"}'='"$@"'
-  setopt NO_GLOB_SUBST
-else
-  case `(set -o) 2>/dev/null` in
-  *posix*) set -o posix ;;
-esac
-
-fi
-
-
-:
-(as_func_return () {
-  (exit $1)
-}
-as_func_success () {
-  as_func_return 0
-}
-as_func_failure () {
-  as_func_return 1
-}
-as_func_ret_success () {
-  return 0
-}
-as_func_ret_failure () {
-  return 1
-}
-
-exitcode=0
-if as_func_success; then
-  :
-else
-  exitcode=1
-  echo as_func_success failed.
-fi
-
-if as_func_failure; then
-  exitcode=1
-  echo as_func_failure succeeded.
-fi
-
-if as_func_ret_success; then
-  :
-else
-  exitcode=1
-  echo as_func_ret_success failed.
-fi
-
-if as_func_ret_failure; then
-  exitcode=1
-  echo as_func_ret_failure succeeded.
-fi
-
-if ( set x; as_func_ret_success y && test x = "$1" ); then
-  :
-else
-  exitcode=1
-  echo positional parameters were not saved.
-fi
-
-test $exitcode = 0) || { (exit 1); exit 1; }
-
-(
-  as_lineno_1=$LINENO
-  as_lineno_2=$LINENO
-  test "x$as_lineno_1" != "x$as_lineno_2" &&
-  test "x`expr $as_lineno_1 + 1`" = "x$as_lineno_2") || { (exit 1); exit 1; }
-
-_ASEOF
-}; then
-  break
-fi
-
-fi
-
-      done
-
-      if test "x$CONFIG_SHELL" != x; then
-  for as_var in BASH_ENV ENV
-	do ($as_unset $as_var) >/dev/null 2>&1 && $as_unset $as_var
-	done
+      if test "x$CONFIG_SHELL" != x; then :
+  # We cannot yet assume a decent shell, so we have to provide a
+	# neutralization value for shells without unset; and this also
+	# works around shells that cannot unset nonexistent variables.
+	BASH_ENV=/dev/null
+	ENV=/dev/null
+	(unset BASH_ENV) >/dev/null 2>&1 && unset BASH_ENV ENV
 	export CONFIG_SHELL
 	exec "$CONFIG_SHELL" "$as_myself" ${1+"$@"}
 fi
 
-
-    if test $as_have_required = no; then
-  echo This script requires a shell more modern than all the
-      echo shells that I found on your system.  Please install a
-      echo modern shell, or manually run the script under such a
-      echo shell if you do have one.
-      { (exit 1); exit 1; }
+    if test x$as_have_required = xno; then :
+  $as_echo "$0: This script requires a shell more modern than all"
+  $as_echo "$0: the shells that I found on your system."
+  if test x${ZSH_VERSION+set} = xset ; then
+    $as_echo "$0: In particular, zsh $ZSH_VERSION has bugs and should"
+    $as_echo "$0: be upgraded to zsh 4.3.4 or later."
+  else
+    $as_echo "$0: Please tell bug-autoconf@gnu.org and
+$0: http://live.gnome.org/Rygel about your system,
+$0: including any error possibly output before this
+$0: message. Then install a modern shell, or manually run
+$0: the script under such a shell if you do have one."
+  fi
+  exit 1
 fi
-
-
 fi
-
 fi
+SHELL=${CONFIG_SHELL-/bin/sh}
+export SHELL
+# Unset more variables known to interfere with behavior of common tools.
+CLICOLOR_FORCE= GREP_OPTIONS=
+unset CLICOLOR_FORCE GREP_OPTIONS
 
+## --------------------- ##
+## M4sh Shell Functions. ##
+## --------------------- ##
+# as_fn_unset VAR
+# ---------------
+# Portably unset VAR.
+as_fn_unset ()
+{
+  { eval $1=; unset $1;}
+}
+as_unset=as_fn_unset
+
+# as_fn_set_status STATUS
+# -----------------------
+# Set $? to STATUS, without forking.
+as_fn_set_status ()
+{
+  return $1
+} # as_fn_set_status
+
+# as_fn_exit STATUS
+# -----------------
+# Exit the shell with STATUS, even in a "trap 0" or "set -e" context.
+as_fn_exit ()
+{
+  set +e
+  as_fn_set_status $1
+  exit $1
+} # as_fn_exit
+
+# as_fn_mkdir_p
+# -------------
+# Create "$as_dir" as a directory, including parents if necessary.
+as_fn_mkdir_p ()
+{
+
+  case $as_dir in #(
+  -*) as_dir=./$as_dir;;
+  esac
+  test -d "$as_dir" || eval $as_mkdir_p || {
+    as_dirs=
+    while :; do
+      case $as_dir in #(
+      *\'*) as_qdir=`$as_echo "$as_dir" | sed "s/'/'\\\\\\\\''/g"`;; #'(
+      *) as_qdir=$as_dir;;
+      esac
+      as_dirs="'$as_qdir' $as_dirs"
+      as_dir=`$as_dirname -- "$as_dir" ||
+$as_expr X"$as_dir" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	 X"$as_dir" : 'X\(//\)[^/]' \| \
+	 X"$as_dir" : 'X\(//\)$' \| \
+	 X"$as_dir" : 'X\(/\)' \| . 2>/dev/null ||
+$as_echo X"$as_dir" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)[^/].*/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\).*/{
+	    s//\1/
+	    q
+	  }
+	  s/.*/./; q'`
+      test -d "$as_dir" && break
+    done
+    test -z "$as_dirs" || eval "mkdir $as_dirs"
+  } || test -d "$as_dir" || as_fn_error "cannot create directory $as_dir"
 
 
-(eval "as_func_return () {
-  (exit \$1)
-}
-as_func_success () {
-  as_func_return 0
-}
-as_func_failure () {
-  as_func_return 1
-}
-as_func_ret_success () {
-  return 0
-}
-as_func_ret_failure () {
-  return 1
-}
+} # as_fn_mkdir_p
+# as_fn_append VAR VALUE
+# ----------------------
+# Append the text in VALUE to the end of the definition contained in VAR. Take
+# advantage of any shell optimizations that allow amortized linear growth over
+# repeated appends, instead of the typical quadratic growth present in naive
+# implementations.
+if (eval "as_var=1; as_var+=2; test x\$as_var = x12") 2>/dev/null; then :
+  eval 'as_fn_append ()
+  {
+    eval $1+=\$2
+  }'
+else
+  as_fn_append ()
+  {
+    eval $1=\$$1\$2
+  }
+fi # as_fn_append
 
-exitcode=0
-if as_func_success; then
-  :
+# as_fn_arith ARG...
+# ------------------
+# Perform arithmetic evaluation on the ARGs, and store the result in the
+# global $as_val. Take advantage of shells that can avoid forks. The arguments
+# must be portable across $(()) and expr.
+if (eval "test \$(( 1 + 1 )) = 2") 2>/dev/null; then :
+  eval 'as_fn_arith ()
+  {
+    as_val=$(( $* ))
+  }'
 else
-  exitcode=1
-  echo as_func_success failed.
-fi
+  as_fn_arith ()
+  {
+    as_val=`expr "$@" || test $? -eq 1`
+  }
+fi # as_fn_arith
 
-if as_func_failure; then
-  exitcode=1
-  echo as_func_failure succeeded.
-fi
 
-if as_func_ret_success; then
-  :
+# as_fn_error ERROR [LINENO LOG_FD]
+# ---------------------------------
+# Output "`basename $0`: error: ERROR" to stderr. If LINENO and LOG_FD are
+# provided, also output the error to LOG_FD, referencing LINENO. Then exit the
+# script with status $?, using 1 if that was 0.
+as_fn_error ()
+{
+  as_status=$?; test $as_status -eq 0 && as_status=1
+  if test "$3"; then
+    as_lineno=${as_lineno-"$2"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
+    $as_echo "$as_me:${as_lineno-$LINENO}: error: $1" >&$3
+  fi
+  $as_echo "$as_me: error: $1" >&2
+  as_fn_exit $as_status
+} # as_fn_error
+
+if expr a : '\(a\)' >/dev/null 2>&1 &&
+   test "X`expr 00001 : '.*\(...\)'`" = X001; then
+  as_expr=expr
 else
-  exitcode=1
-  echo as_func_ret_success failed.
+  as_expr=false
 fi
 
-if as_func_ret_failure; then
-  exitcode=1
-  echo as_func_ret_failure succeeded.
+if (basename -- /) >/dev/null 2>&1 && test "X`basename -- / 2>&1`" = "X/"; then
+  as_basename=basename
+else
+  as_basename=false
 fi
 
-if ( set x; as_func_ret_success y && test x = \"\$1\" ); then
-  :
+if (as_dir=`dirname -- /` && test "X$as_dir" = X/) >/dev/null 2>&1; then
+  as_dirname=dirname
 else
-  exitcode=1
-  echo positional parameters were not saved.
+  as_dirname=false
 fi
 
-test \$exitcode = 0") || {
-  echo No shell found that supports shell functions.
-  echo Please tell bug-autoconf@gnu.org about your system,
-  echo including any error possibly output before this message.
-  echo This can help us improve future autoconf versions.
-  echo Configuration will now proceed without shell functions.
-}
+as_me=`$as_basename -- "$0" ||
+$as_expr X/"$0" : '.*/\([^/][^/]*\)/*$' \| \
+	 X"$0" : 'X\(//\)$' \| \
+	 X"$0" : 'X\(/\)' \| . 2>/dev/null ||
+$as_echo X/"$0" |
+    sed '/^.*\/\([^/][^/]*\)\/*$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\/\(\/\/\)$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\/\(\/\).*/{
+	    s//\1/
+	    q
+	  }
+	  s/.*/./; q'`
 
+# Avoid depending upon Character Ranges.
+as_cr_letters='abcdefghijklmnopqrstuvwxyz'
+as_cr_LETTERS='ABCDEFGHIJKLMNOPQRSTUVWXYZ'
+as_cr_Letters=$as_cr_letters$as_cr_LETTERS
+as_cr_digits='0123456789'
+as_cr_alnum=$as_cr_Letters$as_cr_digits
 
 
-  as_lineno_1=$LINENO
-  as_lineno_2=$LINENO
-  test "x$as_lineno_1" != "x$as_lineno_2" &&
-  test "x`expr $as_lineno_1 + 1`" = "x$as_lineno_2" || {
-
-  # Create $as_me.lineno as a copy of $as_myself, but with $LINENO
-  # uniformly replaced by the line number.  The first 'sed' inserts a
-  # line-number line after each line using $LINENO; the second 'sed'
-  # does the real work.  The second script uses 'N' to pair each
-  # line-number line with the line containing $LINENO, and appends
-  # trailing '-' during substitution so that $LINENO is not a special
-  # case at line end.
-  # (Raja R Harinath suggested sed '=', and Paul Eggert wrote the
-  # scripts with optimization help from Paolo Bonzini.  Blame Lee
-  # E. McMahon (1931-1989) for sed's syntax.  :-)
+  as_lineno_1=$LINENO as_lineno_1a=$LINENO
+  as_lineno_2=$LINENO as_lineno_2a=$LINENO
+  eval 'test "x$as_lineno_1'$as_run'" != "x$as_lineno_2'$as_run'" &&
+  test "x`expr $as_lineno_1'$as_run' + 1`" = "x$as_lineno_2'$as_run'"' || {
+  # Blame Lee E. McMahon (1931-1989) for sed's syntax.  :-)
   sed -n '
     p
     /[$]LINENO/=
@@ -473,8 +443,7 @@ test \$exitcode = 0") || {
       s/-\n.*//
     ' >$as_me.lineno &&
   chmod +x "$as_me.lineno" ||
-    { $as_echo "$as_me: error: cannot create $as_me.lineno; rerun with a POSIX shell" >&2
-   { (exit 1); exit 1; }; }
+    { $as_echo "$as_me: error: cannot create $as_me.lineno; rerun with a POSIX shell" >&2; as_fn_exit 1; }
 
   # Don't try to exec as it changes $[0], causing all sort of problems
   # (the dirname of $[0] is not the place where we might find the
@@ -484,29 +453,18 @@ test \$exitcode = 0") || {
   exit
 }
 
-
-if (as_dir=`dirname -- /` && test "X$as_dir" = X/) >/dev/null 2>&1; then
-  as_dirname=dirname
-else
-  as_dirname=false
-fi
-
 ECHO_C= ECHO_N= ECHO_T=
-case `echo -n x` in
+case `echo -n x` in #(((((
 -n*)
-  case `echo 'x\c'` in
+  case `echo 'xy\c'` in
   *c*) ECHO_T='	';;	# ECHO_T is single tab character.
-  *)   ECHO_C='\c';;
+  xy)  ECHO_C='\c';;
+  *)   echo `echo ksh88 bug on AIX 6.1` > /dev/null
+       ECHO_T='	';;
   esac;;
 *)
   ECHO_N='-n';;
 esac
-if expr a : '\(a\)' >/dev/null 2>&1 &&
-   test "X`expr 00001 : '.*\(...\)'`" = X001; then
-  as_expr=expr
-else
-  as_expr=false
-fi
 
 rm -f conf$$ conf$$.exe conf$$.file
 if test -d conf$$.dir; then
@@ -536,7 +494,7 @@ rm -f conf$$ conf$$.exe conf$$.dir/conf$
 rmdir conf$$.dir 2>/dev/null
 
 if mkdir -p . 2>/dev/null; then
-  as_mkdir_p=:
+  as_mkdir_p='mkdir -p "$as_dir"'
 else
   test -d ./-p && rmdir ./-p
   as_mkdir_p=false
@@ -555,10 +513,10 @@ else
       if test -d "$1"; then
 	test -d "$1/.";
       else
-	case $1 in
+	case $1 in #(
 	-*)set "./$1";;
 	esac;
-	case `ls -ld'$as_ls_L_option' "$1" 2>/dev/null` in
+	case `ls -ld'$as_ls_L_option' "$1" 2>/dev/null` in #((
 	???[sx]*):;;*)false;;esac;fi
     '\'' sh
   '
@@ -800,14 +758,14 @@ cross_compiling=no
 subdirs=
 MFLAGS=
 MAKEFLAGS=
-SHELL=${CONFIG_SHELL-/bin/sh}
 
 # Identity of this package.
 PACKAGE_NAME='rygel'
 PACKAGE_TARNAME='rygel'
-PACKAGE_VERSION='0.4.2'
-PACKAGE_STRING='rygel 0.4.2'
+PACKAGE_VERSION='UNKNOWN-dirty'
+PACKAGE_STRING='rygel UNKNOWN-dirty'
 PACKAGE_BUGREPORT='http://live.gnome.org/Rygel'
+PACKAGE_URL=''
 
 ac_unique_file="src/rygel/rygel-root-device.vala"
 # Factoring default headers for most tests.
@@ -869,6 +827,8 @@ MSGFMT_OPTS
 MSGFMT
 USE_NLS
 GETTEXT_PACKAGE
+BUILD_GST_RENDERER_PLUGIN_FALSE
+BUILD_GST_RENDERER_PLUGIN_TRUE
 BUILD_GSTLAUNCH_PLUGIN_FALSE
 BUILD_GSTLAUNCH_PLUGIN_TRUE
 BUILD_EXTERNAL_PLUGIN_FALSE
@@ -892,22 +852,20 @@ HAVE_GTK
 GTK_LIBS
 GTK_CFLAGS
 VAPIDIR
-GUPNP_VALA_LIBS
-GUPNP_VALA_CFLAGS
 VALAC
 GLIB_GENMARSHAL
 LIBSQLITE3_LIBS
 LIBSQLITE3_CFLAGS
 LIBSOUP_LIBS
 LIBSOUP_CFLAGS
-UUID_LIBS
-UUID_CFLAGS
 GEE_LIBS
 GEE_CFLAGS
 LIBGIO_LIBS
 LIBGIO_CFLAGS
-LIBGSTREAMER_LIBS
-LIBGSTREAMER_CFLAGS
+LIBGLIB_LIBS
+LIBGLIB_CFLAGS
+LIBVLC_LIBS
+LIBVLC_CFLAGS
 LIBDBUS_GLIB_LIBS
 LIBDBUS_GLIB_CFLAGS
 LIBGUPNP_AV_LIBS
@@ -1015,6 +973,7 @@ bindir
 program_transform_name
 prefix
 exec_prefix
+PACKAGE_URL
 PACKAGE_BUGREPORT
 PACKAGE_STRING
 PACKAGE_VERSION
@@ -1045,6 +1004,7 @@ enable_media_export_plugin
 enable_external_plugin
 enable_mediathek_plugin
 enable_gstlaunch_plugin
+enable_gst_renderer_plugin
 enable_silent_rules
 '
       ac_precious_vars='build_alias
@@ -1063,20 +1023,18 @@ LIBGUPNP_AV_CFLAGS
 LIBGUPNP_AV_LIBS
 LIBDBUS_GLIB_CFLAGS
 LIBDBUS_GLIB_LIBS
-LIBGSTREAMER_CFLAGS
-LIBGSTREAMER_LIBS
+LIBVLC_CFLAGS
+LIBVLC_LIBS
+LIBGLIB_CFLAGS
+LIBGLIB_LIBS
 LIBGIO_CFLAGS
 LIBGIO_LIBS
 GEE_CFLAGS
 GEE_LIBS
-UUID_CFLAGS
-UUID_LIBS
 LIBSOUP_CFLAGS
 LIBSOUP_LIBS
 LIBSQLITE3_CFLAGS
 LIBSQLITE3_LIBS
-GUPNP_VALA_CFLAGS
-GUPNP_VALA_LIBS
 GTK_CFLAGS
 GTK_LIBS'
 
@@ -1187,8 +1145,7 @@ do
     ac_useropt=`expr "x$ac_option" : 'x-*disable-\(.*\)'`
     # Reject names that are not valid shell variable names.
     expr "x$ac_useropt" : ".*[^-+._$as_cr_alnum]" >/dev/null &&
-      { $as_echo "$as_me: error: invalid feature name: $ac_useropt" >&2
-   { (exit 1); exit 1; }; }
+      as_fn_error "invalid feature name: $ac_useropt"
     ac_useropt_orig=$ac_useropt
     ac_useropt=`$as_echo "$ac_useropt" | sed 's/[-+.]/_/g'`
     case $ac_user_opts in
@@ -1214,8 +1171,7 @@ do
     ac_useropt=`expr "x$ac_option" : 'x-*enable-\([^=]*\)'`
     # Reject names that are not valid shell variable names.
     expr "x$ac_useropt" : ".*[^-+._$as_cr_alnum]" >/dev/null &&
-      { $as_echo "$as_me: error: invalid feature name: $ac_useropt" >&2
-   { (exit 1); exit 1; }; }
+      as_fn_error "invalid feature name: $ac_useropt"
     ac_useropt_orig=$ac_useropt
     ac_useropt=`$as_echo "$ac_useropt" | sed 's/[-+.]/_/g'`
     case $ac_user_opts in
@@ -1419,8 +1375,7 @@ do
     ac_useropt=`expr "x$ac_option" : 'x-*with-\([^=]*\)'`
     # Reject names that are not valid shell variable names.
     expr "x$ac_useropt" : ".*[^-+._$as_cr_alnum]" >/dev/null &&
-      { $as_echo "$as_me: error: invalid package name: $ac_useropt" >&2
-   { (exit 1); exit 1; }; }
+      as_fn_error "invalid package name: $ac_useropt"
     ac_useropt_orig=$ac_useropt
     ac_useropt=`$as_echo "$ac_useropt" | sed 's/[-+.]/_/g'`
     case $ac_user_opts in
@@ -1436,8 +1391,7 @@ do
     ac_useropt=`expr "x$ac_option" : 'x-*without-\(.*\)'`
     # Reject names that are not valid shell variable names.
     expr "x$ac_useropt" : ".*[^-+._$as_cr_alnum]" >/dev/null &&
-      { $as_echo "$as_me: error: invalid package name: $ac_useropt" >&2
-   { (exit 1); exit 1; }; }
+      as_fn_error "invalid package name: $ac_useropt"
     ac_useropt_orig=$ac_useropt
     ac_useropt=`$as_echo "$ac_useropt" | sed 's/[-+.]/_/g'`
     case $ac_user_opts in
@@ -1467,17 +1421,17 @@ do
   | --x-librar=* | --x-libra=* | --x-libr=* | --x-lib=* | --x-li=* | --x-l=*)
     x_libraries=$ac_optarg ;;
 
-  -*) { $as_echo "$as_me: error: unrecognized option: $ac_option
-Try \`$0 --help' for more information." >&2
-   { (exit 1); exit 1; }; }
+  -*) as_fn_error "unrecognized option: \`$ac_option'
+Try \`$0 --help' for more information."
     ;;
 
   *=*)
     ac_envvar=`expr "x$ac_option" : 'x\([^=]*\)='`
     # Reject names that are not valid shell variable names.
-    expr "x$ac_envvar" : ".*[^_$as_cr_alnum]" >/dev/null &&
-      { $as_echo "$as_me: error: invalid variable name: $ac_envvar" >&2
-   { (exit 1); exit 1; }; }
+    case $ac_envvar in #(
+      '' | [0-9]* | *[!_$as_cr_alnum]* )
+      as_fn_error "invalid variable name: \`$ac_envvar'" ;;
+    esac
     eval $ac_envvar=\$ac_optarg
     export $ac_envvar ;;
 
@@ -1494,15 +1448,13 @@ done
 
 if test -n "$ac_prev"; then
   ac_option=--`echo $ac_prev | sed 's/_/-/g'`
-  { $as_echo "$as_me: error: missing argument to $ac_option" >&2
-   { (exit 1); exit 1; }; }
+  as_fn_error "missing argument to $ac_option"
 fi
 
 if test -n "$ac_unrecognized_opts"; then
   case $enable_option_checking in
     no) ;;
-    fatal) { $as_echo "$as_me: error: unrecognized options: $ac_unrecognized_opts" >&2
-   { (exit 1); exit 1; }; } ;;
+    fatal) as_fn_error "unrecognized options: $ac_unrecognized_opts" ;;
     *)     $as_echo "$as_me: WARNING: unrecognized options: $ac_unrecognized_opts" >&2 ;;
   esac
 fi
@@ -1525,8 +1477,7 @@ do
     [\\/$]* | ?:[\\/]* )  continue;;
     NONE | '' ) case $ac_var in *prefix ) continue;; esac;;
   esac
-  { $as_echo "$as_me: error: expected an absolute directory name for --$ac_var: $ac_val" >&2
-   { (exit 1); exit 1; }; }
+  as_fn_error "expected an absolute directory name for --$ac_var: $ac_val"
 done
 
 # There might be people who depend on the old broken behavior: `$host'
@@ -1556,11 +1507,9 @@ test "$silent" = yes && exec 6>/dev/null
 ac_pwd=`pwd` && test -n "$ac_pwd" &&
 ac_ls_di=`ls -di .` &&
 ac_pwd_ls_di=`cd "$ac_pwd" && ls -di .` ||
-  { $as_echo "$as_me: error: working directory cannot be determined" >&2
-   { (exit 1); exit 1; }; }
+  as_fn_error "working directory cannot be determined"
 test "X$ac_ls_di" = "X$ac_pwd_ls_di" ||
-  { $as_echo "$as_me: error: pwd does not report name of working directory" >&2
-   { (exit 1); exit 1; }; }
+  as_fn_error "pwd does not report name of working directory"
 
 
 # Find the source files, if location was not specified.
@@ -1599,13 +1548,11 @@ else
 fi
 if test ! -r "$srcdir/$ac_unique_file"; then
   test "$ac_srcdir_defaulted" = yes && srcdir="$ac_confdir or .."
-  { $as_echo "$as_me: error: cannot find sources ($ac_unique_file) in $srcdir" >&2
-   { (exit 1); exit 1; }; }
+  as_fn_error "cannot find sources ($ac_unique_file) in $srcdir"
 fi
 ac_msg="sources are in $srcdir, but \`cd $srcdir' does not work"
 ac_abs_confdir=`(
-	cd "$srcdir" && test -r "./$ac_unique_file" || { $as_echo "$as_me: error: $ac_msg" >&2
-   { (exit 1); exit 1; }; }
+	cd "$srcdir" && test -r "./$ac_unique_file" || as_fn_error "$ac_msg"
 	pwd)`
 # When building in place, set srcdir=.
 if test "$ac_abs_confdir" = "$ac_pwd"; then
@@ -1631,7 +1578,7 @@ if test "$ac_init_help" = "long"; then
   # Omit some internal or obsolete options to make the list less imposing.
   # This message is too long to be a string in the A/UX 3.1 sh.
   cat <<_ACEOF
-\`configure' configures rygel 0.4.2 to adapt to many kinds of systems.
+\`configure' configures rygel UNKNOWN-dirty to adapt to many kinds of systems.
 
 Usage: $0 [OPTION]... [VAR=VALUE]...
 
@@ -1701,7 +1648,7 @@ fi
 
 if test -n "$ac_init_help"; then
   case $ac_init_help in
-     short | recursive ) echo "Configuration of rygel 0.4.2:";;
+     short | recursive ) echo "Configuration of rygel UNKNOWN-dirty:";;
    esac
   cat <<\_ACEOF
 
@@ -1729,6 +1676,7 @@ Optional Features:
   --enable-external-plugin          build External plugin
   --enable-mediathek-plugin          build Mediathek plugin
   --enable-gstlaunch-plugin          build Gstreamer launchline plugin
+  --enable-gst-renderer-plugin       build renderer plugin
   --enable-silent-rules          less verbose build output (undo: `make V=1')
   --disable-silent-rules         verbose build output (undo: `make V=0')
 
@@ -1762,17 +1710,18 @@ Some influential environment variables:
               C compiler flags for LIBDBUS_GLIB, overriding pkg-config
   LIBDBUS_GLIB_LIBS
               linker flags for LIBDBUS_GLIB, overriding pkg-config
-  LIBGSTREAMER_CFLAGS
-              C compiler flags for LIBGSTREAMER, overriding pkg-config
-  LIBGSTREAMER_LIBS
-              linker flags for LIBGSTREAMER, overriding pkg-config
+  LIBVLC_CFLAGS
+              C compiler flags for LIBVLC, overriding pkg-config
+  LIBVLC_LIBS linker flags for LIBVLC, overriding pkg-config
+  LIBGLIB_CFLAGS
+              C compiler flags for LIBGLIB, overriding pkg-config
+  LIBGLIB_LIBS
+              linker flags for LIBGLIB, overriding pkg-config
   LIBGIO_CFLAGS
               C compiler flags for LIBGIO, overriding pkg-config
   LIBGIO_LIBS linker flags for LIBGIO, overriding pkg-config
   GEE_CFLAGS  C compiler flags for GEE, overriding pkg-config
   GEE_LIBS    linker flags for GEE, overriding pkg-config
-  UUID_CFLAGS C compiler flags for UUID, overriding pkg-config
-  UUID_LIBS   linker flags for UUID, overriding pkg-config
   LIBSOUP_CFLAGS
               C compiler flags for LIBSOUP, overriding pkg-config
   LIBSOUP_LIBS
@@ -1781,10 +1730,6 @@ Some influential environment variables:
               C compiler flags for LIBSQLITE3, overriding pkg-config
   LIBSQLITE3_LIBS
               linker flags for LIBSQLITE3, overriding pkg-config
-  GUPNP_VALA_CFLAGS
-              C compiler flags for GUPNP_VALA, overriding pkg-config
-  GUPNP_VALA_LIBS
-              linker flags for GUPNP_VALA, overriding pkg-config
   GTK_CFLAGS  C compiler flags for GTK, overriding pkg-config
   GTK_LIBS    linker flags for GTK, overriding pkg-config
 
@@ -1854,22 +1799,379 @@ fi
 test -n "$ac_init_help" && exit $ac_status
 if $ac_init_version; then
   cat <<\_ACEOF
-rygel configure 0.4.2
-generated by GNU Autoconf 2.63
+rygel configure UNKNOWN-dirty
+generated by GNU Autoconf 2.64
 
-Copyright (C) 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001,
-2002, 2003, 2004, 2005, 2006, 2007, 2008 Free Software Foundation, Inc.
+Copyright (C) 2009 Free Software Foundation, Inc.
 This configure script is free software; the Free Software Foundation
 gives unlimited permission to copy, distribute and modify it.
 _ACEOF
   exit
 fi
+
+## ------------------------ ##
+## Autoconf initialization. ##
+## ------------------------ ##
+
+# ac_fn_c_try_compile LINENO
+# --------------------------
+# Try to compile conftest.$ac_ext, and return whether this succeeded.
+ac_fn_c_try_compile ()
+{
+  as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
+  rm -f conftest.$ac_objext
+  if { { ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
+$as_echo "$ac_try_echo"; } >&5
+  (eval "$ac_compile") 2>conftest.err
+  ac_status=$?
+  if test -s conftest.err; then
+    grep -v '^ *+' conftest.err >conftest.er1
+    cat conftest.er1 >&5
+    mv -f conftest.er1 conftest.err
+  fi
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest.$ac_objext; then :
+  ac_retval=0
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	ac_retval=1
+fi
+  eval $as_lineno_stack; test "x$as_lineno_stack" = x && { as_lineno=; unset as_lineno;}
+  return $ac_retval
+
+} # ac_fn_c_try_compile
+
+# ac_fn_c_try_link LINENO
+# -----------------------
+# Try to link conftest.$ac_ext, and return whether this succeeded.
+ac_fn_c_try_link ()
+{
+  as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
+  rm -f conftest.$ac_objext conftest$ac_exeext
+  if { { ac_try="$ac_link"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
+$as_echo "$ac_try_echo"; } >&5
+  (eval "$ac_link") 2>conftest.err
+  ac_status=$?
+  if test -s conftest.err; then
+    grep -v '^ *+' conftest.err >conftest.er1
+    cat conftest.er1 >&5
+    mv -f conftest.er1 conftest.err
+  fi
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest$ac_exeext && {
+	 test "$cross_compiling" = yes ||
+	 $as_test_x conftest$ac_exeext
+       }; then :
+  ac_retval=0
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	ac_retval=1
+fi
+  # Delete the IPA/IPO (Inter Procedural Analysis/Optimization) information
+  # created by the PGI compiler (conftest_ipa8_conftest.oo), as it would
+  # interfere with the next link command; also delete a directory that is
+  # left behind by Apple's compiler.  We do this before executing the actions.
+  rm -rf conftest.dSYM conftest_ipa8_conftest.oo
+  eval $as_lineno_stack; test "x$as_lineno_stack" = x && { as_lineno=; unset as_lineno;}
+  return $ac_retval
+
+} # ac_fn_c_try_link
+
+# ac_fn_c_try_cpp LINENO
+# ----------------------
+# Try to preprocess conftest.$ac_ext, and return whether this succeeded.
+ac_fn_c_try_cpp ()
+{
+  as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
+  if { { ac_try="$ac_cpp conftest.$ac_ext"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
+$as_echo "$ac_try_echo"; } >&5
+  (eval "$ac_cpp conftest.$ac_ext") 2>conftest.err
+  ac_status=$?
+  if test -s conftest.err; then
+    grep -v '^ *+' conftest.err >conftest.er1
+    cat conftest.er1 >&5
+    mv -f conftest.er1 conftest.err
+  fi
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; } >/dev/null && {
+	 test -z "$ac_c_preproc_warn_flag$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       }; then :
+  ac_retval=0
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+    ac_retval=1
+fi
+  eval $as_lineno_stack; test "x$as_lineno_stack" = x && { as_lineno=; unset as_lineno;}
+  return $ac_retval
+
+} # ac_fn_c_try_cpp
+
+# ac_fn_c_try_run LINENO
+# ----------------------
+# Try to link conftest.$ac_ext, and return whether this succeeded. Assumes
+# that executables *can* be run.
+ac_fn_c_try_run ()
+{
+  as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
+  if { { ac_try="$ac_link"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
+$as_echo "$ac_try_echo"; } >&5
+  (eval "$ac_link") 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; } && { ac_try='./conftest$ac_exeext'
+  { { case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
+$as_echo "$ac_try_echo"; } >&5
+  (eval "$ac_try") 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }; }; then :
+  ac_retval=0
+else
+  $as_echo "$as_me: program exited with status $ac_status" >&5
+       $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+       ac_retval=$ac_status
+fi
+  rm -rf conftest.dSYM conftest_ipa8_conftest.oo
+  eval $as_lineno_stack; test "x$as_lineno_stack" = x && { as_lineno=; unset as_lineno;}
+  return $ac_retval
+
+} # ac_fn_c_try_run
+
+# ac_fn_c_check_header_compile LINENO HEADER VAR INCLUDES
+# -------------------------------------------------------
+# Tests whether HEADER exists and can be compiled using the include files in
+# INCLUDES, setting the cache variable VAR accordingly.
+ac_fn_c_check_header_compile ()
+{
+  as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $2" >&5
+$as_echo_n "checking for $2... " >&6; }
+if { as_var=$3; eval "test \"\${$as_var+set}\" = set"; }; then :
+  $as_echo_n "(cached) " >&6
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+$4
+#include <$2>
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  eval "$3=yes"
+else
+  eval "$3=no"
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+eval ac_res=\$$3
+	       { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
+$as_echo "$ac_res" >&6; }
+  eval $as_lineno_stack; test "x$as_lineno_stack" = x && { as_lineno=; unset as_lineno;}
+
+} # ac_fn_c_check_header_compile
+
+# ac_fn_c_check_func LINENO FUNC VAR
+# ----------------------------------
+# Tests whether FUNC exists, setting the cache variable VAR accordingly
+ac_fn_c_check_func ()
+{
+  as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $2" >&5
+$as_echo_n "checking for $2... " >&6; }
+if { as_var=$3; eval "test \"\${$as_var+set}\" = set"; }; then :
+  $as_echo_n "(cached) " >&6
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+/* Define $2 to an innocuous variant, in case <limits.h> declares $2.
+   For example, HP-UX 11i <limits.h> declares gettimeofday.  */
+#define $2 innocuous_$2
+
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char $2 (); below.
+    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+    <limits.h> exists even on freestanding compilers.  */
+
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+
+#undef $2
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char $2 ();
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined __stub_$2 || defined __stub___$2
+choke me
+#endif
+
+int
+main ()
+{
+return $2 ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  eval "$3=yes"
+else
+  eval "$3=no"
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+fi
+eval ac_res=\$$3
+	       { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
+$as_echo "$ac_res" >&6; }
+  eval $as_lineno_stack; test "x$as_lineno_stack" = x && { as_lineno=; unset as_lineno;}
+
+} # ac_fn_c_check_func
+
+# ac_fn_c_check_header_mongrel LINENO HEADER VAR INCLUDES
+# -------------------------------------------------------
+# Tests whether HEADER exists, giving a warning if it cannot be compiled using
+# the include files in INCLUDES and setting the cache variable VAR
+# accordingly.
+ac_fn_c_check_header_mongrel ()
+{
+  as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
+  if { as_var=$3; eval "test \"\${$as_var+set}\" = set"; }; then :
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $2" >&5
+$as_echo_n "checking for $2... " >&6; }
+if { as_var=$3; eval "test \"\${$as_var+set}\" = set"; }; then :
+  $as_echo_n "(cached) " >&6
+fi
+eval ac_res=\$$3
+	       { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
+$as_echo "$ac_res" >&6; }
+else
+  # Is the header compilable?
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking $2 usability" >&5
+$as_echo_n "checking $2 usability... " >&6; }
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+$4
+#include <$2>
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  ac_header_compiler=yes
+else
+  ac_header_compiler=no
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_header_compiler" >&5
+$as_echo "$ac_header_compiler" >&6; }
+
+# Is the header present?
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking $2 presence" >&5
+$as_echo_n "checking $2 presence... " >&6; }
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <$2>
+_ACEOF
+if ac_fn_c_try_cpp "$LINENO"; then :
+  ac_header_preproc=yes
+else
+  ac_header_preproc=no
+fi
+rm -f conftest.err conftest.$ac_ext
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_header_preproc" >&5
+$as_echo "$ac_header_preproc" >&6; }
+
+# So?  What about this header?
+case $ac_header_compiler:$ac_header_preproc:$ac_c_preproc_warn_flag in #((
+  yes:no: )
+    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: $2: accepted by the compiler, rejected by the preprocessor!" >&5
+$as_echo "$as_me: WARNING: $2: accepted by the compiler, rejected by the preprocessor!" >&2;}
+    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: $2: proceeding with the compiler's result" >&5
+$as_echo "$as_me: WARNING: $2: proceeding with the compiler's result" >&2;}
+    ;;
+  no:yes:* )
+    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: $2: present but cannot be compiled" >&5
+$as_echo "$as_me: WARNING: $2: present but cannot be compiled" >&2;}
+    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: $2:     check for missing prerequisite headers?" >&5
+$as_echo "$as_me: WARNING: $2:     check for missing prerequisite headers?" >&2;}
+    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: $2: see the Autoconf documentation" >&5
+$as_echo "$as_me: WARNING: $2: see the Autoconf documentation" >&2;}
+    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: $2:     section \"Present But Cannot Be Compiled\"" >&5
+$as_echo "$as_me: WARNING: $2:     section \"Present But Cannot Be Compiled\"" >&2;}
+    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: $2: proceeding with the compiler's result" >&5
+$as_echo "$as_me: WARNING: $2: proceeding with the compiler's result" >&2;}
+( cat <<\_ASBOX
+## ------------------------------------------ ##
+## Report this to http://live.gnome.org/Rygel ##
+## ------------------------------------------ ##
+_ASBOX
+     ) | sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
+esac
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $2" >&5
+$as_echo_n "checking for $2... " >&6; }
+if { as_var=$3; eval "test \"\${$as_var+set}\" = set"; }; then :
+  $as_echo_n "(cached) " >&6
+else
+  eval "$3=\$ac_header_compiler"
+fi
+eval ac_res=\$$3
+	       { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
+$as_echo "$ac_res" >&6; }
+fi
+  eval $as_lineno_stack; test "x$as_lineno_stack" = x && { as_lineno=; unset as_lineno;}
+
+} # ac_fn_c_check_header_mongrel
 cat >config.log <<_ACEOF
 This file contains any messages produced by compilers while
 running configure, to aid debugging if configure makes a mistake.
 
-It was created by rygel $as_me 0.4.2, which was
-generated by GNU Autoconf 2.63.  Invocation command line was
+It was created by rygel $as_me UNKNOWN-dirty, which was
+generated by GNU Autoconf 2.64.  Invocation command line was
 
   $ $0 $@
 
@@ -1905,8 +2207,8 @@ for as_dir in $PATH
 do
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
-  $as_echo "PATH: $as_dir"
-done
+    $as_echo "PATH: $as_dir"
+  done
 IFS=$as_save_IFS
 
 } >&5
@@ -1943,9 +2245,9 @@ do
       ac_arg=`$as_echo "$ac_arg" | sed "s/'/'\\\\\\\\''/g"` ;;
     esac
     case $ac_pass in
-    1) ac_configure_args0="$ac_configure_args0 '$ac_arg'" ;;
+    1) as_fn_append ac_configure_args0 " '$ac_arg'" ;;
     2)
-      ac_configure_args1="$ac_configure_args1 '$ac_arg'"
+      as_fn_append ac_configure_args1 " '$ac_arg'"
       if test $ac_must_keep_next = true; then
 	ac_must_keep_next=false # Got value, back to normal.
       else
@@ -1961,13 +2263,13 @@ do
 	  -* ) ac_must_keep_next=true ;;
 	esac
       fi
-      ac_configure_args="$ac_configure_args '$ac_arg'"
+      as_fn_append ac_configure_args " '$ac_arg'"
       ;;
     esac
   done
 done
-$as_unset ac_configure_args0 || test "${ac_configure_args0+set}" != set || { ac_configure_args0=; export ac_configure_args0; }
-$as_unset ac_configure_args1 || test "${ac_configure_args1+set}" != set || { ac_configure_args1=; export ac_configure_args1; }
+{ ac_configure_args0=; unset ac_configure_args0;}
+{ ac_configure_args1=; unset ac_configure_args1;}
 
 # When interrupted or exit'd, cleanup temporary files, and complete
 # config.log.  We remove comments because anyway the quotes in there
@@ -1992,13 +2294,13 @@ _ASBOX
     case $ac_val in #(
     *${as_nl}*)
       case $ac_var in #(
-      *_cv_*) { $as_echo "$as_me:$LINENO: WARNING: cache variable $ac_var contains a newline" >&5
+      *_cv_*) { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: cache variable $ac_var contains a newline" >&5
 $as_echo "$as_me: WARNING: cache variable $ac_var contains a newline" >&2;} ;;
       esac
       case $ac_var in #(
       _ | IFS | as_nl) ;; #(
       BASH_ARGV | BASH_SOURCE) eval $ac_var= ;; #(
-      *) $as_unset $ac_var ;;
+      *) { eval $ac_var=; unset $ac_var;} ;;
       esac ;;
     esac
   done
@@ -2070,13 +2372,15 @@ _ASBOX
     exit $exit_status
 ' 0
 for ac_signal in 1 2 13 15; do
-  trap 'ac_signal='$ac_signal'; { (exit 1); exit 1; }' $ac_signal
+  trap 'ac_signal='$ac_signal'; as_fn_exit 1' $ac_signal
 done
 ac_signal=0
 
 # confdefs.h avoids OS command line length limits that DEFS can exceed.
 rm -f -r conftest* confdefs.h
 
+$as_echo "/* confdefs.h */" > confdefs.h
+
 # Predefined preprocessor variables.
 
 cat >>confdefs.h <<_ACEOF
@@ -2103,6 +2407,10 @@ cat >>confdefs.h <<_ACEOF
 #define PACKAGE_BUGREPORT "$PACKAGE_BUGREPORT"
 _ACEOF
 
+cat >>confdefs.h <<_ACEOF
+#define PACKAGE_URL "$PACKAGE_URL"
+_ACEOF
+
 
 # Let the site file select an alternate cache file if it wants to.
 # Prefer an explicitly selected file to automatically selected ones.
@@ -2121,7 +2429,7 @@ for ac_site_file in "$ac_site_file1" "$a
 do
   test "x$ac_site_file" = xNONE && continue
   if test -r "$ac_site_file"; then
-    { $as_echo "$as_me:$LINENO: loading site script $ac_site_file" >&5
+    { $as_echo "$as_me:${as_lineno-$LINENO}: loading site script $ac_site_file" >&5
 $as_echo "$as_me: loading site script $ac_site_file" >&6;}
     sed 's/^/| /' "$ac_site_file" >&5
     . "$ac_site_file"
@@ -2132,7 +2440,7 @@ if test -r "$cache_file"; then
   # Some versions of bash will fail to source /dev/null (special
   # files actually), so we avoid doing that.
   if test -f "$cache_file"; then
-    { $as_echo "$as_me:$LINENO: loading cache $cache_file" >&5
+    { $as_echo "$as_me:${as_lineno-$LINENO}: loading cache $cache_file" >&5
 $as_echo "$as_me: loading cache $cache_file" >&6;}
     case $cache_file in
       [\\/]* | ?:[\\/]* ) . "$cache_file";;
@@ -2140,7 +2448,7 @@ $as_echo "$as_me: loading cache $cache_f
     esac
   fi
 else
-  { $as_echo "$as_me:$LINENO: creating cache $cache_file" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: creating cache $cache_file" >&5
 $as_echo "$as_me: creating cache $cache_file" >&6;}
   >$cache_file
 fi
@@ -2155,11 +2463,11 @@ for ac_var in $ac_precious_vars; do
   eval ac_new_val=\$ac_env_${ac_var}_value
   case $ac_old_set,$ac_new_set in
     set,)
-      { $as_echo "$as_me:$LINENO: error: \`$ac_var' was set to \`$ac_old_val' in the previous run" >&5
+      { $as_echo "$as_me:${as_lineno-$LINENO}: error: \`$ac_var' was set to \`$ac_old_val' in the previous run" >&5
 $as_echo "$as_me: error: \`$ac_var' was set to \`$ac_old_val' in the previous run" >&2;}
       ac_cache_corrupted=: ;;
     ,set)
-      { $as_echo "$as_me:$LINENO: error: \`$ac_var' was not set in the previous run" >&5
+      { $as_echo "$as_me:${as_lineno-$LINENO}: error: \`$ac_var' was not set in the previous run" >&5
 $as_echo "$as_me: error: \`$ac_var' was not set in the previous run" >&2;}
       ac_cache_corrupted=: ;;
     ,);;
@@ -2169,17 +2477,17 @@ $as_echo "$as_me: error: \`$ac_var' was
 	ac_old_val_w=`echo x $ac_old_val`
 	ac_new_val_w=`echo x $ac_new_val`
 	if test "$ac_old_val_w" != "$ac_new_val_w"; then
-	  { $as_echo "$as_me:$LINENO: error: \`$ac_var' has changed since the previous run:" >&5
+	  { $as_echo "$as_me:${as_lineno-$LINENO}: error: \`$ac_var' has changed since the previous run:" >&5
 $as_echo "$as_me: error: \`$ac_var' has changed since the previous run:" >&2;}
 	  ac_cache_corrupted=:
 	else
-	  { $as_echo "$as_me:$LINENO: warning: ignoring whitespace changes in \`$ac_var' since the previous run:" >&5
+	  { $as_echo "$as_me:${as_lineno-$LINENO}: warning: ignoring whitespace changes in \`$ac_var' since the previous run:" >&5
 $as_echo "$as_me: warning: ignoring whitespace changes in \`$ac_var' since the previous run:" >&2;}
 	  eval $ac_var=\$ac_old_val
 	fi
-	{ $as_echo "$as_me:$LINENO:   former value:  \`$ac_old_val'" >&5
+	{ $as_echo "$as_me:${as_lineno-$LINENO}:   former value:  \`$ac_old_val'" >&5
 $as_echo "$as_me:   former value:  \`$ac_old_val'" >&2;}
-	{ $as_echo "$as_me:$LINENO:   current value: \`$ac_new_val'" >&5
+	{ $as_echo "$as_me:${as_lineno-$LINENO}:   current value: \`$ac_new_val'" >&5
 $as_echo "$as_me:   current value: \`$ac_new_val'" >&2;}
       fi;;
   esac
@@ -2191,43 +2499,20 @@ $as_echo "$as_me:   current value: \`$ac
     esac
     case " $ac_configure_args " in
       *" '$ac_arg' "*) ;; # Avoid dups.  Use of quotes ensures accuracy.
-      *) ac_configure_args="$ac_configure_args '$ac_arg'" ;;
+      *) as_fn_append ac_configure_args " '$ac_arg'" ;;
     esac
   fi
 done
 if $ac_cache_corrupted; then
-  { $as_echo "$as_me:$LINENO: error: in \`$ac_pwd':" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
 $as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
-  { $as_echo "$as_me:$LINENO: error: changes in the environment can compromise the build" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: error: changes in the environment can compromise the build" >&5
 $as_echo "$as_me: error: changes in the environment can compromise the build" >&2;}
-  { { $as_echo "$as_me:$LINENO: error: run \`make distclean' and/or \`rm $cache_file' and start over" >&5
-$as_echo "$as_me: error: run \`make distclean' and/or \`rm $cache_file' and start over" >&2;}
-   { (exit 1); exit 1; }; }
+  as_fn_error "run \`make distclean' and/or \`rm $cache_file' and start over" "$LINENO" 5
 fi
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
+## -------------------- ##
+## Main body of script. ##
+## -------------------- ##
 
 ac_ext=c
 ac_cpp='$CPP $CPPFLAGS'
@@ -2238,24 +2523,16 @@ ac_compiler_gnu=$ac_cv_c_compiler_gnu
 
 ac_aux_dir=
 for ac_dir in build-aux "$srcdir"/build-aux; do
-  if test -f "$ac_dir/install-sh"; then
-    ac_aux_dir=$ac_dir
-    ac_install_sh="$ac_aux_dir/install-sh -c"
-    break
-  elif test -f "$ac_dir/install.sh"; then
-    ac_aux_dir=$ac_dir
-    ac_install_sh="$ac_aux_dir/install.sh -c"
-    break
-  elif test -f "$ac_dir/shtool"; then
-    ac_aux_dir=$ac_dir
-    ac_install_sh="$ac_aux_dir/shtool install -c"
-    break
-  fi
+  for ac_t in install-sh install.sh shtool; do
+    if test -f "$ac_dir/$ac_t"; then
+      ac_aux_dir=$ac_dir
+      ac_install_sh="$ac_aux_dir/$ac_t -c"
+      break 2
+    fi
+  done
 done
 if test -z "$ac_aux_dir"; then
-  { { $as_echo "$as_me:$LINENO: error: cannot find install-sh or install.sh in build-aux \"$srcdir\"/build-aux" >&5
-$as_echo "$as_me: error: cannot find install-sh or install.sh in build-aux \"$srcdir\"/build-aux" >&2;}
-   { (exit 1); exit 1; }; }
+  as_fn_error "cannot find install-sh, install.sh, or shtool in build-aux \"$srcdir\"/build-aux" "$LINENO" 5
 fi
 
 # These three variables are undocumented and unsupported,
@@ -2285,10 +2562,10 @@ am__api_version='1.11'
 # OS/2's system install, which has a completely different semantic
 # ./install, which can be erroneously created by make from ./install.sh.
 # Reject install programs that cannot install multiple files.
-{ $as_echo "$as_me:$LINENO: checking for a BSD-compatible install" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for a BSD-compatible install" >&5
 $as_echo_n "checking for a BSD-compatible install... " >&6; }
 if test -z "$INSTALL"; then
-if test "${ac_cv_path_install+set}" = set; then
+if test "${ac_cv_path_install+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
@@ -2296,11 +2573,11 @@ for as_dir in $PATH
 do
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
-  # Account for people who put trailing slashes in PATH elements.
-case $as_dir/ in
-  ./ | .// | /cC/* | \
+    # Account for people who put trailing slashes in PATH elements.
+case $as_dir/ in #((
+  ./ | .// | /[cC]/* | \
   /etc/* | /usr/sbin/* | /usr/etc/* | /sbin/* | /usr/afsws/bin/* | \
-  ?:\\/os2\\/install\\/* | ?:\\/OS2\\/INSTALL\\/* | \
+  ?:[\\/]os2[\\/]install[\\/]* | ?:[\\/]OS2[\\/]INSTALL[\\/]* | \
   /usr/ucb/* ) ;;
   *)
     # OSF1 and SCO ODT 3.0 have their own names for install.
@@ -2337,7 +2614,7 @@ case $as_dir/ in
     ;;
 esac
 
-done
+  done
 IFS=$as_save_IFS
 
 rm -rf conftest.one conftest.two conftest.dir
@@ -2353,7 +2630,7 @@ fi
     INSTALL=$ac_install_sh
   fi
 fi
-{ $as_echo "$as_me:$LINENO: result: $INSTALL" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $INSTALL" >&5
 $as_echo "$INSTALL" >&6; }
 
 # Use test -z because SunOS4 sh mishandles braces in ${var-val}.
@@ -2364,7 +2641,7 @@ test -z "$INSTALL_SCRIPT" && INSTALL_SCR
 
 test -z "$INSTALL_DATA" && INSTALL_DATA='${INSTALL} -m 644'
 
-{ $as_echo "$as_me:$LINENO: checking whether build environment is sane" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether build environment is sane" >&5
 $as_echo_n "checking whether build environment is sane... " >&6; }
 # Just in case
 sleep 1
@@ -2375,15 +2652,11 @@ am_lf='
 '
 case `pwd` in
   *[\\\"\#\$\&\'\`$am_lf]*)
-    { { $as_echo "$as_me:$LINENO: error: unsafe absolute working directory name" >&5
-$as_echo "$as_me: error: unsafe absolute working directory name" >&2;}
-   { (exit 1); exit 1; }; };;
+    as_fn_error "unsafe absolute working directory name" "$LINENO" 5;;
 esac
 case $srcdir in
   *[\\\"\#\$\&\'\`$am_lf\ \	]*)
-    { { $as_echo "$as_me:$LINENO: error: unsafe srcdir value: \`$srcdir'" >&5
-$as_echo "$as_me: error: unsafe srcdir value: \`$srcdir'" >&2;}
-   { (exit 1); exit 1; }; };;
+    as_fn_error "unsafe srcdir value: \`$srcdir'" "$LINENO" 5;;
 esac
 
 # Do `set' in a subshell so we don't clobber the current shell's
@@ -2405,11 +2678,8 @@ if (
       # if, for instance, CONFIG_SHELL is bash and it inherits a
       # broken ls alias from the environment.  This has actually
       # happened.  Such a system could not be considered "sane".
-      { { $as_echo "$as_me:$LINENO: error: ls -t appears to fail.  Make sure there is not a broken
-alias in your environment" >&5
-$as_echo "$as_me: error: ls -t appears to fail.  Make sure there is not a broken
-alias in your environment" >&2;}
-   { (exit 1); exit 1; }; }
+      as_fn_error "ls -t appears to fail.  Make sure there is not a broken
+alias in your environment" "$LINENO" 5
    fi
 
    test "$2" = conftest.file
@@ -2418,13 +2688,10 @@ then
    # Ok.
    :
 else
-   { { $as_echo "$as_me:$LINENO: error: newly created file is older than distributed files!
-Check your system clock" >&5
-$as_echo "$as_me: error: newly created file is older than distributed files!
-Check your system clock" >&2;}
-   { (exit 1); exit 1; }; }
+   as_fn_error "newly created file is older than distributed files!
+Check your system clock" "$LINENO" 5
 fi
-{ $as_echo "$as_me:$LINENO: result: yes" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
 $as_echo "yes" >&6; }
 test "$program_prefix" != NONE &&
   program_transform_name="s&^&$program_prefix&;$program_transform_name"
@@ -2452,7 +2719,7 @@ if eval "$MISSING --run true"; then
   am_missing_run="$MISSING --run "
 else
   am_missing_run=
-  { $as_echo "$as_me:$LINENO: WARNING: \`missing' script is too old or missing" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: \`missing' script is too old or missing" >&5
 $as_echo "$as_me: WARNING: \`missing' script is too old or missing" >&2;}
 fi
 
@@ -2473,9 +2740,9 @@ if test "$cross_compiling" != no; then
   if test -n "$ac_tool_prefix"; then
   # Extract the first word of "${ac_tool_prefix}strip", so it can be a program name with args.
 set dummy ${ac_tool_prefix}strip; ac_word=$2
-{ $as_echo "$as_me:$LINENO: checking for $ac_word" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
 $as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_prog_STRIP+set}" = set; then
+if test "${ac_cv_prog_STRIP+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   if test -n "$STRIP"; then
@@ -2486,24 +2753,24 @@ for as_dir in $PATH
 do
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
-  for ac_exec_ext in '' $ac_executable_extensions; do
+    for ac_exec_ext in '' $ac_executable_extensions; do
   if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
     ac_cv_prog_STRIP="${ac_tool_prefix}strip"
-    $as_echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
   fi
 done
-done
+  done
 IFS=$as_save_IFS
 
 fi
 fi
 STRIP=$ac_cv_prog_STRIP
 if test -n "$STRIP"; then
-  { $as_echo "$as_me:$LINENO: result: $STRIP" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $STRIP" >&5
 $as_echo "$STRIP" >&6; }
 else
-  { $as_echo "$as_me:$LINENO: result: no" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
 $as_echo "no" >&6; }
 fi
 
@@ -2513,9 +2780,9 @@ if test -z "$ac_cv_prog_STRIP"; then
   ac_ct_STRIP=$STRIP
   # Extract the first word of "strip", so it can be a program name with args.
 set dummy strip; ac_word=$2
-{ $as_echo "$as_me:$LINENO: checking for $ac_word" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
 $as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_prog_ac_ct_STRIP+set}" = set; then
+if test "${ac_cv_prog_ac_ct_STRIP+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   if test -n "$ac_ct_STRIP"; then
@@ -2526,24 +2793,24 @@ for as_dir in $PATH
 do
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
-  for ac_exec_ext in '' $ac_executable_extensions; do
+    for ac_exec_ext in '' $ac_executable_extensions; do
   if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
     ac_cv_prog_ac_ct_STRIP="strip"
-    $as_echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
   fi
 done
-done
+  done
 IFS=$as_save_IFS
 
 fi
 fi
 ac_ct_STRIP=$ac_cv_prog_ac_ct_STRIP
 if test -n "$ac_ct_STRIP"; then
-  { $as_echo "$as_me:$LINENO: result: $ac_ct_STRIP" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_STRIP" >&5
 $as_echo "$ac_ct_STRIP" >&6; }
 else
-  { $as_echo "$as_me:$LINENO: result: no" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
 $as_echo "no" >&6; }
 fi
 
@@ -2552,7 +2819,7 @@ fi
   else
     case $cross_compiling:$ac_tool_warned in
 yes:)
-{ $as_echo "$as_me:$LINENO: WARNING: using cross tools not prefixed with host triplet" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
 $as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
 ac_tool_warned=yes ;;
 esac
@@ -2565,10 +2832,10 @@ fi
 fi
 INSTALL_STRIP_PROGRAM="\$(install_sh) -c -s"
 
-{ $as_echo "$as_me:$LINENO: checking for a thread-safe mkdir -p" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for a thread-safe mkdir -p" >&5
 $as_echo_n "checking for a thread-safe mkdir -p... " >&6; }
 if test -z "$MKDIR_P"; then
-  if test "${ac_cv_path_mkdir+set}" = set; then
+  if test "${ac_cv_path_mkdir+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
@@ -2576,7 +2843,7 @@ for as_dir in $PATH$PATH_SEPARATOR/opt/s
 do
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
-  for ac_prog in mkdir gmkdir; do
+    for ac_prog in mkdir gmkdir; do
 	 for ac_exec_ext in '' $ac_executable_extensions; do
 	   { test -f "$as_dir/$ac_prog$ac_exec_ext" && $as_test_x "$as_dir/$ac_prog$ac_exec_ext"; } || continue
 	   case `"$as_dir/$ac_prog$ac_exec_ext" --version 2>&1` in #(
@@ -2588,7 +2855,7 @@ do
 	   esac
 	 done
        done
-done
+  done
 IFS=$as_save_IFS
 
 fi
@@ -2604,7 +2871,7 @@ fi
     MKDIR_P="$ac_install_sh -d"
   fi
 fi
-{ $as_echo "$as_me:$LINENO: result: $MKDIR_P" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $MKDIR_P" >&5
 $as_echo "$MKDIR_P" >&6; }
 
 mkdir_p="$MKDIR_P"
@@ -2617,9 +2884,9 @@ for ac_prog in gawk mawk nawk awk
 do
   # Extract the first word of "$ac_prog", so it can be a program name with args.
 set dummy $ac_prog; ac_word=$2
-{ $as_echo "$as_me:$LINENO: checking for $ac_word" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
 $as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_prog_AWK+set}" = set; then
+if test "${ac_cv_prog_AWK+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   if test -n "$AWK"; then
@@ -2630,24 +2897,24 @@ for as_dir in $PATH
 do
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
-  for ac_exec_ext in '' $ac_executable_extensions; do
+    for ac_exec_ext in '' $ac_executable_extensions; do
   if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
     ac_cv_prog_AWK="$ac_prog"
-    $as_echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
   fi
 done
-done
+  done
 IFS=$as_save_IFS
 
 fi
 fi
 AWK=$ac_cv_prog_AWK
 if test -n "$AWK"; then
-  { $as_echo "$as_me:$LINENO: result: $AWK" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $AWK" >&5
 $as_echo "$AWK" >&6; }
 else
-  { $as_echo "$as_me:$LINENO: result: no" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
 $as_echo "no" >&6; }
 fi
 
@@ -2655,11 +2922,11 @@ fi
   test -n "$AWK" && break
 done
 
-{ $as_echo "$as_me:$LINENO: checking whether ${MAKE-make} sets \$(MAKE)" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether ${MAKE-make} sets \$(MAKE)" >&5
 $as_echo_n "checking whether ${MAKE-make} sets \$(MAKE)... " >&6; }
 set x ${MAKE-make}
 ac_make=`$as_echo "$2" | sed 's/+/p/g; s/[^a-zA-Z0-9_]/_/g'`
-if { as_var=ac_cv_prog_make_${ac_make}_set; eval "test \"\${$as_var+set}\" = set"; }; then
+if { as_var=ac_cv_prog_make_${ac_make}_set; eval "test \"\${$as_var+set}\" = set"; }; then :
   $as_echo_n "(cached) " >&6
 else
   cat >conftest.make <<\_ACEOF
@@ -2677,11 +2944,11 @@ esac
 rm -f conftest.make
 fi
 if eval test \$ac_cv_prog_make_${ac_make}_set = yes; then
-  { $as_echo "$as_me:$LINENO: result: yes" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
 $as_echo "yes" >&6; }
   SET_MAKE=
 else
-  { $as_echo "$as_me:$LINENO: result: no" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
 $as_echo "no" >&6; }
   SET_MAKE="MAKE=${MAKE-make}"
 fi
@@ -2701,9 +2968,7 @@ if test "`cd $srcdir && pwd`" != "`pwd`"
   am__isrc=' -I$(srcdir)'
   # test to see if srcdir already configured
   if test -f $srcdir/config.status; then
-    { { $as_echo "$as_me:$LINENO: error: source directory already configured; run \"make distclean\" there first" >&5
-$as_echo "$as_me: error: source directory already configured; run \"make distclean\" there first" >&2;}
-   { (exit 1); exit 1; }; }
+    as_fn_error "source directory already configured; run \"make distclean\" there first" "$LINENO" 5
   fi
 fi
 
@@ -2719,7 +2984,7 @@ fi
 
 # Define the identity of the package.
  PACKAGE='rygel'
- VERSION='0.4.2'
+ VERSION='UNKNOWN-dirty'
 
 
 cat >>confdefs.h <<_ACEOF
@@ -2764,16 +3029,16 @@ ac_config_headers="$ac_config_headers co
 
 
 
-{ $as_echo "$as_me:$LINENO: checking whether to enable maintainer-specific portions of Makefiles" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether to enable maintainer-specific portions of Makefiles" >&5
 $as_echo_n "checking whether to enable maintainer-specific portions of Makefiles... " >&6; }
     # Check whether --enable-maintainer-mode was given.
-if test "${enable_maintainer_mode+set}" = set; then
+if test "${enable_maintainer_mode+set}" = set; then :
   enableval=$enable_maintainer_mode; USE_MAINTAINER_MODE=$enableval
 else
   USE_MAINTAINER_MODE=no
 fi
 
-  { $as_echo "$as_me:$LINENO: result: $USE_MAINTAINER_MODE" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $USE_MAINTAINER_MODE" >&5
 $as_echo "$USE_MAINTAINER_MODE" >&6; }
    if test $USE_MAINTAINER_MODE = yes; then
   MAINTAINER_MODE_TRUE=
@@ -2789,7 +3054,7 @@ fi
 
 # Disable generation of static libraries
 # Check whether --enable-static was given.
-if test "${enable_static+set}" = set; then
+if test "${enable_static+set}" = set; then :
   enableval=$enable_static; p=${PACKAGE-default}
     case $enableval in
     yes) enable_static=yes ;;
@@ -2832,7 +3097,7 @@ am__doit:
 .PHONY: am__doit
 END
 # If we don't find an include directive, just comment out the code.
-{ $as_echo "$as_me:$LINENO: checking for style of include used by $am_make" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for style of include used by $am_make" >&5
 $as_echo_n "checking for style of include used by $am_make... " >&6; }
 am__include="#"
 am__quote=
@@ -2860,12 +3125,12 @@ if test "$am__include" = "#"; then
 fi
 
 
-{ $as_echo "$as_me:$LINENO: result: $_am_result" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $_am_result" >&5
 $as_echo "$_am_result" >&6; }
 rm -f confinc confmf
 
 # Check whether --enable-dependency-tracking was given.
-if test "${enable_dependency_tracking+set}" = set; then
+if test "${enable_dependency_tracking+set}" = set; then :
   enableval=$enable_dependency_tracking;
 fi
 
@@ -2890,9 +3155,9 @@ ac_compiler_gnu=$ac_cv_c_compiler_gnu
 if test -n "$ac_tool_prefix"; then
   # Extract the first word of "${ac_tool_prefix}gcc", so it can be a program name with args.
 set dummy ${ac_tool_prefix}gcc; ac_word=$2
-{ $as_echo "$as_me:$LINENO: checking for $ac_word" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
 $as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_prog_CC+set}" = set; then
+if test "${ac_cv_prog_CC+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   if test -n "$CC"; then
@@ -2903,24 +3168,24 @@ for as_dir in $PATH
 do
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
-  for ac_exec_ext in '' $ac_executable_extensions; do
+    for ac_exec_ext in '' $ac_executable_extensions; do
   if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
     ac_cv_prog_CC="${ac_tool_prefix}gcc"
-    $as_echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
   fi
 done
-done
+  done
 IFS=$as_save_IFS
 
 fi
 fi
 CC=$ac_cv_prog_CC
 if test -n "$CC"; then
-  { $as_echo "$as_me:$LINENO: result: $CC" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $CC" >&5
 $as_echo "$CC" >&6; }
 else
-  { $as_echo "$as_me:$LINENO: result: no" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
 $as_echo "no" >&6; }
 fi
 
@@ -2930,9 +3195,9 @@ if test -z "$ac_cv_prog_CC"; then
   ac_ct_CC=$CC
   # Extract the first word of "gcc", so it can be a program name with args.
 set dummy gcc; ac_word=$2
-{ $as_echo "$as_me:$LINENO: checking for $ac_word" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
 $as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_prog_ac_ct_CC+set}" = set; then
+if test "${ac_cv_prog_ac_ct_CC+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   if test -n "$ac_ct_CC"; then
@@ -2943,24 +3208,24 @@ for as_dir in $PATH
 do
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
-  for ac_exec_ext in '' $ac_executable_extensions; do
+    for ac_exec_ext in '' $ac_executable_extensions; do
   if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
     ac_cv_prog_ac_ct_CC="gcc"
-    $as_echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
   fi
 done
-done
+  done
 IFS=$as_save_IFS
 
 fi
 fi
 ac_ct_CC=$ac_cv_prog_ac_ct_CC
 if test -n "$ac_ct_CC"; then
-  { $as_echo "$as_me:$LINENO: result: $ac_ct_CC" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_CC" >&5
 $as_echo "$ac_ct_CC" >&6; }
 else
-  { $as_echo "$as_me:$LINENO: result: no" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
 $as_echo "no" >&6; }
 fi
 
@@ -2969,7 +3234,7 @@ fi
   else
     case $cross_compiling:$ac_tool_warned in
 yes:)
-{ $as_echo "$as_me:$LINENO: WARNING: using cross tools not prefixed with host triplet" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
 $as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
 ac_tool_warned=yes ;;
 esac
@@ -2983,9 +3248,9 @@ if test -z "$CC"; then
           if test -n "$ac_tool_prefix"; then
     # Extract the first word of "${ac_tool_prefix}cc", so it can be a program name with args.
 set dummy ${ac_tool_prefix}cc; ac_word=$2
-{ $as_echo "$as_me:$LINENO: checking for $ac_word" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
 $as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_prog_CC+set}" = set; then
+if test "${ac_cv_prog_CC+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   if test -n "$CC"; then
@@ -2996,24 +3261,24 @@ for as_dir in $PATH
 do
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
-  for ac_exec_ext in '' $ac_executable_extensions; do
+    for ac_exec_ext in '' $ac_executable_extensions; do
   if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
     ac_cv_prog_CC="${ac_tool_prefix}cc"
-    $as_echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
   fi
 done
-done
+  done
 IFS=$as_save_IFS
 
 fi
 fi
 CC=$ac_cv_prog_CC
 if test -n "$CC"; then
-  { $as_echo "$as_me:$LINENO: result: $CC" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $CC" >&5
 $as_echo "$CC" >&6; }
 else
-  { $as_echo "$as_me:$LINENO: result: no" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
 $as_echo "no" >&6; }
 fi
 
@@ -3023,9 +3288,9 @@ fi
 if test -z "$CC"; then
   # Extract the first word of "cc", so it can be a program name with args.
 set dummy cc; ac_word=$2
-{ $as_echo "$as_me:$LINENO: checking for $ac_word" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
 $as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_prog_CC+set}" = set; then
+if test "${ac_cv_prog_CC+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   if test -n "$CC"; then
@@ -3037,18 +3302,18 @@ for as_dir in $PATH
 do
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
-  for ac_exec_ext in '' $ac_executable_extensions; do
+    for ac_exec_ext in '' $ac_executable_extensions; do
   if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
     if test "$as_dir/$ac_word$ac_exec_ext" = "/usr/ucb/cc"; then
        ac_prog_rejected=yes
        continue
      fi
     ac_cv_prog_CC="cc"
-    $as_echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
   fi
 done
-done
+  done
 IFS=$as_save_IFS
 
 if test $ac_prog_rejected = yes; then
@@ -3067,10 +3332,10 @@ fi
 fi
 CC=$ac_cv_prog_CC
 if test -n "$CC"; then
-  { $as_echo "$as_me:$LINENO: result: $CC" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $CC" >&5
 $as_echo "$CC" >&6; }
 else
-  { $as_echo "$as_me:$LINENO: result: no" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
 $as_echo "no" >&6; }
 fi
 
@@ -3082,9 +3347,9 @@ if test -z "$CC"; then
   do
     # Extract the first word of "$ac_tool_prefix$ac_prog", so it can be a program name with args.
 set dummy $ac_tool_prefix$ac_prog; ac_word=$2
-{ $as_echo "$as_me:$LINENO: checking for $ac_word" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
 $as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_prog_CC+set}" = set; then
+if test "${ac_cv_prog_CC+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   if test -n "$CC"; then
@@ -3095,24 +3360,24 @@ for as_dir in $PATH
 do
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
-  for ac_exec_ext in '' $ac_executable_extensions; do
+    for ac_exec_ext in '' $ac_executable_extensions; do
   if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
     ac_cv_prog_CC="$ac_tool_prefix$ac_prog"
-    $as_echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
   fi
 done
-done
+  done
 IFS=$as_save_IFS
 
 fi
 fi
 CC=$ac_cv_prog_CC
 if test -n "$CC"; then
-  { $as_echo "$as_me:$LINENO: result: $CC" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $CC" >&5
 $as_echo "$CC" >&6; }
 else
-  { $as_echo "$as_me:$LINENO: result: no" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
 $as_echo "no" >&6; }
 fi
 
@@ -3126,9 +3391,9 @@ if test -z "$CC"; then
 do
   # Extract the first word of "$ac_prog", so it can be a program name with args.
 set dummy $ac_prog; ac_word=$2
-{ $as_echo "$as_me:$LINENO: checking for $ac_word" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
 $as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_prog_ac_ct_CC+set}" = set; then
+if test "${ac_cv_prog_ac_ct_CC+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   if test -n "$ac_ct_CC"; then
@@ -3139,24 +3404,24 @@ for as_dir in $PATH
 do
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
-  for ac_exec_ext in '' $ac_executable_extensions; do
+    for ac_exec_ext in '' $ac_executable_extensions; do
   if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
     ac_cv_prog_ac_ct_CC="$ac_prog"
-    $as_echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
   fi
 done
-done
+  done
 IFS=$as_save_IFS
 
 fi
 fi
 ac_ct_CC=$ac_cv_prog_ac_ct_CC
 if test -n "$ac_ct_CC"; then
-  { $as_echo "$as_me:$LINENO: result: $ac_ct_CC" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_CC" >&5
 $as_echo "$ac_ct_CC" >&6; }
 else
-  { $as_echo "$as_me:$LINENO: result: no" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
 $as_echo "no" >&6; }
 fi
 
@@ -3169,7 +3434,7 @@ done
   else
     case $cross_compiling:$ac_tool_warned in
 yes:)
-{ $as_echo "$as_me:$LINENO: WARNING: using cross tools not prefixed with host triplet" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
 $as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
 ac_tool_warned=yes ;;
 esac
@@ -3180,73 +3445,55 @@ fi
 fi
 
 
-test -z "$CC" && { { $as_echo "$as_me:$LINENO: error: in \`$ac_pwd':" >&5
+test -z "$CC" && { { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
 $as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
-{ { $as_echo "$as_me:$LINENO: error: no acceptable C compiler found in \$PATH
-See \`config.log' for more details." >&5
-$as_echo "$as_me: error: no acceptable C compiler found in \$PATH
-See \`config.log' for more details." >&2;}
-   { (exit 1); exit 1; }; }; }
+as_fn_error "no acceptable C compiler found in \$PATH
+See \`config.log' for more details." "$LINENO" 5; }
 
 # Provide some information about the compiler.
-$as_echo "$as_me:$LINENO: checking for C compiler version" >&5
+$as_echo "$as_me:${as_lineno-$LINENO}: checking for C compiler version" >&5
 set X $ac_compile
 ac_compiler=$2
-{ (ac_try="$ac_compiler --version >&5"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_compiler --version >&5") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }
-{ (ac_try="$ac_compiler -v >&5"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_compiler -v >&5") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }
-{ (ac_try="$ac_compiler -V >&5"
+for ac_option in --version -v -V -qversion; do
+  { { ac_try="$ac_compiler $ac_option >&5"
 case "(($ac_try" in
   *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
   *) ac_try_echo=$ac_try;;
 esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_compiler -V >&5") 2>&5
+eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
+$as_echo "$ac_try_echo"; } >&5
+  (eval "$ac_compiler $ac_option >&5") 2>conftest.err
   ac_status=$?
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }
+  if test -s conftest.err; then
+    sed '10a\
+... rest of stderr output deleted ...
+         10q' conftest.err >conftest.er1
+    cat conftest.er1 >&5
+    rm -f conftest.er1 conftest.err
+  fi
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }
+done
 
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
-
+#include <stdio.h>
 int
 main ()
 {
+FILE *f = fopen ("conftest.out", "w");
+ return ferror (f) || fclose (f) != 0;
 
   ;
   return 0;
 }
 _ACEOF
 ac_clean_files_save=$ac_clean_files
-ac_clean_files="$ac_clean_files a.out a.out.dSYM a.exe b.out"
+ac_clean_files="$ac_clean_files a.out a.out.dSYM a.exe b.out conftest.out"
 # Try to create an executable without -o first, disregard a.out.
 # It will help us diagnose broken compilers, and finding out an intuition
 # of exeext.
-{ $as_echo "$as_me:$LINENO: checking for C compiler default output file name" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for C compiler default output file name" >&5
 $as_echo_n "checking for C compiler default output file name... " >&6; }
 ac_link_default=`$as_echo "$ac_link" | sed 's/ -o *conftest[^ ]*//'`
 
@@ -3263,17 +3510,17 @@ do
 done
 rm -f $ac_rmfiles
 
-if { (ac_try="$ac_link_default"
+if { { ac_try="$ac_link_default"
 case "(($ac_try" in
   *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
   *) ac_try_echo=$ac_try;;
 esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
+eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
+$as_echo "$ac_try_echo"; } >&5
   (eval "$ac_link_default") 2>&5
   ac_status=$?
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; then
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }; then :
   # Autoconf-2.13 could set the ac_cv_exeext variable to `no'.
 # So ignore a value of `no', otherwise this would lead to `EXEEXT = no'
 # in a Makefile.  We should not override ac_cv_exeext if it was cached,
@@ -3290,7 +3537,7 @@ do
 	# certainly right.
 	break;;
     *.* )
-        if test "${ac_cv_exeext+set}" = set && test "$ac_cv_exeext" != no;
+	if test "${ac_cv_exeext+set}" = set && test "$ac_cv_exeext" != no;
 	then :; else
 	   ac_cv_exeext=`expr "$ac_file" : '[^.]*\(\..*\)'`
 	fi
@@ -3309,84 +3556,75 @@ test "$ac_cv_exeext" = no && ac_cv_exeex
 else
   ac_file=''
 fi
-
-{ $as_echo "$as_me:$LINENO: result: $ac_file" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_file" >&5
 $as_echo "$ac_file" >&6; }
-if test -z "$ac_file"; then
+if test -z "$ac_file"; then :
   $as_echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
-{ { $as_echo "$as_me:$LINENO: error: in \`$ac_pwd':" >&5
+{ { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
 $as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
-{ { $as_echo "$as_me:$LINENO: error: C compiler cannot create executables
-See \`config.log' for more details." >&5
-$as_echo "$as_me: error: C compiler cannot create executables
-See \`config.log' for more details." >&2;}
-   { (exit 77); exit 77; }; }; }
+{ as_fn_set_status 77
+as_fn_error "C compiler cannot create executables
+See \`config.log' for more details." "$LINENO" 5; }; }
 fi
-
 ac_exeext=$ac_cv_exeext
 
 # Check that the compiler produces executables we can run.  If not, either
 # the compiler is broken, or we cross compile.
-{ $as_echo "$as_me:$LINENO: checking whether the C compiler works" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the C compiler works" >&5
 $as_echo_n "checking whether the C compiler works... " >&6; }
-# FIXME: These cross compiler hacks should be removed for Autoconf 3.0
 # If not cross compiling, check that we can run a simple program.
 if test "$cross_compiling" != yes; then
   if { ac_try='./$ac_file'
-  { (case "(($ac_try" in
+  { { case "(($ac_try" in
   *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
   *) ac_try_echo=$ac_try;;
 esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
+eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
+$as_echo "$ac_try_echo"; } >&5
   (eval "$ac_try") 2>&5
   ac_status=$?
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }; }; then
     cross_compiling=no
   else
     if test "$cross_compiling" = maybe; then
 	cross_compiling=yes
     else
-	{ { $as_echo "$as_me:$LINENO: error: in \`$ac_pwd':" >&5
+	{ { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
 $as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
-{ { $as_echo "$as_me:$LINENO: error: cannot run C compiled programs.
-If you meant to cross compile, use \`--host'.
-See \`config.log' for more details." >&5
-$as_echo "$as_me: error: cannot run C compiled programs.
+as_fn_error "cannot run C compiled programs.
 If you meant to cross compile, use \`--host'.
-See \`config.log' for more details." >&2;}
-   { (exit 1); exit 1; }; }; }
+See \`config.log' for more details." "$LINENO" 5; }
     fi
   fi
 fi
-{ $as_echo "$as_me:$LINENO: result: yes" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
 $as_echo "yes" >&6; }
 
-rm -f -r a.out a.out.dSYM a.exe conftest$ac_cv_exeext b.out
+rm -f -r a.out a.out.dSYM a.exe conftest$ac_cv_exeext b.out conftest.out
 ac_clean_files=$ac_clean_files_save
 # Check that the compiler produces executables we can run.  If not, either
 # the compiler is broken, or we cross compile.
-{ $as_echo "$as_me:$LINENO: checking whether we are cross compiling" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether we are cross compiling" >&5
 $as_echo_n "checking whether we are cross compiling... " >&6; }
-{ $as_echo "$as_me:$LINENO: result: $cross_compiling" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $cross_compiling" >&5
 $as_echo "$cross_compiling" >&6; }
 
-{ $as_echo "$as_me:$LINENO: checking for suffix of executables" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for suffix of executables" >&5
 $as_echo_n "checking for suffix of executables... " >&6; }
-if { (ac_try="$ac_link"
+if { { ac_try="$ac_link"
 case "(($ac_try" in
   *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
   *) ac_try_echo=$ac_try;;
 esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
+eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
+$as_echo "$ac_try_echo"; } >&5
   (eval "$ac_link") 2>&5
   ac_status=$?
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; then
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }; then :
   # If both `conftest.exe' and `conftest' are `present' (well, observable)
 # catch `conftest.exe'.  For instance with Cygwin, `ls conftest' will
 # work properly (i.e., refer to `conftest.exe'), while it won't with
@@ -3401,32 +3639,24 @@ for ac_file in conftest.exe conftest con
   esac
 done
 else
-  { { $as_echo "$as_me:$LINENO: error: in \`$ac_pwd':" >&5
+  { { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
 $as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
-{ { $as_echo "$as_me:$LINENO: error: cannot compute suffix of executables: cannot compile and link
-See \`config.log' for more details." >&5
-$as_echo "$as_me: error: cannot compute suffix of executables: cannot compile and link
-See \`config.log' for more details." >&2;}
-   { (exit 1); exit 1; }; }; }
+as_fn_error "cannot compute suffix of executables: cannot compile and link
+See \`config.log' for more details." "$LINENO" 5; }
 fi
-
 rm -f conftest$ac_cv_exeext
-{ $as_echo "$as_me:$LINENO: result: $ac_cv_exeext" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_exeext" >&5
 $as_echo "$ac_cv_exeext" >&6; }
 
 rm -f conftest.$ac_ext
 EXEEXT=$ac_cv_exeext
 ac_exeext=$EXEEXT
-{ $as_echo "$as_me:$LINENO: checking for suffix of object files" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for suffix of object files" >&5
 $as_echo_n "checking for suffix of object files... " >&6; }
-if test "${ac_cv_objext+set}" = set; then
+if test "${ac_cv_objext+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 
 int
@@ -3438,17 +3668,17 @@ main ()
 }
 _ACEOF
 rm -f conftest.o conftest.obj
-if { (ac_try="$ac_compile"
+if { { ac_try="$ac_compile"
 case "(($ac_try" in
   *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
   *) ac_try_echo=$ac_try;;
 esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
+eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
+$as_echo "$ac_try_echo"; } >&5
   (eval "$ac_compile") 2>&5
   ac_status=$?
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; then
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }; then :
   for ac_file in conftest.o conftest.obj conftest.*; do
   test -f "$ac_file" || continue;
   case $ac_file in
@@ -3461,31 +3691,23 @@ else
   $as_echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
-{ { $as_echo "$as_me:$LINENO: error: in \`$ac_pwd':" >&5
+{ { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
 $as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
-{ { $as_echo "$as_me:$LINENO: error: cannot compute suffix of object files: cannot compile
-See \`config.log' for more details." >&5
-$as_echo "$as_me: error: cannot compute suffix of object files: cannot compile
-See \`config.log' for more details." >&2;}
-   { (exit 1); exit 1; }; }; }
+as_fn_error "cannot compute suffix of object files: cannot compile
+See \`config.log' for more details." "$LINENO" 5; }
 fi
-
 rm -f conftest.$ac_cv_objext conftest.$ac_ext
 fi
-{ $as_echo "$as_me:$LINENO: result: $ac_cv_objext" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_objext" >&5
 $as_echo "$ac_cv_objext" >&6; }
 OBJEXT=$ac_cv_objext
 ac_objext=$OBJEXT
-{ $as_echo "$as_me:$LINENO: checking whether we are using the GNU C compiler" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether we are using the GNU C compiler" >&5
 $as_echo_n "checking whether we are using the GNU C compiler... " >&6; }
-if test "${ac_cv_c_compiler_gnu+set}" = set; then
+if test "${ac_cv_c_compiler_gnu+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 
 int
@@ -3499,37 +3721,16 @@ main ()
   return 0;
 }
 _ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
+if ac_fn_c_try_compile "$LINENO"; then :
   ac_compiler_gnu=yes
 else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_compiler_gnu=no
+  ac_compiler_gnu=no
 fi
-
 rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
 ac_cv_c_compiler_gnu=$ac_compiler_gnu
 
 fi
-{ $as_echo "$as_me:$LINENO: result: $ac_cv_c_compiler_gnu" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_c_compiler_gnu" >&5
 $as_echo "$ac_cv_c_compiler_gnu" >&6; }
 if test $ac_compiler_gnu = yes; then
   GCC=yes
@@ -3538,20 +3739,16 @@ else
 fi
 ac_test_CFLAGS=${CFLAGS+set}
 ac_save_CFLAGS=$CFLAGS
-{ $as_echo "$as_me:$LINENO: checking whether $CC accepts -g" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether $CC accepts -g" >&5
 $as_echo_n "checking whether $CC accepts -g... " >&6; }
-if test "${ac_cv_prog_cc_g+set}" = set; then
+if test "${ac_cv_prog_cc_g+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   ac_save_c_werror_flag=$ac_c_werror_flag
    ac_c_werror_flag=yes
    ac_cv_prog_cc_g=no
    CFLAGS="-g"
-   cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
+   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 
 int
@@ -3562,35 +3759,11 @@ main ()
   return 0;
 }
 _ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
+if ac_fn_c_try_compile "$LINENO"; then :
   ac_cv_prog_cc_g=yes
 else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	CFLAGS=""
-      cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
+  CFLAGS=""
+      cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 
 int
@@ -3601,36 +3774,12 @@ main ()
   return 0;
 }
 _ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
-  :
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
+if ac_fn_c_try_compile "$LINENO"; then :
 
-	ac_c_werror_flag=$ac_save_c_werror_flag
+else
+  ac_c_werror_flag=$ac_save_c_werror_flag
 	 CFLAGS="-g"
-	 cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
+	 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 
 int
@@ -3641,42 +3790,17 @@ main ()
   return 0;
 }
 _ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
+if ac_fn_c_try_compile "$LINENO"; then :
   ac_cv_prog_cc_g=yes
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-
 fi
-
 rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
 fi
-
 rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
 fi
-
 rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
    ac_c_werror_flag=$ac_save_c_werror_flag
 fi
-{ $as_echo "$as_me:$LINENO: result: $ac_cv_prog_cc_g" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_prog_cc_g" >&5
 $as_echo "$ac_cv_prog_cc_g" >&6; }
 if test "$ac_test_CFLAGS" = set; then
   CFLAGS=$ac_save_CFLAGS
@@ -3693,18 +3817,14 @@ else
     CFLAGS=
   fi
 fi
-{ $as_echo "$as_me:$LINENO: checking for $CC option to accept ISO C89" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $CC option to accept ISO C89" >&5
 $as_echo_n "checking for $CC option to accept ISO C89... " >&6; }
-if test "${ac_cv_prog_cc_c89+set}" = set; then
+if test "${ac_cv_prog_cc_c89+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   ac_cv_prog_cc_c89=no
 ac_save_CC=$CC
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 #include <stdarg.h>
 #include <stdio.h>
@@ -3761,32 +3881,9 @@ for ac_arg in '' -qlanglvl=extc89 -qlang
 	-Ae "-Aa -D_HPUX_SOURCE" "-Xc -D__EXTENSIONS__"
 do
   CC="$ac_save_CC $ac_arg"
-  rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
+  if ac_fn_c_try_compile "$LINENO"; then :
   ac_cv_prog_cc_c89=$ac_arg
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-
 fi
-
 rm -f core conftest.err conftest.$ac_objext
   test "x$ac_cv_prog_cc_c89" != "xno" && break
 done
@@ -3797,17 +3894,19 @@ fi
 # AC_CACHE_VAL
 case "x$ac_cv_prog_cc_c89" in
   x)
-    { $as_echo "$as_me:$LINENO: result: none needed" >&5
+    { $as_echo "$as_me:${as_lineno-$LINENO}: result: none needed" >&5
 $as_echo "none needed" >&6; } ;;
   xno)
-    { $as_echo "$as_me:$LINENO: result: unsupported" >&5
+    { $as_echo "$as_me:${as_lineno-$LINENO}: result: unsupported" >&5
 $as_echo "unsupported" >&6; } ;;
   *)
     CC="$CC $ac_cv_prog_cc_c89"
-    { $as_echo "$as_me:$LINENO: result: $ac_cv_prog_cc_c89" >&5
+    { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_prog_cc_c89" >&5
 $as_echo "$ac_cv_prog_cc_c89" >&6; } ;;
 esac
+if test "x$ac_cv_prog_cc_c89" != xno; then :
 
+fi
 
 ac_ext=c
 ac_cpp='$CPP $CPPFLAGS'
@@ -3817,9 +3916,9 @@ ac_compiler_gnu=$ac_cv_c_compiler_gnu
 
 depcc="$CC"   am_compiler_list=
 
-{ $as_echo "$as_me:$LINENO: checking dependency style of $depcc" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking dependency style of $depcc" >&5
 $as_echo_n "checking dependency style of $depcc... " >&6; }
-if test "${am_cv_CC_dependencies_compiler_type+set}" = set; then
+if test "${am_cv_CC_dependencies_compiler_type+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   if test -z "$AMDEP_TRUE" && test -f "$am_depcomp"; then
@@ -3927,7 +4026,7 @@ else
 fi
 
 fi
-{ $as_echo "$as_me:$LINENO: result: $am_cv_CC_dependencies_compiler_type" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $am_cv_CC_dependencies_compiler_type" >&5
 $as_echo "$am_cv_CC_dependencies_compiler_type" >&6; }
 CCDEPMODE=depmode=$am_cv_CC_dependencies_compiler_type
 
@@ -3943,17 +4042,15 @@ fi
 
 
 
-{ $as_echo "$as_me:$LINENO: checking for library containing strerror" >&5
-$as_echo_n "checking for library containing strerror... " >&6; }
-if test "${ac_cv_search_strerror+set}" = set; then
+
+        { $as_echo "$as_me:${as_lineno-$LINENO}: checking for strerror in -lcposix" >&5
+$as_echo_n "checking for strerror in -lcposix... " >&6; }
+if test "${ac_cv_lib_cposix_strerror+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
-  ac_func_search_save_LIBS=$LIBS
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lcposix  $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 
 /* Override any GCC internal prototype to avoid an error.
@@ -3971,64 +4068,22 @@ return strerror ();
   return 0;
 }
 _ACEOF
-for ac_lib in '' cposix; do
-  if test -z "$ac_lib"; then
-    ac_res="none required"
-  else
-    ac_res=-l$ac_lib
-    LIBS="-l$ac_lib  $ac_func_search_save_LIBS"
-  fi
-  rm -f conftest.$ac_objext conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_link") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest$ac_exeext && {
-	 test "$cross_compiling" = yes ||
-	 $as_test_x conftest$ac_exeext
-       }; then
-  ac_cv_search_strerror=$ac_res
+if ac_fn_c_try_link "$LINENO"; then :
+  ac_cv_lib_cposix_strerror=yes
 else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-
-fi
-
-rm -rf conftest.dSYM
-rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
-      conftest$ac_exeext
-  if test "${ac_cv_search_strerror+set}" = set; then
-  break
+  ac_cv_lib_cposix_strerror=no
 fi
-done
-if test "${ac_cv_search_strerror+set}" = set; then
-  :
-else
-  ac_cv_search_strerror=no
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
 fi
-rm conftest.$ac_ext
-LIBS=$ac_func_search_save_LIBS
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_cposix_strerror" >&5
+$as_echo "$ac_cv_lib_cposix_strerror" >&6; }
+if test "x$ac_cv_lib_cposix_strerror" = x""yes; then :
+  LIBS="$LIBS -lcposix"
 fi
-{ $as_echo "$as_me:$LINENO: result: $ac_cv_search_strerror" >&5
-$as_echo "$ac_cv_search_strerror" >&6; }
-ac_res=$ac_cv_search_strerror
-if test "$ac_res" != no; then
-  test "$ac_res" = "none required" || LIBS="$ac_res $LIBS"
 
-fi
+
 
 ac_ext=c
 ac_cpp='$CPP $CPPFLAGS'
@@ -4038,9 +4093,9 @@ ac_compiler_gnu=$ac_cv_c_compiler_gnu
 if test -n "$ac_tool_prefix"; then
   # Extract the first word of "${ac_tool_prefix}gcc", so it can be a program name with args.
 set dummy ${ac_tool_prefix}gcc; ac_word=$2
-{ $as_echo "$as_me:$LINENO: checking for $ac_word" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
 $as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_prog_CC+set}" = set; then
+if test "${ac_cv_prog_CC+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   if test -n "$CC"; then
@@ -4051,24 +4106,24 @@ for as_dir in $PATH
 do
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
-  for ac_exec_ext in '' $ac_executable_extensions; do
+    for ac_exec_ext in '' $ac_executable_extensions; do
   if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
     ac_cv_prog_CC="${ac_tool_prefix}gcc"
-    $as_echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
   fi
 done
-done
+  done
 IFS=$as_save_IFS
 
 fi
 fi
 CC=$ac_cv_prog_CC
 if test -n "$CC"; then
-  { $as_echo "$as_me:$LINENO: result: $CC" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $CC" >&5
 $as_echo "$CC" >&6; }
 else
-  { $as_echo "$as_me:$LINENO: result: no" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
 $as_echo "no" >&6; }
 fi
 
@@ -4078,9 +4133,9 @@ if test -z "$ac_cv_prog_CC"; then
   ac_ct_CC=$CC
   # Extract the first word of "gcc", so it can be a program name with args.
 set dummy gcc; ac_word=$2
-{ $as_echo "$as_me:$LINENO: checking for $ac_word" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
 $as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_prog_ac_ct_CC+set}" = set; then
+if test "${ac_cv_prog_ac_ct_CC+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   if test -n "$ac_ct_CC"; then
@@ -4091,24 +4146,24 @@ for as_dir in $PATH
 do
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
-  for ac_exec_ext in '' $ac_executable_extensions; do
+    for ac_exec_ext in '' $ac_executable_extensions; do
   if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
     ac_cv_prog_ac_ct_CC="gcc"
-    $as_echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
   fi
 done
-done
+  done
 IFS=$as_save_IFS
 
 fi
 fi
 ac_ct_CC=$ac_cv_prog_ac_ct_CC
 if test -n "$ac_ct_CC"; then
-  { $as_echo "$as_me:$LINENO: result: $ac_ct_CC" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_CC" >&5
 $as_echo "$ac_ct_CC" >&6; }
 else
-  { $as_echo "$as_me:$LINENO: result: no" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
 $as_echo "no" >&6; }
 fi
 
@@ -4117,7 +4172,7 @@ fi
   else
     case $cross_compiling:$ac_tool_warned in
 yes:)
-{ $as_echo "$as_me:$LINENO: WARNING: using cross tools not prefixed with host triplet" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
 $as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
 ac_tool_warned=yes ;;
 esac
@@ -4131,9 +4186,9 @@ if test -z "$CC"; then
           if test -n "$ac_tool_prefix"; then
     # Extract the first word of "${ac_tool_prefix}cc", so it can be a program name with args.
 set dummy ${ac_tool_prefix}cc; ac_word=$2
-{ $as_echo "$as_me:$LINENO: checking for $ac_word" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
 $as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_prog_CC+set}" = set; then
+if test "${ac_cv_prog_CC+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   if test -n "$CC"; then
@@ -4144,24 +4199,24 @@ for as_dir in $PATH
 do
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
-  for ac_exec_ext in '' $ac_executable_extensions; do
+    for ac_exec_ext in '' $ac_executable_extensions; do
   if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
     ac_cv_prog_CC="${ac_tool_prefix}cc"
-    $as_echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
   fi
 done
-done
+  done
 IFS=$as_save_IFS
 
 fi
 fi
 CC=$ac_cv_prog_CC
 if test -n "$CC"; then
-  { $as_echo "$as_me:$LINENO: result: $CC" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $CC" >&5
 $as_echo "$CC" >&6; }
 else
-  { $as_echo "$as_me:$LINENO: result: no" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
 $as_echo "no" >&6; }
 fi
 
@@ -4171,9 +4226,9 @@ fi
 if test -z "$CC"; then
   # Extract the first word of "cc", so it can be a program name with args.
 set dummy cc; ac_word=$2
-{ $as_echo "$as_me:$LINENO: checking for $ac_word" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
 $as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_prog_CC+set}" = set; then
+if test "${ac_cv_prog_CC+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   if test -n "$CC"; then
@@ -4185,18 +4240,18 @@ for as_dir in $PATH
 do
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
-  for ac_exec_ext in '' $ac_executable_extensions; do
+    for ac_exec_ext in '' $ac_executable_extensions; do
   if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
     if test "$as_dir/$ac_word$ac_exec_ext" = "/usr/ucb/cc"; then
        ac_prog_rejected=yes
        continue
      fi
     ac_cv_prog_CC="cc"
-    $as_echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
   fi
 done
-done
+  done
 IFS=$as_save_IFS
 
 if test $ac_prog_rejected = yes; then
@@ -4215,10 +4270,10 @@ fi
 fi
 CC=$ac_cv_prog_CC
 if test -n "$CC"; then
-  { $as_echo "$as_me:$LINENO: result: $CC" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $CC" >&5
 $as_echo "$CC" >&6; }
 else
-  { $as_echo "$as_me:$LINENO: result: no" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
 $as_echo "no" >&6; }
 fi
 
@@ -4230,9 +4285,9 @@ if test -z "$CC"; then
   do
     # Extract the first word of "$ac_tool_prefix$ac_prog", so it can be a program name with args.
 set dummy $ac_tool_prefix$ac_prog; ac_word=$2
-{ $as_echo "$as_me:$LINENO: checking for $ac_word" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
 $as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_prog_CC+set}" = set; then
+if test "${ac_cv_prog_CC+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   if test -n "$CC"; then
@@ -4243,24 +4298,24 @@ for as_dir in $PATH
 do
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
-  for ac_exec_ext in '' $ac_executable_extensions; do
+    for ac_exec_ext in '' $ac_executable_extensions; do
   if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
     ac_cv_prog_CC="$ac_tool_prefix$ac_prog"
-    $as_echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
   fi
 done
-done
+  done
 IFS=$as_save_IFS
 
 fi
 fi
 CC=$ac_cv_prog_CC
 if test -n "$CC"; then
-  { $as_echo "$as_me:$LINENO: result: $CC" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $CC" >&5
 $as_echo "$CC" >&6; }
 else
-  { $as_echo "$as_me:$LINENO: result: no" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
 $as_echo "no" >&6; }
 fi
 
@@ -4274,9 +4329,9 @@ if test -z "$CC"; then
 do
   # Extract the first word of "$ac_prog", so it can be a program name with args.
 set dummy $ac_prog; ac_word=$2
-{ $as_echo "$as_me:$LINENO: checking for $ac_word" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
 $as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_prog_ac_ct_CC+set}" = set; then
+if test "${ac_cv_prog_ac_ct_CC+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   if test -n "$ac_ct_CC"; then
@@ -4287,24 +4342,24 @@ for as_dir in $PATH
 do
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
-  for ac_exec_ext in '' $ac_executable_extensions; do
+    for ac_exec_ext in '' $ac_executable_extensions; do
   if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
     ac_cv_prog_ac_ct_CC="$ac_prog"
-    $as_echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
   fi
 done
-done
+  done
 IFS=$as_save_IFS
 
 fi
 fi
 ac_ct_CC=$ac_cv_prog_ac_ct_CC
 if test -n "$ac_ct_CC"; then
-  { $as_echo "$as_me:$LINENO: result: $ac_ct_CC" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_CC" >&5
 $as_echo "$ac_ct_CC" >&6; }
 else
-  { $as_echo "$as_me:$LINENO: result: no" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
 $as_echo "no" >&6; }
 fi
 
@@ -4317,7 +4372,7 @@ done
   else
     case $cross_compiling:$ac_tool_warned in
 yes:)
-{ $as_echo "$as_me:$LINENO: WARNING: using cross tools not prefixed with host triplet" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
 $as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
 ac_tool_warned=yes ;;
 esac
@@ -4328,62 +4383,42 @@ fi
 fi
 
 
-test -z "$CC" && { { $as_echo "$as_me:$LINENO: error: in \`$ac_pwd':" >&5
+test -z "$CC" && { { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
 $as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
-{ { $as_echo "$as_me:$LINENO: error: no acceptable C compiler found in \$PATH
-See \`config.log' for more details." >&5
-$as_echo "$as_me: error: no acceptable C compiler found in \$PATH
-See \`config.log' for more details." >&2;}
-   { (exit 1); exit 1; }; }; }
+as_fn_error "no acceptable C compiler found in \$PATH
+See \`config.log' for more details." "$LINENO" 5; }
 
 # Provide some information about the compiler.
-$as_echo "$as_me:$LINENO: checking for C compiler version" >&5
+$as_echo "$as_me:${as_lineno-$LINENO}: checking for C compiler version" >&5
 set X $ac_compile
 ac_compiler=$2
-{ (ac_try="$ac_compiler --version >&5"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_compiler --version >&5") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }
-{ (ac_try="$ac_compiler -v >&5"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_compiler -v >&5") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }
-{ (ac_try="$ac_compiler -V >&5"
+for ac_option in --version -v -V -qversion; do
+  { { ac_try="$ac_compiler $ac_option >&5"
 case "(($ac_try" in
   *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
   *) ac_try_echo=$ac_try;;
 esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_compiler -V >&5") 2>&5
+eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
+$as_echo "$ac_try_echo"; } >&5
+  (eval "$ac_compiler $ac_option >&5") 2>conftest.err
   ac_status=$?
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }
+  if test -s conftest.err; then
+    sed '10a\
+... rest of stderr output deleted ...
+         10q' conftest.err >conftest.er1
+    cat conftest.er1 >&5
+    rm -f conftest.er1 conftest.err
+  fi
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }
+done
 
-{ $as_echo "$as_me:$LINENO: checking whether we are using the GNU C compiler" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether we are using the GNU C compiler" >&5
 $as_echo_n "checking whether we are using the GNU C compiler... " >&6; }
-if test "${ac_cv_c_compiler_gnu+set}" = set; then
+if test "${ac_cv_c_compiler_gnu+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 
 int
@@ -4397,37 +4432,16 @@ main ()
   return 0;
 }
 _ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
+if ac_fn_c_try_compile "$LINENO"; then :
   ac_compiler_gnu=yes
 else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_compiler_gnu=no
+  ac_compiler_gnu=no
 fi
-
 rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
 ac_cv_c_compiler_gnu=$ac_compiler_gnu
 
 fi
-{ $as_echo "$as_me:$LINENO: result: $ac_cv_c_compiler_gnu" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_c_compiler_gnu" >&5
 $as_echo "$ac_cv_c_compiler_gnu" >&6; }
 if test $ac_compiler_gnu = yes; then
   GCC=yes
@@ -4436,20 +4450,16 @@ else
 fi
 ac_test_CFLAGS=${CFLAGS+set}
 ac_save_CFLAGS=$CFLAGS
-{ $as_echo "$as_me:$LINENO: checking whether $CC accepts -g" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether $CC accepts -g" >&5
 $as_echo_n "checking whether $CC accepts -g... " >&6; }
-if test "${ac_cv_prog_cc_g+set}" = set; then
+if test "${ac_cv_prog_cc_g+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   ac_save_c_werror_flag=$ac_c_werror_flag
    ac_c_werror_flag=yes
    ac_cv_prog_cc_g=no
    CFLAGS="-g"
-   cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
+   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 
 int
@@ -4460,35 +4470,11 @@ main ()
   return 0;
 }
 _ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
+if ac_fn_c_try_compile "$LINENO"; then :
   ac_cv_prog_cc_g=yes
 else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	CFLAGS=""
-      cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
+  CFLAGS=""
+      cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 
 int
@@ -4499,36 +4485,12 @@ main ()
   return 0;
 }
 _ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
-  :
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
+if ac_fn_c_try_compile "$LINENO"; then :
 
-	ac_c_werror_flag=$ac_save_c_werror_flag
+else
+  ac_c_werror_flag=$ac_save_c_werror_flag
 	 CFLAGS="-g"
-	 cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
+	 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 
 int
@@ -4539,42 +4501,17 @@ main ()
   return 0;
 }
 _ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
+if ac_fn_c_try_compile "$LINENO"; then :
   ac_cv_prog_cc_g=yes
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-
 fi
-
 rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
 fi
-
 rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
 fi
-
 rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
    ac_c_werror_flag=$ac_save_c_werror_flag
 fi
-{ $as_echo "$as_me:$LINENO: result: $ac_cv_prog_cc_g" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_prog_cc_g" >&5
 $as_echo "$ac_cv_prog_cc_g" >&6; }
 if test "$ac_test_CFLAGS" = set; then
   CFLAGS=$ac_save_CFLAGS
@@ -4591,18 +4528,14 @@ else
     CFLAGS=
   fi
 fi
-{ $as_echo "$as_me:$LINENO: checking for $CC option to accept ISO C89" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $CC option to accept ISO C89" >&5
 $as_echo_n "checking for $CC option to accept ISO C89... " >&6; }
-if test "${ac_cv_prog_cc_c89+set}" = set; then
+if test "${ac_cv_prog_cc_c89+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   ac_cv_prog_cc_c89=no
 ac_save_CC=$CC
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 #include <stdarg.h>
 #include <stdio.h>
@@ -4653,38 +4586,15 @@ main ()
 return f (e, argv, 0) != argv[0]  ||  f (e, argv, 1) != argv[1];
   ;
   return 0;
-}
-_ACEOF
-for ac_arg in '' -qlanglvl=extc89 -qlanglvl=ansi -std \
-	-Ae "-Aa -D_HPUX_SOURCE" "-Xc -D__EXTENSIONS__"
-do
-  CC="$ac_save_CC $ac_arg"
-  rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
+}
+_ACEOF
+for ac_arg in '' -qlanglvl=extc89 -qlanglvl=ansi -std \
+	-Ae "-Aa -D_HPUX_SOURCE" "-Xc -D__EXTENSIONS__"
+do
+  CC="$ac_save_CC $ac_arg"
+  if ac_fn_c_try_compile "$LINENO"; then :
   ac_cv_prog_cc_c89=$ac_arg
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-
 fi
-
 rm -f core conftest.err conftest.$ac_objext
   test "x$ac_cv_prog_cc_c89" != "xno" && break
 done
@@ -4695,17 +4605,19 @@ fi
 # AC_CACHE_VAL
 case "x$ac_cv_prog_cc_c89" in
   x)
-    { $as_echo "$as_me:$LINENO: result: none needed" >&5
+    { $as_echo "$as_me:${as_lineno-$LINENO}: result: none needed" >&5
 $as_echo "none needed" >&6; } ;;
   xno)
-    { $as_echo "$as_me:$LINENO: result: unsupported" >&5
+    { $as_echo "$as_me:${as_lineno-$LINENO}: result: unsupported" >&5
 $as_echo "unsupported" >&6; } ;;
   *)
     CC="$CC $ac_cv_prog_cc_c89"
-    { $as_echo "$as_me:$LINENO: result: $ac_cv_prog_cc_c89" >&5
+    { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_prog_cc_c89" >&5
 $as_echo "$ac_cv_prog_cc_c89" >&6; } ;;
 esac
+if test "x$ac_cv_prog_cc_c89" != xno; then :
 
+fi
 
 ac_ext=c
 ac_cpp='$CPP $CPPFLAGS'
@@ -4715,9 +4627,9 @@ ac_compiler_gnu=$ac_cv_c_compiler_gnu
 
 depcc="$CC"   am_compiler_list=
 
-{ $as_echo "$as_me:$LINENO: checking dependency style of $depcc" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking dependency style of $depcc" >&5
 $as_echo_n "checking dependency style of $depcc... " >&6; }
-if test "${am_cv_CC_dependencies_compiler_type+set}" = set; then
+if test "${am_cv_CC_dependencies_compiler_type+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   if test -z "$AMDEP_TRUE" && test -f "$am_depcomp"; then
@@ -4825,7 +4737,7 @@ else
 fi
 
 fi
-{ $as_echo "$as_me:$LINENO: result: $am_cv_CC_dependencies_compiler_type" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $am_cv_CC_dependencies_compiler_type" >&5
 $as_echo "$am_cv_CC_dependencies_compiler_type" >&6; }
 CCDEPMODE=depmode=$am_cv_CC_dependencies_compiler_type
 
@@ -4845,14 +4757,14 @@ ac_cpp='$CPP $CPPFLAGS'
 ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
 ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
 ac_compiler_gnu=$ac_cv_c_compiler_gnu
-{ $as_echo "$as_me:$LINENO: checking how to run the C preprocessor" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking how to run the C preprocessor" >&5
 $as_echo_n "checking how to run the C preprocessor... " >&6; }
 # On Suns, sometimes $CPP names a directory.
 if test -n "$CPP" && test -d "$CPP"; then
   CPP=
 fi
 if test -z "$CPP"; then
-  if test "${ac_cv_prog_CPP+set}" = set; then
+  if test "${ac_cv_prog_CPP+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
       # Double quotes because CPP needs to be expanded
@@ -4867,11 +4779,7 @@ do
   # <limits.h> exists even on freestanding compilers.
   # On the NeXT, cc -E runs the code through the compiler's parser,
   # not just through cpp. "Syntax error" is here to catch this case.
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 #ifdef __STDC__
 # include <limits.h>
@@ -4880,28 +4788,9 @@ cat >>conftest.$ac_ext <<_ACEOF
 #endif
 		     Syntax error
 _ACEOF
-if { (ac_try="$ac_cpp conftest.$ac_ext"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_cpp conftest.$ac_ext") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } >/dev/null && {
-	 test -z "$ac_c_preproc_warn_flag$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       }; then
-  :
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
+if ac_fn_c_try_cpp "$LINENO"; then :
 
+else
   # Broken: fails on valid input.
 continue
 fi
@@ -4910,37 +4799,14 @@ rm -f conftest.err conftest.$ac_ext
 
   # OK, works on sane cases.  Now check whether nonexistent headers
   # can be detected and how.
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 #include <ac_nonexistent.h>
 _ACEOF
-if { (ac_try="$ac_cpp conftest.$ac_ext"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_cpp conftest.$ac_ext") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } >/dev/null && {
-	 test -z "$ac_c_preproc_warn_flag$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       }; then
+if ac_fn_c_try_cpp "$LINENO"; then :
   # Broken: success on invalid input.
 continue
 else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
   # Passes both tests.
 ac_preproc_ok=:
 break
@@ -4951,7 +4817,7 @@ rm -f conftest.err conftest.$ac_ext
 done
 # Because of `break', _AC_PREPROC_IFELSE's cleaning code was skipped.
 rm -f conftest.err conftest.$ac_ext
-if $ac_preproc_ok; then
+if $ac_preproc_ok; then :
   break
 fi
 
@@ -4963,7 +4829,7 @@ fi
 else
   ac_cv_prog_CPP=$CPP
 fi
-{ $as_echo "$as_me:$LINENO: result: $CPP" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $CPP" >&5
 $as_echo "$CPP" >&6; }
 ac_preproc_ok=false
 for ac_c_preproc_warn_flag in '' yes
@@ -4974,11 +4840,7 @@ do
   # <limits.h> exists even on freestanding compilers.
   # On the NeXT, cc -E runs the code through the compiler's parser,
   # not just through cpp. "Syntax error" is here to catch this case.
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 #ifdef __STDC__
 # include <limits.h>
@@ -4987,28 +4849,9 @@ cat >>conftest.$ac_ext <<_ACEOF
 #endif
 		     Syntax error
 _ACEOF
-if { (ac_try="$ac_cpp conftest.$ac_ext"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_cpp conftest.$ac_ext") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } >/dev/null && {
-	 test -z "$ac_c_preproc_warn_flag$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       }; then
-  :
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
+if ac_fn_c_try_cpp "$LINENO"; then :
 
+else
   # Broken: fails on valid input.
 continue
 fi
@@ -5017,37 +4860,14 @@ rm -f conftest.err conftest.$ac_ext
 
   # OK, works on sane cases.  Now check whether nonexistent headers
   # can be detected and how.
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 #include <ac_nonexistent.h>
 _ACEOF
-if { (ac_try="$ac_cpp conftest.$ac_ext"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_cpp conftest.$ac_ext") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } >/dev/null && {
-	 test -z "$ac_c_preproc_warn_flag$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       }; then
+if ac_fn_c_try_cpp "$LINENO"; then :
   # Broken: success on invalid input.
 continue
 else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
   # Passes both tests.
 ac_preproc_ok=:
 break
@@ -5058,16 +4878,13 @@ rm -f conftest.err conftest.$ac_ext
 done
 # Because of `break', _AC_PREPROC_IFELSE's cleaning code was skipped.
 rm -f conftest.err conftest.$ac_ext
-if $ac_preproc_ok; then
-  :
+if $ac_preproc_ok; then :
+
 else
-  { { $as_echo "$as_me:$LINENO: error: in \`$ac_pwd':" >&5
+  { { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
 $as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
-{ { $as_echo "$as_me:$LINENO: error: C preprocessor \"$CPP\" fails sanity check
-See \`config.log' for more details." >&5
-$as_echo "$as_me: error: C preprocessor \"$CPP\" fails sanity check
-See \`config.log' for more details." >&2;}
-   { (exit 1); exit 1; }; }; }
+as_fn_error "C preprocessor \"$CPP\" fails sanity check
+See \`config.log' for more details." "$LINENO" 5; }
 fi
 
 ac_ext=c
@@ -5077,9 +4894,9 @@ ac_link='$CC -o conftest$ac_exeext $CFLA
 ac_compiler_gnu=$ac_cv_c_compiler_gnu
 
 
-{ $as_echo "$as_me:$LINENO: checking for grep that handles long lines and -e" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for grep that handles long lines and -e" >&5
 $as_echo_n "checking for grep that handles long lines and -e... " >&6; }
-if test "${ac_cv_path_GREP+set}" = set; then
+if test "${ac_cv_path_GREP+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   if test -z "$GREP"; then
@@ -5090,7 +4907,7 @@ for as_dir in $PATH$PATH_SEPARATOR/usr/x
 do
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
-  for ac_prog in grep ggrep; do
+    for ac_prog in grep ggrep; do
     for ac_exec_ext in '' $ac_executable_extensions; do
       ac_path_GREP="$as_dir/$ac_prog$ac_exec_ext"
       { test -f "$ac_path_GREP" && $as_test_x "$ac_path_GREP"; } || continue
@@ -5110,7 +4927,7 @@ case `"$ac_path_GREP" --version 2>&1` in
     $as_echo 'GREP' >> "conftest.nl"
     "$ac_path_GREP" -e 'GREP$' -e '-(cannot match)-' < "conftest.nl" >"conftest.out" 2>/dev/null || break
     diff "conftest.out" "conftest.nl" >/dev/null 2>&1 || break
-    ac_count=`expr $ac_count + 1`
+    as_fn_arith $ac_count + 1 && ac_count=$as_val
     if test $ac_count -gt ${ac_path_GREP_max-0}; then
       # Best one so far, save it but keep looking for a better one
       ac_cv_path_GREP="$ac_path_GREP"
@@ -5125,26 +4942,24 @@ esac
       $ac_path_GREP_found && break 3
     done
   done
-done
+  done
 IFS=$as_save_IFS
   if test -z "$ac_cv_path_GREP"; then
-    { { $as_echo "$as_me:$LINENO: error: no acceptable grep could be found in $PATH$PATH_SEPARATOR/usr/xpg4/bin" >&5
-$as_echo "$as_me: error: no acceptable grep could be found in $PATH$PATH_SEPARATOR/usr/xpg4/bin" >&2;}
-   { (exit 1); exit 1; }; }
+    as_fn_error "no acceptable grep could be found in $PATH$PATH_SEPARATOR/usr/xpg4/bin" "$LINENO" 5
   fi
 else
   ac_cv_path_GREP=$GREP
 fi
 
 fi
-{ $as_echo "$as_me:$LINENO: result: $ac_cv_path_GREP" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_path_GREP" >&5
 $as_echo "$ac_cv_path_GREP" >&6; }
  GREP="$ac_cv_path_GREP"
 
 
-{ $as_echo "$as_me:$LINENO: checking for egrep" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for egrep" >&5
 $as_echo_n "checking for egrep... " >&6; }
-if test "${ac_cv_path_EGREP+set}" = set; then
+if test "${ac_cv_path_EGREP+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   if echo a | $GREP -E '(a|b)' >/dev/null 2>&1
@@ -5158,7 +4973,7 @@ for as_dir in $PATH$PATH_SEPARATOR/usr/x
 do
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
-  for ac_prog in egrep; do
+    for ac_prog in egrep; do
     for ac_exec_ext in '' $ac_executable_extensions; do
       ac_path_EGREP="$as_dir/$ac_prog$ac_exec_ext"
       { test -f "$ac_path_EGREP" && $as_test_x "$ac_path_EGREP"; } || continue
@@ -5178,7 +4993,7 @@ case `"$ac_path_EGREP" --version 2>&1` i
     $as_echo 'EGREP' >> "conftest.nl"
     "$ac_path_EGREP" 'EGREP$' < "conftest.nl" >"conftest.out" 2>/dev/null || break
     diff "conftest.out" "conftest.nl" >/dev/null 2>&1 || break
-    ac_count=`expr $ac_count + 1`
+    as_fn_arith $ac_count + 1 && ac_count=$as_val
     if test $ac_count -gt ${ac_path_EGREP_max-0}; then
       # Best one so far, save it but keep looking for a better one
       ac_cv_path_EGREP="$ac_path_EGREP"
@@ -5193,12 +5008,10 @@ esac
       $ac_path_EGREP_found && break 3
     done
   done
-done
+  done
 IFS=$as_save_IFS
   if test -z "$ac_cv_path_EGREP"; then
-    { { $as_echo "$as_me:$LINENO: error: no acceptable egrep could be found in $PATH$PATH_SEPARATOR/usr/xpg4/bin" >&5
-$as_echo "$as_me: error: no acceptable egrep could be found in $PATH$PATH_SEPARATOR/usr/xpg4/bin" >&2;}
-   { (exit 1); exit 1; }; }
+    as_fn_error "no acceptable egrep could be found in $PATH$PATH_SEPARATOR/usr/xpg4/bin" "$LINENO" 5
   fi
 else
   ac_cv_path_EGREP=$EGREP
@@ -5206,21 +5019,17 @@ fi
 
    fi
 fi
-{ $as_echo "$as_me:$LINENO: result: $ac_cv_path_EGREP" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_path_EGREP" >&5
 $as_echo "$ac_cv_path_EGREP" >&6; }
  EGREP="$ac_cv_path_EGREP"
 
 
-{ $as_echo "$as_me:$LINENO: checking for ANSI C header files" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for ANSI C header files" >&5
 $as_echo_n "checking for ANSI C header files... " >&6; }
-if test "${ac_cv_header_stdc+set}" = set; then
+if test "${ac_cv_header_stdc+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 #include <stdlib.h>
 #include <stdarg.h>
@@ -5235,48 +5044,23 @@ main ()
   return 0;
 }
 _ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
+if ac_fn_c_try_compile "$LINENO"; then :
   ac_cv_header_stdc=yes
 else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_cv_header_stdc=no
+  ac_cv_header_stdc=no
 fi
-
 rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
 
 if test $ac_cv_header_stdc = yes; then
   # SunOS 4.x string.h does not declare mem*, contrary to ANSI.
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 #include <string.h>
 
 _ACEOF
 if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
-  $EGREP "memchr" >/dev/null 2>&1; then
-  :
+  $EGREP "memchr" >/dev/null 2>&1; then :
+
 else
   ac_cv_header_stdc=no
 fi
@@ -5286,18 +5070,14 @@ fi
 
 if test $ac_cv_header_stdc = yes; then
   # ISC 2.0.2 stdlib.h does not declare free, contrary to ANSI.
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 #include <stdlib.h>
 
 _ACEOF
 if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
-  $EGREP "free" >/dev/null 2>&1; then
-  :
+  $EGREP "free" >/dev/null 2>&1; then :
+
 else
   ac_cv_header_stdc=no
 fi
@@ -5307,14 +5087,10 @@ fi
 
 if test $ac_cv_header_stdc = yes; then
   # /bin/cc in Irix-4.0.5 gets non-ANSI ctype macros unless using -ansi.
-  if test "$cross_compiling" = yes; then
+  if test "$cross_compiling" = yes; then :
   :
 else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 #include <ctype.h>
 #include <stdlib.h>
@@ -5341,57 +5117,28 @@ main ()
   return 0;
 }
 _ACEOF
-rm -f conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_link") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  :
-else
-  $as_echo "$as_me: program exited with status $ac_status" >&5
-$as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
+if ac_fn_c_try_run "$LINENO"; then :
 
-( exit $ac_status )
-ac_cv_header_stdc=no
+else
+  ac_cv_header_stdc=no
 fi
-rm -rf conftest.dSYM
-rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
+rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext \
+  conftest.$ac_objext conftest.beam conftest.$ac_ext
 fi
 
-
 fi
 fi
-{ $as_echo "$as_me:$LINENO: result: $ac_cv_header_stdc" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_header_stdc" >&5
 $as_echo "$ac_cv_header_stdc" >&6; }
 if test $ac_cv_header_stdc = yes; then
 
-cat >>confdefs.h <<\_ACEOF
-#define STDC_HEADERS 1
-_ACEOF
+$as_echo "#define STDC_HEADERS 1" >>confdefs.h
 
 fi
 
 case `pwd` in
   *\ * | *\	*)
-    { $as_echo "$as_me:$LINENO: WARNING: Libtool does not cope well with whitespace in \`pwd\`" >&5
+    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: Libtool does not cope well with whitespace in \`pwd\`" >&5
 $as_echo "$as_me: WARNING: Libtool does not cope well with whitespace in \`pwd\`" >&2;} ;;
 esac
 
@@ -5416,35 +5163,27 @@ ltmain="$ac_aux_dir/ltmain.sh"
 
 # Make sure we can run config.sub.
 $SHELL "$ac_aux_dir/config.sub" sun4 >/dev/null 2>&1 ||
-  { { $as_echo "$as_me:$LINENO: error: cannot run $SHELL $ac_aux_dir/config.sub" >&5
-$as_echo "$as_me: error: cannot run $SHELL $ac_aux_dir/config.sub" >&2;}
-   { (exit 1); exit 1; }; }
+  as_fn_error "cannot run $SHELL $ac_aux_dir/config.sub" "$LINENO" 5
 
-{ $as_echo "$as_me:$LINENO: checking build system type" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking build system type" >&5
 $as_echo_n "checking build system type... " >&6; }
-if test "${ac_cv_build+set}" = set; then
+if test "${ac_cv_build+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   ac_build_alias=$build_alias
 test "x$ac_build_alias" = x &&
   ac_build_alias=`$SHELL "$ac_aux_dir/config.guess"`
 test "x$ac_build_alias" = x &&
-  { { $as_echo "$as_me:$LINENO: error: cannot guess build type; you must specify one" >&5
-$as_echo "$as_me: error: cannot guess build type; you must specify one" >&2;}
-   { (exit 1); exit 1; }; }
+  as_fn_error "cannot guess build type; you must specify one" "$LINENO" 5
 ac_cv_build=`$SHELL "$ac_aux_dir/config.sub" $ac_build_alias` ||
-  { { $as_echo "$as_me:$LINENO: error: $SHELL $ac_aux_dir/config.sub $ac_build_alias failed" >&5
-$as_echo "$as_me: error: $SHELL $ac_aux_dir/config.sub $ac_build_alias failed" >&2;}
-   { (exit 1); exit 1; }; }
+  as_fn_error "$SHELL $ac_aux_dir/config.sub $ac_build_alias failed" "$LINENO" 5
 
 fi
-{ $as_echo "$as_me:$LINENO: result: $ac_cv_build" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_build" >&5
 $as_echo "$ac_cv_build" >&6; }
 case $ac_cv_build in
 *-*-*) ;;
-*) { { $as_echo "$as_me:$LINENO: error: invalid value of canonical build" >&5
-$as_echo "$as_me: error: invalid value of canonical build" >&2;}
-   { (exit 1); exit 1; }; };;
+*) as_fn_error "invalid value of canonical build" "$LINENO" 5;;
 esac
 build=$ac_cv_build
 ac_save_IFS=$IFS; IFS='-'
@@ -5460,28 +5199,24 @@ IFS=$ac_save_IFS
 case $build_os in *\ *) build_os=`echo "$build_os" | sed 's/ /-/g'`;; esac
 
 
-{ $as_echo "$as_me:$LINENO: checking host system type" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking host system type" >&5
 $as_echo_n "checking host system type... " >&6; }
-if test "${ac_cv_host+set}" = set; then
+if test "${ac_cv_host+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   if test "x$host_alias" = x; then
   ac_cv_host=$ac_cv_build
 else
   ac_cv_host=`$SHELL "$ac_aux_dir/config.sub" $host_alias` ||
-    { { $as_echo "$as_me:$LINENO: error: $SHELL $ac_aux_dir/config.sub $host_alias failed" >&5
-$as_echo "$as_me: error: $SHELL $ac_aux_dir/config.sub $host_alias failed" >&2;}
-   { (exit 1); exit 1; }; }
+    as_fn_error "$SHELL $ac_aux_dir/config.sub $host_alias failed" "$LINENO" 5
 fi
 
 fi
-{ $as_echo "$as_me:$LINENO: result: $ac_cv_host" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_host" >&5
 $as_echo "$ac_cv_host" >&6; }
 case $ac_cv_host in
 *-*-*) ;;
-*) { { $as_echo "$as_me:$LINENO: error: invalid value of canonical host" >&5
-$as_echo "$as_me: error: invalid value of canonical host" >&2;}
-   { (exit 1); exit 1; }; };;
+*) as_fn_error "invalid value of canonical host" "$LINENO" 5;;
 esac
 host=$ac_cv_host
 ac_save_IFS=$IFS; IFS='-'
@@ -5497,9 +5232,9 @@ IFS=$ac_save_IFS
 case $host_os in *\ *) host_os=`echo "$host_os" | sed 's/ /-/g'`;; esac
 
 
-{ $as_echo "$as_me:$LINENO: checking for a sed that does not truncate output" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for a sed that does not truncate output" >&5
 $as_echo_n "checking for a sed that does not truncate output... " >&6; }
-if test "${ac_cv_path_SED+set}" = set; then
+if test "${ac_cv_path_SED+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
             ac_script=s/aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa/bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb/
@@ -5507,7 +5242,7 @@ else
        ac_script="$ac_script$as_nl$ac_script"
      done
      echo "$ac_script" 2>/dev/null | sed 99q >conftest.sed
-     $as_unset ac_script || ac_script=
+     { ac_script=; unset ac_script;}
      if test -z "$SED"; then
   ac_path_SED_found=false
   # Loop through the user's path and test for each of PROGNAME-LIST
@@ -5516,7 +5251,7 @@ for as_dir in $PATH
 do
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
-  for ac_prog in sed gsed; do
+    for ac_prog in sed gsed; do
     for ac_exec_ext in '' $ac_executable_extensions; do
       ac_path_SED="$as_dir/$ac_prog$ac_exec_ext"
       { test -f "$ac_path_SED" && $as_test_x "$ac_path_SED"; } || continue
@@ -5536,7 +5271,7 @@ case `"$ac_path_SED" --version 2>&1` in
     $as_echo '' >> "conftest.nl"
     "$ac_path_SED" -f conftest.sed < "conftest.nl" >"conftest.out" 2>/dev/null || break
     diff "conftest.out" "conftest.nl" >/dev/null 2>&1 || break
-    ac_count=`expr $ac_count + 1`
+    as_fn_arith $ac_count + 1 && ac_count=$as_val
     if test $ac_count -gt ${ac_path_SED_max-0}; then
       # Best one so far, save it but keep looking for a better one
       ac_cv_path_SED="$ac_path_SED"
@@ -5551,19 +5286,17 @@ esac
       $ac_path_SED_found && break 3
     done
   done
-done
+  done
 IFS=$as_save_IFS
   if test -z "$ac_cv_path_SED"; then
-    { { $as_echo "$as_me:$LINENO: error: no acceptable sed could be found in \$PATH" >&5
-$as_echo "$as_me: error: no acceptable sed could be found in \$PATH" >&2;}
-   { (exit 1); exit 1; }; }
+    as_fn_error "no acceptable sed could be found in \$PATH" "$LINENO" 5
   fi
 else
   ac_cv_path_SED=$SED
 fi
 
 fi
-{ $as_echo "$as_me:$LINENO: result: $ac_cv_path_SED" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_path_SED" >&5
 $as_echo "$ac_cv_path_SED" >&6; }
  SED="$ac_cv_path_SED"
   rm -f conftest.sed
@@ -5581,9 +5314,9 @@ Xsed="$SED -e 1s/^X//"
 
 
 
-{ $as_echo "$as_me:$LINENO: checking for fgrep" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for fgrep" >&5
 $as_echo_n "checking for fgrep... " >&6; }
-if test "${ac_cv_path_FGREP+set}" = set; then
+if test "${ac_cv_path_FGREP+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   if echo 'ab*c' | $GREP -F 'ab*c' >/dev/null 2>&1
@@ -5597,7 +5330,7 @@ for as_dir in $PATH$PATH_SEPARATOR/usr/x
 do
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
-  for ac_prog in fgrep; do
+    for ac_prog in fgrep; do
     for ac_exec_ext in '' $ac_executable_extensions; do
       ac_path_FGREP="$as_dir/$ac_prog$ac_exec_ext"
       { test -f "$ac_path_FGREP" && $as_test_x "$ac_path_FGREP"; } || continue
@@ -5617,7 +5350,7 @@ case `"$ac_path_FGREP" --version 2>&1` i
     $as_echo 'FGREP' >> "conftest.nl"
     "$ac_path_FGREP" FGREP < "conftest.nl" >"conftest.out" 2>/dev/null || break
     diff "conftest.out" "conftest.nl" >/dev/null 2>&1 || break
-    ac_count=`expr $ac_count + 1`
+    as_fn_arith $ac_count + 1 && ac_count=$as_val
     if test $ac_count -gt ${ac_path_FGREP_max-0}; then
       # Best one so far, save it but keep looking for a better one
       ac_cv_path_FGREP="$ac_path_FGREP"
@@ -5632,12 +5365,10 @@ esac
       $ac_path_FGREP_found && break 3
     done
   done
-done
+  done
 IFS=$as_save_IFS
   if test -z "$ac_cv_path_FGREP"; then
-    { { $as_echo "$as_me:$LINENO: error: no acceptable fgrep could be found in $PATH$PATH_SEPARATOR/usr/xpg4/bin" >&5
-$as_echo "$as_me: error: no acceptable fgrep could be found in $PATH$PATH_SEPARATOR/usr/xpg4/bin" >&2;}
-   { (exit 1); exit 1; }; }
+    as_fn_error "no acceptable fgrep could be found in $PATH$PATH_SEPARATOR/usr/xpg4/bin" "$LINENO" 5
   fi
 else
   ac_cv_path_FGREP=$FGREP
@@ -5645,7 +5376,7 @@ fi
 
    fi
 fi
-{ $as_echo "$as_me:$LINENO: result: $ac_cv_path_FGREP" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_path_FGREP" >&5
 $as_echo "$ac_cv_path_FGREP" >&6; }
  FGREP="$ac_cv_path_FGREP"
 
@@ -5671,7 +5402,7 @@ test -z "$GREP" && GREP=grep
 
 
 # Check whether --with-gnu-ld was given.
-if test "${with_gnu_ld+set}" = set; then
+if test "${with_gnu_ld+set}" = set; then :
   withval=$with_gnu_ld; test "$withval" = no || with_gnu_ld=yes
 else
   with_gnu_ld=no
@@ -5680,7 +5411,7 @@ fi
 ac_prog=ld
 if test "$GCC" = yes; then
   # Check if gcc -print-prog-name=ld gives a path.
-  { $as_echo "$as_me:$LINENO: checking for ld used by $CC" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for ld used by $CC" >&5
 $as_echo_n "checking for ld used by $CC... " >&6; }
   case $host in
   *-*-mingw*)
@@ -5710,13 +5441,13 @@ $as_echo_n "checking for ld used by $CC.
     ;;
   esac
 elif test "$with_gnu_ld" = yes; then
-  { $as_echo "$as_me:$LINENO: checking for GNU ld" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for GNU ld" >&5
 $as_echo_n "checking for GNU ld... " >&6; }
 else
-  { $as_echo "$as_me:$LINENO: checking for non-GNU ld" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for non-GNU ld" >&5
 $as_echo_n "checking for non-GNU ld... " >&6; }
 fi
-if test "${lt_cv_path_LD+set}" = set; then
+if test "${lt_cv_path_LD+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   if test -z "$LD"; then
@@ -5747,18 +5478,16 @@ fi
 
 LD="$lt_cv_path_LD"
 if test -n "$LD"; then
-  { $as_echo "$as_me:$LINENO: result: $LD" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $LD" >&5
 $as_echo "$LD" >&6; }
 else
-  { $as_echo "$as_me:$LINENO: result: no" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
 $as_echo "no" >&6; }
 fi
-test -z "$LD" && { { $as_echo "$as_me:$LINENO: error: no acceptable ld found in \$PATH" >&5
-$as_echo "$as_me: error: no acceptable ld found in \$PATH" >&2;}
-   { (exit 1); exit 1; }; }
-{ $as_echo "$as_me:$LINENO: checking if the linker ($LD) is GNU ld" >&5
+test -z "$LD" && as_fn_error "no acceptable ld found in \$PATH" "$LINENO" 5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking if the linker ($LD) is GNU ld" >&5
 $as_echo_n "checking if the linker ($LD) is GNU ld... " >&6; }
-if test "${lt_cv_prog_gnu_ld+set}" = set; then
+if test "${lt_cv_prog_gnu_ld+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   # I'd rather use --version here, but apparently some GNU lds only accept -v.
@@ -5771,7 +5500,7 @@ case `$LD -v 2>&1 </dev/null` in
   ;;
 esac
 fi
-{ $as_echo "$as_me:$LINENO: result: $lt_cv_prog_gnu_ld" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_prog_gnu_ld" >&5
 $as_echo "$lt_cv_prog_gnu_ld" >&6; }
 with_gnu_ld=$lt_cv_prog_gnu_ld
 
@@ -5783,9 +5512,9 @@ with_gnu_ld=$lt_cv_prog_gnu_ld
 
 
 
-{ $as_echo "$as_me:$LINENO: checking for BSD- or MS-compatible name lister (nm)" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for BSD- or MS-compatible name lister (nm)" >&5
 $as_echo_n "checking for BSD- or MS-compatible name lister (nm)... " >&6; }
-if test "${lt_cv_path_NM+set}" = set; then
+if test "${lt_cv_path_NM+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   if test -n "$NM"; then
@@ -5832,7 +5561,7 @@ else
   : ${lt_cv_path_NM=no}
 fi
 fi
-{ $as_echo "$as_me:$LINENO: result: $lt_cv_path_NM" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_path_NM" >&5
 $as_echo "$lt_cv_path_NM" >&6; }
 if test "$lt_cv_path_NM" != "no"; then
   NM="$lt_cv_path_NM"
@@ -5843,9 +5572,9 @@ else
   do
     # Extract the first word of "$ac_tool_prefix$ac_prog", so it can be a program name with args.
 set dummy $ac_tool_prefix$ac_prog; ac_word=$2
-{ $as_echo "$as_me:$LINENO: checking for $ac_word" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
 $as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_prog_DUMPBIN+set}" = set; then
+if test "${ac_cv_prog_DUMPBIN+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   if test -n "$DUMPBIN"; then
@@ -5856,24 +5585,24 @@ for as_dir in $PATH
 do
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
-  for ac_exec_ext in '' $ac_executable_extensions; do
+    for ac_exec_ext in '' $ac_executable_extensions; do
   if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
     ac_cv_prog_DUMPBIN="$ac_tool_prefix$ac_prog"
-    $as_echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
   fi
 done
-done
+  done
 IFS=$as_save_IFS
 
 fi
 fi
 DUMPBIN=$ac_cv_prog_DUMPBIN
 if test -n "$DUMPBIN"; then
-  { $as_echo "$as_me:$LINENO: result: $DUMPBIN" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $DUMPBIN" >&5
 $as_echo "$DUMPBIN" >&6; }
 else
-  { $as_echo "$as_me:$LINENO: result: no" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
 $as_echo "no" >&6; }
 fi
 
@@ -5887,9 +5616,9 @@ if test -z "$DUMPBIN"; then
 do
   # Extract the first word of "$ac_prog", so it can be a program name with args.
 set dummy $ac_prog; ac_word=$2
-{ $as_echo "$as_me:$LINENO: checking for $ac_word" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
 $as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_prog_ac_ct_DUMPBIN+set}" = set; then
+if test "${ac_cv_prog_ac_ct_DUMPBIN+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   if test -n "$ac_ct_DUMPBIN"; then
@@ -5900,24 +5629,24 @@ for as_dir in $PATH
 do
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
-  for ac_exec_ext in '' $ac_executable_extensions; do
+    for ac_exec_ext in '' $ac_executable_extensions; do
   if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
     ac_cv_prog_ac_ct_DUMPBIN="$ac_prog"
-    $as_echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
   fi
 done
-done
+  done
 IFS=$as_save_IFS
 
 fi
 fi
 ac_ct_DUMPBIN=$ac_cv_prog_ac_ct_DUMPBIN
 if test -n "$ac_ct_DUMPBIN"; then
-  { $as_echo "$as_me:$LINENO: result: $ac_ct_DUMPBIN" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_DUMPBIN" >&5
 $as_echo "$ac_ct_DUMPBIN" >&6; }
 else
-  { $as_echo "$as_me:$LINENO: result: no" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
 $as_echo "no" >&6; }
 fi
 
@@ -5930,7 +5659,7 @@ done
   else
     case $cross_compiling:$ac_tool_warned in
 yes:)
-{ $as_echo "$as_me:$LINENO: WARNING: using cross tools not prefixed with host triplet" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
 $as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
 ac_tool_warned=yes ;;
 esac
@@ -5950,44 +5679,44 @@ test -z "$NM" && NM=nm
 
 
 
-{ $as_echo "$as_me:$LINENO: checking the name lister ($NM) interface" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking the name lister ($NM) interface" >&5
 $as_echo_n "checking the name lister ($NM) interface... " >&6; }
-if test "${lt_cv_nm_interface+set}" = set; then
+if test "${lt_cv_nm_interface+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   lt_cv_nm_interface="BSD nm"
   echo "int some_variable = 0;" > conftest.$ac_ext
-  (eval echo "\"\$as_me:5960: $ac_compile\"" >&5)
+  (eval echo "\"\$as_me:5677: $ac_compile\"" >&5)
   (eval "$ac_compile" 2>conftest.err)
   cat conftest.err >&5
-  (eval echo "\"\$as_me:5963: $NM \\\"conftest.$ac_objext\\\"\"" >&5)
+  (eval echo "\"\$as_me:5680: $NM \\\"conftest.$ac_objext\\\"\"" >&5)
   (eval "$NM \"conftest.$ac_objext\"" 2>conftest.err > conftest.out)
   cat conftest.err >&5
-  (eval echo "\"\$as_me:5966: output\"" >&5)
+  (eval echo "\"\$as_me:5683: output\"" >&5)
   cat conftest.out >&5
   if $GREP 'External.*some_variable' conftest.out > /dev/null; then
     lt_cv_nm_interface="MS dumpbin"
   fi
   rm -f conftest*
 fi
-{ $as_echo "$as_me:$LINENO: result: $lt_cv_nm_interface" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_nm_interface" >&5
 $as_echo "$lt_cv_nm_interface" >&6; }
 
-{ $as_echo "$as_me:$LINENO: checking whether ln -s works" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether ln -s works" >&5
 $as_echo_n "checking whether ln -s works... " >&6; }
 LN_S=$as_ln_s
 if test "$LN_S" = "ln -s"; then
-  { $as_echo "$as_me:$LINENO: result: yes" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
 $as_echo "yes" >&6; }
 else
-  { $as_echo "$as_me:$LINENO: result: no, using $LN_S" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no, using $LN_S" >&5
 $as_echo "no, using $LN_S" >&6; }
 fi
 
 # find the maximum length of command line arguments
-{ $as_echo "$as_me:$LINENO: checking the maximum length of command line arguments" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking the maximum length of command line arguments" >&5
 $as_echo_n "checking the maximum length of command line arguments... " >&6; }
-if test "${lt_cv_sys_max_cmd_len+set}" = set; then
+if test "${lt_cv_sys_max_cmd_len+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
     i=0
@@ -6105,10 +5834,10 @@ else
 fi
 
 if test -n $lt_cv_sys_max_cmd_len ; then
-  { $as_echo "$as_me:$LINENO: result: $lt_cv_sys_max_cmd_len" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_sys_max_cmd_len" >&5
 $as_echo "$lt_cv_sys_max_cmd_len" >&6; }
 else
-  { $as_echo "$as_me:$LINENO: result: none" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: none" >&5
 $as_echo "none" >&6; }
 fi
 max_cmd_len=$lt_cv_sys_max_cmd_len
@@ -6122,7 +5851,7 @@ max_cmd_len=$lt_cv_sys_max_cmd_len
 : ${MV="mv -f"}
 : ${RM="rm -f"}
 
-{ $as_echo "$as_me:$LINENO: checking whether the shell understands some XSI constructs" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the shell understands some XSI constructs" >&5
 $as_echo_n "checking whether the shell understands some XSI constructs... " >&6; }
 # Try some XSI features
 xsi_shell=no
@@ -6132,17 +5861,17 @@ xsi_shell=no
     && eval 'test $(( 1 + 1 )) -eq 2 \
     && test "${#_lt_dummy}" -eq 5' ) >/dev/null 2>&1 \
   && xsi_shell=yes
-{ $as_echo "$as_me:$LINENO: result: $xsi_shell" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $xsi_shell" >&5
 $as_echo "$xsi_shell" >&6; }
 
 
-{ $as_echo "$as_me:$LINENO: checking whether the shell understands \"+=\"" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the shell understands \"+=\"" >&5
 $as_echo_n "checking whether the shell understands \"+=\"... " >&6; }
 lt_shell_append=no
 ( foo=bar; set foo baz; eval "$1+=\$2" && test "$foo" = barbaz ) \
     >/dev/null 2>&1 \
   && lt_shell_append=yes
-{ $as_echo "$as_me:$LINENO: result: $lt_shell_append" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_shell_append" >&5
 $as_echo "$lt_shell_append" >&6; }
 
 
@@ -6177,14 +5906,14 @@ esac
 
 
 
-{ $as_echo "$as_me:$LINENO: checking for $LD option to reload object files" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $LD option to reload object files" >&5
 $as_echo_n "checking for $LD option to reload object files... " >&6; }
-if test "${lt_cv_ld_reload_flag+set}" = set; then
+if test "${lt_cv_ld_reload_flag+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   lt_cv_ld_reload_flag='-r'
 fi
-{ $as_echo "$as_me:$LINENO: result: $lt_cv_ld_reload_flag" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_ld_reload_flag" >&5
 $as_echo "$lt_cv_ld_reload_flag" >&6; }
 reload_flag=$lt_cv_ld_reload_flag
 case $reload_flag in
@@ -6213,9 +5942,9 @@ esac
 if test -n "$ac_tool_prefix"; then
   # Extract the first word of "${ac_tool_prefix}objdump", so it can be a program name with args.
 set dummy ${ac_tool_prefix}objdump; ac_word=$2
-{ $as_echo "$as_me:$LINENO: checking for $ac_word" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
 $as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_prog_OBJDUMP+set}" = set; then
+if test "${ac_cv_prog_OBJDUMP+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   if test -n "$OBJDUMP"; then
@@ -6226,24 +5955,24 @@ for as_dir in $PATH
 do
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
-  for ac_exec_ext in '' $ac_executable_extensions; do
+    for ac_exec_ext in '' $ac_executable_extensions; do
   if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
     ac_cv_prog_OBJDUMP="${ac_tool_prefix}objdump"
-    $as_echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
   fi
 done
-done
+  done
 IFS=$as_save_IFS
 
 fi
 fi
 OBJDUMP=$ac_cv_prog_OBJDUMP
 if test -n "$OBJDUMP"; then
-  { $as_echo "$as_me:$LINENO: result: $OBJDUMP" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $OBJDUMP" >&5
 $as_echo "$OBJDUMP" >&6; }
 else
-  { $as_echo "$as_me:$LINENO: result: no" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
 $as_echo "no" >&6; }
 fi
 
@@ -6253,9 +5982,9 @@ if test -z "$ac_cv_prog_OBJDUMP"; then
   ac_ct_OBJDUMP=$OBJDUMP
   # Extract the first word of "objdump", so it can be a program name with args.
 set dummy objdump; ac_word=$2
-{ $as_echo "$as_me:$LINENO: checking for $ac_word" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
 $as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_prog_ac_ct_OBJDUMP+set}" = set; then
+if test "${ac_cv_prog_ac_ct_OBJDUMP+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   if test -n "$ac_ct_OBJDUMP"; then
@@ -6266,24 +5995,24 @@ for as_dir in $PATH
 do
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
-  for ac_exec_ext in '' $ac_executable_extensions; do
+    for ac_exec_ext in '' $ac_executable_extensions; do
   if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
     ac_cv_prog_ac_ct_OBJDUMP="objdump"
-    $as_echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
   fi
 done
-done
+  done
 IFS=$as_save_IFS
 
 fi
 fi
 ac_ct_OBJDUMP=$ac_cv_prog_ac_ct_OBJDUMP
 if test -n "$ac_ct_OBJDUMP"; then
-  { $as_echo "$as_me:$LINENO: result: $ac_ct_OBJDUMP" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_OBJDUMP" >&5
 $as_echo "$ac_ct_OBJDUMP" >&6; }
 else
-  { $as_echo "$as_me:$LINENO: result: no" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
 $as_echo "no" >&6; }
 fi
 
@@ -6292,7 +6021,7 @@ fi
   else
     case $cross_compiling:$ac_tool_warned in
 yes:)
-{ $as_echo "$as_me:$LINENO: WARNING: using cross tools not prefixed with host triplet" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
 $as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
 ac_tool_warned=yes ;;
 esac
@@ -6312,9 +6041,9 @@ test -z "$OBJDUMP" && OBJDUMP=objdump
 
 
 
-{ $as_echo "$as_me:$LINENO: checking how to recognize dependent libraries" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking how to recognize dependent libraries" >&5
 $as_echo_n "checking how to recognize dependent libraries... " >&6; }
-if test "${lt_cv_deplibs_check_method+set}" = set; then
+if test "${lt_cv_deplibs_check_method+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   lt_cv_file_magic_cmd='$MAGIC_CMD'
@@ -6433,7 +6162,7 @@ linux* | k*bsd*-gnu)
   lt_cv_deplibs_check_method=pass_all
   ;;
 
-netbsd*)
+netbsd* | netbsdelf*-gnu)
   if echo __ELF__ | $CC -E - | $GREP __ELF__ > /dev/null; then
     lt_cv_deplibs_check_method='match_pattern /lib[^/]+(\.so\.[0-9]+\.[0-9]+|_pic\.a)$'
   else
@@ -6508,7 +6237,7 @@ tpf*)
 esac
 
 fi
-{ $as_echo "$as_me:$LINENO: result: $lt_cv_deplibs_check_method" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_deplibs_check_method" >&5
 $as_echo "$lt_cv_deplibs_check_method" >&6; }
 file_magic_cmd=$lt_cv_file_magic_cmd
 deplibs_check_method=$lt_cv_deplibs_check_method
@@ -6528,9 +6257,9 @@ test -z "$deplibs_check_method" && depli
 if test -n "$ac_tool_prefix"; then
   # Extract the first word of "${ac_tool_prefix}ar", so it can be a program name with args.
 set dummy ${ac_tool_prefix}ar; ac_word=$2
-{ $as_echo "$as_me:$LINENO: checking for $ac_word" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
 $as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_prog_AR+set}" = set; then
+if test "${ac_cv_prog_AR+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   if test -n "$AR"; then
@@ -6541,24 +6270,24 @@ for as_dir in $PATH
 do
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
-  for ac_exec_ext in '' $ac_executable_extensions; do
+    for ac_exec_ext in '' $ac_executable_extensions; do
   if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
     ac_cv_prog_AR="${ac_tool_prefix}ar"
-    $as_echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
   fi
 done
-done
+  done
 IFS=$as_save_IFS
 
 fi
 fi
 AR=$ac_cv_prog_AR
 if test -n "$AR"; then
-  { $as_echo "$as_me:$LINENO: result: $AR" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $AR" >&5
 $as_echo "$AR" >&6; }
 else
-  { $as_echo "$as_me:$LINENO: result: no" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
 $as_echo "no" >&6; }
 fi
 
@@ -6568,9 +6297,9 @@ if test -z "$ac_cv_prog_AR"; then
   ac_ct_AR=$AR
   # Extract the first word of "ar", so it can be a program name with args.
 set dummy ar; ac_word=$2
-{ $as_echo "$as_me:$LINENO: checking for $ac_word" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
 $as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_prog_ac_ct_AR+set}" = set; then
+if test "${ac_cv_prog_ac_ct_AR+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   if test -n "$ac_ct_AR"; then
@@ -6581,24 +6310,24 @@ for as_dir in $PATH
 do
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
-  for ac_exec_ext in '' $ac_executable_extensions; do
+    for ac_exec_ext in '' $ac_executable_extensions; do
   if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
     ac_cv_prog_ac_ct_AR="ar"
-    $as_echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
   fi
 done
-done
+  done
 IFS=$as_save_IFS
 
 fi
 fi
 ac_ct_AR=$ac_cv_prog_ac_ct_AR
 if test -n "$ac_ct_AR"; then
-  { $as_echo "$as_me:$LINENO: result: $ac_ct_AR" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_AR" >&5
 $as_echo "$ac_ct_AR" >&6; }
 else
-  { $as_echo "$as_me:$LINENO: result: no" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
 $as_echo "no" >&6; }
 fi
 
@@ -6607,7 +6336,7 @@ fi
   else
     case $cross_compiling:$ac_tool_warned in
 yes:)
-{ $as_echo "$as_me:$LINENO: WARNING: using cross tools not prefixed with host triplet" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
 $as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
 ac_tool_warned=yes ;;
 esac
@@ -6633,9 +6362,9 @@ test -z "$AR_FLAGS" && AR_FLAGS=cru
 if test -n "$ac_tool_prefix"; then
   # Extract the first word of "${ac_tool_prefix}strip", so it can be a program name with args.
 set dummy ${ac_tool_prefix}strip; ac_word=$2
-{ $as_echo "$as_me:$LINENO: checking for $ac_word" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
 $as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_prog_STRIP+set}" = set; then
+if test "${ac_cv_prog_STRIP+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   if test -n "$STRIP"; then
@@ -6646,24 +6375,24 @@ for as_dir in $PATH
 do
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
-  for ac_exec_ext in '' $ac_executable_extensions; do
+    for ac_exec_ext in '' $ac_executable_extensions; do
   if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
     ac_cv_prog_STRIP="${ac_tool_prefix}strip"
-    $as_echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
   fi
 done
-done
+  done
 IFS=$as_save_IFS
 
 fi
 fi
 STRIP=$ac_cv_prog_STRIP
 if test -n "$STRIP"; then
-  { $as_echo "$as_me:$LINENO: result: $STRIP" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $STRIP" >&5
 $as_echo "$STRIP" >&6; }
 else
-  { $as_echo "$as_me:$LINENO: result: no" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
 $as_echo "no" >&6; }
 fi
 
@@ -6673,9 +6402,9 @@ if test -z "$ac_cv_prog_STRIP"; then
   ac_ct_STRIP=$STRIP
   # Extract the first word of "strip", so it can be a program name with args.
 set dummy strip; ac_word=$2
-{ $as_echo "$as_me:$LINENO: checking for $ac_word" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
 $as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_prog_ac_ct_STRIP+set}" = set; then
+if test "${ac_cv_prog_ac_ct_STRIP+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   if test -n "$ac_ct_STRIP"; then
@@ -6686,24 +6415,24 @@ for as_dir in $PATH
 do
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
-  for ac_exec_ext in '' $ac_executable_extensions; do
+    for ac_exec_ext in '' $ac_executable_extensions; do
   if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
     ac_cv_prog_ac_ct_STRIP="strip"
-    $as_echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
   fi
 done
-done
+  done
 IFS=$as_save_IFS
 
 fi
 fi
 ac_ct_STRIP=$ac_cv_prog_ac_ct_STRIP
 if test -n "$ac_ct_STRIP"; then
-  { $as_echo "$as_me:$LINENO: result: $ac_ct_STRIP" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_STRIP" >&5
 $as_echo "$ac_ct_STRIP" >&6; }
 else
-  { $as_echo "$as_me:$LINENO: result: no" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
 $as_echo "no" >&6; }
 fi
 
@@ -6712,7 +6441,7 @@ fi
   else
     case $cross_compiling:$ac_tool_warned in
 yes:)
-{ $as_echo "$as_me:$LINENO: WARNING: using cross tools not prefixed with host triplet" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
 $as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
 ac_tool_warned=yes ;;
 esac
@@ -6732,9 +6461,9 @@ test -z "$STRIP" && STRIP=:
 if test -n "$ac_tool_prefix"; then
   # Extract the first word of "${ac_tool_prefix}ranlib", so it can be a program name with args.
 set dummy ${ac_tool_prefix}ranlib; ac_word=$2
-{ $as_echo "$as_me:$LINENO: checking for $ac_word" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
 $as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_prog_RANLIB+set}" = set; then
+if test "${ac_cv_prog_RANLIB+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   if test -n "$RANLIB"; then
@@ -6745,24 +6474,24 @@ for as_dir in $PATH
 do
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
-  for ac_exec_ext in '' $ac_executable_extensions; do
+    for ac_exec_ext in '' $ac_executable_extensions; do
   if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
     ac_cv_prog_RANLIB="${ac_tool_prefix}ranlib"
-    $as_echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
   fi
 done
-done
+  done
 IFS=$as_save_IFS
 
 fi
 fi
 RANLIB=$ac_cv_prog_RANLIB
 if test -n "$RANLIB"; then
-  { $as_echo "$as_me:$LINENO: result: $RANLIB" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $RANLIB" >&5
 $as_echo "$RANLIB" >&6; }
 else
-  { $as_echo "$as_me:$LINENO: result: no" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
 $as_echo "no" >&6; }
 fi
 
@@ -6772,9 +6501,9 @@ if test -z "$ac_cv_prog_RANLIB"; then
   ac_ct_RANLIB=$RANLIB
   # Extract the first word of "ranlib", so it can be a program name with args.
 set dummy ranlib; ac_word=$2
-{ $as_echo "$as_me:$LINENO: checking for $ac_word" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
 $as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_prog_ac_ct_RANLIB+set}" = set; then
+if test "${ac_cv_prog_ac_ct_RANLIB+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   if test -n "$ac_ct_RANLIB"; then
@@ -6785,24 +6514,24 @@ for as_dir in $PATH
 do
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
-  for ac_exec_ext in '' $ac_executable_extensions; do
+    for ac_exec_ext in '' $ac_executable_extensions; do
   if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
     ac_cv_prog_ac_ct_RANLIB="ranlib"
-    $as_echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
   fi
 done
-done
+  done
 IFS=$as_save_IFS
 
 fi
 fi
 ac_ct_RANLIB=$ac_cv_prog_ac_ct_RANLIB
 if test -n "$ac_ct_RANLIB"; then
-  { $as_echo "$as_me:$LINENO: result: $ac_ct_RANLIB" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_RANLIB" >&5
 $as_echo "$ac_ct_RANLIB" >&6; }
 else
-  { $as_echo "$as_me:$LINENO: result: no" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
 $as_echo "no" >&6; }
 fi
 
@@ -6811,7 +6540,7 @@ fi
   else
     case $cross_compiling:$ac_tool_warned in
 yes:)
-{ $as_echo "$as_me:$LINENO: WARNING: using cross tools not prefixed with host triplet" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
 $as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
 ac_tool_warned=yes ;;
 esac
@@ -6889,9 +6618,9 @@ compiler=$CC
 
 
 # Check for command to grab the raw symbol name followed by C symbol from nm.
-{ $as_echo "$as_me:$LINENO: checking command to parse $NM output from $compiler object" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking command to parse $NM output from $compiler object" >&5
 $as_echo_n "checking command to parse $NM output from $compiler object... " >&6; }
-if test "${lt_cv_sys_global_symbol_pipe+set}" = set; then
+if test "${lt_cv_sys_global_symbol_pipe+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
 
@@ -7007,18 +6736,18 @@ void nm_test_func(void){}
 int main(){nm_test_var='a';nm_test_func();return(0);}
 _LT_EOF
 
-  if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  if { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_compile\""; } >&5
   (eval $ac_compile) 2>&5
   ac_status=$?
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; then
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }; then
     # Now try to grab the symbols.
     nlist=conftest.nm
-    if { (eval echo "$as_me:$LINENO: \"$NM conftest.$ac_objext \| $lt_cv_sys_global_symbol_pipe \> $nlist\"") >&5
+    if { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$NM conftest.$ac_objext \| $lt_cv_sys_global_symbol_pipe \> $nlist\""; } >&5
   (eval $NM conftest.$ac_objext \| $lt_cv_sys_global_symbol_pipe \> $nlist) 2>&5
   ac_status=$?
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && test -s "$nlist"; then
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; } && test -s "$nlist"; then
       # Try sorting and uniquifying the output.
       if sort "$nlist" | uniq > "$nlist"T; then
 	mv -f "$nlist"T "$nlist"
@@ -7071,11 +6800,11 @@ _LT_EOF
 	  lt_save_CFLAGS="$CFLAGS"
 	  LIBS="conftstm.$ac_objext"
 	  CFLAGS="$CFLAGS$lt_prog_compiler_no_builtin_flag"
-	  if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+	  if { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_link\""; } >&5
   (eval $ac_link) 2>&5
   ac_status=$?
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && test -s conftest${ac_exeext}; then
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; } && test -s conftest${ac_exeext}; then
 	    pipe_works=yes
 	  fi
 	  LIBS="$lt_save_LIBS"
@@ -7109,10 +6838,10 @@ if test -z "$lt_cv_sys_global_symbol_pip
   lt_cv_sys_global_symbol_to_cdecl=
 fi
 if test -z "$lt_cv_sys_global_symbol_pipe$lt_cv_sys_global_symbol_to_cdecl"; then
-  { $as_echo "$as_me:$LINENO: result: failed" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: failed" >&5
 $as_echo "failed" >&6; }
 else
-  { $as_echo "$as_me:$LINENO: result: ok" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: ok" >&5
 $as_echo "ok" >&6; }
 fi
 
@@ -7138,7 +6867,7 @@ fi
 
 
 # Check whether --enable-libtool-lock was given.
-if test "${enable_libtool_lock+set}" = set; then
+if test "${enable_libtool_lock+set}" = set; then :
   enableval=$enable_libtool_lock;
 fi
 
@@ -7150,11 +6879,11 @@ case $host in
 ia64-*-hpux*)
   # Find out which ABI we are using.
   echo 'int i;' > conftest.$ac_ext
-  if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  if { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_compile\""; } >&5
   (eval $ac_compile) 2>&5
   ac_status=$?
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; then
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }; then
     case `/usr/bin/file conftest.$ac_objext` in
       *ELF-32*)
 	HPUX_IA64_MODE="32"
@@ -7168,12 +6897,12 @@ ia64-*-hpux*)
   ;;
 *-*-irix6*)
   # Find out which ABI we are using.
-  echo '#line 7171 "configure"' > conftest.$ac_ext
-  if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  echo '#line 6888 "configure"' > conftest.$ac_ext
+  if { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_compile\""; } >&5
   (eval $ac_compile) 2>&5
   ac_status=$?
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; then
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }; then
     if test "$lt_cv_prog_gnu_ld" = yes; then
       case `/usr/bin/file conftest.$ac_objext` in
 	*32-bit*)
@@ -7207,11 +6936,11 @@ x86_64-*kfreebsd*-gnu|x86_64-*linux*|ppc
 s390*-*linux*|s390*-*tpf*|sparc*-*linux*)
   # Find out which ABI we are using.
   echo 'int i;' > conftest.$ac_ext
-  if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  if { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_compile\""; } >&5
   (eval $ac_compile) 2>&5
   ac_status=$?
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; then
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }; then
     case `/usr/bin/file conftest.o` in
       *32-bit*)
 	case $host in
@@ -7260,9 +6989,9 @@ s390*-*linux*|s390*-*tpf*|sparc*-*linux*
   # On SCO OpenServer 5, we need -belf to get full-featured binaries.
   SAVE_CFLAGS="$CFLAGS"
   CFLAGS="$CFLAGS -belf"
-  { $as_echo "$as_me:$LINENO: checking whether the C compiler needs -belf" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the C compiler needs -belf" >&5
 $as_echo_n "checking whether the C compiler needs -belf... " >&6; }
-if test "${lt_cv_cc_needs_belf+set}" = set; then
+if test "${lt_cv_cc_needs_belf+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   ac_ext=c
@@ -7271,11 +7000,7 @@ ac_compile='$CC -c $CFLAGS $CPPFLAGS con
 ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
 ac_compiler_gnu=$ac_cv_c_compiler_gnu
 
-     cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
+     cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 
 int
@@ -7286,38 +7011,13 @@ main ()
   return 0;
 }
 _ACEOF
-rm -f conftest.$ac_objext conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_link") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest$ac_exeext && {
-	 test "$cross_compiling" = yes ||
-	 $as_test_x conftest$ac_exeext
-       }; then
+if ac_fn_c_try_link "$LINENO"; then :
   lt_cv_cc_needs_belf=yes
 else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	lt_cv_cc_needs_belf=no
+  lt_cv_cc_needs_belf=no
 fi
-
-rm -rf conftest.dSYM
-rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
-      conftest$ac_exeext conftest.$ac_ext
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
      ac_ext=c
 ac_cpp='$CPP $CPPFLAGS'
 ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
@@ -7325,7 +7025,7 @@ ac_link='$CC -o conftest$ac_exeext $CFLA
 ac_compiler_gnu=$ac_cv_c_compiler_gnu
 
 fi
-{ $as_echo "$as_me:$LINENO: result: $lt_cv_cc_needs_belf" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_cc_needs_belf" >&5
 $as_echo "$lt_cv_cc_needs_belf" >&6; }
   if test x"$lt_cv_cc_needs_belf" != x"yes"; then
     # this is probably gcc 2.8.0, egcs 1.0 or newer; no need for -belf
@@ -7335,11 +7035,11 @@ $as_echo "$lt_cv_cc_needs_belf" >&6; }
 sparc*-*solaris*)
   # Find out which ABI we are using.
   echo 'int i;' > conftest.$ac_ext
-  if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  if { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_compile\""; } >&5
   (eval $ac_compile) 2>&5
   ac_status=$?
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; then
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }; then
     case `/usr/bin/file conftest.o` in
     *64-bit*)
       case $lt_cv_prog_gnu_ld in
@@ -7365,9 +7065,9 @@ need_locks="$enable_libtool_lock"
     if test -n "$ac_tool_prefix"; then
   # Extract the first word of "${ac_tool_prefix}dsymutil", so it can be a program name with args.
 set dummy ${ac_tool_prefix}dsymutil; ac_word=$2
-{ $as_echo "$as_me:$LINENO: checking for $ac_word" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
 $as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_prog_DSYMUTIL+set}" = set; then
+if test "${ac_cv_prog_DSYMUTIL+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   if test -n "$DSYMUTIL"; then
@@ -7378,24 +7078,24 @@ for as_dir in $PATH
 do
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
-  for ac_exec_ext in '' $ac_executable_extensions; do
+    for ac_exec_ext in '' $ac_executable_extensions; do
   if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
     ac_cv_prog_DSYMUTIL="${ac_tool_prefix}dsymutil"
-    $as_echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
   fi
 done
-done
+  done
 IFS=$as_save_IFS
 
 fi
 fi
 DSYMUTIL=$ac_cv_prog_DSYMUTIL
 if test -n "$DSYMUTIL"; then
-  { $as_echo "$as_me:$LINENO: result: $DSYMUTIL" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $DSYMUTIL" >&5
 $as_echo "$DSYMUTIL" >&6; }
 else
-  { $as_echo "$as_me:$LINENO: result: no" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
 $as_echo "no" >&6; }
 fi
 
@@ -7405,9 +7105,9 @@ if test -z "$ac_cv_prog_DSYMUTIL"; then
   ac_ct_DSYMUTIL=$DSYMUTIL
   # Extract the first word of "dsymutil", so it can be a program name with args.
 set dummy dsymutil; ac_word=$2
-{ $as_echo "$as_me:$LINENO: checking for $ac_word" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
 $as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_prog_ac_ct_DSYMUTIL+set}" = set; then
+if test "${ac_cv_prog_ac_ct_DSYMUTIL+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   if test -n "$ac_ct_DSYMUTIL"; then
@@ -7418,24 +7118,24 @@ for as_dir in $PATH
 do
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
-  for ac_exec_ext in '' $ac_executable_extensions; do
+    for ac_exec_ext in '' $ac_executable_extensions; do
   if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
     ac_cv_prog_ac_ct_DSYMUTIL="dsymutil"
-    $as_echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
   fi
 done
-done
+  done
 IFS=$as_save_IFS
 
 fi
 fi
 ac_ct_DSYMUTIL=$ac_cv_prog_ac_ct_DSYMUTIL
 if test -n "$ac_ct_DSYMUTIL"; then
-  { $as_echo "$as_me:$LINENO: result: $ac_ct_DSYMUTIL" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_DSYMUTIL" >&5
 $as_echo "$ac_ct_DSYMUTIL" >&6; }
 else
-  { $as_echo "$as_me:$LINENO: result: no" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
 $as_echo "no" >&6; }
 fi
 
@@ -7444,7 +7144,7 @@ fi
   else
     case $cross_compiling:$ac_tool_warned in
 yes:)
-{ $as_echo "$as_me:$LINENO: WARNING: using cross tools not prefixed with host triplet" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
 $as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
 ac_tool_warned=yes ;;
 esac
@@ -7457,9 +7157,9 @@ fi
     if test -n "$ac_tool_prefix"; then
   # Extract the first word of "${ac_tool_prefix}nmedit", so it can be a program name with args.
 set dummy ${ac_tool_prefix}nmedit; ac_word=$2
-{ $as_echo "$as_me:$LINENO: checking for $ac_word" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
 $as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_prog_NMEDIT+set}" = set; then
+if test "${ac_cv_prog_NMEDIT+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   if test -n "$NMEDIT"; then
@@ -7470,24 +7170,24 @@ for as_dir in $PATH
 do
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
-  for ac_exec_ext in '' $ac_executable_extensions; do
+    for ac_exec_ext in '' $ac_executable_extensions; do
   if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
     ac_cv_prog_NMEDIT="${ac_tool_prefix}nmedit"
-    $as_echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
   fi
 done
-done
+  done
 IFS=$as_save_IFS
 
 fi
 fi
 NMEDIT=$ac_cv_prog_NMEDIT
 if test -n "$NMEDIT"; then
-  { $as_echo "$as_me:$LINENO: result: $NMEDIT" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $NMEDIT" >&5
 $as_echo "$NMEDIT" >&6; }
 else
-  { $as_echo "$as_me:$LINENO: result: no" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
 $as_echo "no" >&6; }
 fi
 
@@ -7497,9 +7197,9 @@ if test -z "$ac_cv_prog_NMEDIT"; then
   ac_ct_NMEDIT=$NMEDIT
   # Extract the first word of "nmedit", so it can be a program name with args.
 set dummy nmedit; ac_word=$2
-{ $as_echo "$as_me:$LINENO: checking for $ac_word" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
 $as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_prog_ac_ct_NMEDIT+set}" = set; then
+if test "${ac_cv_prog_ac_ct_NMEDIT+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   if test -n "$ac_ct_NMEDIT"; then
@@ -7510,24 +7210,24 @@ for as_dir in $PATH
 do
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
-  for ac_exec_ext in '' $ac_executable_extensions; do
+    for ac_exec_ext in '' $ac_executable_extensions; do
   if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
     ac_cv_prog_ac_ct_NMEDIT="nmedit"
-    $as_echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
   fi
 done
-done
+  done
 IFS=$as_save_IFS
 
 fi
 fi
 ac_ct_NMEDIT=$ac_cv_prog_ac_ct_NMEDIT
 if test -n "$ac_ct_NMEDIT"; then
-  { $as_echo "$as_me:$LINENO: result: $ac_ct_NMEDIT" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_NMEDIT" >&5
 $as_echo "$ac_ct_NMEDIT" >&6; }
 else
-  { $as_echo "$as_me:$LINENO: result: no" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
 $as_echo "no" >&6; }
 fi
 
@@ -7536,7 +7236,7 @@ fi
   else
     case $cross_compiling:$ac_tool_warned in
 yes:)
-{ $as_echo "$as_me:$LINENO: WARNING: using cross tools not prefixed with host triplet" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
 $as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
 ac_tool_warned=yes ;;
 esac
@@ -7549,9 +7249,9 @@ fi
     if test -n "$ac_tool_prefix"; then
   # Extract the first word of "${ac_tool_prefix}lipo", so it can be a program name with args.
 set dummy ${ac_tool_prefix}lipo; ac_word=$2
-{ $as_echo "$as_me:$LINENO: checking for $ac_word" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
 $as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_prog_LIPO+set}" = set; then
+if test "${ac_cv_prog_LIPO+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   if test -n "$LIPO"; then
@@ -7562,24 +7262,24 @@ for as_dir in $PATH
 do
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
-  for ac_exec_ext in '' $ac_executable_extensions; do
+    for ac_exec_ext in '' $ac_executable_extensions; do
   if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
     ac_cv_prog_LIPO="${ac_tool_prefix}lipo"
-    $as_echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
   fi
 done
-done
+  done
 IFS=$as_save_IFS
 
 fi
 fi
 LIPO=$ac_cv_prog_LIPO
 if test -n "$LIPO"; then
-  { $as_echo "$as_me:$LINENO: result: $LIPO" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $LIPO" >&5
 $as_echo "$LIPO" >&6; }
 else
-  { $as_echo "$as_me:$LINENO: result: no" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
 $as_echo "no" >&6; }
 fi
 
@@ -7589,9 +7289,9 @@ if test -z "$ac_cv_prog_LIPO"; then
   ac_ct_LIPO=$LIPO
   # Extract the first word of "lipo", so it can be a program name with args.
 set dummy lipo; ac_word=$2
-{ $as_echo "$as_me:$LINENO: checking for $ac_word" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
 $as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_prog_ac_ct_LIPO+set}" = set; then
+if test "${ac_cv_prog_ac_ct_LIPO+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   if test -n "$ac_ct_LIPO"; then
@@ -7602,24 +7302,24 @@ for as_dir in $PATH
 do
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
-  for ac_exec_ext in '' $ac_executable_extensions; do
+    for ac_exec_ext in '' $ac_executable_extensions; do
   if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
     ac_cv_prog_ac_ct_LIPO="lipo"
-    $as_echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
   fi
 done
-done
+  done
 IFS=$as_save_IFS
 
 fi
 fi
 ac_ct_LIPO=$ac_cv_prog_ac_ct_LIPO
 if test -n "$ac_ct_LIPO"; then
-  { $as_echo "$as_me:$LINENO: result: $ac_ct_LIPO" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_LIPO" >&5
 $as_echo "$ac_ct_LIPO" >&6; }
 else
-  { $as_echo "$as_me:$LINENO: result: no" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
 $as_echo "no" >&6; }
 fi
 
@@ -7628,7 +7328,7 @@ fi
   else
     case $cross_compiling:$ac_tool_warned in
 yes:)
-{ $as_echo "$as_me:$LINENO: WARNING: using cross tools not prefixed with host triplet" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
 $as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
 ac_tool_warned=yes ;;
 esac
@@ -7641,9 +7341,9 @@ fi
     if test -n "$ac_tool_prefix"; then
   # Extract the first word of "${ac_tool_prefix}otool", so it can be a program name with args.
 set dummy ${ac_tool_prefix}otool; ac_word=$2
-{ $as_echo "$as_me:$LINENO: checking for $ac_word" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
 $as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_prog_OTOOL+set}" = set; then
+if test "${ac_cv_prog_OTOOL+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   if test -n "$OTOOL"; then
@@ -7654,24 +7354,24 @@ for as_dir in $PATH
 do
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
-  for ac_exec_ext in '' $ac_executable_extensions; do
+    for ac_exec_ext in '' $ac_executable_extensions; do
   if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
     ac_cv_prog_OTOOL="${ac_tool_prefix}otool"
-    $as_echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
   fi
 done
-done
+  done
 IFS=$as_save_IFS
 
 fi
 fi
 OTOOL=$ac_cv_prog_OTOOL
 if test -n "$OTOOL"; then
-  { $as_echo "$as_me:$LINENO: result: $OTOOL" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $OTOOL" >&5
 $as_echo "$OTOOL" >&6; }
 else
-  { $as_echo "$as_me:$LINENO: result: no" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
 $as_echo "no" >&6; }
 fi
 
@@ -7681,9 +7381,9 @@ if test -z "$ac_cv_prog_OTOOL"; then
   ac_ct_OTOOL=$OTOOL
   # Extract the first word of "otool", so it can be a program name with args.
 set dummy otool; ac_word=$2
-{ $as_echo "$as_me:$LINENO: checking for $ac_word" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
 $as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_prog_ac_ct_OTOOL+set}" = set; then
+if test "${ac_cv_prog_ac_ct_OTOOL+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   if test -n "$ac_ct_OTOOL"; then
@@ -7694,24 +7394,24 @@ for as_dir in $PATH
 do
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
-  for ac_exec_ext in '' $ac_executable_extensions; do
+    for ac_exec_ext in '' $ac_executable_extensions; do
   if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
     ac_cv_prog_ac_ct_OTOOL="otool"
-    $as_echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
   fi
 done
-done
+  done
 IFS=$as_save_IFS
 
 fi
 fi
 ac_ct_OTOOL=$ac_cv_prog_ac_ct_OTOOL
 if test -n "$ac_ct_OTOOL"; then
-  { $as_echo "$as_me:$LINENO: result: $ac_ct_OTOOL" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_OTOOL" >&5
 $as_echo "$ac_ct_OTOOL" >&6; }
 else
-  { $as_echo "$as_me:$LINENO: result: no" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
 $as_echo "no" >&6; }
 fi
 
@@ -7720,7 +7420,7 @@ fi
   else
     case $cross_compiling:$ac_tool_warned in
 yes:)
-{ $as_echo "$as_me:$LINENO: WARNING: using cross tools not prefixed with host triplet" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
 $as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
 ac_tool_warned=yes ;;
 esac
@@ -7733,9 +7433,9 @@ fi
     if test -n "$ac_tool_prefix"; then
   # Extract the first word of "${ac_tool_prefix}otool64", so it can be a program name with args.
 set dummy ${ac_tool_prefix}otool64; ac_word=$2
-{ $as_echo "$as_me:$LINENO: checking for $ac_word" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
 $as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_prog_OTOOL64+set}" = set; then
+if test "${ac_cv_prog_OTOOL64+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   if test -n "$OTOOL64"; then
@@ -7746,24 +7446,24 @@ for as_dir in $PATH
 do
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
-  for ac_exec_ext in '' $ac_executable_extensions; do
+    for ac_exec_ext in '' $ac_executable_extensions; do
   if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
     ac_cv_prog_OTOOL64="${ac_tool_prefix}otool64"
-    $as_echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
   fi
 done
-done
+  done
 IFS=$as_save_IFS
 
 fi
 fi
 OTOOL64=$ac_cv_prog_OTOOL64
 if test -n "$OTOOL64"; then
-  { $as_echo "$as_me:$LINENO: result: $OTOOL64" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $OTOOL64" >&5
 $as_echo "$OTOOL64" >&6; }
 else
-  { $as_echo "$as_me:$LINENO: result: no" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
 $as_echo "no" >&6; }
 fi
 
@@ -7773,9 +7473,9 @@ if test -z "$ac_cv_prog_OTOOL64"; then
   ac_ct_OTOOL64=$OTOOL64
   # Extract the first word of "otool64", so it can be a program name with args.
 set dummy otool64; ac_word=$2
-{ $as_echo "$as_me:$LINENO: checking for $ac_word" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
 $as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_prog_ac_ct_OTOOL64+set}" = set; then
+if test "${ac_cv_prog_ac_ct_OTOOL64+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   if test -n "$ac_ct_OTOOL64"; then
@@ -7786,24 +7486,24 @@ for as_dir in $PATH
 do
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
-  for ac_exec_ext in '' $ac_executable_extensions; do
+    for ac_exec_ext in '' $ac_executable_extensions; do
   if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
     ac_cv_prog_ac_ct_OTOOL64="otool64"
-    $as_echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
   fi
 done
-done
+  done
 IFS=$as_save_IFS
 
 fi
 fi
 ac_ct_OTOOL64=$ac_cv_prog_ac_ct_OTOOL64
 if test -n "$ac_ct_OTOOL64"; then
-  { $as_echo "$as_me:$LINENO: result: $ac_ct_OTOOL64" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_OTOOL64" >&5
 $as_echo "$ac_ct_OTOOL64" >&6; }
 else
-  { $as_echo "$as_me:$LINENO: result: no" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
 $as_echo "no" >&6; }
 fi
 
@@ -7812,7 +7512,7 @@ fi
   else
     case $cross_compiling:$ac_tool_warned in
 yes:)
-{ $as_echo "$as_me:$LINENO: WARNING: using cross tools not prefixed with host triplet" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
 $as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
 ac_tool_warned=yes ;;
 esac
@@ -7848,9 +7548,9 @@ fi
 
 
 
-    { $as_echo "$as_me:$LINENO: checking for -single_module linker flag" >&5
+    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for -single_module linker flag" >&5
 $as_echo_n "checking for -single_module linker flag... " >&6; }
-if test "${lt_cv_apple_cc_single_mod+set}" = set; then
+if test "${lt_cv_apple_cc_single_mod+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   lt_cv_apple_cc_single_mod=no
@@ -7875,22 +7575,18 @@ else
 	rm -f conftest.*
       fi
 fi
-{ $as_echo "$as_me:$LINENO: result: $lt_cv_apple_cc_single_mod" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_apple_cc_single_mod" >&5
 $as_echo "$lt_cv_apple_cc_single_mod" >&6; }
-    { $as_echo "$as_me:$LINENO: checking for -exported_symbols_list linker flag" >&5
+    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for -exported_symbols_list linker flag" >&5
 $as_echo_n "checking for -exported_symbols_list linker flag... " >&6; }
-if test "${lt_cv_ld_exported_symbols_list+set}" = set; then
+if test "${lt_cv_ld_exported_symbols_list+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   lt_cv_ld_exported_symbols_list=no
       save_LDFLAGS=$LDFLAGS
       echo "_main" > conftest.sym
       LDFLAGS="$LDFLAGS -Wl,-exported_symbols_list,conftest.sym"
-      cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
+      cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 
 int
@@ -7901,42 +7597,17 @@ main ()
   return 0;
 }
 _ACEOF
-rm -f conftest.$ac_objext conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_link") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest$ac_exeext && {
-	 test "$cross_compiling" = yes ||
-	 $as_test_x conftest$ac_exeext
-       }; then
+if ac_fn_c_try_link "$LINENO"; then :
   lt_cv_ld_exported_symbols_list=yes
 else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	lt_cv_ld_exported_symbols_list=no
+  lt_cv_ld_exported_symbols_list=no
 fi
-
-rm -rf conftest.dSYM
-rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
-      conftest$ac_exeext conftest.$ac_ext
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
 	LDFLAGS="$save_LDFLAGS"
 
 fi
-{ $as_echo "$as_me:$LINENO: result: $lt_cv_ld_exported_symbols_list" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_ld_exported_symbols_list" >&5
 $as_echo "$lt_cv_ld_exported_symbols_list" >&6; }
     case $host_os in
     rhapsody* | darwin1.[012])
@@ -7959,84 +7630,29 @@ $as_echo "$lt_cv_ld_exported_symbols_lis
   esac
     if test "$lt_cv_apple_cc_single_mod" = "yes"; then
       _lt_dar_single_mod='$single_module'
-    fi
-    if test "$lt_cv_ld_exported_symbols_list" = "yes"; then
-      _lt_dar_export_syms=' ${wl}-exported_symbols_list,$output_objdir/${libname}-symbols.expsym'
-    else
-      _lt_dar_export_syms='~$NMEDIT -s $output_objdir/${libname}-symbols.expsym ${lib}'
-    fi
-    if test "$DSYMUTIL" != ":"; then
-      _lt_dsymutil='~$DSYMUTIL $lib || :'
-    else
-      _lt_dsymutil=
-    fi
-    ;;
-  esac
-
-# On IRIX 5.3, sys/types and inttypes.h are conflicting.
-
-
-
-
-
-
-
-
-
-for ac_header in sys/types.h sys/stat.h stdlib.h string.h memory.h strings.h \
-		  inttypes.h stdint.h unistd.h
-do
-as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
-{ $as_echo "$as_me:$LINENO: checking for $ac_header" >&5
-$as_echo_n "checking for $ac_header... " >&6; }
-if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
-  $as_echo_n "(cached) " >&6
-else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-
-#include <$ac_header>
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
-  eval "$as_ac_Header=yes"
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	eval "$as_ac_Header=no"
-fi
+    fi
+    if test "$lt_cv_ld_exported_symbols_list" = "yes"; then
+      _lt_dar_export_syms=' ${wl}-exported_symbols_list,$output_objdir/${libname}-symbols.expsym'
+    else
+      _lt_dar_export_syms='~$NMEDIT -s $output_objdir/${libname}-symbols.expsym ${lib}'
+    fi
+    if test "$DSYMUTIL" != ":"; then
+      _lt_dsymutil='~$DSYMUTIL $lib || :'
+    else
+      _lt_dsymutil=
+    fi
+    ;;
+  esac
 
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-fi
-ac_res=`eval 'as_val=${'$as_ac_Header'}
-		 $as_echo "$as_val"'`
-	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
-as_val=`eval 'as_val=${'$as_ac_Header'}
-		 $as_echo "$as_val"'`
-   if test "x$as_val" = x""yes; then
+# On IRIX 5.3, sys/types and inttypes.h are conflicting.
+for ac_header in sys/types.h sys/stat.h stdlib.h string.h memory.h strings.h \
+		  inttypes.h stdint.h unistd.h
+do :
+  as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
+ac_fn_c_check_header_compile "$LINENO" "$ac_header" "$as_ac_Header" "$ac_includes_default
+"
+eval as_val=\$$as_ac_Header
+   if test "x$as_val" = x""yes; then :
   cat >>confdefs.h <<_ACEOF
 #define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
 _ACEOF
@@ -8046,62 +7662,13 @@ fi
 done
 
 
-
 for ac_header in dlfcn.h
-do
-as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
-{ $as_echo "$as_me:$LINENO: checking for $ac_header" >&5
-$as_echo_n "checking for $ac_header... " >&6; }
-if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
-  $as_echo_n "(cached) " >&6
-else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-
-#include <$ac_header>
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
-  eval "$as_ac_Header=yes"
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	eval "$as_ac_Header=no"
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-fi
-ac_res=`eval 'as_val=${'$as_ac_Header'}
-		 $as_echo "$as_val"'`
-	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
-as_val=`eval 'as_val=${'$as_ac_Header'}
-		 $as_echo "$as_val"'`
-   if test "x$as_val" = x""yes; then
+do :
+  ac_fn_c_check_header_compile "$LINENO" "dlfcn.h" "ac_cv_header_dlfcn_h" "$ac_includes_default
+"
+if test "x$ac_cv_header_dlfcn_h" = x""yes; then :
   cat >>confdefs.h <<_ACEOF
-#define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
+#define HAVE_DLFCN_H 1
 _ACEOF
 
 fi
@@ -8121,7 +7688,7 @@ done
 
 
             # Check whether --enable-shared was given.
-if test "${enable_shared+set}" = set; then
+if test "${enable_shared+set}" = set; then :
   enableval=$enable_shared; p=${PACKAGE-default}
     case $enableval in
     yes) enable_shared=yes ;;
@@ -8154,7 +7721,7 @@ fi
 
 
 # Check whether --with-pic was given.
-if test "${with_pic+set}" = set; then
+if test "${with_pic+set}" = set; then :
   withval=$with_pic; pic_mode="$withval"
 else
   pic_mode=default
@@ -8170,7 +7737,7 @@ test -z "$pic_mode" && pic_mode=default
 
 
   # Check whether --enable-fast-install was given.
-if test "${enable_fast_install+set}" = set; then
+if test "${enable_fast_install+set}" = set; then :
   enableval=$enable_fast_install; p=${PACKAGE-default}
     case $enableval in
     yes) enable_fast_install=yes ;;
@@ -8251,9 +7818,9 @@ if test -n "${ZSH_VERSION+set}" ; then
    setopt NO_GLOB_SUBST
 fi
 
-{ $as_echo "$as_me:$LINENO: checking for objdir" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for objdir" >&5
 $as_echo_n "checking for objdir... " >&6; }
-if test "${lt_cv_objdir+set}" = set; then
+if test "${lt_cv_objdir+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   rm -f .libs 2>/dev/null
@@ -8266,7 +7833,7 @@ else
 fi
 rmdir .libs 2>/dev/null
 fi
-{ $as_echo "$as_me:$LINENO: result: $lt_cv_objdir" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_objdir" >&5
 $as_echo "$lt_cv_objdir" >&6; }
 objdir=$lt_cv_objdir
 
@@ -8359,9 +7926,9 @@ test -z "$MAGIC_CMD" && MAGIC_CMD=file
 case $deplibs_check_method in
 file_magic*)
   if test "$file_magic_cmd" = '$MAGIC_CMD'; then
-    { $as_echo "$as_me:$LINENO: checking for ${ac_tool_prefix}file" >&5
+    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for ${ac_tool_prefix}file" >&5
 $as_echo_n "checking for ${ac_tool_prefix}file... " >&6; }
-if test "${lt_cv_path_MAGIC_CMD+set}" = set; then
+if test "${lt_cv_path_MAGIC_CMD+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   case $MAGIC_CMD in
@@ -8412,10 +7979,10 @@ fi
 
 MAGIC_CMD="$lt_cv_path_MAGIC_CMD"
 if test -n "$MAGIC_CMD"; then
-  { $as_echo "$as_me:$LINENO: result: $MAGIC_CMD" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $MAGIC_CMD" >&5
 $as_echo "$MAGIC_CMD" >&6; }
 else
-  { $as_echo "$as_me:$LINENO: result: no" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
 $as_echo "no" >&6; }
 fi
 
@@ -8425,9 +7992,9 @@ fi
 
 if test -z "$lt_cv_path_MAGIC_CMD"; then
   if test -n "$ac_tool_prefix"; then
-    { $as_echo "$as_me:$LINENO: checking for file" >&5
+    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for file" >&5
 $as_echo_n "checking for file... " >&6; }
-if test "${lt_cv_path_MAGIC_CMD+set}" = set; then
+if test "${lt_cv_path_MAGIC_CMD+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   case $MAGIC_CMD in
@@ -8478,10 +8045,10 @@ fi
 
 MAGIC_CMD="$lt_cv_path_MAGIC_CMD"
 if test -n "$MAGIC_CMD"; then
-  { $as_echo "$as_me:$LINENO: result: $MAGIC_CMD" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $MAGIC_CMD" >&5
 $as_echo "$MAGIC_CMD" >&6; }
 else
-  { $as_echo "$as_me:$LINENO: result: no" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
 $as_echo "no" >&6; }
 fi
 
@@ -8562,9 +8129,9 @@ lt_prog_compiler_no_builtin_flag=
 if test "$GCC" = yes; then
   lt_prog_compiler_no_builtin_flag=' -fno-builtin'
 
-  { $as_echo "$as_me:$LINENO: checking if $compiler supports -fno-rtti -fno-exceptions" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking if $compiler supports -fno-rtti -fno-exceptions" >&5
 $as_echo_n "checking if $compiler supports -fno-rtti -fno-exceptions... " >&6; }
-if test "${lt_cv_prog_compiler_rtti_exceptions+set}" = set; then
+if test "${lt_cv_prog_compiler_rtti_exceptions+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   lt_cv_prog_compiler_rtti_exceptions=no
@@ -8580,11 +8147,11 @@ else
    -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
    -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
    -e 's:$: $lt_compiler_flag:'`
-   (eval echo "\"\$as_me:8583: $lt_compile\"" >&5)
+   (eval echo "\"\$as_me:8138: $lt_compile\"" >&5)
    (eval "$lt_compile" 2>conftest.err)
    ac_status=$?
    cat conftest.err >&5
-   echo "$as_me:8587: \$? = $ac_status" >&5
+   echo "$as_me:8142: \$? = $ac_status" >&5
    if (exit $ac_status) && test -s "$ac_outfile"; then
      # The compiler can only warn and ignore the option if not recognized
      # So say no if there are warnings other than the usual output.
@@ -8597,7 +8164,7 @@ else
    $RM conftest*
 
 fi
-{ $as_echo "$as_me:$LINENO: result: $lt_cv_prog_compiler_rtti_exceptions" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_prog_compiler_rtti_exceptions" >&5
 $as_echo "$lt_cv_prog_compiler_rtti_exceptions" >&6; }
 
 if test x"$lt_cv_prog_compiler_rtti_exceptions" = xyes; then
@@ -8617,7 +8184,7 @@ fi
 lt_prog_compiler_pic=
 lt_prog_compiler_static=
 
-{ $as_echo "$as_me:$LINENO: checking for $compiler option to produce PIC" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $compiler option to produce PIC" >&5
 $as_echo_n "checking for $compiler option to produce PIC... " >&6; }
 
   if test "$GCC" = yes; then
@@ -8889,7 +8456,7 @@ case $host_os in
     lt_prog_compiler_pic="$lt_prog_compiler_pic -DPIC"
     ;;
 esac
-{ $as_echo "$as_me:$LINENO: result: $lt_prog_compiler_pic" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_prog_compiler_pic" >&5
 $as_echo "$lt_prog_compiler_pic" >&6; }
 
 
@@ -8901,9 +8468,9 @@ $as_echo "$lt_prog_compiler_pic" >&6; }
 # Check to make sure the PIC flag actually works.
 #
 if test -n "$lt_prog_compiler_pic"; then
-  { $as_echo "$as_me:$LINENO: checking if $compiler PIC flag $lt_prog_compiler_pic works" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking if $compiler PIC flag $lt_prog_compiler_pic works" >&5
 $as_echo_n "checking if $compiler PIC flag $lt_prog_compiler_pic works... " >&6; }
-if test "${lt_cv_prog_compiler_pic_works+set}" = set; then
+if test "${lt_cv_prog_compiler_pic_works+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   lt_cv_prog_compiler_pic_works=no
@@ -8919,11 +8486,11 @@ else
    -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
    -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
    -e 's:$: $lt_compiler_flag:'`
-   (eval echo "\"\$as_me:8922: $lt_compile\"" >&5)
+   (eval echo "\"\$as_me:8477: $lt_compile\"" >&5)
    (eval "$lt_compile" 2>conftest.err)
    ac_status=$?
    cat conftest.err >&5
-   echo "$as_me:8926: \$? = $ac_status" >&5
+   echo "$as_me:8481: \$? = $ac_status" >&5
    if (exit $ac_status) && test -s "$ac_outfile"; then
      # The compiler can only warn and ignore the option if not recognized
      # So say no if there are warnings other than the usual output.
@@ -8936,7 +8503,7 @@ else
    $RM conftest*
 
 fi
-{ $as_echo "$as_me:$LINENO: result: $lt_cv_prog_compiler_pic_works" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_prog_compiler_pic_works" >&5
 $as_echo "$lt_cv_prog_compiler_pic_works" >&6; }
 
 if test x"$lt_cv_prog_compiler_pic_works" = xyes; then
@@ -8960,9 +8527,9 @@ fi
 # Check to make sure the static flag actually works.
 #
 wl=$lt_prog_compiler_wl eval lt_tmp_static_flag=\"$lt_prog_compiler_static\"
-{ $as_echo "$as_me:$LINENO: checking if $compiler static flag $lt_tmp_static_flag works" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking if $compiler static flag $lt_tmp_static_flag works" >&5
 $as_echo_n "checking if $compiler static flag $lt_tmp_static_flag works... " >&6; }
-if test "${lt_cv_prog_compiler_static_works+set}" = set; then
+if test "${lt_cv_prog_compiler_static_works+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   lt_cv_prog_compiler_static_works=no
@@ -8988,7 +8555,7 @@ else
    LDFLAGS="$save_LDFLAGS"
 
 fi
-{ $as_echo "$as_me:$LINENO: result: $lt_cv_prog_compiler_static_works" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_prog_compiler_static_works" >&5
 $as_echo "$lt_cv_prog_compiler_static_works" >&6; }
 
 if test x"$lt_cv_prog_compiler_static_works" = xyes; then
@@ -9003,9 +8570,9 @@ fi
 
 
 
-  { $as_echo "$as_me:$LINENO: checking if $compiler supports -c -o file.$ac_objext" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking if $compiler supports -c -o file.$ac_objext" >&5
 $as_echo_n "checking if $compiler supports -c -o file.$ac_objext... " >&6; }
-if test "${lt_cv_prog_compiler_c_o+set}" = set; then
+if test "${lt_cv_prog_compiler_c_o+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   lt_cv_prog_compiler_c_o=no
@@ -9024,11 +8591,11 @@ else
    -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
    -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
    -e 's:$: $lt_compiler_flag:'`
-   (eval echo "\"\$as_me:9027: $lt_compile\"" >&5)
+   (eval echo "\"\$as_me:8582: $lt_compile\"" >&5)
    (eval "$lt_compile" 2>out/conftest.err)
    ac_status=$?
    cat out/conftest.err >&5
-   echo "$as_me:9031: \$? = $ac_status" >&5
+   echo "$as_me:8586: \$? = $ac_status" >&5
    if (exit $ac_status) && test -s out/conftest2.$ac_objext
    then
      # The compiler can only warn and ignore the option if not recognized
@@ -9050,7 +8617,7 @@ else
    $RM conftest*
 
 fi
-{ $as_echo "$as_me:$LINENO: result: $lt_cv_prog_compiler_c_o" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_prog_compiler_c_o" >&5
 $as_echo "$lt_cv_prog_compiler_c_o" >&6; }
 
 
@@ -9058,9 +8625,9 @@ $as_echo "$lt_cv_prog_compiler_c_o" >&6;
 
 
 
-  { $as_echo "$as_me:$LINENO: checking if $compiler supports -c -o file.$ac_objext" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking if $compiler supports -c -o file.$ac_objext" >&5
 $as_echo_n "checking if $compiler supports -c -o file.$ac_objext... " >&6; }
-if test "${lt_cv_prog_compiler_c_o+set}" = set; then
+if test "${lt_cv_prog_compiler_c_o+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   lt_cv_prog_compiler_c_o=no
@@ -9079,11 +8646,11 @@ else
    -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
    -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
    -e 's:$: $lt_compiler_flag:'`
-   (eval echo "\"\$as_me:9082: $lt_compile\"" >&5)
+   (eval echo "\"\$as_me:8637: $lt_compile\"" >&5)
    (eval "$lt_compile" 2>out/conftest.err)
    ac_status=$?
    cat out/conftest.err >&5
-   echo "$as_me:9086: \$? = $ac_status" >&5
+   echo "$as_me:8641: \$? = $ac_status" >&5
    if (exit $ac_status) && test -s out/conftest2.$ac_objext
    then
      # The compiler can only warn and ignore the option if not recognized
@@ -9105,7 +8672,7 @@ else
    $RM conftest*
 
 fi
-{ $as_echo "$as_me:$LINENO: result: $lt_cv_prog_compiler_c_o" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_prog_compiler_c_o" >&5
 $as_echo "$lt_cv_prog_compiler_c_o" >&6; }
 
 
@@ -9114,7 +8681,7 @@ $as_echo "$lt_cv_prog_compiler_c_o" >&6;
 hard_links="nottested"
 if test "$lt_cv_prog_compiler_c_o" = no && test "$need_locks" != no; then
   # do not overwrite the value of need_locks provided by the user
-  { $as_echo "$as_me:$LINENO: checking if we can lock with hard links" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking if we can lock with hard links" >&5
 $as_echo_n "checking if we can lock with hard links... " >&6; }
   hard_links=yes
   $RM conftest*
@@ -9122,10 +8689,10 @@ $as_echo_n "checking if we can lock with
   touch conftest.a
   ln conftest.a conftest.b 2>&5 || hard_links=no
   ln conftest.a conftest.b 2>/dev/null && hard_links=no
-  { $as_echo "$as_me:$LINENO: result: $hard_links" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $hard_links" >&5
 $as_echo "$hard_links" >&6; }
   if test "$hard_links" = no; then
-    { $as_echo "$as_me:$LINENO: WARNING: \`$CC' does not support \`-c -o', so \`make -j' may be unsafe" >&5
+    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: \`$CC' does not support \`-c -o', so \`make -j' may be unsafe" >&5
 $as_echo "$as_me: WARNING: \`$CC' does not support \`-c -o', so \`make -j' may be unsafe" >&2;}
     need_locks=warn
   fi
@@ -9138,7 +8705,7 @@ fi
 
 
 
-  { $as_echo "$as_me:$LINENO: checking whether the $compiler linker ($LD) supports shared libraries" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the $compiler linker ($LD) supports shared libraries" >&5
 $as_echo_n "checking whether the $compiler linker ($LD) supports shared libraries... " >&6; }
 
   runpath_var=
@@ -9380,7 +8947,7 @@ _LT_EOF
       fi
       ;;
 
-    netbsd*)
+    netbsd* | netbsdelf*-gnu)
       if echo __ELF__ | $CC -E - | $GREP __ELF__ >/dev/null; then
 	archive_cmds='$LD -Bshareable $libobjs $deplibs $linker_flags -o $lib'
 	wlarc=
@@ -9555,6 +9122,7 @@ _LT_EOF
 	if test "$aix_use_runtimelinking" = yes; then
 	  shared_flag="$shared_flag "'${wl}-G'
 	fi
+	link_all_deplibs=no
       else
 	# not using gcc
 	if test "$host_cpu" = ia64; then
@@ -9580,11 +9148,7 @@ _LT_EOF
 	allow_undefined_flag='-berok'
         # Determine the default libpath from the value encoded in an
         # empty executable.
-        cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
+        cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 
 int
@@ -9595,27 +9159,7 @@ main ()
   return 0;
 }
 _ACEOF
-rm -f conftest.$ac_objext conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_link") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest$ac_exeext && {
-	 test "$cross_compiling" = yes ||
-	 $as_test_x conftest$ac_exeext
-       }; then
+if ac_fn_c_try_link "$LINENO"; then :
 
 lt_aix_libpath_sed='
     /Import File Strings/,/^$/ {
@@ -9629,16 +9173,9 @@ aix_libpath=`dump -H conftest$ac_exeext
 if test -z "$aix_libpath"; then
   aix_libpath=`dump -HX64 conftest$ac_exeext 2>/dev/null | $SED -n -e "$lt_aix_libpath_sed"`
 fi
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-
 fi
-
-rm -rf conftest.dSYM
-rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
-      conftest$ac_exeext conftest.$ac_ext
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
 if test -z "$aix_libpath"; then aix_libpath="/usr/lib:/lib"; fi
 
         hardcode_libdir_flag_spec='${wl}-blibpath:$libdir:'"$aix_libpath"
@@ -9651,11 +9188,7 @@ if test -z "$aix_libpath"; then aix_libp
 	else
 	 # Determine the default libpath from the value encoded in an
 	 # empty executable.
-	 cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
+	 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 
 int
@@ -9666,27 +9199,7 @@ main ()
   return 0;
 }
 _ACEOF
-rm -f conftest.$ac_objext conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_link") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest$ac_exeext && {
-	 test "$cross_compiling" = yes ||
-	 $as_test_x conftest$ac_exeext
-       }; then
+if ac_fn_c_try_link "$LINENO"; then :
 
 lt_aix_libpath_sed='
     /Import File Strings/,/^$/ {
@@ -9700,16 +9213,9 @@ aix_libpath=`dump -H conftest$ac_exeext
 if test -z "$aix_libpath"; then
   aix_libpath=`dump -HX64 conftest$ac_exeext 2>/dev/null | $SED -n -e "$lt_aix_libpath_sed"`
 fi
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-
 fi
-
-rm -rf conftest.dSYM
-rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
-      conftest$ac_exeext conftest.$ac_ext
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
 if test -z "$aix_libpath"; then aix_libpath="/usr/lib:/lib"; fi
 
 	 hardcode_libdir_flag_spec='${wl}-blibpath:$libdir:'"$aix_libpath"
@@ -9921,42 +9427,16 @@ if test -z "$aix_libpath"; then aix_libp
 	# implicitly export all symbols.
         save_LDFLAGS="$LDFLAGS"
         LDFLAGS="$LDFLAGS -shared ${wl}-exported_symbol ${wl}foo ${wl}-update_registry ${wl}/dev/null"
-        cat >conftest.$ac_ext <<_ACEOF
+        cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
 int foo(void) {}
 _ACEOF
-rm -f conftest.$ac_objext conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_link") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest$ac_exeext && {
-	 test "$cross_compiling" = yes ||
-	 $as_test_x conftest$ac_exeext
-       }; then
+if ac_fn_c_try_link "$LINENO"; then :
   archive_expsym_cmds='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname ${wl}$soname `test -n "$verstring" && $ECHO "X${wl}-set_version ${wl}$verstring" | $Xsed` ${wl}-update_registry ${wl}${output_objdir}/so_locations ${wl}-exports_file ${wl}$export_symbols -o $lib'
 
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-
 fi
-
-rm -rf conftest.dSYM
-rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
-      conftest$ac_exeext conftest.$ac_ext
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
         LDFLAGS="$save_LDFLAGS"
       else
 	archive_cmds='$CC -shared $libobjs $deplibs $compiler_flags -soname $soname `test -n "$verstring" && $ECHO "X-set_version $verstring" | $Xsed` -update_registry ${output_objdir}/so_locations -o $lib'
@@ -9969,7 +9449,7 @@ rm -f core conftest.err conftest.$ac_obj
       link_all_deplibs=yes
       ;;
 
-    netbsd*)
+    netbsd* | netbsdelf*-gnu)
       if echo __ELF__ | $CC -E - | $GREP __ELF__ >/dev/null; then
 	archive_cmds='$LD -Bshareable -o $lib $libobjs $deplibs $linker_flags'  # a.out
       else
@@ -10212,7 +9692,7 @@ rm -f core conftest.err conftest.$ac_obj
     fi
   fi
 
-{ $as_echo "$as_me:$LINENO: result: $ld_shlibs" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ld_shlibs" >&5
 $as_echo "$ld_shlibs" >&6; }
 test "$ld_shlibs" = no && can_build_shared=no
 
@@ -10249,16 +9729,16 @@ x|xyes)
       # Test whether the compiler implicitly links with -lc since on some
       # systems, -lgcc has to come before -lc. If gcc already passes -lc
       # to ld, don't add -lc before -lgcc.
-      { $as_echo "$as_me:$LINENO: checking whether -lc should be explicitly linked in" >&5
+      { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether -lc should be explicitly linked in" >&5
 $as_echo_n "checking whether -lc should be explicitly linked in... " >&6; }
       $RM conftest*
       echo "$lt_simple_compile_test_code" > conftest.$ac_ext
 
-      if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+      if { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_compile\""; } >&5
   (eval $ac_compile) 2>&5
   ac_status=$?
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } 2>conftest.err; then
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; } 2>conftest.err; then
         soname=conftest
         lib=conftest
         libobjs=conftest.$ac_objext
@@ -10272,11 +9752,11 @@ $as_echo_n "checking whether -lc should
         libname=conftest
         lt_save_allow_undefined_flag=$allow_undefined_flag
         allow_undefined_flag=
-        if { (eval echo "$as_me:$LINENO: \"$archive_cmds 2\>\&1 \| $GREP \" -lc \" \>/dev/null 2\>\&1\"") >&5
+        if { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$archive_cmds 2\>\&1 \| $GREP \" -lc \" \>/dev/null 2\>\&1\""; } >&5
   (eval $archive_cmds 2\>\&1 \| $GREP \" -lc \" \>/dev/null 2\>\&1) 2>&5
   ac_status=$?
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }
         then
 	  archive_cmds_need_lc=no
         else
@@ -10287,7 +9767,7 @@ $as_echo_n "checking whether -lc should
         cat conftest.err 1>&5
       fi
       $RM conftest*
-      { $as_echo "$as_me:$LINENO: result: $archive_cmds_need_lc" >&5
+      { $as_echo "$as_me:${as_lineno-$LINENO}: result: $archive_cmds_need_lc" >&5
 $as_echo "$archive_cmds_need_lc" >&6; }
       ;;
     esac
@@ -10451,7 +9931,7 @@ esac
 
 
 
-  { $as_echo "$as_me:$LINENO: checking dynamic linker characteristics" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking dynamic linker characteristics" >&5
 $as_echo_n "checking dynamic linker characteristics... " >&6; }
 
 if test "$GCC" = yes; then
@@ -10873,11 +10353,7 @@ linux* | k*bsd*-gnu)
   save_libdir=$libdir
   eval "libdir=/foo; wl=\"$lt_prog_compiler_wl\"; \
        LDFLAGS=\"\$LDFLAGS $hardcode_libdir_flag_spec\""
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 
 int
@@ -10888,41 +10364,13 @@ main ()
   return 0;
 }
 _ACEOF
-rm -f conftest.$ac_objext conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_link") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest$ac_exeext && {
-	 test "$cross_compiling" = yes ||
-	 $as_test_x conftest$ac_exeext
-       }; then
-  if  ($OBJDUMP -p conftest$ac_exeext) 2>/dev/null | grep "RUNPATH.*$libdir" >/dev/null; then
+if ac_fn_c_try_link "$LINENO"; then :
+  if  ($OBJDUMP -p conftest$ac_exeext) 2>/dev/null | grep "RUNPATH.*$libdir" >/dev/null; then :
   shlibpath_overrides_runpath=yes
 fi
-
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-
 fi
-
-rm -rf conftest.dSYM
-rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
-      conftest$ac_exeext conftest.$ac_ext
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
   LDFLAGS=$save_LDFLAGS
   libdir=$save_libdir
 
@@ -10946,6 +10394,18 @@ rm -f core conftest.err conftest.$ac_obj
   dynamic_linker='GNU/Linux ld.so'
   ;;
 
+netbsdelf*-gnu)
+  version_type=linux
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major ${libname}${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=no
+  hardcode_into_libs=yes
+  dynamic_linker='NetBSD ld.elf_so'
+  ;;
+
 netbsd*)
   version_type=sunos
   need_lib_prefix=no
@@ -11134,7 +10594,7 @@ uts4*)
   dynamic_linker=no
   ;;
 esac
-{ $as_echo "$as_me:$LINENO: result: $dynamic_linker" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $dynamic_linker" >&5
 $as_echo "$dynamic_linker" >&6; }
 test "$dynamic_linker" = no && can_build_shared=no
 
@@ -11236,7 +10696,7 @@ fi
 
 
 
-  { $as_echo "$as_me:$LINENO: checking how to hardcode library paths into programs" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking how to hardcode library paths into programs" >&5
 $as_echo_n "checking how to hardcode library paths into programs... " >&6; }
 hardcode_action=
 if test -n "$hardcode_libdir_flag_spec" ||
@@ -11261,7 +10721,7 @@ else
   # directories.
   hardcode_action=unsupported
 fi
-{ $as_echo "$as_me:$LINENO: result: $hardcode_action" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $hardcode_action" >&5
 $as_echo "$hardcode_action" >&6; }
 
 if test "$hardcode_action" = relink ||
@@ -11289,201 +10749,31 @@ else
 
   case $host_os in
   beos*)
-    lt_cv_dlopen="load_add_on"
-    lt_cv_dlopen_libs=
-    lt_cv_dlopen_self=yes
-    ;;
-
-  mingw* | pw32* | cegcc*)
-    lt_cv_dlopen="LoadLibrary"
-    lt_cv_dlopen_libs=
-    ;;
-
-  cygwin*)
-    lt_cv_dlopen="dlopen"
-    lt_cv_dlopen_libs=
-    ;;
-
-  darwin*)
-  # if libdl is installed we need to link against it
-    { $as_echo "$as_me:$LINENO: checking for dlopen in -ldl" >&5
-$as_echo_n "checking for dlopen in -ldl... " >&6; }
-if test "${ac_cv_lib_dl_dlopen+set}" = set; then
-  $as_echo_n "(cached) " >&6
-else
-  ac_check_lib_save_LIBS=$LIBS
-LIBS="-ldl  $LIBS"
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char dlopen ();
-int
-main ()
-{
-return dlopen ();
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_link") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest$ac_exeext && {
-	 test "$cross_compiling" = yes ||
-	 $as_test_x conftest$ac_exeext
-       }; then
-  ac_cv_lib_dl_dlopen=yes
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_cv_lib_dl_dlopen=no
-fi
-
-rm -rf conftest.dSYM
-rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
-      conftest$ac_exeext conftest.$ac_ext
-LIBS=$ac_check_lib_save_LIBS
-fi
-{ $as_echo "$as_me:$LINENO: result: $ac_cv_lib_dl_dlopen" >&5
-$as_echo "$ac_cv_lib_dl_dlopen" >&6; }
-if test "x$ac_cv_lib_dl_dlopen" = x""yes; then
-  lt_cv_dlopen="dlopen" lt_cv_dlopen_libs="-ldl"
-else
-
-    lt_cv_dlopen="dyld"
-    lt_cv_dlopen_libs=
-    lt_cv_dlopen_self=yes
-
-fi
-
-    ;;
-
-  *)
-    { $as_echo "$as_me:$LINENO: checking for shl_load" >&5
-$as_echo_n "checking for shl_load... " >&6; }
-if test "${ac_cv_func_shl_load+set}" = set; then
-  $as_echo_n "(cached) " >&6
-else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-/* Define shl_load to an innocuous variant, in case <limits.h> declares shl_load.
-   For example, HP-UX 11i <limits.h> declares gettimeofday.  */
-#define shl_load innocuous_shl_load
-
-/* System header to define __stub macros and hopefully few prototypes,
-    which can conflict with char shl_load (); below.
-    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
-    <limits.h> exists even on freestanding compilers.  */
-
-#ifdef __STDC__
-# include <limits.h>
-#else
-# include <assert.h>
-#endif
-
-#undef shl_load
-
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char shl_load ();
-/* The GNU C library defines this for functions which it implements
-    to always fail with ENOSYS.  Some functions are actually named
-    something starting with __ and the normal name is an alias.  */
-#if defined __stub_shl_load || defined __stub___shl_load
-choke me
-#endif
-
-int
-main ()
-{
-return shl_load ();
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_link") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest$ac_exeext && {
-	 test "$cross_compiling" = yes ||
-	 $as_test_x conftest$ac_exeext
-       }; then
-  ac_cv_func_shl_load=yes
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
+    lt_cv_dlopen="load_add_on"
+    lt_cv_dlopen_libs=
+    lt_cv_dlopen_self=yes
+    ;;
 
-	ac_cv_func_shl_load=no
-fi
+  mingw* | pw32* | cegcc*)
+    lt_cv_dlopen="LoadLibrary"
+    lt_cv_dlopen_libs=
+    ;;
 
-rm -rf conftest.dSYM
-rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
-      conftest$ac_exeext conftest.$ac_ext
-fi
-{ $as_echo "$as_me:$LINENO: result: $ac_cv_func_shl_load" >&5
-$as_echo "$ac_cv_func_shl_load" >&6; }
-if test "x$ac_cv_func_shl_load" = x""yes; then
-  lt_cv_dlopen="shl_load"
-else
-  { $as_echo "$as_me:$LINENO: checking for shl_load in -ldld" >&5
-$as_echo_n "checking for shl_load in -ldld... " >&6; }
-if test "${ac_cv_lib_dld_shl_load+set}" = set; then
+  cygwin*)
+    lt_cv_dlopen="dlopen"
+    lt_cv_dlopen_libs=
+    ;;
+
+  darwin*)
+  # if libdl is installed we need to link against it
+    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for dlopen in -ldl" >&5
+$as_echo_n "checking for dlopen in -ldl... " >&6; }
+if test "${ac_cv_lib_dl_dlopen+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   ac_check_lib_save_LIBS=$LIBS
-LIBS="-ldld  $LIBS"
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
+LIBS="-ldl  $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 
 /* Override any GCC internal prototype to avoid an error.
@@ -11492,81 +10782,52 @@ cat >>conftest.$ac_ext <<_ACEOF
 #ifdef __cplusplus
 extern "C"
 #endif
-char shl_load ();
+char dlopen ();
 int
 main ()
 {
-return shl_load ();
+return dlopen ();
   ;
   return 0;
 }
 _ACEOF
-rm -f conftest.$ac_objext conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_link") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest$ac_exeext && {
-	 test "$cross_compiling" = yes ||
-	 $as_test_x conftest$ac_exeext
-       }; then
-  ac_cv_lib_dld_shl_load=yes
+if ac_fn_c_try_link "$LINENO"; then :
+  ac_cv_lib_dl_dlopen=yes
 else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_cv_lib_dld_shl_load=no
+  ac_cv_lib_dl_dlopen=no
 fi
-
-rm -rf conftest.dSYM
-rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
-      conftest$ac_exeext conftest.$ac_ext
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
 LIBS=$ac_check_lib_save_LIBS
 fi
-{ $as_echo "$as_me:$LINENO: result: $ac_cv_lib_dld_shl_load" >&5
-$as_echo "$ac_cv_lib_dld_shl_load" >&6; }
-if test "x$ac_cv_lib_dld_shl_load" = x""yes; then
-  lt_cv_dlopen="shl_load" lt_cv_dlopen_libs="-ldld"
-else
-  { $as_echo "$as_me:$LINENO: checking for dlopen" >&5
-$as_echo_n "checking for dlopen... " >&6; }
-if test "${ac_cv_func_dlopen+set}" = set; then
-  $as_echo_n "(cached) " >&6
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_dl_dlopen" >&5
+$as_echo "$ac_cv_lib_dl_dlopen" >&6; }
+if test "x$ac_cv_lib_dl_dlopen" = x""yes; then :
+  lt_cv_dlopen="dlopen" lt_cv_dlopen_libs="-ldl"
 else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-/* Define dlopen to an innocuous variant, in case <limits.h> declares dlopen.
-   For example, HP-UX 11i <limits.h> declares gettimeofday.  */
-#define dlopen innocuous_dlopen
 
-/* System header to define __stub macros and hopefully few prototypes,
-    which can conflict with char dlopen (); below.
-    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
-    <limits.h> exists even on freestanding compilers.  */
+    lt_cv_dlopen="dyld"
+    lt_cv_dlopen_libs=
+    lt_cv_dlopen_self=yes
 
-#ifdef __STDC__
-# include <limits.h>
-#else
-# include <assert.h>
-#endif
+fi
+
+    ;;
 
-#undef dlopen
+  *)
+    ac_fn_c_check_func "$LINENO" "shl_load" "ac_cv_func_shl_load"
+if test "x$ac_cv_func_shl_load" = x""yes; then :
+  lt_cv_dlopen="shl_load"
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for shl_load in -ldld" >&5
+$as_echo_n "checking for shl_load in -ldld... " >&6; }
+if test "${ac_cv_lib_dld_shl_load+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-ldld  $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
 
 /* Override any GCC internal prototype to avoid an error.
    Use char because int might match the return type of a GCC
@@ -11574,72 +10835,41 @@ cat >>conftest.$ac_ext <<_ACEOF
 #ifdef __cplusplus
 extern "C"
 #endif
-char dlopen ();
-/* The GNU C library defines this for functions which it implements
-    to always fail with ENOSYS.  Some functions are actually named
-    something starting with __ and the normal name is an alias.  */
-#if defined __stub_dlopen || defined __stub___dlopen
-choke me
-#endif
-
+char shl_load ();
 int
 main ()
 {
-return dlopen ();
+return shl_load ();
   ;
   return 0;
 }
 _ACEOF
-rm -f conftest.$ac_objext conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_link") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest$ac_exeext && {
-	 test "$cross_compiling" = yes ||
-	 $as_test_x conftest$ac_exeext
-       }; then
-  ac_cv_func_dlopen=yes
+if ac_fn_c_try_link "$LINENO"; then :
+  ac_cv_lib_dld_shl_load=yes
 else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_cv_func_dlopen=no
+  ac_cv_lib_dld_shl_load=no
 fi
-
-rm -rf conftest.dSYM
-rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
-      conftest$ac_exeext conftest.$ac_ext
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
 fi
-{ $as_echo "$as_me:$LINENO: result: $ac_cv_func_dlopen" >&5
-$as_echo "$ac_cv_func_dlopen" >&6; }
-if test "x$ac_cv_func_dlopen" = x""yes; then
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_dld_shl_load" >&5
+$as_echo "$ac_cv_lib_dld_shl_load" >&6; }
+if test "x$ac_cv_lib_dld_shl_load" = x""yes; then :
+  lt_cv_dlopen="shl_load" lt_cv_dlopen_libs="-ldld"
+else
+  ac_fn_c_check_func "$LINENO" "dlopen" "ac_cv_func_dlopen"
+if test "x$ac_cv_func_dlopen" = x""yes; then :
   lt_cv_dlopen="dlopen"
 else
-  { $as_echo "$as_me:$LINENO: checking for dlopen in -ldl" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for dlopen in -ldl" >&5
 $as_echo_n "checking for dlopen in -ldl... " >&6; }
-if test "${ac_cv_lib_dl_dlopen+set}" = set; then
+if test "${ac_cv_lib_dl_dlopen+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   ac_check_lib_save_LIBS=$LIBS
 LIBS="-ldl  $LIBS"
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 
 /* Override any GCC internal prototype to avoid an error.
@@ -11657,57 +10887,28 @@ return dlopen ();
   return 0;
 }
 _ACEOF
-rm -f conftest.$ac_objext conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_link") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest$ac_exeext && {
-	 test "$cross_compiling" = yes ||
-	 $as_test_x conftest$ac_exeext
-       }; then
+if ac_fn_c_try_link "$LINENO"; then :
   ac_cv_lib_dl_dlopen=yes
 else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_cv_lib_dl_dlopen=no
+  ac_cv_lib_dl_dlopen=no
 fi
-
-rm -rf conftest.dSYM
-rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
-      conftest$ac_exeext conftest.$ac_ext
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
 LIBS=$ac_check_lib_save_LIBS
 fi
-{ $as_echo "$as_me:$LINENO: result: $ac_cv_lib_dl_dlopen" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_dl_dlopen" >&5
 $as_echo "$ac_cv_lib_dl_dlopen" >&6; }
-if test "x$ac_cv_lib_dl_dlopen" = x""yes; then
+if test "x$ac_cv_lib_dl_dlopen" = x""yes; then :
   lt_cv_dlopen="dlopen" lt_cv_dlopen_libs="-ldl"
 else
-  { $as_echo "$as_me:$LINENO: checking for dlopen in -lsvld" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for dlopen in -lsvld" >&5
 $as_echo_n "checking for dlopen in -lsvld... " >&6; }
-if test "${ac_cv_lib_svld_dlopen+set}" = set; then
+if test "${ac_cv_lib_svld_dlopen+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   ac_check_lib_save_LIBS=$LIBS
 LIBS="-lsvld  $LIBS"
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 
 /* Override any GCC internal prototype to avoid an error.
@@ -11725,57 +10926,28 @@ return dlopen ();
   return 0;
 }
 _ACEOF
-rm -f conftest.$ac_objext conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_link") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest$ac_exeext && {
-	 test "$cross_compiling" = yes ||
-	 $as_test_x conftest$ac_exeext
-       }; then
+if ac_fn_c_try_link "$LINENO"; then :
   ac_cv_lib_svld_dlopen=yes
 else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_cv_lib_svld_dlopen=no
+  ac_cv_lib_svld_dlopen=no
 fi
-
-rm -rf conftest.dSYM
-rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
-      conftest$ac_exeext conftest.$ac_ext
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
 LIBS=$ac_check_lib_save_LIBS
 fi
-{ $as_echo "$as_me:$LINENO: result: $ac_cv_lib_svld_dlopen" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_svld_dlopen" >&5
 $as_echo "$ac_cv_lib_svld_dlopen" >&6; }
-if test "x$ac_cv_lib_svld_dlopen" = x""yes; then
+if test "x$ac_cv_lib_svld_dlopen" = x""yes; then :
   lt_cv_dlopen="dlopen" lt_cv_dlopen_libs="-lsvld"
 else
-  { $as_echo "$as_me:$LINENO: checking for dld_link in -ldld" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for dld_link in -ldld" >&5
 $as_echo_n "checking for dld_link in -ldld... " >&6; }
-if test "${ac_cv_lib_dld_dld_link+set}" = set; then
+if test "${ac_cv_lib_dld_dld_link+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   ac_check_lib_save_LIBS=$LIBS
 LIBS="-ldld  $LIBS"
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 
 /* Override any GCC internal prototype to avoid an error.
@@ -11793,43 +10965,18 @@ return dld_link ();
   return 0;
 }
 _ACEOF
-rm -f conftest.$ac_objext conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_link") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest$ac_exeext && {
-	 test "$cross_compiling" = yes ||
-	 $as_test_x conftest$ac_exeext
-       }; then
+if ac_fn_c_try_link "$LINENO"; then :
   ac_cv_lib_dld_dld_link=yes
 else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_cv_lib_dld_dld_link=no
+  ac_cv_lib_dld_dld_link=no
 fi
-
-rm -rf conftest.dSYM
-rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
-      conftest$ac_exeext conftest.$ac_ext
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
 LIBS=$ac_check_lib_save_LIBS
 fi
-{ $as_echo "$as_me:$LINENO: result: $ac_cv_lib_dld_dld_link" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_dld_dld_link" >&5
 $as_echo "$ac_cv_lib_dld_dld_link" >&6; }
-if test "x$ac_cv_lib_dld_dld_link" = x""yes; then
+if test "x$ac_cv_lib_dld_dld_link" = x""yes; then :
   lt_cv_dlopen="dld_link" lt_cv_dlopen_libs="-ldld"
 fi
 
@@ -11868,9 +11015,9 @@ fi
     save_LIBS="$LIBS"
     LIBS="$lt_cv_dlopen_libs $LIBS"
 
-    { $as_echo "$as_me:$LINENO: checking whether a program can dlopen itself" >&5
+    { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether a program can dlopen itself" >&5
 $as_echo_n "checking whether a program can dlopen itself... " >&6; }
-if test "${lt_cv_dlopen_self+set}" = set; then
+if test "${lt_cv_dlopen_self+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   	  if test "$cross_compiling" = yes; then :
@@ -11879,7 +11026,7 @@ else
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<_LT_EOF
-#line 11882 "configure"
+#line 11017 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
@@ -11938,11 +11085,11 @@ int main ()
   return status;
 }
 _LT_EOF
-  if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  if { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_link\""; } >&5
   (eval $ac_link) 2>&5
   ac_status=$?
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && test -s conftest${ac_exeext} 2>/dev/null; then
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; } && test -s conftest${ac_exeext} 2>/dev/null; then
     (./conftest; exit; ) >&5 2>/dev/null
     lt_status=$?
     case x$lt_status in
@@ -11959,14 +11106,14 @@ rm -fr conftest*
 
 
 fi
-{ $as_echo "$as_me:$LINENO: result: $lt_cv_dlopen_self" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_dlopen_self" >&5
 $as_echo "$lt_cv_dlopen_self" >&6; }
 
     if test "x$lt_cv_dlopen_self" = xyes; then
       wl=$lt_prog_compiler_wl eval LDFLAGS=\"\$LDFLAGS $lt_prog_compiler_static\"
-      { $as_echo "$as_me:$LINENO: checking whether a statically linked program can dlopen itself" >&5
+      { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether a statically linked program can dlopen itself" >&5
 $as_echo_n "checking whether a statically linked program can dlopen itself... " >&6; }
-if test "${lt_cv_dlopen_self_static+set}" = set; then
+if test "${lt_cv_dlopen_self_static+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   	  if test "$cross_compiling" = yes; then :
@@ -11975,7 +11122,7 @@ else
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<_LT_EOF
-#line 11978 "configure"
+#line 11113 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
@@ -12034,11 +11181,11 @@ int main ()
   return status;
 }
 _LT_EOF
-  if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  if { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_link\""; } >&5
   (eval $ac_link) 2>&5
   ac_status=$?
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && test -s conftest${ac_exeext} 2>/dev/null; then
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; } && test -s conftest${ac_exeext} 2>/dev/null; then
     (./conftest; exit; ) >&5 2>/dev/null
     lt_status=$?
     case x$lt_status in
@@ -12055,7 +11202,7 @@ rm -fr conftest*
 
 
 fi
-{ $as_echo "$as_me:$LINENO: result: $lt_cv_dlopen_self_static" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_dlopen_self_static" >&5
 $as_echo "$lt_cv_dlopen_self_static" >&6; }
     fi
 
@@ -12094,12 +11241,12 @@ fi
 
 striplib=
 old_striplib=
-{ $as_echo "$as_me:$LINENO: checking whether stripping libraries is possible" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether stripping libraries is possible" >&5
 $as_echo_n "checking whether stripping libraries is possible... " >&6; }
 if test -n "$STRIP" && $STRIP -V 2>&1 | $GREP "GNU strip" >/dev/null; then
   test -z "$old_striplib" && old_striplib="$STRIP --strip-debug"
   test -z "$striplib" && striplib="$STRIP --strip-unneeded"
-  { $as_echo "$as_me:$LINENO: result: yes" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
 $as_echo "yes" >&6; }
 else
 # FIXME - insert some real tests, host_os isn't really good enough
@@ -12108,15 +11255,15 @@ else
     if test -n "$STRIP" ; then
       striplib="$STRIP -x"
       old_striplib="$STRIP -S"
-      { $as_echo "$as_me:$LINENO: result: yes" >&5
+      { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
 $as_echo "yes" >&6; }
     else
-      { $as_echo "$as_me:$LINENO: result: no" >&5
+      { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
 $as_echo "no" >&6; }
     fi
     ;;
   *)
-    { $as_echo "$as_me:$LINENO: result: no" >&5
+    { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
 $as_echo "no" >&6; }
     ;;
   esac
@@ -12134,12 +11281,12 @@ fi
 
 
   # Report which library types will actually be built
-  { $as_echo "$as_me:$LINENO: checking if libtool supports shared libraries" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking if libtool supports shared libraries" >&5
 $as_echo_n "checking if libtool supports shared libraries... " >&6; }
-  { $as_echo "$as_me:$LINENO: result: $can_build_shared" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $can_build_shared" >&5
 $as_echo "$can_build_shared" >&6; }
 
-  { $as_echo "$as_me:$LINENO: checking whether to build shared libraries" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether to build shared libraries" >&5
 $as_echo_n "checking whether to build shared libraries... " >&6; }
   test "$can_build_shared" = "no" && enable_shared=no
 
@@ -12160,14 +11307,14 @@ $as_echo_n "checking whether to build sh
     fi
     ;;
   esac
-  { $as_echo "$as_me:$LINENO: result: $enable_shared" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $enable_shared" >&5
 $as_echo "$enable_shared" >&6; }
 
-  { $as_echo "$as_me:$LINENO: checking whether to build static libraries" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether to build static libraries" >&5
 $as_echo_n "checking whether to build static libraries... " >&6; }
   # Make sure either enable_shared or enable_static is yes.
   test "$enable_shared" = yes || enable_static=yes
-  { $as_echo "$as_me:$LINENO: result: $enable_static" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $enable_static" >&5
 $as_echo "$enable_static" >&6; }
 
 
@@ -12199,275 +11346,43 @@ CC="$lt_save_CC"
 
 
 
-# Only expand once:
-
-
-
-
-for ac_header in stdlib.h unistd.h
-do
-as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
-if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
-  { $as_echo "$as_me:$LINENO: checking for $ac_header" >&5
-$as_echo_n "checking for $ac_header... " >&6; }
-if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
-  $as_echo_n "(cached) " >&6
-fi
-ac_res=`eval 'as_val=${'$as_ac_Header'}
-		 $as_echo "$as_val"'`
-	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
-else
-  # Is the header compilable?
-{ $as_echo "$as_me:$LINENO: checking $ac_header usability" >&5
-$as_echo_n "checking $ac_header usability... " >&6; }
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-#include <$ac_header>
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
-  ac_header_compiler=yes
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_header_compiler=no
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-{ $as_echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
-$as_echo "$ac_header_compiler" >&6; }
-
-# Is the header present?
-{ $as_echo "$as_me:$LINENO: checking $ac_header presence" >&5
-$as_echo_n "checking $ac_header presence... " >&6; }
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-#include <$ac_header>
-_ACEOF
-if { (ac_try="$ac_cpp conftest.$ac_ext"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_cpp conftest.$ac_ext") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } >/dev/null && {
-	 test -z "$ac_c_preproc_warn_flag$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       }; then
-  ac_header_preproc=yes
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-  ac_header_preproc=no
-fi
-
-rm -f conftest.err conftest.$ac_ext
-{ $as_echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
-$as_echo "$ac_header_preproc" >&6; }
-
-# So?  What about this header?
-case $ac_header_compiler:$ac_header_preproc:$ac_c_preproc_warn_flag in
-  yes:no: )
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&5
-$as_echo "$as_me: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the compiler's result" >&5
-$as_echo "$as_me: WARNING: $ac_header: proceeding with the compiler's result" >&2;}
-    ac_header_preproc=yes
-    ;;
-  no:yes:* )
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: present but cannot be compiled" >&5
-$as_echo "$as_me: WARNING: $ac_header: present but cannot be compiled" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header:     check for missing prerequisite headers?" >&5
-$as_echo "$as_me: WARNING: $ac_header:     check for missing prerequisite headers?" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: see the Autoconf documentation" >&5
-$as_echo "$as_me: WARNING: $ac_header: see the Autoconf documentation" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header:     section \"Present But Cannot Be Compiled\"" >&5
-$as_echo "$as_me: WARNING: $ac_header:     section \"Present But Cannot Be Compiled\"" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
-$as_echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: in the future, the compiler will take precedence" >&5
-$as_echo "$as_me: WARNING: $ac_header: in the future, the compiler will take precedence" >&2;}
-    ( cat <<\_ASBOX
-## ------------------------------------------ ##
-## Report this to http://live.gnome.org/Rygel ##
-## ------------------------------------------ ##
-_ASBOX
-     ) | sed "s/^/$as_me: WARNING:     /" >&2
-    ;;
-esac
-{ $as_echo "$as_me:$LINENO: checking for $ac_header" >&5
-$as_echo_n "checking for $ac_header... " >&6; }
-if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
-  $as_echo_n "(cached) " >&6
-else
-  eval "$as_ac_Header=\$ac_header_preproc"
-fi
-ac_res=`eval 'as_val=${'$as_ac_Header'}
-		 $as_echo "$as_val"'`
-	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
-
-fi
-as_val=`eval 'as_val=${'$as_ac_Header'}
-		 $as_echo "$as_val"'`
-   if test "x$as_val" = x""yes; then
-  cat >>confdefs.h <<_ACEOF
-#define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
-_ACEOF
-
-fi
-
-done
-
-
-for ac_func in getpagesize
-do
-as_ac_var=`$as_echo "ac_cv_func_$ac_func" | $as_tr_sh`
-{ $as_echo "$as_me:$LINENO: checking for $ac_func" >&5
-$as_echo_n "checking for $ac_func... " >&6; }
-if { as_var=$as_ac_var; eval "test \"\${$as_var+set}\" = set"; }; then
-  $as_echo_n "(cached) " >&6
-else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-/* Define $ac_func to an innocuous variant, in case <limits.h> declares $ac_func.
-   For example, HP-UX 11i <limits.h> declares gettimeofday.  */
-#define $ac_func innocuous_$ac_func
-
-/* System header to define __stub macros and hopefully few prototypes,
-    which can conflict with char $ac_func (); below.
-    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
-    <limits.h> exists even on freestanding compilers.  */
-
-#ifdef __STDC__
-# include <limits.h>
-#else
-# include <assert.h>
-#endif
-
-#undef $ac_func
+# Only expand once:
 
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char $ac_func ();
-/* The GNU C library defines this for functions which it implements
-    to always fail with ENOSYS.  Some functions are actually named
-    something starting with __ and the normal name is an alias.  */
-#if defined __stub_$ac_func || defined __stub___$ac_func
-choke me
-#endif
 
-int
-main ()
-{
-return $ac_func ();
-  ;
-  return 0;
-}
+for ac_header in stdlib.h unistd.h
+do :
+  as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
+ac_fn_c_check_header_mongrel "$LINENO" "$ac_header" "$as_ac_Header" "$ac_includes_default"
+eval as_val=\$$as_ac_Header
+   if test "x$as_val" = x""yes; then :
+  cat >>confdefs.h <<_ACEOF
+#define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
 _ACEOF
-rm -f conftest.$ac_objext conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_link") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest$ac_exeext && {
-	 test "$cross_compiling" = yes ||
-	 $as_test_x conftest$ac_exeext
-       }; then
-  eval "$as_ac_var=yes"
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
 
-	eval "$as_ac_var=no"
 fi
 
-rm -rf conftest.dSYM
-rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
-      conftest$ac_exeext conftest.$ac_ext
-fi
-ac_res=`eval 'as_val=${'$as_ac_var'}
-		 $as_echo "$as_val"'`
-	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
-as_val=`eval 'as_val=${'$as_ac_var'}
-		 $as_echo "$as_val"'`
-   if test "x$as_val" = x""yes; then
+done
+
+for ac_func in getpagesize
+do :
+  ac_fn_c_check_func "$LINENO" "getpagesize" "ac_cv_func_getpagesize"
+if test "x$ac_cv_func_getpagesize" = x""yes; then :
   cat >>confdefs.h <<_ACEOF
-#define `$as_echo "HAVE_$ac_func" | $as_tr_cpp` 1
+#define HAVE_GETPAGESIZE 1
 _ACEOF
 
 fi
 done
 
-{ $as_echo "$as_me:$LINENO: checking for working mmap" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for working mmap" >&5
 $as_echo_n "checking for working mmap... " >&6; }
-if test "${ac_cv_func_mmap_fixed_mapped+set}" = set; then
+if test "${ac_cv_func_mmap_fixed_mapped+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
-  if test "$cross_compiling" = yes; then
+  if test "$cross_compiling" = yes; then :
   ac_cv_func_mmap_fixed_mapped=no
 else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 $ac_includes_default
 /* malloc might have been renamed as rpl_malloc. */
@@ -12596,61 +11511,33 @@ main ()
   return 0;
 }
 _ACEOF
-rm -f conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_link") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
+if ac_fn_c_try_run "$LINENO"; then :
   ac_cv_func_mmap_fixed_mapped=yes
 else
-  $as_echo "$as_me: program exited with status $ac_status" >&5
-$as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-( exit $ac_status )
-ac_cv_func_mmap_fixed_mapped=no
+  ac_cv_func_mmap_fixed_mapped=no
 fi
-rm -rf conftest.dSYM
-rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
+rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext \
+  conftest.$ac_objext conftest.beam conftest.$ac_ext
 fi
 
-
 fi
-{ $as_echo "$as_me:$LINENO: result: $ac_cv_func_mmap_fixed_mapped" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_func_mmap_fixed_mapped" >&5
 $as_echo "$ac_cv_func_mmap_fixed_mapped" >&6; }
 if test $ac_cv_func_mmap_fixed_mapped = yes; then
 
-cat >>confdefs.h <<\_ACEOF
-#define HAVE_MMAP 1
-_ACEOF
+$as_echo "#define HAVE_MMAP 1" >>confdefs.h
 
 fi
 rm -f conftest.mmap
 
 
 VALA_REQUIRED=0.7.7
+GLIB_REQUIRED=2.21.3
 GUPNP_REQUIRED=0.13
 GUPNP_AV_REQUIRED=0.5
 GUPNP_VALA_REQUIRED=0.6
 DBUS_GLIB_REQUIRED=0.74
-GSTREAMER_REQUIRED=0.10.23
+VLC_REQUIRED=0.9.9
 GIO_REQUIRED=2.16
 GEE_REQUIRED=0.3.0
 UUID_REQUIRED=1.41.3
@@ -12664,9 +11551,9 @@ if test "x$ac_cv_env_PKG_CONFIG_set" !=
 	if test -n "$ac_tool_prefix"; then
   # Extract the first word of "${ac_tool_prefix}pkg-config", so it can be a program name with args.
 set dummy ${ac_tool_prefix}pkg-config; ac_word=$2
-{ $as_echo "$as_me:$LINENO: checking for $ac_word" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
 $as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_path_PKG_CONFIG+set}" = set; then
+if test "${ac_cv_path_PKG_CONFIG+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   case $PKG_CONFIG in
@@ -12679,14 +11566,14 @@ for as_dir in $PATH
 do
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
-  for ac_exec_ext in '' $ac_executable_extensions; do
+    for ac_exec_ext in '' $ac_executable_extensions; do
   if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
     ac_cv_path_PKG_CONFIG="$as_dir/$ac_word$ac_exec_ext"
-    $as_echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
   fi
 done
-done
+  done
 IFS=$as_save_IFS
 
   ;;
@@ -12694,10 +11581,10 @@ esac
 fi
 PKG_CONFIG=$ac_cv_path_PKG_CONFIG
 if test -n "$PKG_CONFIG"; then
-  { $as_echo "$as_me:$LINENO: result: $PKG_CONFIG" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $PKG_CONFIG" >&5
 $as_echo "$PKG_CONFIG" >&6; }
 else
-  { $as_echo "$as_me:$LINENO: result: no" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
 $as_echo "no" >&6; }
 fi
 
@@ -12707,9 +11594,9 @@ if test -z "$ac_cv_path_PKG_CONFIG"; the
   ac_pt_PKG_CONFIG=$PKG_CONFIG
   # Extract the first word of "pkg-config", so it can be a program name with args.
 set dummy pkg-config; ac_word=$2
-{ $as_echo "$as_me:$LINENO: checking for $ac_word" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
 $as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_path_ac_pt_PKG_CONFIG+set}" = set; then
+if test "${ac_cv_path_ac_pt_PKG_CONFIG+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   case $ac_pt_PKG_CONFIG in
@@ -12722,14 +11609,14 @@ for as_dir in $PATH
 do
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
-  for ac_exec_ext in '' $ac_executable_extensions; do
+    for ac_exec_ext in '' $ac_executable_extensions; do
   if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
     ac_cv_path_ac_pt_PKG_CONFIG="$as_dir/$ac_word$ac_exec_ext"
-    $as_echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
   fi
 done
-done
+  done
 IFS=$as_save_IFS
 
   ;;
@@ -12737,10 +11624,10 @@ esac
 fi
 ac_pt_PKG_CONFIG=$ac_cv_path_ac_pt_PKG_CONFIG
 if test -n "$ac_pt_PKG_CONFIG"; then
-  { $as_echo "$as_me:$LINENO: result: $ac_pt_PKG_CONFIG" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_pt_PKG_CONFIG" >&5
 $as_echo "$ac_pt_PKG_CONFIG" >&6; }
 else
-  { $as_echo "$as_me:$LINENO: result: no" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
 $as_echo "no" >&6; }
 fi
 
@@ -12749,7 +11636,7 @@ fi
   else
     case $cross_compiling:$ac_tool_warned in
 yes:)
-{ $as_echo "$as_me:$LINENO: WARNING: using cross tools not prefixed with host triplet" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
 $as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
 ac_tool_warned=yes ;;
 esac
@@ -12762,13 +11649,13 @@ fi
 fi
 if test -n "$PKG_CONFIG"; then
 	_pkg_min_version=0.9.0
-	{ $as_echo "$as_me:$LINENO: checking pkg-config is at least version $_pkg_min_version" >&5
+	{ $as_echo "$as_me:${as_lineno-$LINENO}: checking pkg-config is at least version $_pkg_min_version" >&5
 $as_echo_n "checking pkg-config is at least version $_pkg_min_version... " >&6; }
 	if $PKG_CONFIG --atleast-pkgconfig-version $_pkg_min_version; then
-		{ $as_echo "$as_me:$LINENO: result: yes" >&5
+		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
 $as_echo "yes" >&6; }
 	else
-		{ $as_echo "$as_me:$LINENO: result: no" >&5
+		{ $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
 $as_echo "no" >&6; }
 		PKG_CONFIG=""
 	fi
@@ -12776,44 +11663,40 @@ $as_echo "no" >&6; }
 fi
 
 pkg_failed=no
-{ $as_echo "$as_me:$LINENO: checking for LIBGUPNP" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for LIBGUPNP" >&5
 $as_echo_n "checking for LIBGUPNP... " >&6; }
 
-if test -n "$PKG_CONFIG"; then
-    if test -n "$LIBGUPNP_CFLAGS"; then
-        pkg_cv_LIBGUPNP_CFLAGS="$LIBGUPNP_CFLAGS"
-    else
-        if test -n "$PKG_CONFIG" && \
-    { ($as_echo "$as_me:$LINENO: \$PKG_CONFIG --exists --print-errors \"gupnp-1.0 >= \$GUPNP_REQUIRED\"") >&5
+if test -n "$LIBGUPNP_CFLAGS"; then
+    pkg_cv_LIBGUPNP_CFLAGS="$LIBGUPNP_CFLAGS"
+ elif test -n "$PKG_CONFIG"; then
+    if test -n "$PKG_CONFIG" && \
+    { { $as_echo "$as_me:${as_lineno-$LINENO}: \$PKG_CONFIG --exists --print-errors \"gupnp-1.0 >= \$GUPNP_REQUIRED\""; } >&5
   ($PKG_CONFIG --exists --print-errors "gupnp-1.0 >= $GUPNP_REQUIRED") 2>&5
   ac_status=$?
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; then
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }; then
   pkg_cv_LIBGUPNP_CFLAGS=`$PKG_CONFIG --cflags "gupnp-1.0 >= $GUPNP_REQUIRED" 2>/dev/null`
 else
   pkg_failed=yes
 fi
-    fi
-else
-	pkg_failed=untried
+ else
+    pkg_failed=untried
 fi
-if test -n "$PKG_CONFIG"; then
-    if test -n "$LIBGUPNP_LIBS"; then
-        pkg_cv_LIBGUPNP_LIBS="$LIBGUPNP_LIBS"
-    else
-        if test -n "$PKG_CONFIG" && \
-    { ($as_echo "$as_me:$LINENO: \$PKG_CONFIG --exists --print-errors \"gupnp-1.0 >= \$GUPNP_REQUIRED\"") >&5
+if test -n "$LIBGUPNP_LIBS"; then
+    pkg_cv_LIBGUPNP_LIBS="$LIBGUPNP_LIBS"
+ elif test -n "$PKG_CONFIG"; then
+    if test -n "$PKG_CONFIG" && \
+    { { $as_echo "$as_me:${as_lineno-$LINENO}: \$PKG_CONFIG --exists --print-errors \"gupnp-1.0 >= \$GUPNP_REQUIRED\""; } >&5
   ($PKG_CONFIG --exists --print-errors "gupnp-1.0 >= $GUPNP_REQUIRED") 2>&5
   ac_status=$?
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; then
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }; then
   pkg_cv_LIBGUPNP_LIBS=`$PKG_CONFIG --libs "gupnp-1.0 >= $GUPNP_REQUIRED" 2>/dev/null`
 else
   pkg_failed=yes
 fi
-    fi
-else
-	pkg_failed=untried
+ else
+    pkg_failed=untried
 fi
 
 
@@ -12826,25 +11709,14 @@ else
         _pkg_short_errors_supported=no
 fi
         if test $_pkg_short_errors_supported = yes; then
-	        LIBGUPNP_PKG_ERRORS=`$PKG_CONFIG --short-errors --errors-to-stdout --print-errors "gupnp-1.0 >= $GUPNP_REQUIRED"`
+	        LIBGUPNP_PKG_ERRORS=`$PKG_CONFIG --short-errors --print-errors "gupnp-1.0 >= $GUPNP_REQUIRED" 2>&1`
         else
-	        LIBGUPNP_PKG_ERRORS=`$PKG_CONFIG --errors-to-stdout --print-errors "gupnp-1.0 >= $GUPNP_REQUIRED"`
+	        LIBGUPNP_PKG_ERRORS=`$PKG_CONFIG --print-errors "gupnp-1.0 >= $GUPNP_REQUIRED" 2>&1`
         fi
 	# Put the nasty error message in config.log where it belongs
 	echo "$LIBGUPNP_PKG_ERRORS" >&5
 
-	{ { $as_echo "$as_me:$LINENO: error: Package requirements (gupnp-1.0 >= $GUPNP_REQUIRED) were not met:
-
-$LIBGUPNP_PKG_ERRORS
-
-Consider adjusting the PKG_CONFIG_PATH environment variable if you
-installed software in a non-standard prefix.
-
-Alternatively, you may set the environment variables LIBGUPNP_CFLAGS
-and LIBGUPNP_LIBS to avoid the need to call pkg-config.
-See the pkg-config man page for more details.
-" >&5
-$as_echo "$as_me: error: Package requirements (gupnp-1.0 >= $GUPNP_REQUIRED) were not met:
+	as_fn_error "Package requirements (gupnp-1.0 >= $GUPNP_REQUIRED) were not met:
 
 $LIBGUPNP_PKG_ERRORS
 
@@ -12854,22 +11726,11 @@ installed software in a non-standard pre
 Alternatively, you may set the environment variables LIBGUPNP_CFLAGS
 and LIBGUPNP_LIBS to avoid the need to call pkg-config.
 See the pkg-config man page for more details.
-" >&2;}
-   { (exit 1); exit 1; }; }
+" "$LINENO" 5
 elif test $pkg_failed = untried; then
-	{ { $as_echo "$as_me:$LINENO: error: in \`$ac_pwd':" >&5
+	{ { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
 $as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
-{ { $as_echo "$as_me:$LINENO: error: The pkg-config script could not be found or is too old.  Make sure it
-is in your PATH or set the PKG_CONFIG environment variable to the full
-path to pkg-config.
-
-Alternatively, you may set the environment variables LIBGUPNP_CFLAGS
-and LIBGUPNP_LIBS to avoid the need to call pkg-config.
-See the pkg-config man page for more details.
-
-To get pkg-config, see <http://pkg-config.freedesktop.org/>.
-See \`config.log' for more details." >&5
-$as_echo "$as_me: error: The pkg-config script could not be found or is too old.  Make sure it
+as_fn_error "The pkg-config script could not be found or is too old.  Make sure it
 is in your PATH or set the PKG_CONFIG environment variable to the full
 path to pkg-config.
 
@@ -12878,55 +11739,50 @@ and LIBGUPNP_LIBS to avoid the need to c
 See the pkg-config man page for more details.
 
 To get pkg-config, see <http://pkg-config.freedesktop.org/>.
-See \`config.log' for more details." >&2;}
-   { (exit 1); exit 1; }; }; }
+See \`config.log' for more details." "$LINENO" 5; }
 else
 	LIBGUPNP_CFLAGS=$pkg_cv_LIBGUPNP_CFLAGS
 	LIBGUPNP_LIBS=$pkg_cv_LIBGUPNP_LIBS
-        { $as_echo "$as_me:$LINENO: result: yes" >&5
+        { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
 $as_echo "yes" >&6; }
 	:
 fi
 
 pkg_failed=no
-{ $as_echo "$as_me:$LINENO: checking for LIBGUPNP_AV" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for LIBGUPNP_AV" >&5
 $as_echo_n "checking for LIBGUPNP_AV... " >&6; }
 
-if test -n "$PKG_CONFIG"; then
-    if test -n "$LIBGUPNP_AV_CFLAGS"; then
-        pkg_cv_LIBGUPNP_AV_CFLAGS="$LIBGUPNP_AV_CFLAGS"
-    else
-        if test -n "$PKG_CONFIG" && \
-    { ($as_echo "$as_me:$LINENO: \$PKG_CONFIG --exists --print-errors \"gupnp-av-1.0 >= \$GUPNP_AV_REQUIRED\"") >&5
+if test -n "$LIBGUPNP_AV_CFLAGS"; then
+    pkg_cv_LIBGUPNP_AV_CFLAGS="$LIBGUPNP_AV_CFLAGS"
+ elif test -n "$PKG_CONFIG"; then
+    if test -n "$PKG_CONFIG" && \
+    { { $as_echo "$as_me:${as_lineno-$LINENO}: \$PKG_CONFIG --exists --print-errors \"gupnp-av-1.0 >= \$GUPNP_AV_REQUIRED\""; } >&5
   ($PKG_CONFIG --exists --print-errors "gupnp-av-1.0 >= $GUPNP_AV_REQUIRED") 2>&5
   ac_status=$?
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; then
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }; then
   pkg_cv_LIBGUPNP_AV_CFLAGS=`$PKG_CONFIG --cflags "gupnp-av-1.0 >= $GUPNP_AV_REQUIRED" 2>/dev/null`
 else
   pkg_failed=yes
 fi
-    fi
-else
-	pkg_failed=untried
+ else
+    pkg_failed=untried
 fi
-if test -n "$PKG_CONFIG"; then
-    if test -n "$LIBGUPNP_AV_LIBS"; then
-        pkg_cv_LIBGUPNP_AV_LIBS="$LIBGUPNP_AV_LIBS"
-    else
-        if test -n "$PKG_CONFIG" && \
-    { ($as_echo "$as_me:$LINENO: \$PKG_CONFIG --exists --print-errors \"gupnp-av-1.0 >= \$GUPNP_AV_REQUIRED\"") >&5
+if test -n "$LIBGUPNP_AV_LIBS"; then
+    pkg_cv_LIBGUPNP_AV_LIBS="$LIBGUPNP_AV_LIBS"
+ elif test -n "$PKG_CONFIG"; then
+    if test -n "$PKG_CONFIG" && \
+    { { $as_echo "$as_me:${as_lineno-$LINENO}: \$PKG_CONFIG --exists --print-errors \"gupnp-av-1.0 >= \$GUPNP_AV_REQUIRED\""; } >&5
   ($PKG_CONFIG --exists --print-errors "gupnp-av-1.0 >= $GUPNP_AV_REQUIRED") 2>&5
   ac_status=$?
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; then
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }; then
   pkg_cv_LIBGUPNP_AV_LIBS=`$PKG_CONFIG --libs "gupnp-av-1.0 >= $GUPNP_AV_REQUIRED" 2>/dev/null`
 else
   pkg_failed=yes
 fi
-    fi
-else
-	pkg_failed=untried
+ else
+    pkg_failed=untried
 fi
 
 
@@ -12939,25 +11795,14 @@ else
         _pkg_short_errors_supported=no
 fi
         if test $_pkg_short_errors_supported = yes; then
-	        LIBGUPNP_AV_PKG_ERRORS=`$PKG_CONFIG --short-errors --errors-to-stdout --print-errors "gupnp-av-1.0 >= $GUPNP_AV_REQUIRED"`
+	        LIBGUPNP_AV_PKG_ERRORS=`$PKG_CONFIG --short-errors --print-errors "gupnp-av-1.0 >= $GUPNP_AV_REQUIRED" 2>&1`
         else
-	        LIBGUPNP_AV_PKG_ERRORS=`$PKG_CONFIG --errors-to-stdout --print-errors "gupnp-av-1.0 >= $GUPNP_AV_REQUIRED"`
+	        LIBGUPNP_AV_PKG_ERRORS=`$PKG_CONFIG --print-errors "gupnp-av-1.0 >= $GUPNP_AV_REQUIRED" 2>&1`
         fi
 	# Put the nasty error message in config.log where it belongs
 	echo "$LIBGUPNP_AV_PKG_ERRORS" >&5
 
-	{ { $as_echo "$as_me:$LINENO: error: Package requirements (gupnp-av-1.0 >= $GUPNP_AV_REQUIRED) were not met:
-
-$LIBGUPNP_AV_PKG_ERRORS
-
-Consider adjusting the PKG_CONFIG_PATH environment variable if you
-installed software in a non-standard prefix.
-
-Alternatively, you may set the environment variables LIBGUPNP_AV_CFLAGS
-and LIBGUPNP_AV_LIBS to avoid the need to call pkg-config.
-See the pkg-config man page for more details.
-" >&5
-$as_echo "$as_me: error: Package requirements (gupnp-av-1.0 >= $GUPNP_AV_REQUIRED) were not met:
+	as_fn_error "Package requirements (gupnp-av-1.0 >= $GUPNP_AV_REQUIRED) were not met:
 
 $LIBGUPNP_AV_PKG_ERRORS
 
@@ -12967,22 +11812,11 @@ installed software in a non-standard pre
 Alternatively, you may set the environment variables LIBGUPNP_AV_CFLAGS
 and LIBGUPNP_AV_LIBS to avoid the need to call pkg-config.
 See the pkg-config man page for more details.
-" >&2;}
-   { (exit 1); exit 1; }; }
+" "$LINENO" 5
 elif test $pkg_failed = untried; then
-	{ { $as_echo "$as_me:$LINENO: error: in \`$ac_pwd':" >&5
+	{ { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
 $as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
-{ { $as_echo "$as_me:$LINENO: error: The pkg-config script could not be found or is too old.  Make sure it
-is in your PATH or set the PKG_CONFIG environment variable to the full
-path to pkg-config.
-
-Alternatively, you may set the environment variables LIBGUPNP_AV_CFLAGS
-and LIBGUPNP_AV_LIBS to avoid the need to call pkg-config.
-See the pkg-config man page for more details.
-
-To get pkg-config, see <http://pkg-config.freedesktop.org/>.
-See \`config.log' for more details." >&5
-$as_echo "$as_me: error: The pkg-config script could not be found or is too old.  Make sure it
+as_fn_error "The pkg-config script could not be found or is too old.  Make sure it
 is in your PATH or set the PKG_CONFIG environment variable to the full
 path to pkg-config.
 
@@ -12991,55 +11825,50 @@ and LIBGUPNP_AV_LIBS to avoid the need t
 See the pkg-config man page for more details.
 
 To get pkg-config, see <http://pkg-config.freedesktop.org/>.
-See \`config.log' for more details." >&2;}
-   { (exit 1); exit 1; }; }; }
+See \`config.log' for more details." "$LINENO" 5; }
 else
 	LIBGUPNP_AV_CFLAGS=$pkg_cv_LIBGUPNP_AV_CFLAGS
 	LIBGUPNP_AV_LIBS=$pkg_cv_LIBGUPNP_AV_LIBS
-        { $as_echo "$as_me:$LINENO: result: yes" >&5
+        { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
 $as_echo "yes" >&6; }
 	:
 fi
 
 pkg_failed=no
-{ $as_echo "$as_me:$LINENO: checking for LIBDBUS_GLIB" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for LIBDBUS_GLIB" >&5
 $as_echo_n "checking for LIBDBUS_GLIB... " >&6; }
 
-if test -n "$PKG_CONFIG"; then
-    if test -n "$LIBDBUS_GLIB_CFLAGS"; then
-        pkg_cv_LIBDBUS_GLIB_CFLAGS="$LIBDBUS_GLIB_CFLAGS"
-    else
-        if test -n "$PKG_CONFIG" && \
-    { ($as_echo "$as_me:$LINENO: \$PKG_CONFIG --exists --print-errors \"dbus-glib-1 >= \$DBUS_GLIB_REQUIRED\"") >&5
+if test -n "$LIBDBUS_GLIB_CFLAGS"; then
+    pkg_cv_LIBDBUS_GLIB_CFLAGS="$LIBDBUS_GLIB_CFLAGS"
+ elif test -n "$PKG_CONFIG"; then
+    if test -n "$PKG_CONFIG" && \
+    { { $as_echo "$as_me:${as_lineno-$LINENO}: \$PKG_CONFIG --exists --print-errors \"dbus-glib-1 >= \$DBUS_GLIB_REQUIRED\""; } >&5
   ($PKG_CONFIG --exists --print-errors "dbus-glib-1 >= $DBUS_GLIB_REQUIRED") 2>&5
   ac_status=$?
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; then
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }; then
   pkg_cv_LIBDBUS_GLIB_CFLAGS=`$PKG_CONFIG --cflags "dbus-glib-1 >= $DBUS_GLIB_REQUIRED" 2>/dev/null`
 else
   pkg_failed=yes
 fi
-    fi
-else
-	pkg_failed=untried
+ else
+    pkg_failed=untried
 fi
-if test -n "$PKG_CONFIG"; then
-    if test -n "$LIBDBUS_GLIB_LIBS"; then
-        pkg_cv_LIBDBUS_GLIB_LIBS="$LIBDBUS_GLIB_LIBS"
-    else
-        if test -n "$PKG_CONFIG" && \
-    { ($as_echo "$as_me:$LINENO: \$PKG_CONFIG --exists --print-errors \"dbus-glib-1 >= \$DBUS_GLIB_REQUIRED\"") >&5
+if test -n "$LIBDBUS_GLIB_LIBS"; then
+    pkg_cv_LIBDBUS_GLIB_LIBS="$LIBDBUS_GLIB_LIBS"
+ elif test -n "$PKG_CONFIG"; then
+    if test -n "$PKG_CONFIG" && \
+    { { $as_echo "$as_me:${as_lineno-$LINENO}: \$PKG_CONFIG --exists --print-errors \"dbus-glib-1 >= \$DBUS_GLIB_REQUIRED\""; } >&5
   ($PKG_CONFIG --exists --print-errors "dbus-glib-1 >= $DBUS_GLIB_REQUIRED") 2>&5
   ac_status=$?
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; then
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }; then
   pkg_cv_LIBDBUS_GLIB_LIBS=`$PKG_CONFIG --libs "dbus-glib-1 >= $DBUS_GLIB_REQUIRED" 2>/dev/null`
 else
   pkg_failed=yes
 fi
-    fi
-else
-	pkg_failed=untried
+ else
+    pkg_failed=untried
 fi
 
 
@@ -13052,25 +11881,14 @@ else
         _pkg_short_errors_supported=no
 fi
         if test $_pkg_short_errors_supported = yes; then
-	        LIBDBUS_GLIB_PKG_ERRORS=`$PKG_CONFIG --short-errors --errors-to-stdout --print-errors "dbus-glib-1 >= $DBUS_GLIB_REQUIRED"`
+	        LIBDBUS_GLIB_PKG_ERRORS=`$PKG_CONFIG --short-errors --print-errors "dbus-glib-1 >= $DBUS_GLIB_REQUIRED" 2>&1`
         else
-	        LIBDBUS_GLIB_PKG_ERRORS=`$PKG_CONFIG --errors-to-stdout --print-errors "dbus-glib-1 >= $DBUS_GLIB_REQUIRED"`
+	        LIBDBUS_GLIB_PKG_ERRORS=`$PKG_CONFIG --print-errors "dbus-glib-1 >= $DBUS_GLIB_REQUIRED" 2>&1`
         fi
 	# Put the nasty error message in config.log where it belongs
 	echo "$LIBDBUS_GLIB_PKG_ERRORS" >&5
 
-	{ { $as_echo "$as_me:$LINENO: error: Package requirements (dbus-glib-1 >= $DBUS_GLIB_REQUIRED) were not met:
-
-$LIBDBUS_GLIB_PKG_ERRORS
-
-Consider adjusting the PKG_CONFIG_PATH environment variable if you
-installed software in a non-standard prefix.
-
-Alternatively, you may set the environment variables LIBDBUS_GLIB_CFLAGS
-and LIBDBUS_GLIB_LIBS to avoid the need to call pkg-config.
-See the pkg-config man page for more details.
-" >&5
-$as_echo "$as_me: error: Package requirements (dbus-glib-1 >= $DBUS_GLIB_REQUIRED) were not met:
+	as_fn_error "Package requirements (dbus-glib-1 >= $DBUS_GLIB_REQUIRED) were not met:
 
 $LIBDBUS_GLIB_PKG_ERRORS
 
@@ -13080,22 +11898,11 @@ installed software in a non-standard pre
 Alternatively, you may set the environment variables LIBDBUS_GLIB_CFLAGS
 and LIBDBUS_GLIB_LIBS to avoid the need to call pkg-config.
 See the pkg-config man page for more details.
-" >&2;}
-   { (exit 1); exit 1; }; }
+" "$LINENO" 5
 elif test $pkg_failed = untried; then
-	{ { $as_echo "$as_me:$LINENO: error: in \`$ac_pwd':" >&5
+	{ { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
 $as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
-{ { $as_echo "$as_me:$LINENO: error: The pkg-config script could not be found or is too old.  Make sure it
-is in your PATH or set the PKG_CONFIG environment variable to the full
-path to pkg-config.
-
-Alternatively, you may set the environment variables LIBDBUS_GLIB_CFLAGS
-and LIBDBUS_GLIB_LIBS to avoid the need to call pkg-config.
-See the pkg-config man page for more details.
-
-To get pkg-config, see <http://pkg-config.freedesktop.org/>.
-See \`config.log' for more details." >&5
-$as_echo "$as_me: error: The pkg-config script could not be found or is too old.  Make sure it
+as_fn_error "The pkg-config script could not be found or is too old.  Make sure it
 is in your PATH or set the PKG_CONFIG environment variable to the full
 path to pkg-config.
 
@@ -13104,55 +11911,50 @@ and LIBDBUS_GLIB_LIBS to avoid the need
 See the pkg-config man page for more details.
 
 To get pkg-config, see <http://pkg-config.freedesktop.org/>.
-See \`config.log' for more details." >&2;}
-   { (exit 1); exit 1; }; }; }
+See \`config.log' for more details." "$LINENO" 5; }
 else
 	LIBDBUS_GLIB_CFLAGS=$pkg_cv_LIBDBUS_GLIB_CFLAGS
 	LIBDBUS_GLIB_LIBS=$pkg_cv_LIBDBUS_GLIB_LIBS
-        { $as_echo "$as_me:$LINENO: result: yes" >&5
+        { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
 $as_echo "yes" >&6; }
 	:
 fi
 
 pkg_failed=no
-{ $as_echo "$as_me:$LINENO: checking for LIBGSTREAMER" >&5
-$as_echo_n "checking for LIBGSTREAMER... " >&6; }
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for LIBVLC" >&5
+$as_echo_n "checking for LIBVLC... " >&6; }
 
-if test -n "$PKG_CONFIG"; then
-    if test -n "$LIBGSTREAMER_CFLAGS"; then
-        pkg_cv_LIBGSTREAMER_CFLAGS="$LIBGSTREAMER_CFLAGS"
-    else
-        if test -n "$PKG_CONFIG" && \
-    { ($as_echo "$as_me:$LINENO: \$PKG_CONFIG --exists --print-errors \"gstreamer-0.10 >= \$GSTREAMER_REQUIRED\"") >&5
-  ($PKG_CONFIG --exists --print-errors "gstreamer-0.10 >= $GSTREAMER_REQUIRED") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; then
-  pkg_cv_LIBGSTREAMER_CFLAGS=`$PKG_CONFIG --cflags "gstreamer-0.10 >= $GSTREAMER_REQUIRED" 2>/dev/null`
+if test -n "$LIBVLC_CFLAGS"; then
+    pkg_cv_LIBVLC_CFLAGS="$LIBVLC_CFLAGS"
+ elif test -n "$PKG_CONFIG"; then
+    if test -n "$PKG_CONFIG" && \
+    { { $as_echo "$as_me:${as_lineno-$LINENO}: \$PKG_CONFIG --exists --print-errors \"libvlc >= \$VLC_REQUIRED\""; } >&5
+  ($PKG_CONFIG --exists --print-errors "libvlc >= $VLC_REQUIRED") 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }; then
+  pkg_cv_LIBVLC_CFLAGS=`$PKG_CONFIG --cflags "libvlc >= $VLC_REQUIRED" 2>/dev/null`
 else
   pkg_failed=yes
 fi
-    fi
-else
-	pkg_failed=untried
+ else
+    pkg_failed=untried
 fi
-if test -n "$PKG_CONFIG"; then
-    if test -n "$LIBGSTREAMER_LIBS"; then
-        pkg_cv_LIBGSTREAMER_LIBS="$LIBGSTREAMER_LIBS"
-    else
-        if test -n "$PKG_CONFIG" && \
-    { ($as_echo "$as_me:$LINENO: \$PKG_CONFIG --exists --print-errors \"gstreamer-0.10 >= \$GSTREAMER_REQUIRED\"") >&5
-  ($PKG_CONFIG --exists --print-errors "gstreamer-0.10 >= $GSTREAMER_REQUIRED") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; then
-  pkg_cv_LIBGSTREAMER_LIBS=`$PKG_CONFIG --libs "gstreamer-0.10 >= $GSTREAMER_REQUIRED" 2>/dev/null`
+if test -n "$LIBVLC_LIBS"; then
+    pkg_cv_LIBVLC_LIBS="$LIBVLC_LIBS"
+ elif test -n "$PKG_CONFIG"; then
+    if test -n "$PKG_CONFIG" && \
+    { { $as_echo "$as_me:${as_lineno-$LINENO}: \$PKG_CONFIG --exists --print-errors \"libvlc >= \$VLC_REQUIRED\""; } >&5
+  ($PKG_CONFIG --exists --print-errors "libvlc >= $VLC_REQUIRED") 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }; then
+  pkg_cv_LIBVLC_LIBS=`$PKG_CONFIG --libs "libvlc >= $VLC_REQUIRED" 2>/dev/null`
 else
   pkg_failed=yes
 fi
-    fi
-else
-	pkg_failed=untried
+ else
+    pkg_failed=untried
 fi
 
 
@@ -13165,107 +11967,80 @@ else
         _pkg_short_errors_supported=no
 fi
         if test $_pkg_short_errors_supported = yes; then
-	        LIBGSTREAMER_PKG_ERRORS=`$PKG_CONFIG --short-errors --errors-to-stdout --print-errors "gstreamer-0.10 >= $GSTREAMER_REQUIRED"`
+	        LIBVLC_PKG_ERRORS=`$PKG_CONFIG --short-errors --print-errors "libvlc >= $VLC_REQUIRED" 2>&1`
         else
-	        LIBGSTREAMER_PKG_ERRORS=`$PKG_CONFIG --errors-to-stdout --print-errors "gstreamer-0.10 >= $GSTREAMER_REQUIRED"`
+	        LIBVLC_PKG_ERRORS=`$PKG_CONFIG --print-errors "libvlc >= $VLC_REQUIRED" 2>&1`
         fi
 	# Put the nasty error message in config.log where it belongs
-	echo "$LIBGSTREAMER_PKG_ERRORS" >&5
-
-	{ { $as_echo "$as_me:$LINENO: error: Package requirements (gstreamer-0.10 >= $GSTREAMER_REQUIRED) were not met:
-
-$LIBGSTREAMER_PKG_ERRORS
-
-Consider adjusting the PKG_CONFIG_PATH environment variable if you
-installed software in a non-standard prefix.
+	echo "$LIBVLC_PKG_ERRORS" >&5
 
-Alternatively, you may set the environment variables LIBGSTREAMER_CFLAGS
-and LIBGSTREAMER_LIBS to avoid the need to call pkg-config.
-See the pkg-config man page for more details.
-" >&5
-$as_echo "$as_me: error: Package requirements (gstreamer-0.10 >= $GSTREAMER_REQUIRED) were not met:
+	as_fn_error "Package requirements (libvlc >= $VLC_REQUIRED) were not met:
 
-$LIBGSTREAMER_PKG_ERRORS
+$LIBVLC_PKG_ERRORS
 
 Consider adjusting the PKG_CONFIG_PATH environment variable if you
 installed software in a non-standard prefix.
 
-Alternatively, you may set the environment variables LIBGSTREAMER_CFLAGS
-and LIBGSTREAMER_LIBS to avoid the need to call pkg-config.
+Alternatively, you may set the environment variables LIBVLC_CFLAGS
+and LIBVLC_LIBS to avoid the need to call pkg-config.
 See the pkg-config man page for more details.
-" >&2;}
-   { (exit 1); exit 1; }; }
+" "$LINENO" 5
 elif test $pkg_failed = untried; then
-	{ { $as_echo "$as_me:$LINENO: error: in \`$ac_pwd':" >&5
+	{ { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
 $as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
-{ { $as_echo "$as_me:$LINENO: error: The pkg-config script could not be found or is too old.  Make sure it
-is in your PATH or set the PKG_CONFIG environment variable to the full
-path to pkg-config.
-
-Alternatively, you may set the environment variables LIBGSTREAMER_CFLAGS
-and LIBGSTREAMER_LIBS to avoid the need to call pkg-config.
-See the pkg-config man page for more details.
-
-To get pkg-config, see <http://pkg-config.freedesktop.org/>.
-See \`config.log' for more details." >&5
-$as_echo "$as_me: error: The pkg-config script could not be found or is too old.  Make sure it
+as_fn_error "The pkg-config script could not be found or is too old.  Make sure it
 is in your PATH or set the PKG_CONFIG environment variable to the full
 path to pkg-config.
 
-Alternatively, you may set the environment variables LIBGSTREAMER_CFLAGS
-and LIBGSTREAMER_LIBS to avoid the need to call pkg-config.
+Alternatively, you may set the environment variables LIBVLC_CFLAGS
+and LIBVLC_LIBS to avoid the need to call pkg-config.
 See the pkg-config man page for more details.
 
 To get pkg-config, see <http://pkg-config.freedesktop.org/>.
-See \`config.log' for more details." >&2;}
-   { (exit 1); exit 1; }; }; }
+See \`config.log' for more details." "$LINENO" 5; }
 else
-	LIBGSTREAMER_CFLAGS=$pkg_cv_LIBGSTREAMER_CFLAGS
-	LIBGSTREAMER_LIBS=$pkg_cv_LIBGSTREAMER_LIBS
-        { $as_echo "$as_me:$LINENO: result: yes" >&5
+	LIBVLC_CFLAGS=$pkg_cv_LIBVLC_CFLAGS
+	LIBVLC_LIBS=$pkg_cv_LIBVLC_LIBS
+        { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
 $as_echo "yes" >&6; }
 	:
 fi
 
 pkg_failed=no
-{ $as_echo "$as_me:$LINENO: checking for LIBGIO" >&5
-$as_echo_n "checking for LIBGIO... " >&6; }
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for LIBGLIB" >&5
+$as_echo_n "checking for LIBGLIB... " >&6; }
 
-if test -n "$PKG_CONFIG"; then
-    if test -n "$LIBGIO_CFLAGS"; then
-        pkg_cv_LIBGIO_CFLAGS="$LIBGIO_CFLAGS"
-    else
-        if test -n "$PKG_CONFIG" && \
-    { ($as_echo "$as_me:$LINENO: \$PKG_CONFIG --exists --print-errors \"gio-2.0 >= \$GIO_REQUIRED\"") >&5
-  ($PKG_CONFIG --exists --print-errors "gio-2.0 >= $GIO_REQUIRED") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; then
-  pkg_cv_LIBGIO_CFLAGS=`$PKG_CONFIG --cflags "gio-2.0 >= $GIO_REQUIRED" 2>/dev/null`
+if test -n "$LIBGLIB_CFLAGS"; then
+    pkg_cv_LIBGLIB_CFLAGS="$LIBGLIB_CFLAGS"
+ elif test -n "$PKG_CONFIG"; then
+    if test -n "$PKG_CONFIG" && \
+    { { $as_echo "$as_me:${as_lineno-$LINENO}: \$PKG_CONFIG --exists --print-errors \"glib-2.0 >= \$GLIB_REQUIRED\""; } >&5
+  ($PKG_CONFIG --exists --print-errors "glib-2.0 >= $GLIB_REQUIRED") 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }; then
+  pkg_cv_LIBGLIB_CFLAGS=`$PKG_CONFIG --cflags "glib-2.0 >= $GLIB_REQUIRED" 2>/dev/null`
 else
   pkg_failed=yes
 fi
-    fi
-else
-	pkg_failed=untried
+ else
+    pkg_failed=untried
 fi
-if test -n "$PKG_CONFIG"; then
-    if test -n "$LIBGIO_LIBS"; then
-        pkg_cv_LIBGIO_LIBS="$LIBGIO_LIBS"
-    else
-        if test -n "$PKG_CONFIG" && \
-    { ($as_echo "$as_me:$LINENO: \$PKG_CONFIG --exists --print-errors \"gio-2.0 >= \$GIO_REQUIRED\"") >&5
-  ($PKG_CONFIG --exists --print-errors "gio-2.0 >= $GIO_REQUIRED") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; then
-  pkg_cv_LIBGIO_LIBS=`$PKG_CONFIG --libs "gio-2.0 >= $GIO_REQUIRED" 2>/dev/null`
+if test -n "$LIBGLIB_LIBS"; then
+    pkg_cv_LIBGLIB_LIBS="$LIBGLIB_LIBS"
+ elif test -n "$PKG_CONFIG"; then
+    if test -n "$PKG_CONFIG" && \
+    { { $as_echo "$as_me:${as_lineno-$LINENO}: \$PKG_CONFIG --exists --print-errors \"glib-2.0 >= \$GLIB_REQUIRED\""; } >&5
+  ($PKG_CONFIG --exists --print-errors "glib-2.0 >= $GLIB_REQUIRED") 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }; then
+  pkg_cv_LIBGLIB_LIBS=`$PKG_CONFIG --libs "glib-2.0 >= $GLIB_REQUIRED" 2>/dev/null`
 else
   pkg_failed=yes
 fi
-    fi
-else
-	pkg_failed=untried
+ else
+    pkg_failed=untried
 fi
 
 
@@ -13278,107 +12053,80 @@ else
         _pkg_short_errors_supported=no
 fi
         if test $_pkg_short_errors_supported = yes; then
-	        LIBGIO_PKG_ERRORS=`$PKG_CONFIG --short-errors --errors-to-stdout --print-errors "gio-2.0 >= $GIO_REQUIRED"`
+	        LIBGLIB_PKG_ERRORS=`$PKG_CONFIG --short-errors --print-errors "glib-2.0 >= $GLIB_REQUIRED" 2>&1`
         else
-	        LIBGIO_PKG_ERRORS=`$PKG_CONFIG --errors-to-stdout --print-errors "gio-2.0 >= $GIO_REQUIRED"`
+	        LIBGLIB_PKG_ERRORS=`$PKG_CONFIG --print-errors "glib-2.0 >= $GLIB_REQUIRED" 2>&1`
         fi
 	# Put the nasty error message in config.log where it belongs
-	echo "$LIBGIO_PKG_ERRORS" >&5
-
-	{ { $as_echo "$as_me:$LINENO: error: Package requirements (gio-2.0 >= $GIO_REQUIRED) were not met:
-
-$LIBGIO_PKG_ERRORS
+	echo "$LIBGLIB_PKG_ERRORS" >&5
 
-Consider adjusting the PKG_CONFIG_PATH environment variable if you
-installed software in a non-standard prefix.
-
-Alternatively, you may set the environment variables LIBGIO_CFLAGS
-and LIBGIO_LIBS to avoid the need to call pkg-config.
-See the pkg-config man page for more details.
-" >&5
-$as_echo "$as_me: error: Package requirements (gio-2.0 >= $GIO_REQUIRED) were not met:
+	as_fn_error "Package requirements (glib-2.0 >= $GLIB_REQUIRED) were not met:
 
-$LIBGIO_PKG_ERRORS
+$LIBGLIB_PKG_ERRORS
 
 Consider adjusting the PKG_CONFIG_PATH environment variable if you
 installed software in a non-standard prefix.
 
-Alternatively, you may set the environment variables LIBGIO_CFLAGS
-and LIBGIO_LIBS to avoid the need to call pkg-config.
+Alternatively, you may set the environment variables LIBGLIB_CFLAGS
+and LIBGLIB_LIBS to avoid the need to call pkg-config.
 See the pkg-config man page for more details.
-" >&2;}
-   { (exit 1); exit 1; }; }
+" "$LINENO" 5
 elif test $pkg_failed = untried; then
-	{ { $as_echo "$as_me:$LINENO: error: in \`$ac_pwd':" >&5
+	{ { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
 $as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
-{ { $as_echo "$as_me:$LINENO: error: The pkg-config script could not be found or is too old.  Make sure it
-is in your PATH or set the PKG_CONFIG environment variable to the full
-path to pkg-config.
-
-Alternatively, you may set the environment variables LIBGIO_CFLAGS
-and LIBGIO_LIBS to avoid the need to call pkg-config.
-See the pkg-config man page for more details.
-
-To get pkg-config, see <http://pkg-config.freedesktop.org/>.
-See \`config.log' for more details." >&5
-$as_echo "$as_me: error: The pkg-config script could not be found or is too old.  Make sure it
+as_fn_error "The pkg-config script could not be found or is too old.  Make sure it
 is in your PATH or set the PKG_CONFIG environment variable to the full
 path to pkg-config.
 
-Alternatively, you may set the environment variables LIBGIO_CFLAGS
-and LIBGIO_LIBS to avoid the need to call pkg-config.
+Alternatively, you may set the environment variables LIBGLIB_CFLAGS
+and LIBGLIB_LIBS to avoid the need to call pkg-config.
 See the pkg-config man page for more details.
 
 To get pkg-config, see <http://pkg-config.freedesktop.org/>.
-See \`config.log' for more details." >&2;}
-   { (exit 1); exit 1; }; }; }
+See \`config.log' for more details." "$LINENO" 5; }
 else
-	LIBGIO_CFLAGS=$pkg_cv_LIBGIO_CFLAGS
-	LIBGIO_LIBS=$pkg_cv_LIBGIO_LIBS
-        { $as_echo "$as_me:$LINENO: result: yes" >&5
+	LIBGLIB_CFLAGS=$pkg_cv_LIBGLIB_CFLAGS
+	LIBGLIB_LIBS=$pkg_cv_LIBGLIB_LIBS
+        { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
 $as_echo "yes" >&6; }
 	:
 fi
 
 pkg_failed=no
-{ $as_echo "$as_me:$LINENO: checking for GEE" >&5
-$as_echo_n "checking for GEE... " >&6; }
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for LIBGIO" >&5
+$as_echo_n "checking for LIBGIO... " >&6; }
 
-if test -n "$PKG_CONFIG"; then
-    if test -n "$GEE_CFLAGS"; then
-        pkg_cv_GEE_CFLAGS="$GEE_CFLAGS"
-    else
-        if test -n "$PKG_CONFIG" && \
-    { ($as_echo "$as_me:$LINENO: \$PKG_CONFIG --exists --print-errors \"gee-1.0 >= \$GEE_REQUIRED\"") >&5
-  ($PKG_CONFIG --exists --print-errors "gee-1.0 >= $GEE_REQUIRED") 2>&5
+if test -n "$LIBGIO_CFLAGS"; then
+    pkg_cv_LIBGIO_CFLAGS="$LIBGIO_CFLAGS"
+ elif test -n "$PKG_CONFIG"; then
+    if test -n "$PKG_CONFIG" && \
+    { { $as_echo "$as_me:${as_lineno-$LINENO}: \$PKG_CONFIG --exists --print-errors \"gio-2.0 >= \$GIO_REQUIRED\""; } >&5
+  ($PKG_CONFIG --exists --print-errors "gio-2.0 >= $GIO_REQUIRED") 2>&5
   ac_status=$?
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; then
-  pkg_cv_GEE_CFLAGS=`$PKG_CONFIG --cflags "gee-1.0 >= $GEE_REQUIRED" 2>/dev/null`
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }; then
+  pkg_cv_LIBGIO_CFLAGS=`$PKG_CONFIG --cflags "gio-2.0 >= $GIO_REQUIRED" 2>/dev/null`
 else
   pkg_failed=yes
 fi
-    fi
-else
-	pkg_failed=untried
+ else
+    pkg_failed=untried
 fi
-if test -n "$PKG_CONFIG"; then
-    if test -n "$GEE_LIBS"; then
-        pkg_cv_GEE_LIBS="$GEE_LIBS"
-    else
-        if test -n "$PKG_CONFIG" && \
-    { ($as_echo "$as_me:$LINENO: \$PKG_CONFIG --exists --print-errors \"gee-1.0 >= \$GEE_REQUIRED\"") >&5
-  ($PKG_CONFIG --exists --print-errors "gee-1.0 >= $GEE_REQUIRED") 2>&5
+if test -n "$LIBGIO_LIBS"; then
+    pkg_cv_LIBGIO_LIBS="$LIBGIO_LIBS"
+ elif test -n "$PKG_CONFIG"; then
+    if test -n "$PKG_CONFIG" && \
+    { { $as_echo "$as_me:${as_lineno-$LINENO}: \$PKG_CONFIG --exists --print-errors \"gio-2.0 >= \$GIO_REQUIRED\""; } >&5
+  ($PKG_CONFIG --exists --print-errors "gio-2.0 >= $GIO_REQUIRED") 2>&5
   ac_status=$?
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; then
-  pkg_cv_GEE_LIBS=`$PKG_CONFIG --libs "gee-1.0 >= $GEE_REQUIRED" 2>/dev/null`
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }; then
+  pkg_cv_LIBGIO_LIBS=`$PKG_CONFIG --libs "gio-2.0 >= $GIO_REQUIRED" 2>/dev/null`
 else
   pkg_failed=yes
 fi
-    fi
-else
-	pkg_failed=untried
+ else
+    pkg_failed=untried
 fi
 
 
@@ -13391,107 +12139,80 @@ else
         _pkg_short_errors_supported=no
 fi
         if test $_pkg_short_errors_supported = yes; then
-	        GEE_PKG_ERRORS=`$PKG_CONFIG --short-errors --errors-to-stdout --print-errors "gee-1.0 >= $GEE_REQUIRED"`
+	        LIBGIO_PKG_ERRORS=`$PKG_CONFIG --short-errors --print-errors "gio-2.0 >= $GIO_REQUIRED" 2>&1`
         else
-	        GEE_PKG_ERRORS=`$PKG_CONFIG --errors-to-stdout --print-errors "gee-1.0 >= $GEE_REQUIRED"`
+	        LIBGIO_PKG_ERRORS=`$PKG_CONFIG --print-errors "gio-2.0 >= $GIO_REQUIRED" 2>&1`
         fi
 	# Put the nasty error message in config.log where it belongs
-	echo "$GEE_PKG_ERRORS" >&5
-
-	{ { $as_echo "$as_me:$LINENO: error: Package requirements (gee-1.0 >= $GEE_REQUIRED) were not met:
-
-$GEE_PKG_ERRORS
-
-Consider adjusting the PKG_CONFIG_PATH environment variable if you
-installed software in a non-standard prefix.
+	echo "$LIBGIO_PKG_ERRORS" >&5
 
-Alternatively, you may set the environment variables GEE_CFLAGS
-and GEE_LIBS to avoid the need to call pkg-config.
-See the pkg-config man page for more details.
-" >&5
-$as_echo "$as_me: error: Package requirements (gee-1.0 >= $GEE_REQUIRED) were not met:
+	as_fn_error "Package requirements (gio-2.0 >= $GIO_REQUIRED) were not met:
 
-$GEE_PKG_ERRORS
+$LIBGIO_PKG_ERRORS
 
 Consider adjusting the PKG_CONFIG_PATH environment variable if you
 installed software in a non-standard prefix.
 
-Alternatively, you may set the environment variables GEE_CFLAGS
-and GEE_LIBS to avoid the need to call pkg-config.
+Alternatively, you may set the environment variables LIBGIO_CFLAGS
+and LIBGIO_LIBS to avoid the need to call pkg-config.
 See the pkg-config man page for more details.
-" >&2;}
-   { (exit 1); exit 1; }; }
+" "$LINENO" 5
 elif test $pkg_failed = untried; then
-	{ { $as_echo "$as_me:$LINENO: error: in \`$ac_pwd':" >&5
+	{ { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
 $as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
-{ { $as_echo "$as_me:$LINENO: error: The pkg-config script could not be found or is too old.  Make sure it
-is in your PATH or set the PKG_CONFIG environment variable to the full
-path to pkg-config.
-
-Alternatively, you may set the environment variables GEE_CFLAGS
-and GEE_LIBS to avoid the need to call pkg-config.
-See the pkg-config man page for more details.
-
-To get pkg-config, see <http://pkg-config.freedesktop.org/>.
-See \`config.log' for more details." >&5
-$as_echo "$as_me: error: The pkg-config script could not be found or is too old.  Make sure it
+as_fn_error "The pkg-config script could not be found or is too old.  Make sure it
 is in your PATH or set the PKG_CONFIG environment variable to the full
 path to pkg-config.
 
-Alternatively, you may set the environment variables GEE_CFLAGS
-and GEE_LIBS to avoid the need to call pkg-config.
+Alternatively, you may set the environment variables LIBGIO_CFLAGS
+and LIBGIO_LIBS to avoid the need to call pkg-config.
 See the pkg-config man page for more details.
 
 To get pkg-config, see <http://pkg-config.freedesktop.org/>.
-See \`config.log' for more details." >&2;}
-   { (exit 1); exit 1; }; }; }
+See \`config.log' for more details." "$LINENO" 5; }
 else
-	GEE_CFLAGS=$pkg_cv_GEE_CFLAGS
-	GEE_LIBS=$pkg_cv_GEE_LIBS
-        { $as_echo "$as_me:$LINENO: result: yes" >&5
+	LIBGIO_CFLAGS=$pkg_cv_LIBGIO_CFLAGS
+	LIBGIO_LIBS=$pkg_cv_LIBGIO_LIBS
+        { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
 $as_echo "yes" >&6; }
 	:
 fi
 
 pkg_failed=no
-{ $as_echo "$as_me:$LINENO: checking for UUID" >&5
-$as_echo_n "checking for UUID... " >&6; }
-
-if test -n "$PKG_CONFIG"; then
-    if test -n "$UUID_CFLAGS"; then
-        pkg_cv_UUID_CFLAGS="$UUID_CFLAGS"
-    else
-        if test -n "$PKG_CONFIG" && \
-    { ($as_echo "$as_me:$LINENO: \$PKG_CONFIG --exists --print-errors \"uuid >= \$UUID_REQUIRED\"") >&5
-  ($PKG_CONFIG --exists --print-errors "uuid >= $UUID_REQUIRED") 2>&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for GEE" >&5
+$as_echo_n "checking for GEE... " >&6; }
+
+if test -n "$GEE_CFLAGS"; then
+    pkg_cv_GEE_CFLAGS="$GEE_CFLAGS"
+ elif test -n "$PKG_CONFIG"; then
+    if test -n "$PKG_CONFIG" && \
+    { { $as_echo "$as_me:${as_lineno-$LINENO}: \$PKG_CONFIG --exists --print-errors \"gee-1.0 >= \$GEE_REQUIRED\""; } >&5
+  ($PKG_CONFIG --exists --print-errors "gee-1.0 >= $GEE_REQUIRED") 2>&5
   ac_status=$?
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; then
-  pkg_cv_UUID_CFLAGS=`$PKG_CONFIG --cflags "uuid >= $UUID_REQUIRED" 2>/dev/null`
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }; then
+  pkg_cv_GEE_CFLAGS=`$PKG_CONFIG --cflags "gee-1.0 >= $GEE_REQUIRED" 2>/dev/null`
 else
   pkg_failed=yes
 fi
-    fi
-else
-	pkg_failed=untried
+ else
+    pkg_failed=untried
 fi
-if test -n "$PKG_CONFIG"; then
-    if test -n "$UUID_LIBS"; then
-        pkg_cv_UUID_LIBS="$UUID_LIBS"
-    else
-        if test -n "$PKG_CONFIG" && \
-    { ($as_echo "$as_me:$LINENO: \$PKG_CONFIG --exists --print-errors \"uuid >= \$UUID_REQUIRED\"") >&5
-  ($PKG_CONFIG --exists --print-errors "uuid >= $UUID_REQUIRED") 2>&5
+if test -n "$GEE_LIBS"; then
+    pkg_cv_GEE_LIBS="$GEE_LIBS"
+ elif test -n "$PKG_CONFIG"; then
+    if test -n "$PKG_CONFIG" && \
+    { { $as_echo "$as_me:${as_lineno-$LINENO}: \$PKG_CONFIG --exists --print-errors \"gee-1.0 >= \$GEE_REQUIRED\""; } >&5
+  ($PKG_CONFIG --exists --print-errors "gee-1.0 >= $GEE_REQUIRED") 2>&5
   ac_status=$?
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; then
-  pkg_cv_UUID_LIBS=`$PKG_CONFIG --libs "uuid >= $UUID_REQUIRED" 2>/dev/null`
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }; then
+  pkg_cv_GEE_LIBS=`$PKG_CONFIG --libs "gee-1.0 >= $GEE_REQUIRED" 2>/dev/null`
 else
   pkg_failed=yes
 fi
-    fi
-else
-	pkg_failed=untried
+ else
+    pkg_failed=untried
 fi
 
 
@@ -13504,107 +12225,81 @@ else
         _pkg_short_errors_supported=no
 fi
         if test $_pkg_short_errors_supported = yes; then
-	        UUID_PKG_ERRORS=`$PKG_CONFIG --short-errors --errors-to-stdout --print-errors "uuid >= $UUID_REQUIRED"`
+	        GEE_PKG_ERRORS=`$PKG_CONFIG --short-errors --print-errors "gee-1.0 >= $GEE_REQUIRED" 2>&1`
         else
-	        UUID_PKG_ERRORS=`$PKG_CONFIG --errors-to-stdout --print-errors "uuid >= $UUID_REQUIRED"`
+	        GEE_PKG_ERRORS=`$PKG_CONFIG --print-errors "gee-1.0 >= $GEE_REQUIRED" 2>&1`
         fi
 	# Put the nasty error message in config.log where it belongs
-	echo "$UUID_PKG_ERRORS" >&5
-
-	{ { $as_echo "$as_me:$LINENO: error: Package requirements (uuid >= $UUID_REQUIRED) were not met:
-
-$UUID_PKG_ERRORS
-
-Consider adjusting the PKG_CONFIG_PATH environment variable if you
-installed software in a non-standard prefix.
+	echo "$GEE_PKG_ERRORS" >&5
 
-Alternatively, you may set the environment variables UUID_CFLAGS
-and UUID_LIBS to avoid the need to call pkg-config.
-See the pkg-config man page for more details.
-" >&5
-$as_echo "$as_me: error: Package requirements (uuid >= $UUID_REQUIRED) were not met:
+	as_fn_error "Package requirements (gee-1.0 >= $GEE_REQUIRED) were not met:
 
-$UUID_PKG_ERRORS
+$GEE_PKG_ERRORS
 
 Consider adjusting the PKG_CONFIG_PATH environment variable if you
 installed software in a non-standard prefix.
 
-Alternatively, you may set the environment variables UUID_CFLAGS
-and UUID_LIBS to avoid the need to call pkg-config.
+Alternatively, you may set the environment variables GEE_CFLAGS
+and GEE_LIBS to avoid the need to call pkg-config.
 See the pkg-config man page for more details.
-" >&2;}
-   { (exit 1); exit 1; }; }
+" "$LINENO" 5
 elif test $pkg_failed = untried; then
-	{ { $as_echo "$as_me:$LINENO: error: in \`$ac_pwd':" >&5
+	{ { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
 $as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
-{ { $as_echo "$as_me:$LINENO: error: The pkg-config script could not be found or is too old.  Make sure it
-is in your PATH or set the PKG_CONFIG environment variable to the full
-path to pkg-config.
-
-Alternatively, you may set the environment variables UUID_CFLAGS
-and UUID_LIBS to avoid the need to call pkg-config.
-See the pkg-config man page for more details.
-
-To get pkg-config, see <http://pkg-config.freedesktop.org/>.
-See \`config.log' for more details." >&5
-$as_echo "$as_me: error: The pkg-config script could not be found or is too old.  Make sure it
+as_fn_error "The pkg-config script could not be found or is too old.  Make sure it
 is in your PATH or set the PKG_CONFIG environment variable to the full
 path to pkg-config.
 
-Alternatively, you may set the environment variables UUID_CFLAGS
-and UUID_LIBS to avoid the need to call pkg-config.
+Alternatively, you may set the environment variables GEE_CFLAGS
+and GEE_LIBS to avoid the need to call pkg-config.
 See the pkg-config man page for more details.
 
 To get pkg-config, see <http://pkg-config.freedesktop.org/>.
-See \`config.log' for more details." >&2;}
-   { (exit 1); exit 1; }; }; }
+See \`config.log' for more details." "$LINENO" 5; }
 else
-	UUID_CFLAGS=$pkg_cv_UUID_CFLAGS
-	UUID_LIBS=$pkg_cv_UUID_LIBS
-        { $as_echo "$as_me:$LINENO: result: yes" >&5
+	GEE_CFLAGS=$pkg_cv_GEE_CFLAGS
+	GEE_LIBS=$pkg_cv_GEE_LIBS
+        { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
 $as_echo "yes" >&6; }
 	:
 fi
+#PKG_CHECK_MODULES(UUID, uuid >= $UUID_REQUIRED)
 
 pkg_failed=no
-{ $as_echo "$as_me:$LINENO: checking for LIBSOUP" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for LIBSOUP" >&5
 $as_echo_n "checking for LIBSOUP... " >&6; }
 
-if test -n "$PKG_CONFIG"; then
-    if test -n "$LIBSOUP_CFLAGS"; then
-        pkg_cv_LIBSOUP_CFLAGS="$LIBSOUP_CFLAGS"
-    else
-        if test -n "$PKG_CONFIG" && \
-    { ($as_echo "$as_me:$LINENO: \$PKG_CONFIG --exists --print-errors \"libsoup-2.4 >= \$LIBSOUP_REQUIRED\"") >&5
+if test -n "$LIBSOUP_CFLAGS"; then
+    pkg_cv_LIBSOUP_CFLAGS="$LIBSOUP_CFLAGS"
+ elif test -n "$PKG_CONFIG"; then
+    if test -n "$PKG_CONFIG" && \
+    { { $as_echo "$as_me:${as_lineno-$LINENO}: \$PKG_CONFIG --exists --print-errors \"libsoup-2.4 >= \$LIBSOUP_REQUIRED\""; } >&5
   ($PKG_CONFIG --exists --print-errors "libsoup-2.4 >= $LIBSOUP_REQUIRED") 2>&5
   ac_status=$?
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; then
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }; then
   pkg_cv_LIBSOUP_CFLAGS=`$PKG_CONFIG --cflags "libsoup-2.4 >= $LIBSOUP_REQUIRED" 2>/dev/null`
 else
   pkg_failed=yes
 fi
-    fi
-else
-	pkg_failed=untried
+ else
+    pkg_failed=untried
 fi
-if test -n "$PKG_CONFIG"; then
-    if test -n "$LIBSOUP_LIBS"; then
-        pkg_cv_LIBSOUP_LIBS="$LIBSOUP_LIBS"
-    else
-        if test -n "$PKG_CONFIG" && \
-    { ($as_echo "$as_me:$LINENO: \$PKG_CONFIG --exists --print-errors \"libsoup-2.4 >= \$LIBSOUP_REQUIRED\"") >&5
+if test -n "$LIBSOUP_LIBS"; then
+    pkg_cv_LIBSOUP_LIBS="$LIBSOUP_LIBS"
+ elif test -n "$PKG_CONFIG"; then
+    if test -n "$PKG_CONFIG" && \
+    { { $as_echo "$as_me:${as_lineno-$LINENO}: \$PKG_CONFIG --exists --print-errors \"libsoup-2.4 >= \$LIBSOUP_REQUIRED\""; } >&5
   ($PKG_CONFIG --exists --print-errors "libsoup-2.4 >= $LIBSOUP_REQUIRED") 2>&5
   ac_status=$?
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; then
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }; then
   pkg_cv_LIBSOUP_LIBS=`$PKG_CONFIG --libs "libsoup-2.4 >= $LIBSOUP_REQUIRED" 2>/dev/null`
 else
   pkg_failed=yes
 fi
-    fi
-else
-	pkg_failed=untried
+ else
+    pkg_failed=untried
 fi
 
 
@@ -13617,25 +12312,14 @@ else
         _pkg_short_errors_supported=no
 fi
         if test $_pkg_short_errors_supported = yes; then
-	        LIBSOUP_PKG_ERRORS=`$PKG_CONFIG --short-errors --errors-to-stdout --print-errors "libsoup-2.4 >= $LIBSOUP_REQUIRED"`
+	        LIBSOUP_PKG_ERRORS=`$PKG_CONFIG --short-errors --print-errors "libsoup-2.4 >= $LIBSOUP_REQUIRED" 2>&1`
         else
-	        LIBSOUP_PKG_ERRORS=`$PKG_CONFIG --errors-to-stdout --print-errors "libsoup-2.4 >= $LIBSOUP_REQUIRED"`
+	        LIBSOUP_PKG_ERRORS=`$PKG_CONFIG --print-errors "libsoup-2.4 >= $LIBSOUP_REQUIRED" 2>&1`
         fi
 	# Put the nasty error message in config.log where it belongs
 	echo "$LIBSOUP_PKG_ERRORS" >&5
 
-	{ { $as_echo "$as_me:$LINENO: error: Package requirements (libsoup-2.4 >= $LIBSOUP_REQUIRED) were not met:
-
-$LIBSOUP_PKG_ERRORS
-
-Consider adjusting the PKG_CONFIG_PATH environment variable if you
-installed software in a non-standard prefix.
-
-Alternatively, you may set the environment variables LIBSOUP_CFLAGS
-and LIBSOUP_LIBS to avoid the need to call pkg-config.
-See the pkg-config man page for more details.
-" >&5
-$as_echo "$as_me: error: Package requirements (libsoup-2.4 >= $LIBSOUP_REQUIRED) were not met:
+	as_fn_error "Package requirements (libsoup-2.4 >= $LIBSOUP_REQUIRED) were not met:
 
 $LIBSOUP_PKG_ERRORS
 
@@ -13645,12 +12329,11 @@ installed software in a non-standard pre
 Alternatively, you may set the environment variables LIBSOUP_CFLAGS
 and LIBSOUP_LIBS to avoid the need to call pkg-config.
 See the pkg-config man page for more details.
-" >&2;}
-   { (exit 1); exit 1; }; }
+" "$LINENO" 5
 elif test $pkg_failed = untried; then
-	{ { $as_echo "$as_me:$LINENO: error: in \`$ac_pwd':" >&5
+	{ { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
 $as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
-{ { $as_echo "$as_me:$LINENO: error: The pkg-config script could not be found or is too old.  Make sure it
+as_fn_error "The pkg-config script could not be found or is too old.  Make sure it
 is in your PATH or set the PKG_CONFIG environment variable to the full
 path to pkg-config.
 
@@ -13659,65 +12342,50 @@ and LIBSOUP_LIBS to avoid the need to ca
 See the pkg-config man page for more details.
 
 To get pkg-config, see <http://pkg-config.freedesktop.org/>.
-See \`config.log' for more details." >&5
-$as_echo "$as_me: error: The pkg-config script could not be found or is too old.  Make sure it
-is in your PATH or set the PKG_CONFIG environment variable to the full
-path to pkg-config.
-
-Alternatively, you may set the environment variables LIBSOUP_CFLAGS
-and LIBSOUP_LIBS to avoid the need to call pkg-config.
-See the pkg-config man page for more details.
-
-To get pkg-config, see <http://pkg-config.freedesktop.org/>.
-See \`config.log' for more details." >&2;}
-   { (exit 1); exit 1; }; }; }
+See \`config.log' for more details." "$LINENO" 5; }
 else
 	LIBSOUP_CFLAGS=$pkg_cv_LIBSOUP_CFLAGS
 	LIBSOUP_LIBS=$pkg_cv_LIBSOUP_LIBS
-        { $as_echo "$as_me:$LINENO: result: yes" >&5
+        { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
 $as_echo "yes" >&6; }
 	:
 fi
 
 pkg_failed=no
-{ $as_echo "$as_me:$LINENO: checking for LIBSQLITE3" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for LIBSQLITE3" >&5
 $as_echo_n "checking for LIBSQLITE3... " >&6; }
 
-if test -n "$PKG_CONFIG"; then
-    if test -n "$LIBSQLITE3_CFLAGS"; then
-        pkg_cv_LIBSQLITE3_CFLAGS="$LIBSQLITE3_CFLAGS"
-    else
-        if test -n "$PKG_CONFIG" && \
-    { ($as_echo "$as_me:$LINENO: \$PKG_CONFIG --exists --print-errors \"sqlite3 >= \$LIBSQLITE3_REQUIRED\"") >&5
+if test -n "$LIBSQLITE3_CFLAGS"; then
+    pkg_cv_LIBSQLITE3_CFLAGS="$LIBSQLITE3_CFLAGS"
+ elif test -n "$PKG_CONFIG"; then
+    if test -n "$PKG_CONFIG" && \
+    { { $as_echo "$as_me:${as_lineno-$LINENO}: \$PKG_CONFIG --exists --print-errors \"sqlite3 >= \$LIBSQLITE3_REQUIRED\""; } >&5
   ($PKG_CONFIG --exists --print-errors "sqlite3 >= $LIBSQLITE3_REQUIRED") 2>&5
   ac_status=$?
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; then
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }; then
   pkg_cv_LIBSQLITE3_CFLAGS=`$PKG_CONFIG --cflags "sqlite3 >= $LIBSQLITE3_REQUIRED" 2>/dev/null`
 else
   pkg_failed=yes
 fi
-    fi
-else
-	pkg_failed=untried
+ else
+    pkg_failed=untried
 fi
-if test -n "$PKG_CONFIG"; then
-    if test -n "$LIBSQLITE3_LIBS"; then
-        pkg_cv_LIBSQLITE3_LIBS="$LIBSQLITE3_LIBS"
-    else
-        if test -n "$PKG_CONFIG" && \
-    { ($as_echo "$as_me:$LINENO: \$PKG_CONFIG --exists --print-errors \"sqlite3 >= \$LIBSQLITE3_REQUIRED\"") >&5
+if test -n "$LIBSQLITE3_LIBS"; then
+    pkg_cv_LIBSQLITE3_LIBS="$LIBSQLITE3_LIBS"
+ elif test -n "$PKG_CONFIG"; then
+    if test -n "$PKG_CONFIG" && \
+    { { $as_echo "$as_me:${as_lineno-$LINENO}: \$PKG_CONFIG --exists --print-errors \"sqlite3 >= \$LIBSQLITE3_REQUIRED\""; } >&5
   ($PKG_CONFIG --exists --print-errors "sqlite3 >= $LIBSQLITE3_REQUIRED") 2>&5
   ac_status=$?
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; then
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }; then
   pkg_cv_LIBSQLITE3_LIBS=`$PKG_CONFIG --libs "sqlite3 >= $LIBSQLITE3_REQUIRED" 2>/dev/null`
 else
   pkg_failed=yes
 fi
-    fi
-else
-	pkg_failed=untried
+ else
+    pkg_failed=untried
 fi
 
 
@@ -13730,14 +12398,14 @@ else
         _pkg_short_errors_supported=no
 fi
         if test $_pkg_short_errors_supported = yes; then
-	        LIBSQLITE3_PKG_ERRORS=`$PKG_CONFIG --short-errors --errors-to-stdout --print-errors "sqlite3 >= $LIBSQLITE3_REQUIRED"`
+	        LIBSQLITE3_PKG_ERRORS=`$PKG_CONFIG --short-errors --print-errors "sqlite3 >= $LIBSQLITE3_REQUIRED" 2>&1`
         else
-	        LIBSQLITE3_PKG_ERRORS=`$PKG_CONFIG --errors-to-stdout --print-errors "sqlite3 >= $LIBSQLITE3_REQUIRED"`
+	        LIBSQLITE3_PKG_ERRORS=`$PKG_CONFIG --print-errors "sqlite3 >= $LIBSQLITE3_REQUIRED" 2>&1`
         fi
 	# Put the nasty error message in config.log where it belongs
 	echo "$LIBSQLITE3_PKG_ERRORS" >&5
 
-	{ { $as_echo "$as_me:$LINENO: error: Package requirements (sqlite3 >= $LIBSQLITE3_REQUIRED) were not met:
+	as_fn_error "Package requirements (sqlite3 >= $LIBSQLITE3_REQUIRED) were not met:
 
 $LIBSQLITE3_PKG_ERRORS
 
@@ -13747,33 +12415,11 @@ installed software in a non-standard pre
 Alternatively, you may set the environment variables LIBSQLITE3_CFLAGS
 and LIBSQLITE3_LIBS to avoid the need to call pkg-config.
 See the pkg-config man page for more details.
-" >&5
-$as_echo "$as_me: error: Package requirements (sqlite3 >= $LIBSQLITE3_REQUIRED) were not met:
-
-$LIBSQLITE3_PKG_ERRORS
-
-Consider adjusting the PKG_CONFIG_PATH environment variable if you
-installed software in a non-standard prefix.
-
-Alternatively, you may set the environment variables LIBSQLITE3_CFLAGS
-and LIBSQLITE3_LIBS to avoid the need to call pkg-config.
-See the pkg-config man page for more details.
-" >&2;}
-   { (exit 1); exit 1; }; }
+" "$LINENO" 5
 elif test $pkg_failed = untried; then
-	{ { $as_echo "$as_me:$LINENO: error: in \`$ac_pwd':" >&5
+	{ { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
 $as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
-{ { $as_echo "$as_me:$LINENO: error: The pkg-config script could not be found or is too old.  Make sure it
-is in your PATH or set the PKG_CONFIG environment variable to the full
-path to pkg-config.
-
-Alternatively, you may set the environment variables LIBSQLITE3_CFLAGS
-and LIBSQLITE3_LIBS to avoid the need to call pkg-config.
-See the pkg-config man page for more details.
-
-To get pkg-config, see <http://pkg-config.freedesktop.org/>.
-See \`config.log' for more details." >&5
-$as_echo "$as_me: error: The pkg-config script could not be found or is too old.  Make sure it
+as_fn_error "The pkg-config script could not be found or is too old.  Make sure it
 is in your PATH or set the PKG_CONFIG environment variable to the full
 path to pkg-config.
 
@@ -13782,12 +12428,11 @@ and LIBSQLITE3_LIBS to avoid the need to
 See the pkg-config man page for more details.
 
 To get pkg-config, see <http://pkg-config.freedesktop.org/>.
-See \`config.log' for more details." >&2;}
-   { (exit 1); exit 1; }; }; }
+See \`config.log' for more details." "$LINENO" 5; }
 else
 	LIBSQLITE3_CFLAGS=$pkg_cv_LIBSQLITE3_CFLAGS
 	LIBSQLITE3_LIBS=$pkg_cv_LIBSQLITE3_LIBS
-        { $as_echo "$as_me:$LINENO: result: yes" >&5
+        { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
 $as_echo "yes" >&6; }
 	:
 fi
@@ -13797,7 +12442,7 @@ GLIB_GENMARSHAL=`pkg-config --variable=g
 
 
 # Check whether --enable-vala was given.
-if test "${enable_vala+set}" = set; then
+if test "${enable_vala+set}" = set; then :
   enableval=$enable_vala;
 else
   enable_vala=no
@@ -13809,9 +12454,9 @@ if test x$enable_vala = xyes ; then
     # check for vala
     # Extract the first word of "valac", so it can be a program name with args.
 set dummy valac; ac_word=$2
-{ $as_echo "$as_me:$LINENO: checking for $ac_word" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
 $as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_path_VALAC+set}" = set; then
+if test "${ac_cv_path_VALAC+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   case $VALAC in
@@ -13824,14 +12469,14 @@ for as_dir in $PATH
 do
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
-  for ac_exec_ext in '' $ac_executable_extensions; do
+    for ac_exec_ext in '' $ac_executable_extensions; do
   if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
     ac_cv_path_VALAC="$as_dir/$ac_word$ac_exec_ext"
-    $as_echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
   fi
 done
-done
+  done
 IFS=$as_save_IFS
 
   ;;
@@ -13839,380 +12484,78 @@ esac
 fi
 VALAC=$ac_cv_path_VALAC
 if test -n "$VALAC"; then
-  { $as_echo "$as_me:$LINENO: result: $VALAC" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $VALAC" >&5
 $as_echo "$VALAC" >&6; }
 else
-  { $as_echo "$as_me:$LINENO: result: no" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
 $as_echo "no" >&6; }
 fi
 
 
- if test -z "$VALAC"; then
-  { $as_echo "$as_me:$LINENO: WARNING: No Vala compiler found.  You will not be able to compile .vala source files." >&5
+ if test -z "$VALAC"; then :
+  { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: No Vala compiler found.  You will not be able to compile .vala source files." >&5
 $as_echo "$as_me: WARNING: No Vala compiler found.  You will not be able to compile .vala source files." >&2;}
 else
-  if test -n "$VALA_REQUIRED"; then
-  { $as_echo "$as_me:$LINENO: checking $VALAC is at least version $VALA_REQUIRED" >&5
+  if test -n "$VALA_REQUIRED"; then :
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking $VALAC is at least version $VALA_REQUIRED" >&5
 $as_echo_n "checking $VALAC is at least version $VALA_REQUIRED... " >&6; }
        am__vala_version=`$VALAC --version | sed 's/Vala  *//'`
        as_arg_v1=$VALA_REQUIRED
 as_arg_v2="$am__vala_version"
 awk "$as_awk_strverscmp" v1="$as_arg_v1" v2="$as_arg_v2" /dev/null
-case $? in
-1) { $as_echo "$as_me:$LINENO: result: yes" >&5
-$as_echo "yes" >&6; };;
-0) { $as_echo "$as_me:$LINENO: result: yes" >&5
-$as_echo "yes" >&6; };;
-2) { $as_echo "$as_me:$LINENO: result: no" >&5
+case $? in #(
+  1) :
+    { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; } ;; #(
+  0) :
+    { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; } ;; #(
+  2) :
+    { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
 $as_echo "no" >&6; }
-          { { $as_echo "$as_me:$LINENO: error: Vala $VALA_REQUIRED not found." >&5
-$as_echo "$as_me: error: Vala $VALA_REQUIRED not found." >&2;}
-   { (exit 1); exit 1; }; };;
+          as_fn_error "Vala $VALA_REQUIRED not found." "$LINENO" 5 ;; #(
+  *) :
+     ;;
 esac
 fi
-
 fi
 
 
-
     if test "x$VALAC" = "x"; then
-        { { $as_echo "$as_me:$LINENO: error: Cannot find the \"valac\" compiler in your PATH" >&5
-$as_echo "$as_me: error: Cannot find the \"valac\" compiler in your PATH" >&2;}
-   { (exit 1); exit 1; }; }
-    fi
-
-
-pkg_failed=no
-{ $as_echo "$as_me:$LINENO: checking for GUPNP_VALA" >&5
-$as_echo_n "checking for GUPNP_VALA... " >&6; }
-
-if test -n "$PKG_CONFIG"; then
-    if test -n "$GUPNP_VALA_CFLAGS"; then
-        pkg_cv_GUPNP_VALA_CFLAGS="$GUPNP_VALA_CFLAGS"
-    else
-        if test -n "$PKG_CONFIG" && \
-    { ($as_echo "$as_me:$LINENO: \$PKG_CONFIG --exists --print-errors \"gupnp-vala-1.0 >= \$GUPNP_VALA_REQUIRED\"") >&5
-  ($PKG_CONFIG --exists --print-errors "gupnp-vala-1.0 >= $GUPNP_VALA_REQUIRED") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; then
-  pkg_cv_GUPNP_VALA_CFLAGS=`$PKG_CONFIG --cflags "gupnp-vala-1.0 >= $GUPNP_VALA_REQUIRED" 2>/dev/null`
-else
-  pkg_failed=yes
-fi
-    fi
-else
-	pkg_failed=untried
-fi
-if test -n "$PKG_CONFIG"; then
-    if test -n "$GUPNP_VALA_LIBS"; then
-        pkg_cv_GUPNP_VALA_LIBS="$GUPNP_VALA_LIBS"
-    else
-        if test -n "$PKG_CONFIG" && \
-    { ($as_echo "$as_me:$LINENO: \$PKG_CONFIG --exists --print-errors \"gupnp-vala-1.0 >= \$GUPNP_VALA_REQUIRED\"") >&5
-  ($PKG_CONFIG --exists --print-errors "gupnp-vala-1.0 >= $GUPNP_VALA_REQUIRED") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; then
-  pkg_cv_GUPNP_VALA_LIBS=`$PKG_CONFIG --libs "gupnp-vala-1.0 >= $GUPNP_VALA_REQUIRED" 2>/dev/null`
-else
-  pkg_failed=yes
-fi
+        as_fn_error "Cannot find the \"valac\" compiler in your PATH" "$LINENO" 5
     fi
-else
-	pkg_failed=untried
-fi
-
-
-
-if test $pkg_failed = yes; then
-
-if $PKG_CONFIG --atleast-pkgconfig-version 0.20; then
-        _pkg_short_errors_supported=yes
-else
-        _pkg_short_errors_supported=no
-fi
-        if test $_pkg_short_errors_supported = yes; then
-	        GUPNP_VALA_PKG_ERRORS=`$PKG_CONFIG --short-errors --errors-to-stdout --print-errors "gupnp-vala-1.0 >= $GUPNP_VALA_REQUIRED"`
-        else
-	        GUPNP_VALA_PKG_ERRORS=`$PKG_CONFIG --errors-to-stdout --print-errors "gupnp-vala-1.0 >= $GUPNP_VALA_REQUIRED"`
-        fi
-	# Put the nasty error message in config.log where it belongs
-	echo "$GUPNP_VALA_PKG_ERRORS" >&5
-
-	{ { $as_echo "$as_me:$LINENO: error: Package requirements (gupnp-vala-1.0 >= $GUPNP_VALA_REQUIRED) were not met:
-
-$GUPNP_VALA_PKG_ERRORS
-
-Consider adjusting the PKG_CONFIG_PATH environment variable if you
-installed software in a non-standard prefix.
 
-Alternatively, you may set the environment variables GUPNP_VALA_CFLAGS
-and GUPNP_VALA_LIBS to avoid the need to call pkg-config.
-See the pkg-config man page for more details.
-" >&5
-$as_echo "$as_me: error: Package requirements (gupnp-vala-1.0 >= $GUPNP_VALA_REQUIRED) were not met:
-
-$GUPNP_VALA_PKG_ERRORS
-
-Consider adjusting the PKG_CONFIG_PATH environment variable if you
-installed software in a non-standard prefix.
-
-Alternatively, you may set the environment variables GUPNP_VALA_CFLAGS
-and GUPNP_VALA_LIBS to avoid the need to call pkg-config.
-See the pkg-config man page for more details.
-" >&2;}
-   { (exit 1); exit 1; }; }
-elif test $pkg_failed = untried; then
-	{ { $as_echo "$as_me:$LINENO: error: in \`$ac_pwd':" >&5
-$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
-{ { $as_echo "$as_me:$LINENO: error: The pkg-config script could not be found or is too old.  Make sure it
-is in your PATH or set the PKG_CONFIG environment variable to the full
-path to pkg-config.
-
-Alternatively, you may set the environment variables GUPNP_VALA_CFLAGS
-and GUPNP_VALA_LIBS to avoid the need to call pkg-config.
-See the pkg-config man page for more details.
-
-To get pkg-config, see <http://pkg-config.freedesktop.org/>.
-See \`config.log' for more details." >&5
-$as_echo "$as_me: error: The pkg-config script could not be found or is too old.  Make sure it
-is in your PATH or set the PKG_CONFIG environment variable to the full
-path to pkg-config.
-
-Alternatively, you may set the environment variables GUPNP_VALA_CFLAGS
-and GUPNP_VALA_LIBS to avoid the need to call pkg-config.
-See the pkg-config man page for more details.
-
-To get pkg-config, see <http://pkg-config.freedesktop.org/>.
-See \`config.log' for more details." >&2;}
-   { (exit 1); exit 1; }; }; }
-else
-	GUPNP_VALA_CFLAGS=$pkg_cv_GUPNP_VALA_CFLAGS
-	GUPNP_VALA_LIBS=$pkg_cv_GUPNP_VALA_LIBS
-        { $as_echo "$as_me:$LINENO: result: yes" >&5
-$as_echo "yes" >&6; }
-	:
-fi
+#    PKG_CHECK_MODULES(GUPNP_VALA, gupnp-vala-1.0 >= $GUPNP_VALA_REQUIRED)
     VAPIDIR=`pkg-config --variable=vapidir vala-1.0`
 
     # FIXME: Whats the proper way for checking for particular Vala bindings
-    as_ac_File=`$as_echo "ac_cv_file_"${VAPIDIR}/gupnp-1.0.vapi"" | $as_tr_sh`
-{ $as_echo "$as_me:$LINENO: checking for \"${VAPIDIR}/gupnp-1.0.vapi\"" >&5
-$as_echo_n "checking for \"${VAPIDIR}/gupnp-1.0.vapi\"... " >&6; }
-if { as_var=$as_ac_File; eval "test \"\${$as_var+set}\" = set"; }; then
-  $as_echo_n "(cached) " >&6
-else
-  test "$cross_compiling" = yes &&
-  { { $as_echo "$as_me:$LINENO: error: cannot check for file existence when cross compiling" >&5
-$as_echo "$as_me: error: cannot check for file existence when cross compiling" >&2;}
-   { (exit 1); exit 1; }; }
-if test -r ""${VAPIDIR}/gupnp-1.0.vapi""; then
-  eval "$as_ac_File=yes"
-else
-  eval "$as_ac_File=no"
-fi
-fi
-ac_res=`eval 'as_val=${'$as_ac_File'}
-		 $as_echo "$as_val"'`
-	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
-as_val=`eval 'as_val=${'$as_ac_File'}
-		 $as_echo "$as_val"'`
-   if test "x$as_val" = x""yes; then
-  true
-else
-  { { $as_echo "$as_me:$LINENO: error: \"Unable to find Vala bindings for gupnp-1.0\"" >&5
-$as_echo "$as_me: error: \"Unable to find Vala bindings for gupnp-1.0\"" >&2;}
-   { (exit 1); exit 1; }; }
-fi
-
-
-    as_ac_File=`$as_echo "ac_cv_file_"${VAPIDIR}/gupnp-av-1.0.vapi"" | $as_tr_sh`
-{ $as_echo "$as_me:$LINENO: checking for \"${VAPIDIR}/gupnp-av-1.0.vapi\"" >&5
-$as_echo_n "checking for \"${VAPIDIR}/gupnp-av-1.0.vapi\"... " >&6; }
-if { as_var=$as_ac_File; eval "test \"\${$as_var+set}\" = set"; }; then
-  $as_echo_n "(cached) " >&6
-else
-  test "$cross_compiling" = yes &&
-  { { $as_echo "$as_me:$LINENO: error: cannot check for file existence when cross compiling" >&5
-$as_echo "$as_me: error: cannot check for file existence when cross compiling" >&2;}
-   { (exit 1); exit 1; }; }
-if test -r ""${VAPIDIR}/gupnp-av-1.0.vapi""; then
-  eval "$as_ac_File=yes"
-else
-  eval "$as_ac_File=no"
-fi
-fi
-ac_res=`eval 'as_val=${'$as_ac_File'}
-		 $as_echo "$as_val"'`
-	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
-as_val=`eval 'as_val=${'$as_ac_File'}
-		 $as_echo "$as_val"'`
-   if test "x$as_val" = x""yes; then
-  true
-else
-  { { $as_echo "$as_me:$LINENO: error: \"Unable to find Vala bindings for gupnp-av-1.0\"" >&5
-$as_echo "$as_me: error: \"Unable to find Vala bindings for gupnp-av-1.0\"" >&2;}
-   { (exit 1); exit 1; }; }
-fi
-
-
-    as_ac_File=`$as_echo "ac_cv_file_"${VAPIDIR}/dbus-glib-1.vapi"" | $as_tr_sh`
-{ $as_echo "$as_me:$LINENO: checking for \"${VAPIDIR}/dbus-glib-1.vapi\"" >&5
-$as_echo_n "checking for \"${VAPIDIR}/dbus-glib-1.vapi\"... " >&6; }
-if { as_var=$as_ac_File; eval "test \"\${$as_var+set}\" = set"; }; then
-  $as_echo_n "(cached) " >&6
-else
-  test "$cross_compiling" = yes &&
-  { { $as_echo "$as_me:$LINENO: error: cannot check for file existence when cross compiling" >&5
-$as_echo "$as_me: error: cannot check for file existence when cross compiling" >&2;}
-   { (exit 1); exit 1; }; }
-if test -r ""${VAPIDIR}/dbus-glib-1.vapi""; then
-  eval "$as_ac_File=yes"
-else
-  eval "$as_ac_File=no"
-fi
-fi
-ac_res=`eval 'as_val=${'$as_ac_File'}
-		 $as_echo "$as_val"'`
-	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
-as_val=`eval 'as_val=${'$as_ac_File'}
-		 $as_echo "$as_val"'`
-   if test "x$as_val" = x""yes; then
-  true
-else
-  { { $as_echo "$as_me:$LINENO: error: \"Unable to find Vala bindings for dbus-glib-1\"" >&5
-$as_echo "$as_me: error: \"Unable to find Vala bindings for dbus-glib-1\"" >&2;}
-   { (exit 1); exit 1; }; }
-fi
-
-
-    as_ac_File=`$as_echo "ac_cv_file_"${VAPIDIR}/gstreamer-0.10.vapi"" | $as_tr_sh`
-{ $as_echo "$as_me:$LINENO: checking for \"${VAPIDIR}/gstreamer-0.10.vapi\"" >&5
-$as_echo_n "checking for \"${VAPIDIR}/gstreamer-0.10.vapi\"... " >&6; }
-if { as_var=$as_ac_File; eval "test \"\${$as_var+set}\" = set"; }; then
-  $as_echo_n "(cached) " >&6
-else
-  test "$cross_compiling" = yes &&
-  { { $as_echo "$as_me:$LINENO: error: cannot check for file existence when cross compiling" >&5
-$as_echo "$as_me: error: cannot check for file existence when cross compiling" >&2;}
-   { (exit 1); exit 1; }; }
-if test -r ""${VAPIDIR}/gstreamer-0.10.vapi""; then
-  eval "$as_ac_File=yes"
-else
-  eval "$as_ac_File=no"
-fi
-fi
-ac_res=`eval 'as_val=${'$as_ac_File'}
-		 $as_echo "$as_val"'`
-	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
-as_val=`eval 'as_val=${'$as_ac_File'}
-		 $as_echo "$as_val"'`
-   if test "x$as_val" = x""yes; then
-  true
-else
-  { { $as_echo "$as_me:$LINENO: error: \"Unable to find Vala bindings for gstreamer-0.10\"" >&5
-$as_echo "$as_me: error: \"Unable to find Vala bindings for gstreamer-0.10\"" >&2;}
-   { (exit 1); exit 1; }; }
-fi
-
-
-    as_ac_File=`$as_echo "ac_cv_file_"${VAPIDIR}/gio-2.0.vapi"" | $as_tr_sh`
-{ $as_echo "$as_me:$LINENO: checking for \"${VAPIDIR}/gio-2.0.vapi\"" >&5
-$as_echo_n "checking for \"${VAPIDIR}/gio-2.0.vapi\"... " >&6; }
-if { as_var=$as_ac_File; eval "test \"\${$as_var+set}\" = set"; }; then
-  $as_echo_n "(cached) " >&6
-else
-  test "$cross_compiling" = yes &&
-  { { $as_echo "$as_me:$LINENO: error: cannot check for file existence when cross compiling" >&5
-$as_echo "$as_me: error: cannot check for file existence when cross compiling" >&2;}
-   { (exit 1); exit 1; }; }
-if test -r ""${VAPIDIR}/gio-2.0.vapi""; then
-  eval "$as_ac_File=yes"
-else
-  eval "$as_ac_File=no"
-fi
-fi
-ac_res=`eval 'as_val=${'$as_ac_File'}
-		 $as_echo "$as_val"'`
-	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
-as_val=`eval 'as_val=${'$as_ac_File'}
-		 $as_echo "$as_val"'`
-   if test "x$as_val" = x""yes; then
-  true
-else
-  { { $as_echo "$as_me:$LINENO: error: \"Unable to find Vala bindings for gio-2.0\"" >&5
-$as_echo "$as_me: error: \"Unable to find Vala bindings for gio-2.0\"" >&2;}
-   { (exit 1); exit 1; }; }
-fi
-
-
-    as_ac_File=`$as_echo "ac_cv_file_"${VAPIDIR}/gee-1.0.vapi"" | $as_tr_sh`
-{ $as_echo "$as_me:$LINENO: checking for \"${VAPIDIR}/gee-1.0.vapi\"" >&5
-$as_echo_n "checking for \"${VAPIDIR}/gee-1.0.vapi\"... " >&6; }
-if { as_var=$as_ac_File; eval "test \"\${$as_var+set}\" = set"; }; then
-  $as_echo_n "(cached) " >&6
-else
-  test "$cross_compiling" = yes &&
-  { { $as_echo "$as_me:$LINENO: error: cannot check for file existence when cross compiling" >&5
-$as_echo "$as_me: error: cannot check for file existence when cross compiling" >&2;}
-   { (exit 1); exit 1; }; }
-if test -r ""${VAPIDIR}/gee-1.0.vapi""; then
-  eval "$as_ac_File=yes"
-else
-  eval "$as_ac_File=no"
-fi
-fi
-ac_res=`eval 'as_val=${'$as_ac_File'}
-		 $as_echo "$as_val"'`
-	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
-as_val=`eval 'as_val=${'$as_ac_File'}
-		 $as_echo "$as_val"'`
-   if test "x$as_val" = x""yes; then
-  true
-else
-  { { $as_echo "$as_me:$LINENO: error: \"Unable to find Vala bindings for gee-1.0\"" >&5
-$as_echo "$as_me: error: \"Unable to find Vala bindings for gee-1.0\"" >&2;}
-   { (exit 1); exit 1; }; }
-fi
-
-
-    as_ac_File=`$as_echo "ac_cv_file_"${VAPIDIR}/sqlite3.vapi"" | $as_tr_sh`
-{ $as_echo "$as_me:$LINENO: checking for \"${VAPIDIR}/sqlite3.vapi\"" >&5
-$as_echo_n "checking for \"${VAPIDIR}/sqlite3.vapi\"... " >&6; }
-if { as_var=$as_ac_File; eval "test \"\${$as_var+set}\" = set"; }; then
-  $as_echo_n "(cached) " >&6
-else
-  test "$cross_compiling" = yes &&
-  { { $as_echo "$as_me:$LINENO: error: cannot check for file existence when cross compiling" >&5
-$as_echo "$as_me: error: cannot check for file existence when cross compiling" >&2;}
-   { (exit 1); exit 1; }; }
-if test -r ""${VAPIDIR}/sqlite3.vapi""; then
-  eval "$as_ac_File=yes"
-else
-  eval "$as_ac_File=no"
-fi
-fi
-ac_res=`eval 'as_val=${'$as_ac_File'}
-		 $as_echo "$as_val"'`
-	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
-as_val=`eval 'as_val=${'$as_ac_File'}
-		 $as_echo "$as_val"'`
-   if test "x$as_val" = x""yes; then
-  true
-else
-  { { $as_echo "$as_me:$LINENO: error: \"Unable to find Vala bindings for sqlite3\"" >&5
-$as_echo "$as_me: error: \"Unable to find Vala bindings for sqlite3\"" >&2;}
-   { (exit 1); exit 1; }; }
-fi
-
+#    AC_CHECK_FILE("${VAPIDIR}/gupnp-1.0.vapi",
+#                  true,
+#                  [AC_MSG_ERROR("Unable to find Vala bindings for gupnp-1.0")])
+#
+#    AC_CHECK_FILE("${VAPIDIR}/gupnp-av-1.0.vapi",
+#                  true,
+#                  [AC_MSG_ERROR("Unable to find Vala bindings for gupnp-av-1.0")])
+#
+#    AC_CHECK_FILE("${VAPIDIR}/dbus-glib-1.vapi",
+#                  true,
+#                  [AC_MSG_ERROR("Unable to find Vala bindings for dbus-glib-1")])
+#
+#    AC_CHECK_FILE("${VAPIDIR}/gstreamer-0.10.vapi",
+#                  true,
+#                  [AC_MSG_ERROR("Unable to find Vala bindings for gstreamer-0.10")])
+#
+#    AC_CHECK_FILE("${VAPIDIR}/gio-2.0.vapi",
+#                  true,
+#                  [AC_MSG_ERROR("Unable to find Vala bindings for gio-2.0")])
+#
+#    AC_CHECK_FILE("${VAPIDIR}/gee-1.0.vapi",
+#                  true,
+#                  [AC_MSG_ERROR("Unable to find Vala bindings for gee-1.0")])
+#
+#    AC_CHECK_FILE("${VAPIDIR}/sqlite3.vapi",
+#                  true,
+#                  [AC_MSG_ERROR("Unable to find Vala bindings for sqlite3")])
 else
     VAPIDIR=`echo ${datadir}/vala/vapi`
 fi
@@ -14221,7 +12564,7 @@ fi
 
 # Maemo support
 # Check whether --enable-maemo was given.
-if test "${enable_maemo+set}" = set; then
+if test "${enable_maemo+set}" = set; then :
   enableval=$enable_maemo;
 else
   enable_maemo=no
@@ -14230,7 +12573,7 @@ fi
 
 # Debugging
 # Check whether --enable-debug was given.
-if test "${enable_debug+set}" = set; then
+if test "${enable_debug+set}" = set; then :
   enableval=$enable_debug;
 else
   enable_debug=no
@@ -14242,7 +12585,7 @@ fi
 
 # Strict compiler
 # Check whether --enable-strict-cc was given.
-if test "${enable_strict_cc+set}" = set; then
+if test "${enable_strict_cc+set}" = set; then :
   enableval=$enable_strict_cc;
 else
   enable_strict_cc=no
@@ -14256,69 +12599,65 @@ fi
 
 # Run uninstalled
 # Check whether --enable-uninstalled was given.
-if test "${enable_uninstalled+set}" = set; then
+if test "${enable_uninstalled+set}" = set; then :
   enableval=$enable_uninstalled;
 else
   enable_uninstalled=no
 fi
 
 if test "x$enable_uninstalled" = "xyes"; then
-        { $as_echo "$as_me:$LINENO: WARNING: \"You want to run the tools uninstalled only? Fine!\"" >&5
+        { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: \"You want to run the tools uninstalled only? Fine!\"" >&5
 $as_echo "$as_me: WARNING: \"You want to run the tools uninstalled only? Fine!\"" >&2;}
 fi
 
 # Check wether user wants to build UIs
 
 # Check whether --with-ui was given.
-if test "${with_ui+set}" = set; then
+if test "${with_ui+set}" = set; then :
   withval=$with_ui; try_ui=$withval
 else
   try_ui=yes
 fi
 
-
+try_ui=no
 HAVE_GTK=no
 if test x$try_ui = xyes ; then
 
 pkg_failed=no
-{ $as_echo "$as_me:$LINENO: checking for GTK" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for GTK" >&5
 $as_echo_n "checking for GTK... " >&6; }
 
-if test -n "$PKG_CONFIG"; then
-    if test -n "$GTK_CFLAGS"; then
-        pkg_cv_GTK_CFLAGS="$GTK_CFLAGS"
-    else
-        if test -n "$PKG_CONFIG" && \
-    { ($as_echo "$as_me:$LINENO: \$PKG_CONFIG --exists --print-errors \"gtk+-2.0 >= \$GTK_REQUIRED \"") >&5
+if test -n "$GTK_CFLAGS"; then
+    pkg_cv_GTK_CFLAGS="$GTK_CFLAGS"
+ elif test -n "$PKG_CONFIG"; then
+    if test -n "$PKG_CONFIG" && \
+    { { $as_echo "$as_me:${as_lineno-$LINENO}: \$PKG_CONFIG --exists --print-errors \"gtk+-2.0 >= \$GTK_REQUIRED \""; } >&5
   ($PKG_CONFIG --exists --print-errors "gtk+-2.0 >= $GTK_REQUIRED ") 2>&5
   ac_status=$?
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; then
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }; then
   pkg_cv_GTK_CFLAGS=`$PKG_CONFIG --cflags "gtk+-2.0 >= $GTK_REQUIRED " 2>/dev/null`
 else
   pkg_failed=yes
 fi
-    fi
-else
-	pkg_failed=untried
-fi
-if test -n "$PKG_CONFIG"; then
-    if test -n "$GTK_LIBS"; then
-        pkg_cv_GTK_LIBS="$GTK_LIBS"
-    else
-        if test -n "$PKG_CONFIG" && \
-    { ($as_echo "$as_me:$LINENO: \$PKG_CONFIG --exists --print-errors \"gtk+-2.0 >= \$GTK_REQUIRED \"") >&5
+ else
+    pkg_failed=untried
+fi
+if test -n "$GTK_LIBS"; then
+    pkg_cv_GTK_LIBS="$GTK_LIBS"
+ elif test -n "$PKG_CONFIG"; then
+    if test -n "$PKG_CONFIG" && \
+    { { $as_echo "$as_me:${as_lineno-$LINENO}: \$PKG_CONFIG --exists --print-errors \"gtk+-2.0 >= \$GTK_REQUIRED \""; } >&5
   ($PKG_CONFIG --exists --print-errors "gtk+-2.0 >= $GTK_REQUIRED ") 2>&5
   ac_status=$?
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; then
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }; then
   pkg_cv_GTK_LIBS=`$PKG_CONFIG --libs "gtk+-2.0 >= $GTK_REQUIRED " 2>/dev/null`
 else
   pkg_failed=yes
 fi
-    fi
-else
-	pkg_failed=untried
+ else
+    pkg_failed=untried
 fi
 
 
@@ -14331,71 +12670,65 @@ else
         _pkg_short_errors_supported=no
 fi
         if test $_pkg_short_errors_supported = yes; then
-	        GTK_PKG_ERRORS=`$PKG_CONFIG --short-errors --errors-to-stdout --print-errors "gtk+-2.0 >= $GTK_REQUIRED "`
+	        GTK_PKG_ERRORS=`$PKG_CONFIG --short-errors --print-errors "gtk+-2.0 >= $GTK_REQUIRED " 2>&1`
         else
-	        GTK_PKG_ERRORS=`$PKG_CONFIG --errors-to-stdout --print-errors "gtk+-2.0 >= $GTK_REQUIRED "`
+	        GTK_PKG_ERRORS=`$PKG_CONFIG --print-errors "gtk+-2.0 >= $GTK_REQUIRED " 2>&1`
         fi
 	# Put the nasty error message in config.log where it belongs
 	echo "$GTK_PKG_ERRORS" >&5
 
-	{ $as_echo "$as_me:$LINENO: result: no" >&5
+	{ $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
 $as_echo "no" >&6; }
 
         HAVE_GTK=no
-        { $as_echo "$as_me:$LINENO: WARNING: gtk $GTK_REQUIRED or greater not found." >&5
+        { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: gtk $GTK_REQUIRED or greater not found." >&5
 $as_echo "$as_me: WARNING: gtk $GTK_REQUIRED or greater not found." >&2;}
-        { $as_echo "$as_me:$LINENO: WARNING: UI applications will not be built." >&5
+        { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: UI applications will not be built." >&5
 $as_echo "$as_me: WARNING: UI applications will not be built." >&2;}
 
 elif test $pkg_failed = untried; then
 
         HAVE_GTK=no
-        { $as_echo "$as_me:$LINENO: WARNING: gtk $GTK_REQUIRED or greater not found." >&5
+        { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: gtk $GTK_REQUIRED or greater not found." >&5
 $as_echo "$as_me: WARNING: gtk $GTK_REQUIRED or greater not found." >&2;}
-        { $as_echo "$as_me:$LINENO: WARNING: UI applications will not be built." >&5
+        { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: UI applications will not be built." >&5
 $as_echo "$as_me: WARNING: UI applications will not be built." >&2;}
 
 else
 	GTK_CFLAGS=$pkg_cv_GTK_CFLAGS
 	GTK_LIBS=$pkg_cv_GTK_LIBS
-        { $as_echo "$as_me:$LINENO: result: yes" >&5
+        { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
 $as_echo "yes" >&6; }
 
 
 
         if test x$enable_vala = xyes ; then
                 as_ac_File=`$as_echo "ac_cv_file_"${VAPIDIR}/gtk+-2.0.vapi"" | $as_tr_sh`
-{ $as_echo "$as_me:$LINENO: checking for \"${VAPIDIR}/gtk+-2.0.vapi\"" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for \"${VAPIDIR}/gtk+-2.0.vapi\"" >&5
 $as_echo_n "checking for \"${VAPIDIR}/gtk+-2.0.vapi\"... " >&6; }
-if { as_var=$as_ac_File; eval "test \"\${$as_var+set}\" = set"; }; then
+if { as_var=$as_ac_File; eval "test \"\${$as_var+set}\" = set"; }; then :
   $as_echo_n "(cached) " >&6
 else
   test "$cross_compiling" = yes &&
-  { { $as_echo "$as_me:$LINENO: error: cannot check for file existence when cross compiling" >&5
-$as_echo "$as_me: error: cannot check for file existence when cross compiling" >&2;}
-   { (exit 1); exit 1; }; }
+  as_fn_error "cannot check for file existence when cross compiling" "$LINENO" 5
 if test -r ""${VAPIDIR}/gtk+-2.0.vapi""; then
   eval "$as_ac_File=yes"
 else
   eval "$as_ac_File=no"
 fi
 fi
-ac_res=`eval 'as_val=${'$as_ac_File'}
-		 $as_echo "$as_val"'`
-	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
+eval ac_res=\$$as_ac_File
+	       { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
 $as_echo "$ac_res" >&6; }
-as_val=`eval 'as_val=${'$as_ac_File'}
-		 $as_echo "$as_val"'`
-   if test "x$as_val" = x""yes; then
+eval as_val=\$$as_ac_File
+   if test "x$as_val" = x""yes; then :
 
                         HAVE_GTK=yes
 
 else
 
                         HAVE_GTK=no
-                        { { $as_echo "$as_me:$LINENO: error: \"Unable to find Vala bindings for gtk+-2.0\"" >&5
-$as_echo "$as_me: error: \"Unable to find Vala bindings for gtk+-2.0\"" >&2;}
-   { (exit 1); exit 1; }; }
+                        as_fn_error "\"Unable to find Vala bindings for gtk+-2.0\"" "$LINENO" 5
 
 fi
 
@@ -14405,7 +12738,7 @@ fi
 
 fi
 else
-    { $as_echo "$as_me:$LINENO: UI applications disabled." >&5
+    { $as_echo "$as_me:${as_lineno-$LINENO}: UI applications disabled." >&5
 $as_echo "$as_me: UI applications disabled." >&6;}
 fi
 
@@ -14414,9 +12747,7 @@ if test x$HAVE_GTK = xno; then
 else
   BUILD_UI=yes
 
-cat >>confdefs.h <<\_ACEOF
-#define HAVE_GTK /**/
-_ACEOF
+$as_echo "#define HAVE_GTK /**/" >>confdefs.h
 
 fi
 
@@ -14432,7 +12763,7 @@ fi
 
 # Build test plugin
 # Check whether --enable-test-plugin was given.
-if test "${enable_test_plugin+set}" = set; then
+if test "${enable_test_plugin+set}" = set; then :
   enableval=$enable_test_plugin;
 else
   enable_test_plugin=no
@@ -14441,7 +12772,7 @@ fi
 
 # Build Tracker plugin
 # Check whether --enable-tracker-plugin was given.
-if test "${enable_tracker_plugin+set}" = set; then
+if test "${enable_tracker_plugin+set}" = set; then :
   enableval=$enable_tracker_plugin;
 else
   enable_tracker_plugin=yes
@@ -14450,7 +12781,7 @@ fi
 
 # Build MediaExport plugin
 # Check whether --enable-media-export-plugin was given.
-if test "${enable_media_export_plugin+set}" = set; then
+if test "${enable_media_export_plugin+set}" = set; then :
   enableval=$enable_media_export_plugin;
 else
   enable_media_export_plugin=yes
@@ -14459,7 +12790,7 @@ fi
 
 # Build External plugin
 # Check whether --enable-external-plugin was given.
-if test "${enable_external_plugin+set}" = set; then
+if test "${enable_external_plugin+set}" = set; then :
   enableval=$enable_external_plugin;
 else
   enable_external_plugin=yes
@@ -14468,7 +12799,7 @@ fi
 
 # Build Mediathek plugin
 # Check whether --enable-mediathek-plugin was given.
-if test "${enable_mediathek_plugin+set}" = set; then
+if test "${enable_mediathek_plugin+set}" = set; then :
   enableval=$enable_mediathek_plugin;
 else
   enable_mediathek_plugin=no
@@ -14477,13 +12808,22 @@ fi
 
 # Build GstLaunch plugin
 # Check whether --enable-gstlaunch-plugin was given.
-if test "${enable_gstlaunch_plugin+set}" = set; then
+if test "${enable_gstlaunch_plugin+set}" = set; then :
   enableval=$enable_gstlaunch_plugin;
 else
   enable_gstlaunch_plugin=no
 fi
 
 
+# Build GstRenderer plugin
+# Check whether --enable-gst-renderer-plugin was given.
+if test "${enable_gst_renderer_plugin+set}" = set; then :
+  enableval=$enable_gst_renderer_plugin;
+else
+  enable_gst_renderer_plugin=no
+fi
+
+
 
 
 
@@ -14551,6 +12891,14 @@ else
   BUILD_GSTLAUNCH_PLUGIN_FALSE=
 fi
 
+ if test "x$enable_gst_renderer_plugin" = "xyes"; then
+  BUILD_GST_RENDERER_PLUGIN_TRUE=
+  BUILD_GST_RENDERER_PLUGIN_FALSE='#'
+else
+  BUILD_GST_RENDERER_PLUGIN_TRUE='#'
+  BUILD_GST_RENDERER_PLUGIN_FALSE=
+fi
+
 
 # Gettext
 GETTEXT_PACKAGE=rygel
@@ -14563,151 +12911,12 @@ _ACEOF
 
 ALL_LINGUAS=""
 
-
-for ac_header in locale.h
-do
-as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
-if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
-  { $as_echo "$as_me:$LINENO: checking for $ac_header" >&5
-$as_echo_n "checking for $ac_header... " >&6; }
-if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
-  $as_echo_n "(cached) " >&6
-fi
-ac_res=`eval 'as_val=${'$as_ac_Header'}
-		 $as_echo "$as_val"'`
-	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
-else
-  # Is the header compilable?
-{ $as_echo "$as_me:$LINENO: checking $ac_header usability" >&5
-$as_echo_n "checking $ac_header usability... " >&6; }
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-#include <$ac_header>
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
-  ac_header_compiler=yes
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_header_compiler=no
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-{ $as_echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
-$as_echo "$ac_header_compiler" >&6; }
-
-# Is the header present?
-{ $as_echo "$as_me:$LINENO: checking $ac_header presence" >&5
-$as_echo_n "checking $ac_header presence... " >&6; }
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-#include <$ac_header>
-_ACEOF
-if { (ac_try="$ac_cpp conftest.$ac_ext"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_cpp conftest.$ac_ext") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } >/dev/null && {
-	 test -z "$ac_c_preproc_warn_flag$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       }; then
-  ac_header_preproc=yes
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-  ac_header_preproc=no
-fi
-
-rm -f conftest.err conftest.$ac_ext
-{ $as_echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
-$as_echo "$ac_header_preproc" >&6; }
-
-# So?  What about this header?
-case $ac_header_compiler:$ac_header_preproc:$ac_c_preproc_warn_flag in
-  yes:no: )
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&5
-$as_echo "$as_me: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the compiler's result" >&5
-$as_echo "$as_me: WARNING: $ac_header: proceeding with the compiler's result" >&2;}
-    ac_header_preproc=yes
-    ;;
-  no:yes:* )
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: present but cannot be compiled" >&5
-$as_echo "$as_me: WARNING: $ac_header: present but cannot be compiled" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header:     check for missing prerequisite headers?" >&5
-$as_echo "$as_me: WARNING: $ac_header:     check for missing prerequisite headers?" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: see the Autoconf documentation" >&5
-$as_echo "$as_me: WARNING: $ac_header: see the Autoconf documentation" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header:     section \"Present But Cannot Be Compiled\"" >&5
-$as_echo "$as_me: WARNING: $ac_header:     section \"Present But Cannot Be Compiled\"" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
-$as_echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: $ac_header: in the future, the compiler will take precedence" >&5
-$as_echo "$as_me: WARNING: $ac_header: in the future, the compiler will take precedence" >&2;}
-    ( cat <<\_ASBOX
-## ------------------------------------------ ##
-## Report this to http://live.gnome.org/Rygel ##
-## ------------------------------------------ ##
-_ASBOX
-     ) | sed "s/^/$as_me: WARNING:     /" >&2
-    ;;
-esac
-{ $as_echo "$as_me:$LINENO: checking for $ac_header" >&5
-$as_echo_n "checking for $ac_header... " >&6; }
-if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
-  $as_echo_n "(cached) " >&6
-else
-  eval "$as_ac_Header=\$ac_header_preproc"
-fi
-ac_res=`eval 'as_val=${'$as_ac_Header'}
-		 $as_echo "$as_val"'`
-	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
-
-fi
-as_val=`eval 'as_val=${'$as_ac_Header'}
-		 $as_echo "$as_val"'`
-   if test "x$as_val" = x""yes; then
+   for ac_header in locale.h
+do :
+  ac_fn_c_check_header_mongrel "$LINENO" "locale.h" "ac_cv_header_locale_h" "$ac_includes_default"
+if test "x$ac_cv_header_locale_h" = x""yes; then :
   cat >>confdefs.h <<_ACEOF
-#define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
+#define HAVE_LOCALE_H 1
 _ACEOF
 
 fi
@@ -14715,16 +12924,12 @@ fi
 done
 
     if test $ac_cv_header_locale_h = yes; then
-    { $as_echo "$as_me:$LINENO: checking for LC_MESSAGES" >&5
+    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for LC_MESSAGES" >&5
 $as_echo_n "checking for LC_MESSAGES... " >&6; }
-if test "${am_cv_val_LC_MESSAGES+set}" = set; then
+if test "${am_cv_val_LC_MESSAGES+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 #include <locale.h>
 int
@@ -14735,46 +12940,19 @@ return LC_MESSAGES
   return 0;
 }
 _ACEOF
-rm -f conftest.$ac_objext conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_link") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest$ac_exeext && {
-	 test "$cross_compiling" = yes ||
-	 $as_test_x conftest$ac_exeext
-       }; then
+if ac_fn_c_try_link "$LINENO"; then :
   am_cv_val_LC_MESSAGES=yes
 else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	am_cv_val_LC_MESSAGES=no
+  am_cv_val_LC_MESSAGES=no
 fi
-
-rm -rf conftest.dSYM
-rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
-      conftest$ac_exeext conftest.$ac_ext
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
 fi
-{ $as_echo "$as_me:$LINENO: result: $am_cv_val_LC_MESSAGES" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $am_cv_val_LC_MESSAGES" >&5
 $as_echo "$am_cv_val_LC_MESSAGES" >&6; }
     if test $am_cv_val_LC_MESSAGES = yes; then
 
-cat >>confdefs.h <<\_ACEOF
-#define HAVE_LC_MESSAGES 1
-_ACEOF
+$as_echo "#define HAVE_LC_MESSAGES 1" >>confdefs.h
 
     fi
   fi
@@ -14787,155 +12965,20 @@ _ACEOF
     XGETTEXT=:
     INTLLIBS=
 
-    if test "${ac_cv_header_libintl_h+set}" = set; then
-  { $as_echo "$as_me:$LINENO: checking for libintl.h" >&5
-$as_echo_n "checking for libintl.h... " >&6; }
-if test "${ac_cv_header_libintl_h+set}" = set; then
-  $as_echo_n "(cached) " >&6
-fi
-{ $as_echo "$as_me:$LINENO: result: $ac_cv_header_libintl_h" >&5
-$as_echo "$ac_cv_header_libintl_h" >&6; }
-else
-  # Is the header compilable?
-{ $as_echo "$as_me:$LINENO: checking libintl.h usability" >&5
-$as_echo_n "checking libintl.h usability... " >&6; }
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-#include <libintl.h>
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
-  ac_header_compiler=yes
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_header_compiler=no
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-{ $as_echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
-$as_echo "$ac_header_compiler" >&6; }
-
-# Is the header present?
-{ $as_echo "$as_me:$LINENO: checking libintl.h presence" >&5
-$as_echo_n "checking libintl.h presence... " >&6; }
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-#include <libintl.h>
-_ACEOF
-if { (ac_try="$ac_cpp conftest.$ac_ext"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_cpp conftest.$ac_ext") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } >/dev/null && {
-	 test -z "$ac_c_preproc_warn_flag$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       }; then
-  ac_header_preproc=yes
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-  ac_header_preproc=no
-fi
-
-rm -f conftest.err conftest.$ac_ext
-{ $as_echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
-$as_echo "$ac_header_preproc" >&6; }
-
-# So?  What about this header?
-case $ac_header_compiler:$ac_header_preproc:$ac_c_preproc_warn_flag in
-  yes:no: )
-    { $as_echo "$as_me:$LINENO: WARNING: libintl.h: accepted by the compiler, rejected by the preprocessor!" >&5
-$as_echo "$as_me: WARNING: libintl.h: accepted by the compiler, rejected by the preprocessor!" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: libintl.h: proceeding with the compiler's result" >&5
-$as_echo "$as_me: WARNING: libintl.h: proceeding with the compiler's result" >&2;}
-    ac_header_preproc=yes
-    ;;
-  no:yes:* )
-    { $as_echo "$as_me:$LINENO: WARNING: libintl.h: present but cannot be compiled" >&5
-$as_echo "$as_me: WARNING: libintl.h: present but cannot be compiled" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: libintl.h:     check for missing prerequisite headers?" >&5
-$as_echo "$as_me: WARNING: libintl.h:     check for missing prerequisite headers?" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: libintl.h: see the Autoconf documentation" >&5
-$as_echo "$as_me: WARNING: libintl.h: see the Autoconf documentation" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: libintl.h:     section \"Present But Cannot Be Compiled\"" >&5
-$as_echo "$as_me: WARNING: libintl.h:     section \"Present But Cannot Be Compiled\"" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: libintl.h: proceeding with the preprocessor's result" >&5
-$as_echo "$as_me: WARNING: libintl.h: proceeding with the preprocessor's result" >&2;}
-    { $as_echo "$as_me:$LINENO: WARNING: libintl.h: in the future, the compiler will take precedence" >&5
-$as_echo "$as_me: WARNING: libintl.h: in the future, the compiler will take precedence" >&2;}
-    ( cat <<\_ASBOX
-## ------------------------------------------ ##
-## Report this to http://live.gnome.org/Rygel ##
-## ------------------------------------------ ##
-_ASBOX
-     ) | sed "s/^/$as_me: WARNING:     /" >&2
-    ;;
-esac
-{ $as_echo "$as_me:$LINENO: checking for libintl.h" >&5
-$as_echo_n "checking for libintl.h... " >&6; }
-if test "${ac_cv_header_libintl_h+set}" = set; then
-  $as_echo_n "(cached) " >&6
-else
-  ac_cv_header_libintl_h=$ac_header_preproc
-fi
-{ $as_echo "$as_me:$LINENO: result: $ac_cv_header_libintl_h" >&5
-$as_echo "$ac_cv_header_libintl_h" >&6; }
-
-fi
-if test "x$ac_cv_header_libintl_h" = x""yes; then
+    ac_fn_c_check_header_mongrel "$LINENO" "libintl.h" "ac_cv_header_libintl_h" "$ac_includes_default"
+if test "x$ac_cv_header_libintl_h" = x""yes; then :
   gt_cv_func_dgettext_libintl="no"
       libintl_extra_libs=""
 
       #
       # First check in libc
       #
-      { $as_echo "$as_me:$LINENO: checking for ngettext in libc" >&5
+      { $as_echo "$as_me:${as_lineno-$LINENO}: checking for ngettext in libc" >&5
 $as_echo_n "checking for ngettext in libc... " >&6; }
-if test "${gt_cv_func_ngettext_libc+set}" = set; then
+if test "${gt_cv_func_ngettext_libc+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 
 #include <libintl.h>
@@ -14948,54 +12991,25 @@ return !ngettext ("","", 1)
   return 0;
 }
 _ACEOF
-rm -f conftest.$ac_objext conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_link") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest$ac_exeext && {
-	 test "$cross_compiling" = yes ||
-	 $as_test_x conftest$ac_exeext
-       }; then
+if ac_fn_c_try_link "$LINENO"; then :
   gt_cv_func_ngettext_libc=yes
 else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	gt_cv_func_ngettext_libc=no
+  gt_cv_func_ngettext_libc=no
 fi
-
-rm -rf conftest.dSYM
-rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
-      conftest$ac_exeext conftest.$ac_ext
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
 
 fi
-{ $as_echo "$as_me:$LINENO: result: $gt_cv_func_ngettext_libc" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $gt_cv_func_ngettext_libc" >&5
 $as_echo "$gt_cv_func_ngettext_libc" >&6; }
 
       if test "$gt_cv_func_ngettext_libc" = "yes" ; then
-	      { $as_echo "$as_me:$LINENO: checking for dgettext in libc" >&5
+	      { $as_echo "$as_me:${as_lineno-$LINENO}: checking for dgettext in libc" >&5
 $as_echo_n "checking for dgettext in libc... " >&6; }
-if test "${gt_cv_func_dgettext_libc+set}" = set; then
+if test "${gt_cv_func_dgettext_libc+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 
 #include <libintl.h>
@@ -15008,141 +13022,26 @@ return !dgettext ("","")
   return 0;
 }
 _ACEOF
-rm -f conftest.$ac_objext conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_link") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest$ac_exeext && {
-	 test "$cross_compiling" = yes ||
-	 $as_test_x conftest$ac_exeext
-       }; then
+if ac_fn_c_try_link "$LINENO"; then :
   gt_cv_func_dgettext_libc=yes
 else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	gt_cv_func_dgettext_libc=no
+  gt_cv_func_dgettext_libc=no
 fi
-
-rm -rf conftest.dSYM
-rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
-      conftest$ac_exeext conftest.$ac_ext
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
 
 fi
-{ $as_echo "$as_me:$LINENO: result: $gt_cv_func_dgettext_libc" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $gt_cv_func_dgettext_libc" >&5
 $as_echo "$gt_cv_func_dgettext_libc" >&6; }
       fi
-
-      if test "$gt_cv_func_ngettext_libc" = "yes" ; then
-
-for ac_func in bind_textdomain_codeset
-do
-as_ac_var=`$as_echo "ac_cv_func_$ac_func" | $as_tr_sh`
-{ $as_echo "$as_me:$LINENO: checking for $ac_func" >&5
-$as_echo_n "checking for $ac_func... " >&6; }
-if { as_var=$as_ac_var; eval "test \"\${$as_var+set}\" = set"; }; then
-  $as_echo_n "(cached) " >&6
-else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-/* Define $ac_func to an innocuous variant, in case <limits.h> declares $ac_func.
-   For example, HP-UX 11i <limits.h> declares gettimeofday.  */
-#define $ac_func innocuous_$ac_func
-
-/* System header to define __stub macros and hopefully few prototypes,
-    which can conflict with char $ac_func (); below.
-    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
-    <limits.h> exists even on freestanding compilers.  */
-
-#ifdef __STDC__
-# include <limits.h>
-#else
-# include <assert.h>
-#endif
-
-#undef $ac_func
-
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char $ac_func ();
-/* The GNU C library defines this for functions which it implements
-    to always fail with ENOSYS.  Some functions are actually named
-    something starting with __ and the normal name is an alias.  */
-#if defined __stub_$ac_func || defined __stub___$ac_func
-choke me
-#endif
-
-int
-main ()
-{
-return $ac_func ();
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_link") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest$ac_exeext && {
-	 test "$cross_compiling" = yes ||
-	 $as_test_x conftest$ac_exeext
-       }; then
-  eval "$as_ac_var=yes"
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	eval "$as_ac_var=no"
-fi
-
-rm -rf conftest.dSYM
-rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
-      conftest$ac_exeext conftest.$ac_ext
-fi
-ac_res=`eval 'as_val=${'$as_ac_var'}
-		 $as_echo "$as_val"'`
-	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
-as_val=`eval 'as_val=${'$as_ac_var'}
-		 $as_echo "$as_val"'`
-   if test "x$as_val" = x""yes; then
+
+      if test "$gt_cv_func_ngettext_libc" = "yes" ; then
+        for ac_func in bind_textdomain_codeset
+do :
+  ac_fn_c_check_func "$LINENO" "bind_textdomain_codeset" "ac_cv_func_bind_textdomain_codeset"
+if test "x$ac_cv_func_bind_textdomain_codeset" = x""yes; then :
   cat >>confdefs.h <<_ACEOF
-#define `$as_echo "HAVE_$ac_func" | $as_tr_cpp` 1
+#define HAVE_BIND_TEXTDOMAIN_CODESET 1
 _ACEOF
 
 fi
@@ -15157,18 +13056,14 @@ done
 	 || test "$gt_cv_func_ngettext_libc" != "yes" \
          || test "$ac_cv_func_bind_textdomain_codeset" != "yes" ; then
 
-        { $as_echo "$as_me:$LINENO: checking for bindtextdomain in -lintl" >&5
+        { $as_echo "$as_me:${as_lineno-$LINENO}: checking for bindtextdomain in -lintl" >&5
 $as_echo_n "checking for bindtextdomain in -lintl... " >&6; }
-if test "${ac_cv_lib_intl_bindtextdomain+set}" = set; then
+if test "${ac_cv_lib_intl_bindtextdomain+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   ac_check_lib_save_LIBS=$LIBS
 LIBS="-lintl  $LIBS"
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 
 /* Override any GCC internal prototype to avoid an error.
@@ -15186,55 +13081,26 @@ return bindtextdomain ();
   return 0;
 }
 _ACEOF
-rm -f conftest.$ac_objext conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_link") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest$ac_exeext && {
-	 test "$cross_compiling" = yes ||
-	 $as_test_x conftest$ac_exeext
-       }; then
+if ac_fn_c_try_link "$LINENO"; then :
   ac_cv_lib_intl_bindtextdomain=yes
 else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_cv_lib_intl_bindtextdomain=no
+  ac_cv_lib_intl_bindtextdomain=no
 fi
-
-rm -rf conftest.dSYM
-rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
-      conftest$ac_exeext conftest.$ac_ext
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
 LIBS=$ac_check_lib_save_LIBS
 fi
-{ $as_echo "$as_me:$LINENO: result: $ac_cv_lib_intl_bindtextdomain" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_intl_bindtextdomain" >&5
 $as_echo "$ac_cv_lib_intl_bindtextdomain" >&6; }
-if test "x$ac_cv_lib_intl_bindtextdomain" = x""yes; then
-  { $as_echo "$as_me:$LINENO: checking for ngettext in -lintl" >&5
+if test "x$ac_cv_lib_intl_bindtextdomain" = x""yes; then :
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for ngettext in -lintl" >&5
 $as_echo_n "checking for ngettext in -lintl... " >&6; }
-if test "${ac_cv_lib_intl_ngettext+set}" = set; then
+if test "${ac_cv_lib_intl_ngettext+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   ac_check_lib_save_LIBS=$LIBS
 LIBS="-lintl  $LIBS"
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 
 /* Override any GCC internal prototype to avoid an error.
@@ -15252,55 +13118,26 @@ return ngettext ();
   return 0;
 }
 _ACEOF
-rm -f conftest.$ac_objext conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_link") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest$ac_exeext && {
-	 test "$cross_compiling" = yes ||
-	 $as_test_x conftest$ac_exeext
-       }; then
+if ac_fn_c_try_link "$LINENO"; then :
   ac_cv_lib_intl_ngettext=yes
 else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_cv_lib_intl_ngettext=no
+  ac_cv_lib_intl_ngettext=no
 fi
-
-rm -rf conftest.dSYM
-rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
-      conftest$ac_exeext conftest.$ac_ext
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
 LIBS=$ac_check_lib_save_LIBS
 fi
-{ $as_echo "$as_me:$LINENO: result: $ac_cv_lib_intl_ngettext" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_intl_ngettext" >&5
 $as_echo "$ac_cv_lib_intl_ngettext" >&6; }
-if test "x$ac_cv_lib_intl_ngettext" = x""yes; then
-  { $as_echo "$as_me:$LINENO: checking for dgettext in -lintl" >&5
+if test "x$ac_cv_lib_intl_ngettext" = x""yes; then :
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for dgettext in -lintl" >&5
 $as_echo_n "checking for dgettext in -lintl... " >&6; }
-if test "${ac_cv_lib_intl_dgettext+set}" = set; then
+if test "${ac_cv_lib_intl_dgettext+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   ac_check_lib_save_LIBS=$LIBS
 LIBS="-lintl  $LIBS"
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 
 /* Override any GCC internal prototype to avoid an error.
@@ -15318,43 +13155,18 @@ return dgettext ();
   return 0;
 }
 _ACEOF
-rm -f conftest.$ac_objext conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_link") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest$ac_exeext && {
-	 test "$cross_compiling" = yes ||
-	 $as_test_x conftest$ac_exeext
-       }; then
+if ac_fn_c_try_link "$LINENO"; then :
   ac_cv_lib_intl_dgettext=yes
 else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_cv_lib_intl_dgettext=no
+  ac_cv_lib_intl_dgettext=no
 fi
-
-rm -rf conftest.dSYM
-rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
-      conftest$ac_exeext conftest.$ac_ext
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
 LIBS=$ac_check_lib_save_LIBS
 fi
-{ $as_echo "$as_me:$LINENO: result: $ac_cv_lib_intl_dgettext" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_intl_dgettext" >&5
 $as_echo "$ac_cv_lib_intl_dgettext" >&6; }
-if test "x$ac_cv_lib_intl_dgettext" = x""yes; then
+if test "x$ac_cv_lib_intl_dgettext" = x""yes; then :
   gt_cv_func_dgettext_libintl=yes
 fi
 
@@ -15364,22 +13176,18 @@ fi
 
 
 	if test "$gt_cv_func_dgettext_libintl" != "yes" ; then
-	  { $as_echo "$as_me:$LINENO: checking if -liconv is needed to use gettext" >&5
+	  { $as_echo "$as_me:${as_lineno-$LINENO}: checking if -liconv is needed to use gettext" >&5
 $as_echo_n "checking if -liconv is needed to use gettext... " >&6; }
-	  { $as_echo "$as_me:$LINENO: result: " >&5
+	  { $as_echo "$as_me:${as_lineno-$LINENO}: result: " >&5
 $as_echo "" >&6; }
-  	  { $as_echo "$as_me:$LINENO: checking for ngettext in -lintl" >&5
+  	  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for ngettext in -lintl" >&5
 $as_echo_n "checking for ngettext in -lintl... " >&6; }
-if test "${ac_cv_lib_intl_ngettext+set}" = set; then
+if test "${ac_cv_lib_intl_ngettext+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   ac_check_lib_save_LIBS=$LIBS
 LIBS="-lintl -liconv $LIBS"
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 
 /* Override any GCC internal prototype to avoid an error.
@@ -15397,55 +13205,26 @@ return ngettext ();
   return 0;
 }
 _ACEOF
-rm -f conftest.$ac_objext conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_link") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest$ac_exeext && {
-	 test "$cross_compiling" = yes ||
-	 $as_test_x conftest$ac_exeext
-       }; then
+if ac_fn_c_try_link "$LINENO"; then :
   ac_cv_lib_intl_ngettext=yes
 else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_cv_lib_intl_ngettext=no
+  ac_cv_lib_intl_ngettext=no
 fi
-
-rm -rf conftest.dSYM
-rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
-      conftest$ac_exeext conftest.$ac_ext
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
 LIBS=$ac_check_lib_save_LIBS
 fi
-{ $as_echo "$as_me:$LINENO: result: $ac_cv_lib_intl_ngettext" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_intl_ngettext" >&5
 $as_echo "$ac_cv_lib_intl_ngettext" >&6; }
-if test "x$ac_cv_lib_intl_ngettext" = x""yes; then
-  { $as_echo "$as_me:$LINENO: checking for dcgettext in -lintl" >&5
+if test "x$ac_cv_lib_intl_ngettext" = x""yes; then :
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for dcgettext in -lintl" >&5
 $as_echo_n "checking for dcgettext in -lintl... " >&6; }
-if test "${ac_cv_lib_intl_dcgettext+set}" = set; then
+if test "${ac_cv_lib_intl_dcgettext+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   ac_check_lib_save_LIBS=$LIBS
 LIBS="-lintl -liconv $LIBS"
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 
 /* Override any GCC internal prototype to avoid an error.
@@ -15463,43 +13242,18 @@ return dcgettext ();
   return 0;
 }
 _ACEOF
-rm -f conftest.$ac_objext conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_link") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest$ac_exeext && {
-	 test "$cross_compiling" = yes ||
-	 $as_test_x conftest$ac_exeext
-       }; then
+if ac_fn_c_try_link "$LINENO"; then :
   ac_cv_lib_intl_dcgettext=yes
 else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_cv_lib_intl_dcgettext=no
+  ac_cv_lib_intl_dcgettext=no
 fi
-
-rm -rf conftest.dSYM
-rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
-      conftest$ac_exeext conftest.$ac_ext
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
 LIBS=$ac_check_lib_save_LIBS
 fi
-{ $as_echo "$as_me:$LINENO: result: $ac_cv_lib_intl_dcgettext" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_intl_dcgettext" >&5
 $as_echo "$ac_cv_lib_intl_dcgettext" >&6; }
-if test "x$ac_cv_lib_intl_dcgettext" = x""yes; then
+if test "x$ac_cv_lib_intl_dcgettext" = x""yes; then :
   gt_cv_func_dgettext_libintl=yes
 			libintl_extra_libs=-liconv
 else
@@ -15521,102 +13275,12 @@ fi
           glib_save_LIBS="$LIBS"
           LIBS="$LIBS -lintl $libintl_extra_libs"
           unset ac_cv_func_bind_textdomain_codeset
-
-for ac_func in bind_textdomain_codeset
-do
-as_ac_var=`$as_echo "ac_cv_func_$ac_func" | $as_tr_sh`
-{ $as_echo "$as_me:$LINENO: checking for $ac_func" >&5
-$as_echo_n "checking for $ac_func... " >&6; }
-if { as_var=$as_ac_var; eval "test \"\${$as_var+set}\" = set"; }; then
-  $as_echo_n "(cached) " >&6
-else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-/* Define $ac_func to an innocuous variant, in case <limits.h> declares $ac_func.
-   For example, HP-UX 11i <limits.h> declares gettimeofday.  */
-#define $ac_func innocuous_$ac_func
-
-/* System header to define __stub macros and hopefully few prototypes,
-    which can conflict with char $ac_func (); below.
-    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
-    <limits.h> exists even on freestanding compilers.  */
-
-#ifdef __STDC__
-# include <limits.h>
-#else
-# include <assert.h>
-#endif
-
-#undef $ac_func
-
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char $ac_func ();
-/* The GNU C library defines this for functions which it implements
-    to always fail with ENOSYS.  Some functions are actually named
-    something starting with __ and the normal name is an alias.  */
-#if defined __stub_$ac_func || defined __stub___$ac_func
-choke me
-#endif
-
-int
-main ()
-{
-return $ac_func ();
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_link") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest$ac_exeext && {
-	 test "$cross_compiling" = yes ||
-	 $as_test_x conftest$ac_exeext
-       }; then
-  eval "$as_ac_var=yes"
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	eval "$as_ac_var=no"
-fi
-
-rm -rf conftest.dSYM
-rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
-      conftest$ac_exeext conftest.$ac_ext
-fi
-ac_res=`eval 'as_val=${'$as_ac_var'}
-		 $as_echo "$as_val"'`
-	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
-as_val=`eval 'as_val=${'$as_ac_var'}
-		 $as_echo "$as_val"'`
-   if test "x$as_val" = x""yes; then
+          for ac_func in bind_textdomain_codeset
+do :
+  ac_fn_c_check_func "$LINENO" "bind_textdomain_codeset" "ac_cv_func_bind_textdomain_codeset"
+if test "x$ac_cv_func_bind_textdomain_codeset" = x""yes; then :
   cat >>confdefs.h <<_ACEOF
-#define `$as_echo "HAVE_$ac_func" | $as_tr_cpp` 1
+#define HAVE_BIND_TEXTDOMAIN_CODESET 1
 _ACEOF
 
 fi
@@ -15646,15 +13310,13 @@ done
 
       if test "$gt_cv_have_gettext" = "yes"; then
 
-cat >>confdefs.h <<\_ACEOF
-#define HAVE_GETTEXT 1
-_ACEOF
+$as_echo "#define HAVE_GETTEXT 1" >>confdefs.h
 
 	# Extract the first word of "msgfmt", so it can be a program name with args.
 set dummy msgfmt; ac_word=$2
-{ $as_echo "$as_me:$LINENO: checking for $ac_word" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
 $as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_path_MSGFMT+set}" = set; then
+if test "${ac_cv_path_MSGFMT+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   case "$MSGFMT" in
@@ -15679,118 +13341,28 @@ esac
 fi
 MSGFMT="$ac_cv_path_MSGFMT"
 if test "$MSGFMT" != "no"; then
-  { $as_echo "$as_me:$LINENO: result: $MSGFMT" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $MSGFMT" >&5
 $as_echo "$MSGFMT" >&6; }
 else
-  { $as_echo "$as_me:$LINENO: result: no" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
 $as_echo "no" >&6; }
 fi
 	if test "$MSGFMT" != "no"; then
           glib_save_LIBS="$LIBS"
           LIBS="$LIBS $INTLLIBS"
-
-for ac_func in dcgettext
-do
-as_ac_var=`$as_echo "ac_cv_func_$ac_func" | $as_tr_sh`
-{ $as_echo "$as_me:$LINENO: checking for $ac_func" >&5
-$as_echo_n "checking for $ac_func... " >&6; }
-if { as_var=$as_ac_var; eval "test \"\${$as_var+set}\" = set"; }; then
-  $as_echo_n "(cached) " >&6
-else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-/* Define $ac_func to an innocuous variant, in case <limits.h> declares $ac_func.
-   For example, HP-UX 11i <limits.h> declares gettimeofday.  */
-#define $ac_func innocuous_$ac_func
-
-/* System header to define __stub macros and hopefully few prototypes,
-    which can conflict with char $ac_func (); below.
-    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
-    <limits.h> exists even on freestanding compilers.  */
-
-#ifdef __STDC__
-# include <limits.h>
-#else
-# include <assert.h>
-#endif
-
-#undef $ac_func
-
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char $ac_func ();
-/* The GNU C library defines this for functions which it implements
-    to always fail with ENOSYS.  Some functions are actually named
-    something starting with __ and the normal name is an alias.  */
-#if defined __stub_$ac_func || defined __stub___$ac_func
-choke me
-#endif
-
-int
-main ()
-{
-return $ac_func ();
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_link") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest$ac_exeext && {
-	 test "$cross_compiling" = yes ||
-	 $as_test_x conftest$ac_exeext
-       }; then
-  eval "$as_ac_var=yes"
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	eval "$as_ac_var=no"
-fi
-
-rm -rf conftest.dSYM
-rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
-      conftest$ac_exeext conftest.$ac_ext
-fi
-ac_res=`eval 'as_val=${'$as_ac_var'}
-		 $as_echo "$as_val"'`
-	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
-as_val=`eval 'as_val=${'$as_ac_var'}
-		 $as_echo "$as_val"'`
-   if test "x$as_val" = x""yes; then
+	  for ac_func in dcgettext
+do :
+  ac_fn_c_check_func "$LINENO" "dcgettext" "ac_cv_func_dcgettext"
+if test "x$ac_cv_func_dcgettext" = x""yes; then :
   cat >>confdefs.h <<_ACEOF
-#define `$as_echo "HAVE_$ac_func" | $as_tr_cpp` 1
+#define HAVE_DCGETTEXT 1
 _ACEOF
 
 fi
 done
 
 	  MSGFMT_OPTS=
-	  { $as_echo "$as_me:$LINENO: checking if msgfmt accepts -c" >&5
+	  { $as_echo "$as_me:${as_lineno-$LINENO}: checking if msgfmt accepts -c" >&5
 $as_echo_n "checking if msgfmt accepts -c... " >&6; }
 	  cat >conftest.foo <<_ACEOF
 
@@ -15805,14 +13377,14 @@ msgstr ""
 "Content-Transfer-Encoding: 8bit\n"
 
 _ACEOF
-if { ($as_echo "$as_me:$LINENO: \$MSGFMT -c -o /dev/null conftest.foo") >&5
+if { { $as_echo "$as_me:${as_lineno-$LINENO}: \$MSGFMT -c -o /dev/null conftest.foo"; } >&5
   ($MSGFMT -c -o /dev/null conftest.foo) 2>&5
   ac_status=$?
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; then
-  MSGFMT_OPTS=-c; { $as_echo "$as_me:$LINENO: result: yes" >&5
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }; then
+  MSGFMT_OPTS=-c; { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
 $as_echo "yes" >&6; }
-else { $as_echo "$as_me:$LINENO: result: no" >&5
+else { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
 $as_echo "no" >&6; }
 echo "$as_me: failed input was:" >&5
 sed 's/^/| /' conftest.foo >&5
@@ -15820,9 +13392,9 @@ fi
 
 	  # Extract the first word of "gmsgfmt", so it can be a program name with args.
 set dummy gmsgfmt; ac_word=$2
-{ $as_echo "$as_me:$LINENO: checking for $ac_word" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
 $as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_path_GMSGFMT+set}" = set; then
+if test "${ac_cv_path_GMSGFMT+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   case $GMSGFMT in
@@ -15835,14 +13407,14 @@ for as_dir in $PATH
 do
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
-  for ac_exec_ext in '' $ac_executable_extensions; do
+    for ac_exec_ext in '' $ac_executable_extensions; do
   if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
     ac_cv_path_GMSGFMT="$as_dir/$ac_word$ac_exec_ext"
-    $as_echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
   fi
 done
-done
+  done
 IFS=$as_save_IFS
 
   test -z "$ac_cv_path_GMSGFMT" && ac_cv_path_GMSGFMT="$MSGFMT"
@@ -15851,19 +13423,19 @@ esac
 fi
 GMSGFMT=$ac_cv_path_GMSGFMT
 if test -n "$GMSGFMT"; then
-  { $as_echo "$as_me:$LINENO: result: $GMSGFMT" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $GMSGFMT" >&5
 $as_echo "$GMSGFMT" >&6; }
 else
-  { $as_echo "$as_me:$LINENO: result: no" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
 $as_echo "no" >&6; }
 fi
 
 
 	  # Extract the first word of "xgettext", so it can be a program name with args.
 set dummy xgettext; ac_word=$2
-{ $as_echo "$as_me:$LINENO: checking for $ac_word" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
 $as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_path_XGETTEXT+set}" = set; then
+if test "${ac_cv_path_XGETTEXT+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   case "$XGETTEXT" in
@@ -15884,148 +13456,37 @@ else
   IFS="$ac_save_ifs"
   test -z "$ac_cv_path_XGETTEXT" && ac_cv_path_XGETTEXT=":"
   ;;
-esac
-fi
-XGETTEXT="$ac_cv_path_XGETTEXT"
-if test "$XGETTEXT" != ":"; then
-  { $as_echo "$as_me:$LINENO: result: $XGETTEXT" >&5
-$as_echo "$XGETTEXT" >&6; }
-else
-  { $as_echo "$as_me:$LINENO: result: no" >&5
-$as_echo "no" >&6; }
-fi
-
-	  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-
-int
-main ()
-{
-extern int _nl_msg_cat_cntr;
-			 return _nl_msg_cat_cntr
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_link") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest$ac_exeext && {
-	 test "$cross_compiling" = yes ||
-	 $as_test_x conftest$ac_exeext
-       }; then
-  CATOBJEXT=.gmo
-             DATADIRNAME=share
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	case $host in
-	    *-*-solaris*)
-	    	                	    	                { $as_echo "$as_me:$LINENO: checking for bind_textdomain_codeset" >&5
-$as_echo_n "checking for bind_textdomain_codeset... " >&6; }
-if test "${ac_cv_func_bind_textdomain_codeset+set}" = set; then
-  $as_echo_n "(cached) " >&6
-else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-/* Define bind_textdomain_codeset to an innocuous variant, in case <limits.h> declares bind_textdomain_codeset.
-   For example, HP-UX 11i <limits.h> declares gettimeofday.  */
-#define bind_textdomain_codeset innocuous_bind_textdomain_codeset
-
-/* System header to define __stub macros and hopefully few prototypes,
-    which can conflict with char bind_textdomain_codeset (); below.
-    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
-    <limits.h> exists even on freestanding compilers.  */
-
-#ifdef __STDC__
-# include <limits.h>
-#else
-# include <assert.h>
-#endif
-
-#undef bind_textdomain_codeset
+esac
+fi
+XGETTEXT="$ac_cv_path_XGETTEXT"
+if test "$XGETTEXT" != ":"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $XGETTEXT" >&5
+$as_echo "$XGETTEXT" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
 
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char bind_textdomain_codeset ();
-/* The GNU C library defines this for functions which it implements
-    to always fail with ENOSYS.  Some functions are actually named
-    something starting with __ and the normal name is an alias.  */
-#if defined __stub_bind_textdomain_codeset || defined __stub___bind_textdomain_codeset
-choke me
-#endif
+	  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
 
 int
 main ()
 {
-return bind_textdomain_codeset ();
+extern int _nl_msg_cat_cntr;
+			 return _nl_msg_cat_cntr
   ;
   return 0;
 }
 _ACEOF
-rm -f conftest.$ac_objext conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
-$as_echo "$ac_try_echo") >&5
-  (eval "$ac_link") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest$ac_exeext && {
-	 test "$cross_compiling" = yes ||
-	 $as_test_x conftest$ac_exeext
-       }; then
-  ac_cv_func_bind_textdomain_codeset=yes
+if ac_fn_c_try_link "$LINENO"; then :
+  CATOBJEXT=.gmo
+             DATADIRNAME=share
 else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_cv_func_bind_textdomain_codeset=no
-fi
-
-rm -rf conftest.dSYM
-rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
-      conftest$ac_exeext conftest.$ac_ext
-fi
-{ $as_echo "$as_me:$LINENO: result: $ac_cv_func_bind_textdomain_codeset" >&5
-$as_echo "$ac_cv_func_bind_textdomain_codeset" >&6; }
-if test "x$ac_cv_func_bind_textdomain_codeset" = x""yes; then
+  case $host in
+	    *-*-solaris*)
+	    	                	    	                ac_fn_c_check_func "$LINENO" "bind_textdomain_codeset" "ac_cv_func_bind_textdomain_codeset"
+if test "x$ac_cv_func_bind_textdomain_codeset" = x""yes; then :
   CATOBJEXT=.gmo
                DATADIRNAME=share
 else
@@ -16040,10 +13501,8 @@ fi
 	    ;;
 	    esac
 fi
-
-rm -rf conftest.dSYM
-rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
-      conftest$ac_exeext conftest.$ac_ext
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
           LIBS="$glib_save_LIBS"
 	  INSTOBJEXT=.mo
 	else
@@ -16057,9 +13516,7 @@ fi
 
     if test "$gt_cv_have_gettext" = "yes" ; then
 
-cat >>confdefs.h <<\_ACEOF
-#define ENABLE_NLS 1
-_ACEOF
+$as_echo "#define ENABLE_NLS 1" >>confdefs.h
 
     fi
 
@@ -16067,7 +13524,7 @@ _ACEOF
                   if $XGETTEXT --omit-header /dev/null 2> /dev/null; then
         : ;
       else
-        { $as_echo "$as_me:$LINENO: result: found xgettext program is not GNU xgettext; ignore it" >&5
+        { $as_echo "$as_me:${as_lineno-$LINENO}: result: found xgettext program is not GNU xgettext; ignore it" >&5
 $as_echo "found xgettext program is not GNU xgettext; ignore it" >&6; }
         XGETTEXT=":"
       fi
@@ -16100,7 +13557,7 @@ $as_echo "found xgettext program is not
      if test "x$ALL_LINGUAS" = "x"; then
        LINGUAS=
      else
-       { $as_echo "$as_me:$LINENO: checking for catalogs to be installed" >&5
+       { $as_echo "$as_me:${as_lineno-$LINENO}: checking for catalogs to be installed" >&5
 $as_echo_n "checking for catalogs to be installed... " >&6; }
        NEW_LINGUAS=
        for presentlang in $ALL_LINGUAS; do
@@ -16125,7 +13582,7 @@ $as_echo_n "checking for catalogs to be
          fi
        done
        LINGUAS=$NEW_LINGUAS
-       { $as_echo "$as_me:$LINENO: result: $LINGUAS" >&5
+       { $as_echo "$as_me:${as_lineno-$LINENO}: result: $LINGUAS" >&5
 $as_echo "$LINGUAS" >&6; }
      fi
 
@@ -16179,7 +13636,7 @@ _ACEOF
 
 
 # Check whether --enable-silent-rules was given.
-if test "${enable_silent_rules+set}" = set; then
+if test "${enable_silent_rules+set}" = set; then :
   enableval=$enable_silent_rules;
 fi
 
@@ -16191,7 +13648,7 @@ esac
 AM_BACKSLASH='\'
 
 
-ac_config_files="$ac_config_files Makefile src/Makefile src/rygel/Makefile src/ui/Makefile src/plugins/Makefile src/plugins/media-export/Makefile src/plugins/external/Makefile src/plugins/gstlaunch/Makefile src/plugins/mediathek/Makefile src/plugins/tracker/Makefile src/plugins/test/Makefile data/Makefile data/xml/Makefile rygel-1.0.pc"
+ac_config_files="$ac_config_files Makefile src/Makefile src/rygel/Makefile src/ui/Makefile src/plugins/Makefile src/plugins/media-export/Makefile src/plugins/external/Makefile src/plugins/gstlaunch/Makefile src/plugins/mediathek/Makefile src/plugins/tracker/Makefile src/plugins/gst-renderer/Makefile src/plugins/test/Makefile data/Makefile data/xml/Makefile rygel-1.0.pc"
 
 cat >confcache <<\_ACEOF
 # This file is a shell script that caches the results of configure
@@ -16220,13 +13677,13 @@ _ACEOF
     case $ac_val in #(
     *${as_nl}*)
       case $ac_var in #(
-      *_cv_*) { $as_echo "$as_me:$LINENO: WARNING: cache variable $ac_var contains a newline" >&5
+      *_cv_*) { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: cache variable $ac_var contains a newline" >&5
 $as_echo "$as_me: WARNING: cache variable $ac_var contains a newline" >&2;} ;;
       esac
       case $ac_var in #(
       _ | IFS | as_nl) ;; #(
       BASH_ARGV | BASH_SOURCE) eval $ac_var= ;; #(
-      *) $as_unset $ac_var ;;
+      *) { eval $ac_var=; unset $ac_var;} ;;
       esac ;;
     esac
   done
@@ -16234,8 +13691,8 @@ $as_echo "$as_me: WARNING: cache variabl
   (set) 2>&1 |
     case $as_nl`(ac_space=' '; set) 2>&1` in #(
     *${as_nl}ac_space=\ *)
-      # `set' does not quote correctly, so add quotes (double-quote
-      # substitution turns \\\\ into \\, and sed turns \\ into \).
+      # `set' does not quote correctly, so add quotes: double-quote
+      # substitution turns \\\\ into \\, and sed turns \\ into \.
       sed -n \
 	"s/'/'\\\\''/g;
 	  s/^\\([_$as_cr_alnum]*_cv_[_$as_cr_alnum]*\\)=\\(.*\\)/\\1='\\2'/p"
@@ -16258,11 +13715,11 @@ $as_echo "$as_me: WARNING: cache variabl
 if diff "$cache_file" confcache >/dev/null 2>&1; then :; else
   if test -w "$cache_file"; then
     test "x$cache_file" != "x/dev/null" &&
-      { $as_echo "$as_me:$LINENO: updating cache $cache_file" >&5
+      { $as_echo "$as_me:${as_lineno-$LINENO}: updating cache $cache_file" >&5
 $as_echo "$as_me: updating cache $cache_file" >&6;}
     cat confcache >$cache_file
   else
-    { $as_echo "$as_me:$LINENO: not updating unwritable cache $cache_file" >&5
+    { $as_echo "$as_me:${as_lineno-$LINENO}: not updating unwritable cache $cache_file" >&5
 $as_echo "$as_me: not updating unwritable cache $cache_file" >&6;}
   fi
 fi
@@ -16282,8 +13739,8 @@ for ac_i in : $LIBOBJS; do test "x$ac_i"
   ac_i=`$as_echo "$ac_i" | sed "$ac_script"`
   # 2. Prepend LIBOBJDIR.  When used with automake>=1.10 LIBOBJDIR
   #    will be set to the directory where LIBOBJS objects are built.
-  ac_libobjs="$ac_libobjs \${LIBOBJDIR}$ac_i\$U.$ac_objext"
-  ac_ltlibobjs="$ac_ltlibobjs \${LIBOBJDIR}$ac_i"'$U.lo'
+  as_fn_append ac_libobjs " \${LIBOBJDIR}$ac_i\$U.$ac_objext"
+  as_fn_append ac_ltlibobjs " \${LIBOBJDIR}$ac_i"'$U.lo'
 done
 LIBOBJS=$ac_libobjs
 
@@ -16299,104 +13756,70 @@ else
 fi
 
 if test -z "${MAINTAINER_MODE_TRUE}" && test -z "${MAINTAINER_MODE_FALSE}"; then
-  { { $as_echo "$as_me:$LINENO: error: conditional \"MAINTAINER_MODE\" was never defined.
-Usually this means the macro was only invoked conditionally." >&5
-$as_echo "$as_me: error: conditional \"MAINTAINER_MODE\" was never defined.
-Usually this means the macro was only invoked conditionally." >&2;}
-   { (exit 1); exit 1; }; }
+  as_fn_error "conditional \"MAINTAINER_MODE\" was never defined.
+Usually this means the macro was only invoked conditionally." "$LINENO" 5
 fi
 if test -z "${AMDEP_TRUE}" && test -z "${AMDEP_FALSE}"; then
-  { { $as_echo "$as_me:$LINENO: error: conditional \"AMDEP\" was never defined.
-Usually this means the macro was only invoked conditionally." >&5
-$as_echo "$as_me: error: conditional \"AMDEP\" was never defined.
-Usually this means the macro was only invoked conditionally." >&2;}
-   { (exit 1); exit 1; }; }
+  as_fn_error "conditional \"AMDEP\" was never defined.
+Usually this means the macro was only invoked conditionally." "$LINENO" 5
 fi
 if test -z "${am__fastdepCC_TRUE}" && test -z "${am__fastdepCC_FALSE}"; then
-  { { $as_echo "$as_me:$LINENO: error: conditional \"am__fastdepCC\" was never defined.
-Usually this means the macro was only invoked conditionally." >&5
-$as_echo "$as_me: error: conditional \"am__fastdepCC\" was never defined.
-Usually this means the macro was only invoked conditionally." >&2;}
-   { (exit 1); exit 1; }; }
+  as_fn_error "conditional \"am__fastdepCC\" was never defined.
+Usually this means the macro was only invoked conditionally." "$LINENO" 5
 fi
 if test -z "${am__fastdepCC_TRUE}" && test -z "${am__fastdepCC_FALSE}"; then
-  { { $as_echo "$as_me:$LINENO: error: conditional \"am__fastdepCC\" was never defined.
-Usually this means the macro was only invoked conditionally." >&5
-$as_echo "$as_me: error: conditional \"am__fastdepCC\" was never defined.
-Usually this means the macro was only invoked conditionally." >&2;}
-   { (exit 1); exit 1; }; }
+  as_fn_error "conditional \"am__fastdepCC\" was never defined.
+Usually this means the macro was only invoked conditionally." "$LINENO" 5
 fi
 if test -z "${BUILD_UI_TRUE}" && test -z "${BUILD_UI_FALSE}"; then
-  { { $as_echo "$as_me:$LINENO: error: conditional \"BUILD_UI\" was never defined.
-Usually this means the macro was only invoked conditionally." >&5
-$as_echo "$as_me: error: conditional \"BUILD_UI\" was never defined.
-Usually this means the macro was only invoked conditionally." >&2;}
-   { (exit 1); exit 1; }; }
+  as_fn_error "conditional \"BUILD_UI\" was never defined.
+Usually this means the macro was only invoked conditionally." "$LINENO" 5
 fi
 if test -z "${UNINSTALLED_TRUE}" && test -z "${UNINSTALLED_FALSE}"; then
-  { { $as_echo "$as_me:$LINENO: error: conditional \"UNINSTALLED\" was never defined.
-Usually this means the macro was only invoked conditionally." >&5
-$as_echo "$as_me: error: conditional \"UNINSTALLED\" was never defined.
-Usually this means the macro was only invoked conditionally." >&2;}
-   { (exit 1); exit 1; }; }
+  as_fn_error "conditional \"UNINSTALLED\" was never defined.
+Usually this means the macro was only invoked conditionally." "$LINENO" 5
 fi
 if test -z "${ENABLE_MAEMO_TRUE}" && test -z "${ENABLE_MAEMO_FALSE}"; then
-  { { $as_echo "$as_me:$LINENO: error: conditional \"ENABLE_MAEMO\" was never defined.
-Usually this means the macro was only invoked conditionally." >&5
-$as_echo "$as_me: error: conditional \"ENABLE_MAEMO\" was never defined.
-Usually this means the macro was only invoked conditionally." >&2;}
-   { (exit 1); exit 1; }; }
+  as_fn_error "conditional \"ENABLE_MAEMO\" was never defined.
+Usually this means the macro was only invoked conditionally." "$LINENO" 5
 fi
 if test -z "${BUILD_TEST_PLUGIN_TRUE}" && test -z "${BUILD_TEST_PLUGIN_FALSE}"; then
-  { { $as_echo "$as_me:$LINENO: error: conditional \"BUILD_TEST_PLUGIN\" was never defined.
-Usually this means the macro was only invoked conditionally." >&5
-$as_echo "$as_me: error: conditional \"BUILD_TEST_PLUGIN\" was never defined.
-Usually this means the macro was only invoked conditionally." >&2;}
-   { (exit 1); exit 1; }; }
+  as_fn_error "conditional \"BUILD_TEST_PLUGIN\" was never defined.
+Usually this means the macro was only invoked conditionally." "$LINENO" 5
 fi
 if test -z "${BUILD_TRACKER_PLUGIN_TRUE}" && test -z "${BUILD_TRACKER_PLUGIN_FALSE}"; then
-  { { $as_echo "$as_me:$LINENO: error: conditional \"BUILD_TRACKER_PLUGIN\" was never defined.
-Usually this means the macro was only invoked conditionally." >&5
-$as_echo "$as_me: error: conditional \"BUILD_TRACKER_PLUGIN\" was never defined.
-Usually this means the macro was only invoked conditionally." >&2;}
-   { (exit 1); exit 1; }; }
+  as_fn_error "conditional \"BUILD_TRACKER_PLUGIN\" was never defined.
+Usually this means the macro was only invoked conditionally." "$LINENO" 5
 fi
 if test -z "${BUILD_MEDIATHEK_PLUGIN_TRUE}" && test -z "${BUILD_MEDIATHEK_PLUGIN_FALSE}"; then
-  { { $as_echo "$as_me:$LINENO: error: conditional \"BUILD_MEDIATHEK_PLUGIN\" was never defined.
-Usually this means the macro was only invoked conditionally." >&5
-$as_echo "$as_me: error: conditional \"BUILD_MEDIATHEK_PLUGIN\" was never defined.
-Usually this means the macro was only invoked conditionally." >&2;}
-   { (exit 1); exit 1; }; }
+  as_fn_error "conditional \"BUILD_MEDIATHEK_PLUGIN\" was never defined.
+Usually this means the macro was only invoked conditionally." "$LINENO" 5
 fi
 if test -z "${BUILD_MEDIA_EXPORT_PLUGIN_TRUE}" && test -z "${BUILD_MEDIA_EXPORT_PLUGIN_FALSE}"; then
-  { { $as_echo "$as_me:$LINENO: error: conditional \"BUILD_MEDIA_EXPORT_PLUGIN\" was never defined.
-Usually this means the macro was only invoked conditionally." >&5
-$as_echo "$as_me: error: conditional \"BUILD_MEDIA_EXPORT_PLUGIN\" was never defined.
-Usually this means the macro was only invoked conditionally." >&2;}
-   { (exit 1); exit 1; }; }
+  as_fn_error "conditional \"BUILD_MEDIA_EXPORT_PLUGIN\" was never defined.
+Usually this means the macro was only invoked conditionally." "$LINENO" 5
 fi
 if test -z "${BUILD_EXTERNAL_PLUGIN_TRUE}" && test -z "${BUILD_EXTERNAL_PLUGIN_FALSE}"; then
-  { { $as_echo "$as_me:$LINENO: error: conditional \"BUILD_EXTERNAL_PLUGIN\" was never defined.
-Usually this means the macro was only invoked conditionally." >&5
-$as_echo "$as_me: error: conditional \"BUILD_EXTERNAL_PLUGIN\" was never defined.
-Usually this means the macro was only invoked conditionally." >&2;}
-   { (exit 1); exit 1; }; }
+  as_fn_error "conditional \"BUILD_EXTERNAL_PLUGIN\" was never defined.
+Usually this means the macro was only invoked conditionally." "$LINENO" 5
 fi
 if test -z "${BUILD_GSTLAUNCH_PLUGIN_TRUE}" && test -z "${BUILD_GSTLAUNCH_PLUGIN_FALSE}"; then
-  { { $as_echo "$as_me:$LINENO: error: conditional \"BUILD_GSTLAUNCH_PLUGIN\" was never defined.
-Usually this means the macro was only invoked conditionally." >&5
-$as_echo "$as_me: error: conditional \"BUILD_GSTLAUNCH_PLUGIN\" was never defined.
-Usually this means the macro was only invoked conditionally." >&2;}
-   { (exit 1); exit 1; }; }
+  as_fn_error "conditional \"BUILD_GSTLAUNCH_PLUGIN\" was never defined.
+Usually this means the macro was only invoked conditionally." "$LINENO" 5
+fi
+if test -z "${BUILD_GST_RENDERER_PLUGIN_TRUE}" && test -z "${BUILD_GST_RENDERER_PLUGIN_FALSE}"; then
+  as_fn_error "conditional \"BUILD_GST_RENDERER_PLUGIN\" was never defined.
+Usually this means the macro was only invoked conditionally." "$LINENO" 5
 fi
 
 : ${CONFIG_STATUS=./config.status}
 ac_write_fail=0
 ac_clean_files_save=$ac_clean_files
 ac_clean_files="$ac_clean_files $CONFIG_STATUS"
-{ $as_echo "$as_me:$LINENO: creating $CONFIG_STATUS" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: creating $CONFIG_STATUS" >&5
 $as_echo "$as_me: creating $CONFIG_STATUS" >&6;}
-cat >$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
+as_write_fail=0
+cat >$CONFIG_STATUS <<_ASEOF || as_write_fail=1
 #! $SHELL
 # Generated by $as_me.
 # Run this file to recreate the current configuration.
@@ -16406,17 +13829,18 @@ cat >$CONFIG_STATUS <<_ACEOF || ac_write
 debug=false
 ac_cs_recheck=false
 ac_cs_silent=false
-SHELL=\${CONFIG_SHELL-$SHELL}
-_ACEOF
 
-cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
-## --------------------- ##
-## M4sh Initialization.  ##
-## --------------------- ##
+SHELL=\${CONFIG_SHELL-$SHELL}
+export SHELL
+_ASEOF
+cat >>$CONFIG_STATUS <<\_ASEOF || as_write_fail=1
+## -------------------- ##
+## M4sh Initialization. ##
+## -------------------- ##
 
 # Be more Bourne compatible
 DUALCASE=1; export DUALCASE # for MKS sh
-if test -n "${ZSH_VERSION+set}" && (emulate sh) >/dev/null 2>&1; then
+if test -n "${ZSH_VERSION+set}" && (emulate sh) >/dev/null 2>&1; then :
   emulate sh
   NULLCMD=:
   # Pre-4.2 versions of Zsh do word splitting on ${1+"$@"}, which
@@ -16424,23 +13848,15 @@ if test -n "${ZSH_VERSION+set}" && (emul
   alias -g '${1+"$@"}'='"$@"'
   setopt NO_GLOB_SUBST
 else
-  case `(set -o) 2>/dev/null` in
-  *posix*) set -o posix ;;
+  case `(set -o) 2>/dev/null` in #(
+  *posix*) :
+    set -o posix ;; #(
+  *) :
+     ;;
 esac
-
 fi
 
 
-
-
-# PATH needs CR
-# Avoid depending upon Character Ranges.
-as_cr_letters='abcdefghijklmnopqrstuvwxyz'
-as_cr_LETTERS='ABCDEFGHIJKLMNOPQRSTUVWXYZ'
-as_cr_Letters=$as_cr_letters$as_cr_LETTERS
-as_cr_digits='0123456789'
-as_cr_alnum=$as_cr_Letters$as_cr_digits
-
 as_nl='
 '
 export as_nl
@@ -16448,7 +13864,13 @@ export as_nl
 as_echo='\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'
 as_echo=$as_echo$as_echo$as_echo$as_echo$as_echo
 as_echo=$as_echo$as_echo$as_echo$as_echo$as_echo$as_echo
-if (test "X`printf %s $as_echo`" = "X$as_echo") 2>/dev/null; then
+# Prefer a ksh shell builtin over an external printf program on Solaris,
+# but without wasting forks for bash or zsh.
+if test -z "$BASH_VERSION$ZSH_VERSION" \
+    && (test "X`print -r -- $as_echo`" = "X$as_echo") 2>/dev/null; then
+  as_echo='print -r --'
+  as_echo_n='print -rn --'
+elif (test "X`printf %s $as_echo`" = "X$as_echo") 2>/dev/null; then
   as_echo='printf %s\n'
   as_echo_n='printf %s'
 else
@@ -16459,7 +13881,7 @@ else
     as_echo_body='eval expr "X$1" : "X\\(.*\\)"'
     as_echo_n_body='eval
       arg=$1;
-      case $arg in
+      case $arg in #(
       *"$as_nl"*)
 	expr "X$arg" : "X\\(.*\\)$as_nl";
 	arg=`expr "X$arg" : ".*$as_nl\\(.*\\)"`;;
@@ -16482,13 +13904,6 @@ if test "${PATH_SEPARATOR+set}" != set;
   }
 fi
 
-# Support unset when possible.
-if ( (MAIL=60; unset MAIL) || exit) >/dev/null 2>&1; then
-  as_unset=unset
-else
-  as_unset=false
-fi
-
 
 # IFS
 # We need space, tab and new line, in precisely that order.  Quoting is
@@ -16498,15 +13913,15 @@ fi
 IFS=" ""	$as_nl"
 
 # Find who we are.  Look in the path if we contain no directory separator.
-case $0 in
+case $0 in #((
   *[\\/]* ) as_myself=$0 ;;
   *) as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
 for as_dir in $PATH
 do
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
-  test -r "$as_dir/$0" && as_myself=$as_dir/$0 && break
-done
+    test -r "$as_dir/$0" && as_myself=$as_dir/$0 && break
+  done
 IFS=$as_save_IFS
 
      ;;
@@ -16518,12 +13933,16 @@ if test "x$as_myself" = x; then
 fi
 if test ! -f "$as_myself"; then
   $as_echo "$as_myself: error: cannot find myself; rerun with an absolute file name" >&2
-  { (exit 1); exit 1; }
+  exit 1
 fi
 
-# Work around bugs in pre-3.0 UWIN ksh.
-for as_var in ENV MAIL MAILPATH
-do ($as_unset $as_var) >/dev/null 2>&1 && $as_unset $as_var
+# Unset variables that we do not need and which cause bugs (e.g. in
+# pre-3.0 UWIN ksh).  But do not cause bugs in bash 2.01; the "|| exit 1"
+# suppresses any "Segmentation fault" message there.  '((' could
+# trigger a bug in pdksh 5.2.14.
+for as_var in BASH_ENV ENV MAIL MAILPATH
+do eval test x\${$as_var+set} = xset \
+  && ( (unset $as_var) || exit 1) >/dev/null 2>&1 && unset $as_var || :
 done
 PS1='$ '
 PS2='> '
@@ -16535,7 +13954,89 @@ export LC_ALL
 LANGUAGE=C
 export LANGUAGE
 
-# Required to use basename.
+# CDPATH.
+(unset CDPATH) >/dev/null 2>&1 && unset CDPATH
+
+
+# as_fn_error ERROR [LINENO LOG_FD]
+# ---------------------------------
+# Output "`basename $0`: error: ERROR" to stderr. If LINENO and LOG_FD are
+# provided, also output the error to LOG_FD, referencing LINENO. Then exit the
+# script with status $?, using 1 if that was 0.
+as_fn_error ()
+{
+  as_status=$?; test $as_status -eq 0 && as_status=1
+  if test "$3"; then
+    as_lineno=${as_lineno-"$2"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
+    $as_echo "$as_me:${as_lineno-$LINENO}: error: $1" >&$3
+  fi
+  $as_echo "$as_me: error: $1" >&2
+  as_fn_exit $as_status
+} # as_fn_error
+
+
+# as_fn_set_status STATUS
+# -----------------------
+# Set $? to STATUS, without forking.
+as_fn_set_status ()
+{
+  return $1
+} # as_fn_set_status
+
+# as_fn_exit STATUS
+# -----------------
+# Exit the shell with STATUS, even in a "trap 0" or "set -e" context.
+as_fn_exit ()
+{
+  set +e
+  as_fn_set_status $1
+  exit $1
+} # as_fn_exit
+
+# as_fn_unset VAR
+# ---------------
+# Portably unset VAR.
+as_fn_unset ()
+{
+  { eval $1=; unset $1;}
+}
+as_unset=as_fn_unset
+# as_fn_append VAR VALUE
+# ----------------------
+# Append the text in VALUE to the end of the definition contained in VAR. Take
+# advantage of any shell optimizations that allow amortized linear growth over
+# repeated appends, instead of the typical quadratic growth present in naive
+# implementations.
+if (eval "as_var=1; as_var+=2; test x\$as_var = x12") 2>/dev/null; then :
+  eval 'as_fn_append ()
+  {
+    eval $1+=\$2
+  }'
+else
+  as_fn_append ()
+  {
+    eval $1=\$$1\$2
+  }
+fi # as_fn_append
+
+# as_fn_arith ARG...
+# ------------------
+# Perform arithmetic evaluation on the ARGs, and store the result in the
+# global $as_val. Take advantage of shells that can avoid forks. The arguments
+# must be portable across $(()) and expr.
+if (eval "test \$(( 1 + 1 )) = 2") 2>/dev/null; then :
+  eval 'as_fn_arith ()
+  {
+    as_val=$(( $* ))
+  }'
+else
+  as_fn_arith ()
+  {
+    as_val=`expr "$@" || test $? -eq 1`
+  }
+fi # as_fn_arith
+
+
 if expr a : '\(a\)' >/dev/null 2>&1 &&
    test "X`expr 00001 : '.*\(...\)'`" = X001; then
   as_expr=expr
@@ -16549,8 +14050,12 @@ else
   as_basename=false
 fi
 
+if (as_dir=`dirname -- /` && test "X$as_dir" = X/) >/dev/null 2>&1; then
+  as_dirname=dirname
+else
+  as_dirname=false
+fi
 
-# Name of the executable.
 as_me=`$as_basename -- "$0" ||
 $as_expr X/"$0" : '.*/\([^/][^/]*\)/*$' \| \
 	 X"$0" : 'X\(//\)$' \| \
@@ -16570,76 +14075,25 @@ $as_echo X/"$0" |
 	  }
 	  s/.*/./; q'`
 
-# CDPATH.
-$as_unset CDPATH
-
-
-
-  as_lineno_1=$LINENO
-  as_lineno_2=$LINENO
-  test "x$as_lineno_1" != "x$as_lineno_2" &&
-  test "x`expr $as_lineno_1 + 1`" = "x$as_lineno_2" || {
-
-  # Create $as_me.lineno as a copy of $as_myself, but with $LINENO
-  # uniformly replaced by the line number.  The first 'sed' inserts a
-  # line-number line after each line using $LINENO; the second 'sed'
-  # does the real work.  The second script uses 'N' to pair each
-  # line-number line with the line containing $LINENO, and appends
-  # trailing '-' during substitution so that $LINENO is not a special
-  # case at line end.
-  # (Raja R Harinath suggested sed '=', and Paul Eggert wrote the
-  # scripts with optimization help from Paolo Bonzini.  Blame Lee
-  # E. McMahon (1931-1989) for sed's syntax.  :-)
-  sed -n '
-    p
-    /[$]LINENO/=
-  ' <$as_myself |
-    sed '
-      s/[$]LINENO.*/&-/
-      t lineno
-      b
-      :lineno
-      N
-      :loop
-      s/[$]LINENO\([^'$as_cr_alnum'_].*\n\)\(.*\)/\2\1\2/
-      t loop
-      s/-\n.*//
-    ' >$as_me.lineno &&
-  chmod +x "$as_me.lineno" ||
-    { $as_echo "$as_me: error: cannot create $as_me.lineno; rerun with a POSIX shell" >&2
-   { (exit 1); exit 1; }; }
-
-  # Don't try to exec as it changes $[0], causing all sort of problems
-  # (the dirname of $[0] is not the place where we might find the
-  # original and so on.  Autoconf is especially sensitive to this).
-  . "./$as_me.lineno"
-  # Exit status is that of the last command.
-  exit
-}
-
-
-if (as_dir=`dirname -- /` && test "X$as_dir" = X/) >/dev/null 2>&1; then
-  as_dirname=dirname
-else
-  as_dirname=false
-fi
+# Avoid depending upon Character Ranges.
+as_cr_letters='abcdefghijklmnopqrstuvwxyz'
+as_cr_LETTERS='ABCDEFGHIJKLMNOPQRSTUVWXYZ'
+as_cr_Letters=$as_cr_letters$as_cr_LETTERS
+as_cr_digits='0123456789'
+as_cr_alnum=$as_cr_Letters$as_cr_digits
 
 ECHO_C= ECHO_N= ECHO_T=
-case `echo -n x` in
+case `echo -n x` in #(((((
 -n*)
-  case `echo 'x\c'` in
+  case `echo 'xy\c'` in
   *c*) ECHO_T='	';;	# ECHO_T is single tab character.
-  *)   ECHO_C='\c';;
+  xy)  ECHO_C='\c';;
+  *)   echo `echo ksh88 bug on AIX 6.1` > /dev/null
+       ECHO_T='	';;
   esac;;
 *)
   ECHO_N='-n';;
 esac
-if expr a : '\(a\)' >/dev/null 2>&1 &&
-   test "X`expr 00001 : '.*\(...\)'`" = X001; then
-  as_expr=expr
-else
-  as_expr=false
-fi
 
 rm -f conf$$ conf$$.exe conf$$.file
 if test -d conf$$.dir; then
@@ -16668,8 +14122,56 @@ fi
 rm -f conf$$ conf$$.exe conf$$.dir/conf$$.file conf$$.file
 rmdir conf$$.dir 2>/dev/null
 
+
+# as_fn_mkdir_p
+# -------------
+# Create "$as_dir" as a directory, including parents if necessary.
+as_fn_mkdir_p ()
+{
+
+  case $as_dir in #(
+  -*) as_dir=./$as_dir;;
+  esac
+  test -d "$as_dir" || eval $as_mkdir_p || {
+    as_dirs=
+    while :; do
+      case $as_dir in #(
+      *\'*) as_qdir=`$as_echo "$as_dir" | sed "s/'/'\\\\\\\\''/g"`;; #'(
+      *) as_qdir=$as_dir;;
+      esac
+      as_dirs="'$as_qdir' $as_dirs"
+      as_dir=`$as_dirname -- "$as_dir" ||
+$as_expr X"$as_dir" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	 X"$as_dir" : 'X\(//\)[^/]' \| \
+	 X"$as_dir" : 'X\(//\)$' \| \
+	 X"$as_dir" : 'X\(/\)' \| . 2>/dev/null ||
+$as_echo X"$as_dir" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)[^/].*/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\).*/{
+	    s//\1/
+	    q
+	  }
+	  s/.*/./; q'`
+      test -d "$as_dir" && break
+    done
+    test -z "$as_dirs" || eval "mkdir $as_dirs"
+  } || test -d "$as_dir" || as_fn_error "cannot create directory $as_dir"
+
+
+} # as_fn_mkdir_p
 if mkdir -p . 2>/dev/null; then
-  as_mkdir_p=:
+  as_mkdir_p='mkdir -p "$as_dir"'
 else
   test -d ./-p && rmdir ./-p
   as_mkdir_p=false
@@ -16688,10 +14190,10 @@ else
       if test -d "$1"; then
 	test -d "$1/.";
       else
-	case $1 in
+	case $1 in #(
 	-*)set "./$1";;
 	esac;
-	case `ls -ld'$as_ls_L_option' "$1" 2>/dev/null` in
+	case `ls -ld'$as_ls_L_option' "$1" 2>/dev/null` in #((
 	???[sx]*):;;*)false;;esac;fi
     '\'' sh
   '
@@ -16706,13 +14208,19 @@ as_tr_sh="eval sed 'y%*+%pp%;s%[^_$as_cr
 
 
 exec 6>&1
+## ----------------------------------- ##
+## Main body of $CONFIG_STATUS script. ##
+## ----------------------------------- ##
+_ASEOF
+test $as_write_fail = 0 && chmod +x $CONFIG_STATUS || ac_write_fail=1
 
-# Save the log message, to keep $[0] and so on meaningful, and to
+cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
+# Save the log message, to keep $0 and so on meaningful, and to
 # report actual input values of CONFIG_FILES etc. instead of their
 # values after options handling.
 ac_log="
-This file was extended by rygel $as_me 0.4.2, which was
-generated by GNU Autoconf 2.63.  Invocation command line was
+This file was extended by rygel $as_me UNKNOWN-dirty, which was
+generated by GNU Autoconf 2.64.  Invocation command line was
 
   CONFIG_FILES    = $CONFIG_FILES
   CONFIG_HEADERS  = $CONFIG_HEADERS
@@ -16744,10 +14252,11 @@ _ACEOF
 
 cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
 ac_cs_usage="\
-\`$as_me' instantiates files from templates according to the
-current configuration.
+\`$as_me' instantiates files and other configuration actions
+from templates according to the current configuration.  Unless the files
+and actions are specified as TAGs, all are instantiated by default.
 
-Usage: $0 [OPTION]... [FILE]...
+Usage: $0 [OPTION]... [TAG]...
 
   -h, --help       print this help, then exit
   -V, --version    print version number and configuration settings, then exit
@@ -16769,16 +14278,16 @@ $config_headers
 Configuration commands:
 $config_commands
 
-Report bugs to <bug-autoconf@gnu.org>."
+Report bugs to <http://live.gnome.org/Rygel>."
 
 _ACEOF
 cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
 ac_cs_version="\\
-rygel config.status 0.4.2
-configured by $0, generated by GNU Autoconf 2.63,
+rygel config.status UNKNOWN-dirty
+configured by $0, generated by GNU Autoconf 2.64,
   with options \\"`$as_echo "$ac_configure_args" | sed 's/^ //; s/[\\""\`\$]/\\\\&/g'`\\"
 
-Copyright (C) 2008 Free Software Foundation, Inc.
+Copyright (C) 2009 Free Software Foundation, Inc.
 This config.status script is free software; the Free Software Foundation
 gives unlimited permission to copy, distribute and modify it."
 
@@ -16821,20 +14330,19 @@ do
     case $ac_optarg in
     *\'*) ac_optarg=`$as_echo "$ac_optarg" | sed "s/'/'\\\\\\\\''/g"` ;;
     esac
-    CONFIG_FILES="$CONFIG_FILES '$ac_optarg'"
+    as_fn_append CONFIG_FILES " '$ac_optarg'"
     ac_need_defaults=false;;
   --header | --heade | --head | --hea )
     $ac_shift
     case $ac_optarg in
     *\'*) ac_optarg=`$as_echo "$ac_optarg" | sed "s/'/'\\\\\\\\''/g"` ;;
     esac
-    CONFIG_HEADERS="$CONFIG_HEADERS '$ac_optarg'"
+    as_fn_append CONFIG_HEADERS " '$ac_optarg'"
     ac_need_defaults=false;;
   --he | --h)
     # Conflict between --help and --header
-    { $as_echo "$as_me: error: ambiguous option: $1
-Try \`$0 --help' for more information." >&2
-   { (exit 1); exit 1; }; };;
+    as_fn_error "ambiguous option: \`$1'
+Try \`$0 --help' for more information.";;
   --help | --hel | -h )
     $as_echo "$ac_cs_usage"; exit ;;
   -q | -quiet | --quiet | --quie | --qui | --qu | --q \
@@ -16842,11 +14350,10 @@ Try \`$0 --help' for more information."
     ac_cs_silent=: ;;
 
   # This is an error.
-  -*) { $as_echo "$as_me: error: unrecognized option: $1
-Try \`$0 --help' for more information." >&2
-   { (exit 1); exit 1; }; } ;;
+  -*) as_fn_error "unrecognized option: \`$1'
+Try \`$0 --help' for more information." ;;
 
-  *) ac_config_targets="$ac_config_targets $1"
+  *) as_fn_append ac_config_targets " $1"
      ac_need_defaults=false ;;
 
   esac
@@ -17167,14 +14674,13 @@ do
     "src/plugins/gstlaunch/Makefile") CONFIG_FILES="$CONFIG_FILES src/plugins/gstlaunch/Makefile" ;;
     "src/plugins/mediathek/Makefile") CONFIG_FILES="$CONFIG_FILES src/plugins/mediathek/Makefile" ;;
     "src/plugins/tracker/Makefile") CONFIG_FILES="$CONFIG_FILES src/plugins/tracker/Makefile" ;;
+    "src/plugins/gst-renderer/Makefile") CONFIG_FILES="$CONFIG_FILES src/plugins/gst-renderer/Makefile" ;;
     "src/plugins/test/Makefile") CONFIG_FILES="$CONFIG_FILES src/plugins/test/Makefile" ;;
     "data/Makefile") CONFIG_FILES="$CONFIG_FILES data/Makefile" ;;
     "data/xml/Makefile") CONFIG_FILES="$CONFIG_FILES data/xml/Makefile" ;;
     "rygel-1.0.pc") CONFIG_FILES="$CONFIG_FILES rygel-1.0.pc" ;;
 
-  *) { { $as_echo "$as_me:$LINENO: error: invalid argument: $ac_config_target" >&5
-$as_echo "$as_me: error: invalid argument: $ac_config_target" >&2;}
-   { (exit 1); exit 1; }; };;
+  *) as_fn_error "invalid argument: \`$ac_config_target'" "$LINENO" 5;;
   esac
 done
 
@@ -17201,7 +14707,7 @@ $debug ||
   trap 'exit_status=$?
   { test -z "$tmp" || test ! -d "$tmp" || rm -fr "$tmp"; } && exit $exit_status
 ' 0
-  trap '{ (exit 1); exit 1; }' 1 2 13 15
+  trap 'as_fn_exit 1' 1 2 13 15
 }
 # Create a (secure) tmp directory for tmp files.
 
@@ -17212,11 +14718,7 @@ $debug ||
 {
   tmp=./conf$$-$RANDOM
   (umask 077 && mkdir "$tmp")
-} ||
-{
-   $as_echo "$as_me: cannot create a temporary directory in ." >&2
-   { (exit 1); exit 1; }
-}
+} || as_fn_error "cannot create a temporary directory in ." "$LINENO" 5
 
 # Set up the scripts for CONFIG_FILES section.
 # No need to generate them if there are no CONFIG_FILES.
@@ -17224,10 +14726,16 @@ $debug ||
 if test -n "$CONFIG_FILES"; then
 
 
-ac_cr=''
+ac_cr=`echo X | tr X '\015'`
+# On cygwin, bash can eat \r inside `` if the user requested igncr.
+# But we know of no other shell where ac_cr would be empty at this
+# point, so we can use a bashism as a fallback.
+if test "x$ac_cr" = x; then
+  eval ac_cr=\$\'\\r\'
+fi
 ac_cs_awk_cr=`$AWK 'BEGIN { print "a\rb" }' </dev/null 2>/dev/null`
 if test "$ac_cs_awk_cr" = "a${ac_cr}b"; then
-  ac_cs_awk_cr='\\r'
+  ac_cs_awk_cr='\r'
 else
   ac_cs_awk_cr=$ac_cr
 fi
@@ -17241,24 +14749,18 @@ _ACEOF
   echo "$ac_subst_vars" | sed 's/.*/&!$&$ac_delim/' &&
   echo "_ACEOF"
 } >conf$$subs.sh ||
-  { { $as_echo "$as_me:$LINENO: error: could not make $CONFIG_STATUS" >&5
-$as_echo "$as_me: error: could not make $CONFIG_STATUS" >&2;}
-   { (exit 1); exit 1; }; }
+  as_fn_error "could not make $CONFIG_STATUS" "$LINENO" 5
 ac_delim_num=`echo "$ac_subst_vars" | grep -c '$'`
 ac_delim='%!_!# '
 for ac_last_try in false false false false false :; do
   . ./conf$$subs.sh ||
-    { { $as_echo "$as_me:$LINENO: error: could not make $CONFIG_STATUS" >&5
-$as_echo "$as_me: error: could not make $CONFIG_STATUS" >&2;}
-   { (exit 1); exit 1; }; }
+    as_fn_error "could not make $CONFIG_STATUS" "$LINENO" 5
 
   ac_delim_n=`sed -n "s/.*$ac_delim\$/X/p" conf$$subs.awk | grep -c X`
   if test $ac_delim_n = $ac_delim_num; then
     break
   elif $ac_last_try; then
-    { { $as_echo "$as_me:$LINENO: error: could not make $CONFIG_STATUS" >&5
-$as_echo "$as_me: error: could not make $CONFIG_STATUS" >&2;}
-   { (exit 1); exit 1; }; }
+    as_fn_error "could not make $CONFIG_STATUS" "$LINENO" 5
   else
     ac_delim="$ac_delim!$ac_delim _$ac_delim!! "
   fi
@@ -17347,9 +14849,7 @@ if sed "s/$ac_cr//" < /dev/null > /dev/n
 else
   cat
 fi < "$tmp/subs1.awk" > "$tmp/subs.awk" \
-  || { { $as_echo "$as_me:$LINENO: error: could not setup config files machinery" >&5
-$as_echo "$as_me: error: could not setup config files machinery" >&2;}
-   { (exit 1); exit 1; }; }
+  || as_fn_error "could not setup config files machinery" "$LINENO" 5
 _ACEOF
 
 # VPATH may cause trouble with some makes, so we remove $(srcdir),
@@ -17390,9 +14890,7 @@ for ac_last_try in false false :; do
   if test -z "$ac_t"; then
     break
   elif $ac_last_try; then
-    { { $as_echo "$as_me:$LINENO: error: could not make $CONFIG_HEADERS" >&5
-$as_echo "$as_me: error: could not make $CONFIG_HEADERS" >&2;}
-   { (exit 1); exit 1; }; }
+    as_fn_error "could not make $CONFIG_HEADERS" "$LINENO" 5
   else
     ac_delim="$ac_delim!$ac_delim _$ac_delim!! "
   fi
@@ -17477,9 +14975,7 @@ cat >>$CONFIG_STATUS <<_ACEOF || ac_writ
 _ACAWK
 _ACEOF
 cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
-  { { $as_echo "$as_me:$LINENO: error: could not setup config headers machinery" >&5
-$as_echo "$as_me: error: could not setup config headers machinery" >&2;}
-   { (exit 1); exit 1; }; }
+  as_fn_error "could not setup config headers machinery" "$LINENO" 5
 fi # test -n "$CONFIG_HEADERS"
 
 
@@ -17492,9 +14988,7 @@ do
   esac
   case $ac_mode$ac_tag in
   :[FHL]*:*);;
-  :L* | :C*:*) { { $as_echo "$as_me:$LINENO: error: invalid tag $ac_tag" >&5
-$as_echo "$as_me: error: invalid tag $ac_tag" >&2;}
-   { (exit 1); exit 1; }; };;
+  :L* | :C*:*) as_fn_error "invalid tag \`$ac_tag'" "$LINENO" 5;;
   :[FH]-) ac_tag=-:-;;
   :[FH]*) ac_tag=$ac_tag:$ac_tag.in;;
   esac
@@ -17522,12 +15016,10 @@ $as_echo "$as_me: error: invalid tag $ac
 	   [\\/$]*) false;;
 	   *) test -f "$srcdir/$ac_f" && ac_f="$srcdir/$ac_f";;
 	   esac ||
-	   { { $as_echo "$as_me:$LINENO: error: cannot find input file: $ac_f" >&5
-$as_echo "$as_me: error: cannot find input file: $ac_f" >&2;}
-   { (exit 1); exit 1; }; };;
+	   as_fn_error "cannot find input file: \`$ac_f'" "$LINENO" 5;;
       esac
       case $ac_f in *\'*) ac_f=`$as_echo "$ac_f" | sed "s/'/'\\\\\\\\''/g"`;; esac
-      ac_file_inputs="$ac_file_inputs '$ac_f'"
+      as_fn_append ac_file_inputs " '$ac_f'"
     done
 
     # Let's still pretend it is `configure' which instantiates (i.e., don't
@@ -17538,7 +15030,7 @@ $as_echo "$as_me: error: cannot find inp
 	`' by configure.'
     if test x"$ac_file" != x-; then
       configure_input="$ac_file.  $configure_input"
-      { $as_echo "$as_me:$LINENO: creating $ac_file" >&5
+      { $as_echo "$as_me:${as_lineno-$LINENO}: creating $ac_file" >&5
 $as_echo "$as_me: creating $ac_file" >&6;}
     fi
     # Neutralize special characters interpreted by sed in replacement strings.
@@ -17551,9 +15043,7 @@ $as_echo "$as_me: creating $ac_file" >&6
 
     case $ac_tag in
     *:-:* | *:-) cat >"$tmp/stdin" \
-      || { { $as_echo "$as_me:$LINENO: error: could not create $ac_file" >&5
-$as_echo "$as_me: error: could not create $ac_file" >&2;}
-   { (exit 1); exit 1; }; } ;;
+      || as_fn_error "could not create $ac_file" "$LINENO" 5 ;;
     esac
     ;;
   esac
@@ -17581,47 +15071,7 @@ $as_echo X"$ac_file" |
 	    q
 	  }
 	  s/.*/./; q'`
-  { as_dir="$ac_dir"
-  case $as_dir in #(
-  -*) as_dir=./$as_dir;;
-  esac
-  test -d "$as_dir" || { $as_mkdir_p && mkdir -p "$as_dir"; } || {
-    as_dirs=
-    while :; do
-      case $as_dir in #(
-      *\'*) as_qdir=`$as_echo "$as_dir" | sed "s/'/'\\\\\\\\''/g"`;; #'(
-      *) as_qdir=$as_dir;;
-      esac
-      as_dirs="'$as_qdir' $as_dirs"
-      as_dir=`$as_dirname -- "$as_dir" ||
-$as_expr X"$as_dir" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
-	 X"$as_dir" : 'X\(//\)[^/]' \| \
-	 X"$as_dir" : 'X\(//\)$' \| \
-	 X"$as_dir" : 'X\(/\)' \| . 2>/dev/null ||
-$as_echo X"$as_dir" |
-    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
-	    s//\1/
-	    q
-	  }
-	  /^X\(\/\/\)[^/].*/{
-	    s//\1/
-	    q
-	  }
-	  /^X\(\/\/\)$/{
-	    s//\1/
-	    q
-	  }
-	  /^X\(\/\).*/{
-	    s//\1/
-	    q
-	  }
-	  s/.*/./; q'`
-      test -d "$as_dir" && break
-    done
-    test -z "$as_dirs" || eval "mkdir $as_dirs"
-  } || test -d "$as_dir" || { { $as_echo "$as_me:$LINENO: error: cannot create directory $as_dir" >&5
-$as_echo "$as_me: error: cannot create directory $as_dir" >&2;}
-   { (exit 1); exit 1; }; }; }
+  as_dir="$ac_dir"; as_fn_mkdir_p
   ac_builddir=.
 
 case "$ac_dir" in
@@ -17688,12 +15138,11 @@ ac_sed_dataroot='
 /@docdir@/p
 /@infodir@/p
 /@localedir@/p
-/@mandir@/p
-'
+/@mandir@/p'
 case `eval "sed -n \"\$ac_sed_dataroot\" $ac_file_inputs"` in
 *datarootdir*) ac_datarootdir_seen=yes;;
 *@datadir@*|*@docdir@*|*@infodir@*|*@localedir@*|*@mandir@*)
-  { $as_echo "$as_me:$LINENO: WARNING: $ac_file_inputs seems to ignore the --datarootdir setting" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: $ac_file_inputs seems to ignore the --datarootdir setting" >&5
 $as_echo "$as_me: WARNING: $ac_file_inputs seems to ignore the --datarootdir setting" >&2;}
 _ACEOF
 cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
@@ -17703,7 +15152,7 @@ cat >>$CONFIG_STATUS <<_ACEOF || ac_writ
   s&@infodir@&$infodir&g
   s&@localedir@&$localedir&g
   s&@mandir@&$mandir&g
-    s&\\\${datarootdir}&$datarootdir&g' ;;
+  s&\\\${datarootdir}&$datarootdir&g' ;;
 esac
 _ACEOF
 
@@ -17732,14 +15181,12 @@ s&@MKDIR_P@&$ac_MKDIR_P&;t t
 $ac_datarootdir_hack
 "
 eval sed \"\$ac_sed_extra\" "$ac_file_inputs" | $AWK -f "$tmp/subs.awk" >$tmp/out \
-  || { { $as_echo "$as_me:$LINENO: error: could not create $ac_file" >&5
-$as_echo "$as_me: error: could not create $ac_file" >&2;}
-   { (exit 1); exit 1; }; }
+  || as_fn_error "could not create $ac_file" "$LINENO" 5
 
 test -z "$ac_datarootdir_hack$ac_datarootdir_seen" &&
   { ac_out=`sed -n '/\${datarootdir}/p' "$tmp/out"`; test -n "$ac_out"; } &&
   { ac_out=`sed -n '/^[	 ]*datarootdir[	 ]*:*=/p' "$tmp/out"`; test -z "$ac_out"; } &&
-  { $as_echo "$as_me:$LINENO: WARNING: $ac_file contains a reference to the variable \`datarootdir'
+  { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: $ac_file contains a reference to the variable \`datarootdir'
 which seems to be undefined.  Please make sure it is defined." >&5
 $as_echo "$as_me: WARNING: $ac_file contains a reference to the variable \`datarootdir'
 which seems to be undefined.  Please make sure it is defined." >&2;}
@@ -17749,9 +15196,7 @@ which seems to be undefined.  Please mak
   -) cat "$tmp/out" && rm -f "$tmp/out";;
   *) rm -f "$ac_file" && mv "$tmp/out" "$ac_file";;
   esac \
-  || { { $as_echo "$as_me:$LINENO: error: could not create $ac_file" >&5
-$as_echo "$as_me: error: could not create $ac_file" >&2;}
-   { (exit 1); exit 1; }; }
+  || as_fn_error "could not create $ac_file" "$LINENO" 5
  ;;
   :H)
   #
@@ -17762,25 +15207,19 @@ $as_echo "$as_me: error: could not creat
       $as_echo "/* $configure_input  */" \
       && eval '$AWK -f "$tmp/defines.awk"' "$ac_file_inputs"
     } >"$tmp/config.h" \
-      || { { $as_echo "$as_me:$LINENO: error: could not create $ac_file" >&5
-$as_echo "$as_me: error: could not create $ac_file" >&2;}
-   { (exit 1); exit 1; }; }
+      || as_fn_error "could not create $ac_file" "$LINENO" 5
     if diff "$ac_file" "$tmp/config.h" >/dev/null 2>&1; then
-      { $as_echo "$as_me:$LINENO: $ac_file is unchanged" >&5
+      { $as_echo "$as_me:${as_lineno-$LINENO}: $ac_file is unchanged" >&5
 $as_echo "$as_me: $ac_file is unchanged" >&6;}
     else
       rm -f "$ac_file"
       mv "$tmp/config.h" "$ac_file" \
-	|| { { $as_echo "$as_me:$LINENO: error: could not create $ac_file" >&5
-$as_echo "$as_me: error: could not create $ac_file" >&2;}
-   { (exit 1); exit 1; }; }
+	|| as_fn_error "could not create $ac_file" "$LINENO" 5
     fi
   else
     $as_echo "/* $configure_input  */" \
       && eval '$AWK -f "$tmp/defines.awk"' "$ac_file_inputs" \
-      || { { $as_echo "$as_me:$LINENO: error: could not create -" >&5
-$as_echo "$as_me: error: could not create -" >&2;}
-   { (exit 1); exit 1; }; }
+      || as_fn_error "could not create -" "$LINENO" 5
   fi
 # Compute "$ac_file"'s index in $config_headers.
 _am_arg="$ac_file"
@@ -17818,7 +15257,7 @@ $as_echo X"$_am_arg" |
 	  s/.*/./; q'`/stamp-h$_am_stamp_count
  ;;
 
-  :C)  { $as_echo "$as_me:$LINENO: executing $ac_file commands" >&5
+  :C)  { $as_echo "$as_me:${as_lineno-$LINENO}: executing $ac_file commands" >&5
 $as_echo "$as_me: executing $ac_file commands" >&6;}
  ;;
   esac
@@ -17913,47 +15352,7 @@ $as_echo X"$file" |
 	    q
 	  }
 	  s/.*/./; q'`
-      { as_dir=$dirpart/$fdir
-  case $as_dir in #(
-  -*) as_dir=./$as_dir;;
-  esac
-  test -d "$as_dir" || { $as_mkdir_p && mkdir -p "$as_dir"; } || {
-    as_dirs=
-    while :; do
-      case $as_dir in #(
-      *\'*) as_qdir=`$as_echo "$as_dir" | sed "s/'/'\\\\\\\\''/g"`;; #'(
-      *) as_qdir=$as_dir;;
-      esac
-      as_dirs="'$as_qdir' $as_dirs"
-      as_dir=`$as_dirname -- "$as_dir" ||
-$as_expr X"$as_dir" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
-	 X"$as_dir" : 'X\(//\)[^/]' \| \
-	 X"$as_dir" : 'X\(//\)$' \| \
-	 X"$as_dir" : 'X\(/\)' \| . 2>/dev/null ||
-$as_echo X"$as_dir" |
-    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
-	    s//\1/
-	    q
-	  }
-	  /^X\(\/\/\)[^/].*/{
-	    s//\1/
-	    q
-	  }
-	  /^X\(\/\/\)$/{
-	    s//\1/
-	    q
-	  }
-	  /^X\(\/\).*/{
-	    s//\1/
-	    q
-	  }
-	  s/.*/./; q'`
-      test -d "$as_dir" && break
-    done
-    test -z "$as_dirs" || eval "mkdir $as_dirs"
-  } || test -d "$as_dir" || { { $as_echo "$as_me:$LINENO: error: cannot create directory $as_dir" >&5
-$as_echo "$as_me: error: cannot create directory $as_dir" >&2;}
-   { (exit 1); exit 1; }; }; }
+      as_dir=$dirpart/$fdir; as_fn_mkdir_p
       # echo "creating $dirpart/$file"
       echo '# dummy' > "$dirpart/$file"
     done
@@ -18603,15 +16002,12 @@ _LT_EOF
 done # for ac_tag
 
 
-{ (exit 0); exit 0; }
+as_fn_exit 0
 _ACEOF
-chmod +x $CONFIG_STATUS
 ac_clean_files=$ac_clean_files_save
 
 test $ac_write_fail = 0 ||
-  { { $as_echo "$as_me:$LINENO: error: write failure creating $CONFIG_STATUS" >&5
-$as_echo "$as_me: error: write failure creating $CONFIG_STATUS" >&2;}
-   { (exit 1); exit 1; }; }
+  as_fn_error "write failure creating $CONFIG_STATUS" "$LINENO" 5
 
 
 # configure is writing to config.log, and then calls config.status.
@@ -18632,10 +16028,10 @@ if test "$no_create" != yes; then
   exec 5>>config.log
   # Use ||, not &&, to avoid exiting from the if with $? = 1, which
   # would make configure fail if this is the last instruction.
-  $ac_cs_success || { (exit 1); exit 1; }
+  $ac_cs_success || as_fn_exit $?
 fi
 if test -n "$ac_unrecognized_opts" && test "$enable_option_checking" != no; then
-  { $as_echo "$as_me:$LINENO: WARNING: unrecognized options: $ac_unrecognized_opts" >&5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: unrecognized options: $ac_unrecognized_opts" >&5
 $as_echo "$as_me: WARNING: unrecognized options: $ac_unrecognized_opts" >&2;}
 fi
 
@@ -18660,4 +16056,5 @@ echo "
         media-export            ${enable_media_export_plugin}
         external:               ${enable_external_plugin}
         gstlaunch:              ${enable_gstlaunch_plugin}
+        gst-renderer:           ${enable_gst_renderer_plugin}
 "
--- a/data/Makefile.in
+++ b/data/Makefile.in
@@ -38,7 +38,8 @@ subdir = data
 DIST_COMMON = $(am__dist_shared_DATA_DIST) $(srcdir)/Makefile.am \
 	$(srcdir)/Makefile.in
 ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
-am__aclocal_m4_deps = $(top_srcdir)/m4/libtool.m4 \
+am__aclocal_m4_deps = $(top_srcdir)/m4/glib-gettext.m4 \
+	$(top_srcdir)/m4/isc-posix.m4 $(top_srcdir)/m4/libtool.m4 \
 	$(top_srcdir)/m4/ltoptions.m4 $(top_srcdir)/m4/ltsugar.m4 \
 	$(top_srcdir)/m4/ltversion.m4 $(top_srcdir)/m4/lt~obsolete.m4 \
 	$(top_srcdir)/configure.ac
@@ -160,8 +161,6 @@ GMSGFMT = @GMSGFMT@
 GREP = @GREP@
 GTK_CFLAGS = @GTK_CFLAGS@
 GTK_LIBS = @GTK_LIBS@
-GUPNP_VALA_CFLAGS = @GUPNP_VALA_CFLAGS@
-GUPNP_VALA_LIBS = @GUPNP_VALA_LIBS@
 HAVE_GTK = @HAVE_GTK@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
@@ -176,8 +175,8 @@ LIBDBUS_GLIB_CFLAGS = @LIBDBUS_GLIB_CFLA
 LIBDBUS_GLIB_LIBS = @LIBDBUS_GLIB_LIBS@
 LIBGIO_CFLAGS = @LIBGIO_CFLAGS@
 LIBGIO_LIBS = @LIBGIO_LIBS@
-LIBGSTREAMER_CFLAGS = @LIBGSTREAMER_CFLAGS@
-LIBGSTREAMER_LIBS = @LIBGSTREAMER_LIBS@
+LIBGLIB_CFLAGS = @LIBGLIB_CFLAGS@
+LIBGLIB_LIBS = @LIBGLIB_LIBS@
 LIBGUPNP_AV_CFLAGS = @LIBGUPNP_AV_CFLAGS@
 LIBGUPNP_AV_LIBS = @LIBGUPNP_AV_LIBS@
 LIBGUPNP_CFLAGS = @LIBGUPNP_CFLAGS@
@@ -189,6 +188,8 @@ LIBSOUP_LIBS = @LIBSOUP_LIBS@
 LIBSQLITE3_CFLAGS = @LIBSQLITE3_CFLAGS@
 LIBSQLITE3_LIBS = @LIBSQLITE3_LIBS@
 LIBTOOL = @LIBTOOL@
+LIBVLC_CFLAGS = @LIBVLC_CFLAGS@
+LIBVLC_LIBS = @LIBVLC_LIBS@
 LIPO = @LIPO@
 LN_S = @LN_S@
 LTLIBOBJS = @LTLIBOBJS@
@@ -209,6 +210,7 @@ PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
 PACKAGE_NAME = @PACKAGE_NAME@
 PACKAGE_STRING = @PACKAGE_STRING@
 PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_URL = @PACKAGE_URL@
 PACKAGE_VERSION = @PACKAGE_VERSION@
 PATH_SEPARATOR = @PATH_SEPARATOR@
 PKG_CONFIG = @PKG_CONFIG@
@@ -222,8 +224,6 @@ SET_MAKE = @SET_MAKE@
 SHELL = @SHELL@
 STRIP = @STRIP@
 USE_NLS = @USE_NLS@
-UUID_CFLAGS = @UUID_CFLAGS@
-UUID_LIBS = @UUID_LIBS@
 VALAC = @VALAC@
 VAPIDIR = @VAPIDIR@
 VERSION = @VERSION@
--- a/data/xml/Makefile.in
+++ b/data/xml/Makefile.in
@@ -37,7 +37,8 @@ host_triplet = @host@
 subdir = data/xml
 DIST_COMMON = $(srcdir)/Makefile.am $(srcdir)/Makefile.in
 ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
-am__aclocal_m4_deps = $(top_srcdir)/m4/libtool.m4 \
+am__aclocal_m4_deps = $(top_srcdir)/m4/glib-gettext.m4 \
+	$(top_srcdir)/m4/isc-posix.m4 $(top_srcdir)/m4/libtool.m4 \
 	$(top_srcdir)/m4/ltoptions.m4 $(top_srcdir)/m4/ltsugar.m4 \
 	$(top_srcdir)/m4/ltversion.m4 $(top_srcdir)/m4/lt~obsolete.m4 \
 	$(top_srcdir)/configure.ac
@@ -115,8 +116,6 @@ GMSGFMT = @GMSGFMT@
 GREP = @GREP@
 GTK_CFLAGS = @GTK_CFLAGS@
 GTK_LIBS = @GTK_LIBS@
-GUPNP_VALA_CFLAGS = @GUPNP_VALA_CFLAGS@
-GUPNP_VALA_LIBS = @GUPNP_VALA_LIBS@
 HAVE_GTK = @HAVE_GTK@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
@@ -131,8 +130,8 @@ LIBDBUS_GLIB_CFLAGS = @LIBDBUS_GLIB_CFLA
 LIBDBUS_GLIB_LIBS = @LIBDBUS_GLIB_LIBS@
 LIBGIO_CFLAGS = @LIBGIO_CFLAGS@
 LIBGIO_LIBS = @LIBGIO_LIBS@
-LIBGSTREAMER_CFLAGS = @LIBGSTREAMER_CFLAGS@
-LIBGSTREAMER_LIBS = @LIBGSTREAMER_LIBS@
+LIBGLIB_CFLAGS = @LIBGLIB_CFLAGS@
+LIBGLIB_LIBS = @LIBGLIB_LIBS@
 LIBGUPNP_AV_CFLAGS = @LIBGUPNP_AV_CFLAGS@
 LIBGUPNP_AV_LIBS = @LIBGUPNP_AV_LIBS@
 LIBGUPNP_CFLAGS = @LIBGUPNP_CFLAGS@
@@ -144,6 +143,8 @@ LIBSOUP_LIBS = @LIBSOUP_LIBS@
 LIBSQLITE3_CFLAGS = @LIBSQLITE3_CFLAGS@
 LIBSQLITE3_LIBS = @LIBSQLITE3_LIBS@
 LIBTOOL = @LIBTOOL@
+LIBVLC_CFLAGS = @LIBVLC_CFLAGS@
+LIBVLC_LIBS = @LIBVLC_LIBS@
 LIPO = @LIPO@
 LN_S = @LN_S@
 LTLIBOBJS = @LTLIBOBJS@
@@ -164,6 +165,7 @@ PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
 PACKAGE_NAME = @PACKAGE_NAME@
 PACKAGE_STRING = @PACKAGE_STRING@
 PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_URL = @PACKAGE_URL@
 PACKAGE_VERSION = @PACKAGE_VERSION@
 PATH_SEPARATOR = @PATH_SEPARATOR@
 PKG_CONFIG = @PKG_CONFIG@
@@ -177,8 +179,6 @@ SET_MAKE = @SET_MAKE@
 SHELL = @SHELL@
 STRIP = @STRIP@
 USE_NLS = @USE_NLS@
-UUID_CFLAGS = @UUID_CFLAGS@
-UUID_LIBS = @UUID_LIBS@
 VALAC = @VALAC@
 VAPIDIR = @VAPIDIR@
 VERSION = @VERSION@
@@ -236,8 +236,11 @@ top_build_prefix = @top_build_prefix@
 top_builddir = @top_builddir@
 top_srcdir = @top_srcdir@
 xml_DATA = MediaServer2.xml \
+	   MediaRenderer.xml \
 	   ContentDirectory.xml \
-	   ConnectionManager.xml
+	   ConnectionManager.xml \
+	   AVTransport.xml \
+	   RenderingControl.xml
 
 xmldir = $(datadir)/rygel/xml
 EXTRA_DIST = $(xml_DATA)
--- /dev/null
+++ b/doc/README.Mediathek
@@ -0,0 +1,23 @@
+Konfiguration des Mediathekplugins
+===================================
+
+Das Mediathekplugin bietet eine Möglichkeit, bequem Sendungen aus der ZDF
+Mediathek anzuschauen.
+
+Im Moment werden nur RSS-Feeds unterstützt. Die zu abbonierenden RSS-Feeds
+werden im GConf-Schlüssel
+
+    /apps/rygel/ZDFMediathek/rss
+
+konfiguriert. Er enthält die "Contentidentifier" der Sendungen oder
+Kategorieren. Diese kann man in Erfahrung bringen, wenn man auf der Seite
+
+http://www.zdf.de/ZDFmediathek/content/9602?inPopup=true
+
+oben rechts auf "Inhalt" klickt. Dann die entsprechende Sendung oder
+Themengruppe heraussuchen und auf das RSS-Icon klicken. Für "aspekte" hat man
+dann folgende URL:
+
+    http://www.zdf.de/ZDFmediathek/content/500?view=rss
+
+Die Content-ID wäre in diesem Fall 500.
--- /dev/null
+++ b/doc/design.txt
@@ -0,0 +1,20 @@
+objects and interfaces:
+
+Name: Rygel.MediaServer
+description: The main object that talks to the control-points.
+
+Name: Rygel.MediaProvider
+description: Interface that all Media provider/backend objects must implement.
+
+Name: Rygel.MediaDB
+description: Object that:
+        - imlements RygelMediaProvider
+        - manages plugins that provides RygelMediaProvider
+
+Name: Rygel.MediaTracker
+description: tracker-based Rygel.MediaProvider implementation.
+             http://www.tracker-project.org
+
+Name: Rygel.MetadataExtractor
+description: Helper object providing metadata extraction facility.
+
--- /dev/null
+++ b/m4/codeset.m4
@@ -0,0 +1,21 @@
+# codeset.m4 serial 2 (gettext-0.16)
+dnl Copyright (C) 2000-2002, 2006 Free Software Foundation, Inc.
+dnl This file is free software; the Free Software Foundation
+dnl gives unlimited permission to copy and/or distribute it,
+dnl with or without modifications, as long as this notice is preserved.
+
+dnl From Bruno Haible.
+
+AC_DEFUN([AM_LANGINFO_CODESET],
+[
+  AC_CACHE_CHECK([for nl_langinfo and CODESET], am_cv_langinfo_codeset,
+    [AC_TRY_LINK([#include <langinfo.h>],
+      [char* cs = nl_langinfo(CODESET); return !cs;],
+      am_cv_langinfo_codeset=yes,
+      am_cv_langinfo_codeset=no)
+    ])
+  if test $am_cv_langinfo_codeset = yes; then
+    AC_DEFINE(HAVE_LANGINFO_CODESET, 1,
+      [Define if you have <langinfo.h> and nl_langinfo(CODESET).])
+  fi
+])
--- /dev/null
+++ b/m4/gettext.m4
@@ -0,0 +1,381 @@
+# gettext.m4 serial 60 (gettext-0.17)
+dnl Copyright (C) 1995-2007 Free Software Foundation, Inc.
+dnl This file is free software; the Free Software Foundation
+dnl gives unlimited permission to copy and/or distribute it,
+dnl with or without modifications, as long as this notice is preserved.
+dnl
+dnl This file can can be used in projects which are not available under
+dnl the GNU General Public License or the GNU Library General Public
+dnl License but which still want to provide support for the GNU gettext
+dnl functionality.
+dnl Please note that the actual code of the GNU gettext library is covered
+dnl by the GNU Library General Public License, and the rest of the GNU
+dnl gettext package package is covered by the GNU General Public License.
+dnl They are *not* in the public domain.
+
+dnl Authors:
+dnl   Ulrich Drepper <drepper@cygnus.com>, 1995-2000.
+dnl   Bruno Haible <haible@clisp.cons.org>, 2000-2006.
+
+dnl Macro to add for using GNU gettext.
+
+dnl Usage: AM_GNU_GETTEXT([INTLSYMBOL], [NEEDSYMBOL], [INTLDIR]).
+dnl INTLSYMBOL can be one of 'external', 'no-libtool', 'use-libtool'. The
+dnl    default (if it is not specified or empty) is 'no-libtool'.
+dnl    INTLSYMBOL should be 'external' for packages with no intl directory,
+dnl    and 'no-libtool' or 'use-libtool' for packages with an intl directory.
+dnl    If INTLSYMBOL is 'use-libtool', then a libtool library
+dnl    $(top_builddir)/intl/libintl.la will be created (shared and/or static,
+dnl    depending on --{enable,disable}-{shared,static} and on the presence of
+dnl    AM-DISABLE-SHARED). If INTLSYMBOL is 'no-libtool', a static library
+dnl    $(top_builddir)/intl/libintl.a will be created.
+dnl If NEEDSYMBOL is specified and is 'need-ngettext', then GNU gettext
+dnl    implementations (in libc or libintl) without the ngettext() function
+dnl    will be ignored.  If NEEDSYMBOL is specified and is
+dnl    'need-formatstring-macros', then GNU gettext implementations that don't
+dnl    support the ISO C 99 <inttypes.h> formatstring macros will be ignored.
+dnl INTLDIR is used to find the intl libraries.  If empty,
+dnl    the value `$(top_builddir)/intl/' is used.
+dnl
+dnl The result of the configuration is one of three cases:
+dnl 1) GNU gettext, as included in the intl subdirectory, will be compiled
+dnl    and used.
+dnl    Catalog format: GNU --> install in $(datadir)
+dnl    Catalog extension: .mo after installation, .gmo in source tree
+dnl 2) GNU gettext has been found in the system's C library.
+dnl    Catalog format: GNU --> install in $(datadir)
+dnl    Catalog extension: .mo after installation, .gmo in source tree
+dnl 3) No internationalization, always use English msgid.
+dnl    Catalog format: none
+dnl    Catalog extension: none
+dnl If INTLSYMBOL is 'external', only cases 2 and 3 can occur.
+dnl The use of .gmo is historical (it was needed to avoid overwriting the
+dnl GNU format catalogs when building on a platform with an X/Open gettext),
+dnl but we keep it in order not to force irrelevant filename changes on the
+dnl maintainers.
+dnl
+AC_DEFUN([AM_GNU_GETTEXT],
+[
+  dnl Argument checking.
+  ifelse([$1], [], , [ifelse([$1], [external], , [ifelse([$1], [no-libtool], , [ifelse([$1], [use-libtool], ,
+    [errprint([ERROR: invalid first argument to AM_GNU_GETTEXT
+])])])])])
+  ifelse([$2], [], , [ifelse([$2], [need-ngettext], , [ifelse([$2], [need-formatstring-macros], ,
+    [errprint([ERROR: invalid second argument to AM_GNU_GETTEXT
+])])])])
+  define([gt_included_intl],
+    ifelse([$1], [external],
+      ifdef([AM_GNU_GETTEXT_][INTL_SUBDIR], [yes], [no]),
+      [yes]))
+  define([gt_libtool_suffix_prefix], ifelse([$1], [use-libtool], [l], []))
+  gt_NEEDS_INIT
+  AM_GNU_GETTEXT_NEED([$2])
+
+  AC_REQUIRE([AM_PO_SUBDIRS])dnl
+  ifelse(gt_included_intl, yes, [
+    AC_REQUIRE([AM_INTL_SUBDIR])dnl
+  ])
+
+  dnl Prerequisites of AC_LIB_LINKFLAGS_BODY.
+  AC_REQUIRE([AC_LIB_PREPARE_PREFIX])
+  AC_REQUIRE([AC_LIB_RPATH])
+
+  dnl Sometimes libintl requires libiconv, so first search for libiconv.
+  dnl Ideally we would do this search only after the
+  dnl      if test "$USE_NLS" = "yes"; then
+  dnl        if { eval "gt_val=\$$gt_func_gnugettext_libc"; test "$gt_val" != "yes"; }; then
+  dnl tests. But if configure.in invokes AM_ICONV after AM_GNU_GETTEXT
+  dnl the configure script would need to contain the same shell code
+  dnl again, outside any 'if'. There are two solutions:
+  dnl - Invoke AM_ICONV_LINKFLAGS_BODY here, outside any 'if'.
+  dnl - Control the expansions in more detail using AC_PROVIDE_IFELSE.
+  dnl Since AC_PROVIDE_IFELSE is only in autoconf >= 2.52 and not
+  dnl documented, we avoid it.
+  ifelse(gt_included_intl, yes, , [
+    AC_REQUIRE([AM_ICONV_LINKFLAGS_BODY])
+  ])
+
+  dnl Sometimes, on MacOS X, libintl requires linking with CoreFoundation.
+  gt_INTL_MACOSX
+
+  dnl Set USE_NLS.
+  AC_REQUIRE([AM_NLS])
+
+  ifelse(gt_included_intl, yes, [
+    BUILD_INCLUDED_LIBINTL=no
+    USE_INCLUDED_LIBINTL=no
+  ])
+  LIBINTL=
+  LTLIBINTL=
+  POSUB=
+
+  dnl Add a version number to the cache macros.
+  case " $gt_needs " in
+    *" need-formatstring-macros "*) gt_api_version=3 ;;
+    *" need-ngettext "*) gt_api_version=2 ;;
+    *) gt_api_version=1 ;;
+  esac
+  gt_func_gnugettext_libc="gt_cv_func_gnugettext${gt_api_version}_libc"
+  gt_func_gnugettext_libintl="gt_cv_func_gnugettext${gt_api_version}_libintl"
+
+  dnl If we use NLS figure out what method
+  if test "$USE_NLS" = "yes"; then
+    gt_use_preinstalled_gnugettext=no
+    ifelse(gt_included_intl, yes, [
+      AC_MSG_CHECKING([whether included gettext is requested])
+      AC_ARG_WITH(included-gettext,
+        [  --with-included-gettext use the GNU gettext library included here],
+        nls_cv_force_use_gnu_gettext=$withval,
+        nls_cv_force_use_gnu_gettext=no)
+      AC_MSG_RESULT($nls_cv_force_use_gnu_gettext)
+
+      nls_cv_use_gnu_gettext="$nls_cv_force_use_gnu_gettext"
+      if test "$nls_cv_force_use_gnu_gettext" != "yes"; then
+    ])
+        dnl User does not insist on using GNU NLS library.  Figure out what
+        dnl to use.  If GNU gettext is available we use this.  Else we have
+        dnl to fall back to GNU NLS library.
+
+        if test $gt_api_version -ge 3; then
+          gt_revision_test_code='
+#ifndef __GNU_GETTEXT_SUPPORTED_REVISION
+#define __GNU_GETTEXT_SUPPORTED_REVISION(major) ((major) == 0 ? 0 : -1)
+#endif
+changequote(,)dnl
+typedef int array [2 * (__GNU_GETTEXT_SUPPORTED_REVISION(0) >= 1) - 1];
+changequote([,])dnl
+'
+        else
+          gt_revision_test_code=
+        fi
+        if test $gt_api_version -ge 2; then
+          gt_expression_test_code=' + * ngettext ("", "", 0)'
+        else
+          gt_expression_test_code=
+        fi
+
+        AC_CACHE_CHECK([for GNU gettext in libc], [$gt_func_gnugettext_libc],
+         [AC_TRY_LINK([#include <libintl.h>
+$gt_revision_test_code
+extern int _nl_msg_cat_cntr;
+extern int *_nl_domain_bindings;],
+            [bindtextdomain ("", "");
+return * gettext ("")$gt_expression_test_code + _nl_msg_cat_cntr + *_nl_domain_bindings],
+            [eval "$gt_func_gnugettext_libc=yes"],
+            [eval "$gt_func_gnugettext_libc=no"])])
+
+        if { eval "gt_val=\$$gt_func_gnugettext_libc"; test "$gt_val" != "yes"; }; then
+          dnl Sometimes libintl requires libiconv, so first search for libiconv.
+          ifelse(gt_included_intl, yes, , [
+            AM_ICONV_LINK
+          ])
+          dnl Search for libintl and define LIBINTL, LTLIBINTL and INCINTL
+          dnl accordingly. Don't use AC_LIB_LINKFLAGS_BODY([intl],[iconv])
+          dnl because that would add "-liconv" to LIBINTL and LTLIBINTL
+          dnl even if libiconv doesn't exist.
+          AC_LIB_LINKFLAGS_BODY([intl])
+          AC_CACHE_CHECK([for GNU gettext in libintl],
+            [$gt_func_gnugettext_libintl],
+           [gt_save_CPPFLAGS="$CPPFLAGS"
+            CPPFLAGS="$CPPFLAGS $INCINTL"
+            gt_save_LIBS="$LIBS"
+            LIBS="$LIBS $LIBINTL"
+            dnl Now see whether libintl exists and does not depend on libiconv.
+            AC_TRY_LINK([#include <libintl.h>
+$gt_revision_test_code
+extern int _nl_msg_cat_cntr;
+extern
+#ifdef __cplusplus
+"C"
+#endif
+const char *_nl_expand_alias (const char *);],
+              [bindtextdomain ("", "");
+return * gettext ("")$gt_expression_test_code + _nl_msg_cat_cntr + *_nl_expand_alias ("")],
+              [eval "$gt_func_gnugettext_libintl=yes"],
+              [eval "$gt_func_gnugettext_libintl=no"])
+            dnl Now see whether libintl exists and depends on libiconv.
+            if { eval "gt_val=\$$gt_func_gnugettext_libintl"; test "$gt_val" != yes; } && test -n "$LIBICONV"; then
+              LIBS="$LIBS $LIBICONV"
+              AC_TRY_LINK([#include <libintl.h>
+$gt_revision_test_code
+extern int _nl_msg_cat_cntr;
+extern
+#ifdef __cplusplus
+"C"
+#endif
+const char *_nl_expand_alias (const char *);],
+                [bindtextdomain ("", "");
+return * gettext ("")$gt_expression_test_code + _nl_msg_cat_cntr + *_nl_expand_alias ("")],
+               [LIBINTL="$LIBINTL $LIBICONV"
+                LTLIBINTL="$LTLIBINTL $LTLIBICONV"
+                eval "$gt_func_gnugettext_libintl=yes"
+               ])
+            fi
+            CPPFLAGS="$gt_save_CPPFLAGS"
+            LIBS="$gt_save_LIBS"])
+        fi
+
+        dnl If an already present or preinstalled GNU gettext() is found,
+        dnl use it.  But if this macro is used in GNU gettext, and GNU
+        dnl gettext is already preinstalled in libintl, we update this
+        dnl libintl.  (Cf. the install rule in intl/Makefile.in.)
+        if { eval "gt_val=\$$gt_func_gnugettext_libc"; test "$gt_val" = "yes"; } \
+           || { { eval "gt_val=\$$gt_func_gnugettext_libintl"; test "$gt_val" = "yes"; } \
+                && test "$PACKAGE" != gettext-runtime \
+                && test "$PACKAGE" != gettext-tools; }; then
+          gt_use_preinstalled_gnugettext=yes
+        else
+          dnl Reset the values set by searching for libintl.
+          LIBINTL=
+          LTLIBINTL=
+          INCINTL=
+        fi
+
+    ifelse(gt_included_intl, yes, [
+        if test "$gt_use_preinstalled_gnugettext" != "yes"; then
+          dnl GNU gettext is not found in the C library.
+          dnl Fall back on included GNU gettext library.
+          nls_cv_use_gnu_gettext=yes
+        fi
+      fi
+
+      if test "$nls_cv_use_gnu_gettext" = "yes"; then
+        dnl Mark actions used to generate GNU NLS library.
+        BUILD_INCLUDED_LIBINTL=yes
+        USE_INCLUDED_LIBINTL=yes
+        LIBINTL="ifelse([$3],[],\${top_builddir}/intl,[$3])/libintl.[]gt_libtool_suffix_prefix[]a $LIBICONV $LIBTHREAD"
+        LTLIBINTL="ifelse([$3],[],\${top_builddir}/intl,[$3])/libintl.[]gt_libtool_suffix_prefix[]a $LTLIBICONV $LTLIBTHREAD"
+        LIBS=`echo " $LIBS " | sed -e 's/ -lintl / /' -e 's/^ //' -e 's/ $//'`
+      fi
+
+      CATOBJEXT=
+      if test "$gt_use_preinstalled_gnugettext" = "yes" \
+         || test "$nls_cv_use_gnu_gettext" = "yes"; then
+        dnl Mark actions to use GNU gettext tools.
+        CATOBJEXT=.gmo
+      fi
+    ])
+
+    if test -n "$INTL_MACOSX_LIBS"; then
+      if test "$gt_use_preinstalled_gnugettext" = "yes" \
+         || test "$nls_cv_use_gnu_gettext" = "yes"; then
+        dnl Some extra flags are needed during linking.
+        LIBINTL="$LIBINTL $INTL_MACOSX_LIBS"
+        LTLIBINTL="$LTLIBINTL $INTL_MACOSX_LIBS"
+      fi
+    fi
+
+    if test "$gt_use_preinstalled_gnugettext" = "yes" \
+       || test "$nls_cv_use_gnu_gettext" = "yes"; then
+      AC_DEFINE(ENABLE_NLS, 1,
+        [Define to 1 if translation of program messages to the user's native language
+   is requested.])
+    else
+      USE_NLS=no
+    fi
+  fi
+
+  AC_MSG_CHECKING([whether to use NLS])
+  AC_MSG_RESULT([$USE_NLS])
+  if test "$USE_NLS" = "yes"; then
+    AC_MSG_CHECKING([where the gettext function comes from])
+    if test "$gt_use_preinstalled_gnugettext" = "yes"; then
+      if { eval "gt_val=\$$gt_func_gnugettext_libintl"; test "$gt_val" = "yes"; }; then
+        gt_source="external libintl"
+      else
+        gt_source="libc"
+      fi
+    else
+      gt_source="included intl directory"
+    fi
+    AC_MSG_RESULT([$gt_source])
+  fi
+
+  if test "$USE_NLS" = "yes"; then
+
+    if test "$gt_use_preinstalled_gnugettext" = "yes"; then
+      if { eval "gt_val=\$$gt_func_gnugettext_libintl"; test "$gt_val" = "yes"; }; then
+        AC_MSG_CHECKING([how to link with libintl])
+        AC_MSG_RESULT([$LIBINTL])
+        AC_LIB_APPENDTOVAR([CPPFLAGS], [$INCINTL])
+      fi
+
+      dnl For backward compatibility. Some packages may be using this.
+      AC_DEFINE(HAVE_GETTEXT, 1,
+       [Define if the GNU gettext() function is already present or preinstalled.])
+      AC_DEFINE(HAVE_DCGETTEXT, 1,
+       [Define if the GNU dcgettext() function is already present or preinstalled.])
+    fi
+
+    dnl We need to process the po/ directory.
+    POSUB=po
+  fi
+
+  ifelse(gt_included_intl, yes, [
+    dnl If this is used in GNU gettext we have to set BUILD_INCLUDED_LIBINTL
+    dnl to 'yes' because some of the testsuite requires it.
+    if test "$PACKAGE" = gettext-runtime || test "$PACKAGE" = gettext-tools; then
+      BUILD_INCLUDED_LIBINTL=yes
+    fi
+
+    dnl Make all variables we use known to autoconf.
+    AC_SUBST(BUILD_INCLUDED_LIBINTL)
+    AC_SUBST(USE_INCLUDED_LIBINTL)
+    AC_SUBST(CATOBJEXT)
+
+    dnl For backward compatibility. Some configure.ins may be using this.
+    nls_cv_header_intl=
+    nls_cv_header_libgt=
+
+    dnl For backward compatibility. Some Makefiles may be using this.
+    DATADIRNAME=share
+    AC_SUBST(DATADIRNAME)
+
+    dnl For backward compatibility. Some Makefiles may be using this.
+    INSTOBJEXT=.mo
+    AC_SUBST(INSTOBJEXT)
+
+    dnl For backward compatibility. Some Makefiles may be using this.
+    GENCAT=gencat
+    AC_SUBST(GENCAT)
+
+    dnl For backward compatibility. Some Makefiles may be using this.
+    INTLOBJS=
+    if test "$USE_INCLUDED_LIBINTL" = yes; then
+      INTLOBJS="\$(GETTOBJS)"
+    fi
+    AC_SUBST(INTLOBJS)
+
+    dnl Enable libtool support if the surrounding package wishes it.
+    INTL_LIBTOOL_SUFFIX_PREFIX=gt_libtool_suffix_prefix
+    AC_SUBST(INTL_LIBTOOL_SUFFIX_PREFIX)
+  ])
+
+  dnl For backward compatibility. Some Makefiles may be using this.
+  INTLLIBS="$LIBINTL"
+  AC_SUBST(INTLLIBS)
+
+  dnl Make all documented variables known to autoconf.
+  AC_SUBST(LIBINTL)
+  AC_SUBST(LTLIBINTL)
+  AC_SUBST(POSUB)
+])
+
+
+dnl gt_NEEDS_INIT ensures that the gt_needs variable is initialized.
+m4_define([gt_NEEDS_INIT],
+[
+  m4_divert_text([DEFAULTS], [gt_needs=])
+  m4_define([gt_NEEDS_INIT], [])
+])
+
+
+dnl Usage: AM_GNU_GETTEXT_NEED([NEEDSYMBOL])
+AC_DEFUN([AM_GNU_GETTEXT_NEED],
+[
+  m4_divert_text([INIT_PREPARE], [gt_needs="$gt_needs $1"])
+])
+
+
+dnl Usage: AM_GNU_GETTEXT_VERSION([gettext-version])
+AC_DEFUN([AM_GNU_GETTEXT_VERSION], [])
--- /dev/null
+++ b/m4/glib-gettext.m4
@@ -0,0 +1,432 @@
+# Copyright (C) 1995-2002 Free Software Foundation, Inc.
+# Copyright (C) 2001-2003,2004 Red Hat, Inc.
+#
+# This file is free software, distributed under the terms of the GNU
+# General Public License.  As a special exception to the GNU General
+# Public License, this file may be distributed as part of a program
+# that contains a configuration script generated by Autoconf, under
+# the same distribution terms as the rest of that program.
+#
+# This file can be copied and used freely without restrictions.  It can
+# be used in projects which are not available under the GNU Public License
+# but which still want to provide support for the GNU gettext functionality.
+#
+# Macro to add for using GNU gettext.
+# Ulrich Drepper <drepper@cygnus.com>, 1995, 1996
+#
+# Modified to never use included libintl.
+# Owen Taylor <otaylor@redhat.com>, 12/15/1998
+#
+# Major rework to remove unused code
+# Owen Taylor <otaylor@redhat.com>, 12/11/2002
+#
+# Added better handling of ALL_LINGUAS from GNU gettext version
+# written by Bruno Haible, Owen Taylor <otaylor.redhat.com> 5/30/3002
+#
+# Modified to require ngettext
+# Matthias Clasen <mclasen@redhat.com> 08/06/2004
+#
+# We need this here as well, since someone might use autoconf-2.5x
+# to configure GLib then an older version to configure a package
+# using AM_GLIB_GNU_GETTEXT
+AC_PREREQ(2.53)
+
+dnl
+dnl We go to great lengths to make sure that aclocal won't
+dnl try to pull in the installed version of these macros
+dnl when running aclocal in the glib directory.
+dnl
+m4_copy([AC_DEFUN],[glib_DEFUN])
+m4_copy([AC_REQUIRE],[glib_REQUIRE])
+dnl
+dnl At the end, if we're not within glib, we'll define the public
+dnl definitions in terms of our private definitions.
+dnl
+
+# GLIB_LC_MESSAGES
+#--------------------
+glib_DEFUN([GLIB_LC_MESSAGES],
+  [AC_CHECK_HEADERS([locale.h])
+    if test $ac_cv_header_locale_h = yes; then
+    AC_CACHE_CHECK([for LC_MESSAGES], am_cv_val_LC_MESSAGES,
+      [AC_TRY_LINK([#include <locale.h>], [return LC_MESSAGES],
+       am_cv_val_LC_MESSAGES=yes, am_cv_val_LC_MESSAGES=no)])
+    if test $am_cv_val_LC_MESSAGES = yes; then
+      AC_DEFINE(HAVE_LC_MESSAGES, 1,
+        [Define if your <locale.h> file defines LC_MESSAGES.])
+    fi
+  fi])
+
+# GLIB_PATH_PROG_WITH_TEST
+#----------------------------
+dnl GLIB_PATH_PROG_WITH_TEST(VARIABLE, PROG-TO-CHECK-FOR,
+dnl   TEST-PERFORMED-ON-FOUND_PROGRAM [, VALUE-IF-NOT-FOUND [, PATH]])
+glib_DEFUN([GLIB_PATH_PROG_WITH_TEST],
+[# Extract the first word of "$2", so it can be a program name with args.
+set dummy $2; ac_word=[$]2
+AC_MSG_CHECKING([for $ac_word])
+AC_CACHE_VAL(ac_cv_path_$1,
+[case "[$]$1" in
+  /*)
+  ac_cv_path_$1="[$]$1" # Let the user override the test with a path.
+  ;;
+  *)
+  IFS="${IFS= 	}"; ac_save_ifs="$IFS"; IFS="${IFS}:"
+  for ac_dir in ifelse([$5], , $PATH, [$5]); do
+    test -z "$ac_dir" && ac_dir=.
+    if test -f $ac_dir/$ac_word; then
+      if [$3]; then
+	ac_cv_path_$1="$ac_dir/$ac_word"
+	break
+      fi
+    fi
+  done
+  IFS="$ac_save_ifs"
+dnl If no 4th arg is given, leave the cache variable unset,
+dnl so AC_PATH_PROGS will keep looking.
+ifelse([$4], , , [  test -z "[$]ac_cv_path_$1" && ac_cv_path_$1="$4"
+])dnl
+  ;;
+esac])dnl
+$1="$ac_cv_path_$1"
+if test ifelse([$4], , [-n "[$]$1"], ["[$]$1" != "$4"]); then
+  AC_MSG_RESULT([$]$1)
+else
+  AC_MSG_RESULT(no)
+fi
+AC_SUBST($1)dnl
+])
+
+# GLIB_WITH_NLS
+#-----------------
+glib_DEFUN([GLIB_WITH_NLS],
+  dnl NLS is obligatory
+  [USE_NLS=yes
+    AC_SUBST(USE_NLS)
+
+    gt_cv_have_gettext=no
+
+    CATOBJEXT=NONE
+    XGETTEXT=:
+    INTLLIBS=
+
+    AC_CHECK_HEADER(libintl.h,
+     [gt_cv_func_dgettext_libintl="no"
+      libintl_extra_libs=""
+
+      #
+      # First check in libc
+      #
+      AC_CACHE_CHECK([for ngettext in libc], gt_cv_func_ngettext_libc,
+        [AC_TRY_LINK([
+#include <libintl.h>
+],
+         [return !ngettext ("","", 1)],
+	  gt_cv_func_ngettext_libc=yes,
+          gt_cv_func_ngettext_libc=no)
+        ])
+
+      if test "$gt_cv_func_ngettext_libc" = "yes" ; then
+	      AC_CACHE_CHECK([for dgettext in libc], gt_cv_func_dgettext_libc,
+        	[AC_TRY_LINK([
+#include <libintl.h>
+],
+	          [return !dgettext ("","")],
+		  gt_cv_func_dgettext_libc=yes,
+	          gt_cv_func_dgettext_libc=no)
+        	])
+      fi
+
+      if test "$gt_cv_func_ngettext_libc" = "yes" ; then
+        AC_CHECK_FUNCS(bind_textdomain_codeset)
+      fi
+
+      #
+      # If we don't have everything we want, check in libintl
+      #
+      if test "$gt_cv_func_dgettext_libc" != "yes" \
+	 || test "$gt_cv_func_ngettext_libc" != "yes" \
+         || test "$ac_cv_func_bind_textdomain_codeset" != "yes" ; then
+
+        AC_CHECK_LIB(intl, bindtextdomain,
+	    [AC_CHECK_LIB(intl, ngettext,
+		    [AC_CHECK_LIB(intl, dgettext,
+			          gt_cv_func_dgettext_libintl=yes)])])
+
+	if test "$gt_cv_func_dgettext_libintl" != "yes" ; then
+	  AC_MSG_CHECKING([if -liconv is needed to use gettext])
+	  AC_MSG_RESULT([])
+  	  AC_CHECK_LIB(intl, ngettext,
+          	[AC_CHECK_LIB(intl, dcgettext,
+		       [gt_cv_func_dgettext_libintl=yes
+			libintl_extra_libs=-liconv],
+			:,-liconv)],
+		:,-liconv)
+        fi
+
+        #
+        # If we found libintl, then check in it for bind_textdomain_codeset();
+        # we'll prefer libc if neither have bind_textdomain_codeset(),
+        # and both have dgettext and ngettext
+        #
+        if test "$gt_cv_func_dgettext_libintl" = "yes" ; then
+          glib_save_LIBS="$LIBS"
+          LIBS="$LIBS -lintl $libintl_extra_libs"
+          unset ac_cv_func_bind_textdomain_codeset
+          AC_CHECK_FUNCS(bind_textdomain_codeset)
+          LIBS="$glib_save_LIBS"
+
+          if test "$ac_cv_func_bind_textdomain_codeset" = "yes" ; then
+            gt_cv_func_dgettext_libc=no
+          else
+            if test "$gt_cv_func_dgettext_libc" = "yes" \
+		&& test "$gt_cv_func_ngettext_libc" = "yes"; then
+              gt_cv_func_dgettext_libintl=no
+            fi
+          fi
+        fi
+      fi
+
+      if test "$gt_cv_func_dgettext_libc" = "yes" \
+	|| test "$gt_cv_func_dgettext_libintl" = "yes"; then
+        gt_cv_have_gettext=yes
+      fi
+
+      if test "$gt_cv_func_dgettext_libintl" = "yes"; then
+        INTLLIBS="-lintl $libintl_extra_libs"
+      fi
+
+      if test "$gt_cv_have_gettext" = "yes"; then
+	AC_DEFINE(HAVE_GETTEXT,1,
+	  [Define if the GNU gettext() function is already present or preinstalled.])
+	GLIB_PATH_PROG_WITH_TEST(MSGFMT, msgfmt,
+	  [test -z "`$ac_dir/$ac_word -h 2>&1 | grep 'dv '`"], no)dnl
+	if test "$MSGFMT" != "no"; then
+          glib_save_LIBS="$LIBS"
+          LIBS="$LIBS $INTLLIBS"
+	  AC_CHECK_FUNCS(dcgettext)
+	  MSGFMT_OPTS=
+	  AC_MSG_CHECKING([if msgfmt accepts -c])
+	  GLIB_RUN_PROG([$MSGFMT -c -o /dev/null],[
+msgid ""
+msgstr ""
+"Content-Type: text/plain; charset=UTF-8\n"
+"Project-Id-Version: test 1.0\n"
+"PO-Revision-Date: 2007-02-15 12:01+0100\n"
+"Last-Translator: test <foo@bar.xx>\n"
+"Language-Team: C <LL@li.org>\n"
+"MIME-Version: 1.0\n"
+"Content-Transfer-Encoding: 8bit\n"
+], [MSGFMT_OPTS=-c; AC_MSG_RESULT([yes])], [AC_MSG_RESULT([no])])
+	  AC_SUBST(MSGFMT_OPTS)
+	  AC_PATH_PROG(GMSGFMT, gmsgfmt, $MSGFMT)
+	  GLIB_PATH_PROG_WITH_TEST(XGETTEXT, xgettext,
+	    [test -z "`$ac_dir/$ac_word -h 2>&1 | grep '(HELP)'`"], :)
+	  AC_TRY_LINK(, [extern int _nl_msg_cat_cntr;
+			 return _nl_msg_cat_cntr],
+	    [CATOBJEXT=.gmo
+             DATADIRNAME=share],
+	    [case $host in
+	    *-*-solaris*)
+	    dnl On Solaris, if bind_textdomain_codeset is in libc,
+	    dnl GNU format message catalog is always supported,
+            dnl since both are added to the libc all together.
+	    dnl Hence, we'd like to go with DATADIRNAME=share and
+	    dnl and CATOBJEXT=.gmo in this case.
+            AC_CHECK_FUNC(bind_textdomain_codeset,
+	      [CATOBJEXT=.gmo
+               DATADIRNAME=share],
+	      [CATOBJEXT=.mo
+               DATADIRNAME=lib])
+	    ;;
+	    *)
+	    CATOBJEXT=.mo
+            DATADIRNAME=lib
+	    ;;
+	    esac])
+          LIBS="$glib_save_LIBS"
+	  INSTOBJEXT=.mo
+	else
+	  gt_cv_have_gettext=no
+	fi
+      fi
+    ])
+
+    if test "$gt_cv_have_gettext" = "yes" ; then
+      AC_DEFINE(ENABLE_NLS, 1,
+        [always defined to indicate that i18n is enabled])
+    fi
+
+    dnl Test whether we really found GNU xgettext.
+    if test "$XGETTEXT" != ":"; then
+      dnl If it is not GNU xgettext we define it as : so that the
+      dnl Makefiles still can work.
+      if $XGETTEXT --omit-header /dev/null 2> /dev/null; then
+        : ;
+      else
+        AC_MSG_RESULT(
+	  [found xgettext program is not GNU xgettext; ignore it])
+        XGETTEXT=":"
+      fi
+    fi
+
+    # We need to process the po/ directory.
+    POSUB=po
+
+    AC_OUTPUT_COMMANDS(
+      [case "$CONFIG_FILES" in *po/Makefile.in*)
+        sed -e "/POTFILES =/r po/POTFILES" po/Makefile.in > po/Makefile
+      esac])
+
+    dnl These rules are solely for the distribution goal.  While doing this
+    dnl we only have to keep exactly one list of the available catalogs
+    dnl in configure.in.
+    for lang in $ALL_LINGUAS; do
+      GMOFILES="$GMOFILES $lang.gmo"
+      POFILES="$POFILES $lang.po"
+    done
+
+    dnl Make all variables we use known to autoconf.
+    AC_SUBST(CATALOGS)
+    AC_SUBST(CATOBJEXT)
+    AC_SUBST(DATADIRNAME)
+    AC_SUBST(GMOFILES)
+    AC_SUBST(INSTOBJEXT)
+    AC_SUBST(INTLLIBS)
+    AC_SUBST(PO_IN_DATADIR_TRUE)
+    AC_SUBST(PO_IN_DATADIR_FALSE)
+    AC_SUBST(POFILES)
+    AC_SUBST(POSUB)
+  ])
+
+# AM_GLIB_GNU_GETTEXT
+# -------------------
+# Do checks necessary for use of gettext. If a suitable implementation
+# of gettext is found in either in libintl or in the C library,
+# it will set INTLLIBS to the libraries needed for use of gettext
+# and AC_DEFINE() HAVE_GETTEXT and ENABLE_NLS. (The shell variable
+# gt_cv_have_gettext will be set to "yes".) It will also call AC_SUBST()
+# on various variables needed by the Makefile.in.in installed by
+# glib-gettextize.
+dnl
+glib_DEFUN([GLIB_GNU_GETTEXT],
+  [AC_REQUIRE([AC_PROG_CC])dnl
+   AC_REQUIRE([AC_HEADER_STDC])dnl
+
+   GLIB_LC_MESSAGES
+   GLIB_WITH_NLS
+
+   if test "$gt_cv_have_gettext" = "yes"; then
+     if test "x$ALL_LINGUAS" = "x"; then
+       LINGUAS=
+     else
+       AC_MSG_CHECKING(for catalogs to be installed)
+       NEW_LINGUAS=
+       for presentlang in $ALL_LINGUAS; do
+         useit=no
+         if test "%UNSET%" != "${LINGUAS-%UNSET%}"; then
+           desiredlanguages="$LINGUAS"
+         else
+           desiredlanguages="$ALL_LINGUAS"
+         fi
+         for desiredlang in $desiredlanguages; do
+ 	   # Use the presentlang catalog if desiredlang is
+           #   a. equal to presentlang, or
+           #   b. a variant of presentlang (because in this case,
+           #      presentlang can be used as a fallback for messages
+           #      which are not translated in the desiredlang catalog).
+           case "$desiredlang" in
+             "$presentlang"*) useit=yes;;
+           esac
+         done
+         if test $useit = yes; then
+           NEW_LINGUAS="$NEW_LINGUAS $presentlang"
+         fi
+       done
+       LINGUAS=$NEW_LINGUAS
+       AC_MSG_RESULT($LINGUAS)
+     fi
+
+     dnl Construct list of names of catalog files to be constructed.
+     if test -n "$LINGUAS"; then
+       for lang in $LINGUAS; do CATALOGS="$CATALOGS $lang$CATOBJEXT"; done
+     fi
+   fi
+
+   dnl If the AC_CONFIG_AUX_DIR macro for autoconf is used we possibly
+   dnl find the mkinstalldirs script in another subdir but ($top_srcdir).
+   dnl Try to locate is.
+   MKINSTALLDIRS=
+   if test -n "$ac_aux_dir"; then
+     MKINSTALLDIRS="$ac_aux_dir/mkinstalldirs"
+   fi
+   if test -z "$MKINSTALLDIRS"; then
+     MKINSTALLDIRS="\$(top_srcdir)/mkinstalldirs"
+   fi
+   AC_SUBST(MKINSTALLDIRS)
+
+   dnl Generate list of files to be processed by xgettext which will
+   dnl be included in po/Makefile.
+   test -d po || mkdir po
+   if test "x$srcdir" != "x."; then
+     if test "x`echo $srcdir | sed 's@/.*@@'`" = "x"; then
+       posrcprefix="$srcdir/"
+     else
+       posrcprefix="../$srcdir/"
+     fi
+   else
+     posrcprefix="../"
+   fi
+   rm -f po/POTFILES
+   sed -e "/^#/d" -e "/^\$/d" -e "s,.*,	$posrcprefix& \\\\," -e "\$s/\(.*\) \\\\/\1/" \
+	< $srcdir/po/POTFILES.in > po/POTFILES
+  ])
+
+# AM_GLIB_DEFINE_LOCALEDIR(VARIABLE)
+# -------------------------------
+# Define VARIABLE to the location where catalog files will
+# be installed by po/Makefile.
+glib_DEFUN([GLIB_DEFINE_LOCALEDIR],
+[glib_REQUIRE([GLIB_GNU_GETTEXT])dnl
+glib_save_prefix="$prefix"
+glib_save_exec_prefix="$exec_prefix"
+glib_save_datarootdir="$datarootdir"
+test "x$prefix" = xNONE && prefix=$ac_default_prefix
+test "x$exec_prefix" = xNONE && exec_prefix=$prefix
+datarootdir=`eval echo "${datarootdir}"`
+if test "x$CATOBJEXT" = "x.mo" ; then
+  localedir=`eval echo "${libdir}/locale"`
+else
+  localedir=`eval echo "${datadir}/locale"`
+fi
+prefix="$glib_save_prefix"
+exec_prefix="$glib_save_exec_prefix"
+datarootdir="$glib_save_datarootdir"
+AC_DEFINE_UNQUOTED($1, "$localedir",
+  [Define the location where the catalogs will be installed])
+])
+
+dnl
+dnl Now the definitions that aclocal will find
+dnl
+ifdef(glib_configure_in,[],[
+AC_DEFUN([AM_GLIB_GNU_GETTEXT],[GLIB_GNU_GETTEXT($@)])
+AC_DEFUN([AM_GLIB_DEFINE_LOCALEDIR],[GLIB_DEFINE_LOCALEDIR($@)])
+])dnl
+
+# GLIB_RUN_PROG(PROGRAM, TEST-FILE, [ACTION-IF-PASS], [ACTION-IF-FAIL])
+#
+# Create a temporary file with TEST-FILE as its contents and pass the
+# file name to PROGRAM.  Perform ACTION-IF-PASS if PROGRAM exits with
+# 0 and perform ACTION-IF-FAIL for any other exit status.
+AC_DEFUN([GLIB_RUN_PROG],
+[cat >conftest.foo <<_ACEOF
+$2
+_ACEOF
+if AC_RUN_LOG([$1 conftest.foo]); then
+  m4_ifval([$3], [$3], [:])
+m4_ifvaln([$4], [else $4])dnl
+echo "$as_me: failed input was:" >&AS_MESSAGE_LOG_FD
+sed 's/^/| /' conftest.foo >&AS_MESSAGE_LOG_FD
+fi])
+
--- /dev/null
+++ b/m4/glibc21.m4
@@ -0,0 +1,30 @@
+# glibc21.m4 serial 3
+dnl Copyright (C) 2000-2002, 2004 Free Software Foundation, Inc.
+dnl This file is free software; the Free Software Foundation
+dnl gives unlimited permission to copy and/or distribute it,
+dnl with or without modifications, as long as this notice is preserved.
+
+# Test for the GNU C Library, version 2.1 or newer.
+# From Bruno Haible.
+
+AC_DEFUN([gl_GLIBC21],
+  [
+    AC_CACHE_CHECK(whether we are using the GNU C Library 2.1 or newer,
+      ac_cv_gnu_library_2_1,
+      [AC_EGREP_CPP([Lucky GNU user],
+	[
+#include <features.h>
+#ifdef __GNU_LIBRARY__
+ #if (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 1) || (__GLIBC__ > 2)
+  Lucky GNU user
+ #endif
+#endif
+	],
+	ac_cv_gnu_library_2_1=yes,
+	ac_cv_gnu_library_2_1=no)
+      ]
+    )
+    AC_SUBST(GLIBC21)
+    GLIBC21="$ac_cv_gnu_library_2_1"
+  ]
+)
--- /dev/null
+++ b/m4/iconv.m4
@@ -0,0 +1,180 @@
+# iconv.m4 serial AM6 (gettext-0.17)
+dnl Copyright (C) 2000-2002, 2007 Free Software Foundation, Inc.
+dnl This file is free software; the Free Software Foundation
+dnl gives unlimited permission to copy and/or distribute it,
+dnl with or without modifications, as long as this notice is preserved.
+
+dnl From Bruno Haible.
+
+AC_DEFUN([AM_ICONV_LINKFLAGS_BODY],
+[
+  dnl Prerequisites of AC_LIB_LINKFLAGS_BODY.
+  AC_REQUIRE([AC_LIB_PREPARE_PREFIX])
+  AC_REQUIRE([AC_LIB_RPATH])
+
+  dnl Search for libiconv and define LIBICONV, LTLIBICONV and INCICONV
+  dnl accordingly.
+  AC_LIB_LINKFLAGS_BODY([iconv])
+])
+
+AC_DEFUN([AM_ICONV_LINK],
+[
+  dnl Some systems have iconv in libc, some have it in libiconv (OSF/1 and
+  dnl those with the standalone portable GNU libiconv installed).
+  AC_REQUIRE([AC_CANONICAL_HOST]) dnl for cross-compiles
+
+  dnl Search for libiconv and define LIBICONV, LTLIBICONV and INCICONV
+  dnl accordingly.
+  AC_REQUIRE([AM_ICONV_LINKFLAGS_BODY])
+
+  dnl Add $INCICONV to CPPFLAGS before performing the following checks,
+  dnl because if the user has installed libiconv and not disabled its use
+  dnl via --without-libiconv-prefix, he wants to use it. The first
+  dnl AC_TRY_LINK will then fail, the second AC_TRY_LINK will succeed.
+  am_save_CPPFLAGS="$CPPFLAGS"
+  AC_LIB_APPENDTOVAR([CPPFLAGS], [$INCICONV])
+
+  AC_CACHE_CHECK([for iconv], am_cv_func_iconv, [
+    am_cv_func_iconv="no, consider installing GNU libiconv"
+    am_cv_lib_iconv=no
+    AC_TRY_LINK([#include <stdlib.h>
+#include <iconv.h>],
+      [iconv_t cd = iconv_open("","");
+       iconv(cd,NULL,NULL,NULL,NULL);
+       iconv_close(cd);],
+      am_cv_func_iconv=yes)
+    if test "$am_cv_func_iconv" != yes; then
+      am_save_LIBS="$LIBS"
+      LIBS="$LIBS $LIBICONV"
+      AC_TRY_LINK([#include <stdlib.h>
+#include <iconv.h>],
+        [iconv_t cd = iconv_open("","");
+         iconv(cd,NULL,NULL,NULL,NULL);
+         iconv_close(cd);],
+        am_cv_lib_iconv=yes
+        am_cv_func_iconv=yes)
+      LIBS="$am_save_LIBS"
+    fi
+  ])
+  if test "$am_cv_func_iconv" = yes; then
+    AC_CACHE_CHECK([for working iconv], am_cv_func_iconv_works, [
+      dnl This tests against bugs in AIX 5.1 and HP-UX 11.11.
+      am_save_LIBS="$LIBS"
+      if test $am_cv_lib_iconv = yes; then
+        LIBS="$LIBS $LIBICONV"
+      fi
+      AC_TRY_RUN([
+#include <iconv.h>
+#include <string.h>
+int main ()
+{
+  /* Test against AIX 5.1 bug: Failures are not distinguishable from successful
+     returns.  */
+  {
+    iconv_t cd_utf8_to_88591 = iconv_open ("ISO8859-1", "UTF-8");
+    if (cd_utf8_to_88591 != (iconv_t)(-1))
+      {
+        static const char input[] = "\342\202\254"; /* EURO SIGN */
+        char buf[10];
+        const char *inptr = input;
+        size_t inbytesleft = strlen (input);
+        char *outptr = buf;
+        size_t outbytesleft = sizeof (buf);
+        size_t res = iconv (cd_utf8_to_88591,
+                            (char **) &inptr, &inbytesleft,
+                            &outptr, &outbytesleft);
+        if (res == 0)
+          return 1;
+      }
+  }
+#if 0 /* This bug could be worked around by the caller.  */
+  /* Test against HP-UX 11.11 bug: Positive return value instead of 0.  */
+  {
+    iconv_t cd_88591_to_utf8 = iconv_open ("utf8", "iso88591");
+    if (cd_88591_to_utf8 != (iconv_t)(-1))
+      {
+        static const char input[] = "\304rger mit b\366sen B\374bchen ohne Augenma\337";
+        char buf[50];
+        const char *inptr = input;
+        size_t inbytesleft = strlen (input);
+        char *outptr = buf;
+        size_t outbytesleft = sizeof (buf);
+        size_t res = iconv (cd_88591_to_utf8,
+                            (char **) &inptr, &inbytesleft,
+                            &outptr, &outbytesleft);
+        if ((int)res > 0)
+          return 1;
+      }
+  }
+#endif
+  /* Test against HP-UX 11.11 bug: No converter from EUC-JP to UTF-8 is
+     provided.  */
+  if (/* Try standardized names.  */
+      iconv_open ("UTF-8", "EUC-JP") == (iconv_t)(-1)
+      /* Try IRIX, OSF/1 names.  */
+      && iconv_open ("UTF-8", "eucJP") == (iconv_t)(-1)
+      /* Try AIX names.  */
+      && iconv_open ("UTF-8", "IBM-eucJP") == (iconv_t)(-1)
+      /* Try HP-UX names.  */
+      && iconv_open ("utf8", "eucJP") == (iconv_t)(-1))
+    return 1;
+  return 0;
+}], [am_cv_func_iconv_works=yes], [am_cv_func_iconv_works=no],
+        [case "$host_os" in
+           aix* | hpux*) am_cv_func_iconv_works="guessing no" ;;
+           *)            am_cv_func_iconv_works="guessing yes" ;;
+         esac])
+      LIBS="$am_save_LIBS"
+    ])
+    case "$am_cv_func_iconv_works" in
+      *no) am_func_iconv=no am_cv_lib_iconv=no ;;
+      *)   am_func_iconv=yes ;;
+    esac
+  else
+    am_func_iconv=no am_cv_lib_iconv=no
+  fi
+  if test "$am_func_iconv" = yes; then
+    AC_DEFINE(HAVE_ICONV, 1,
+      [Define if you have the iconv() function and it works.])
+  fi
+  if test "$am_cv_lib_iconv" = yes; then
+    AC_MSG_CHECKING([how to link with libiconv])
+    AC_MSG_RESULT([$LIBICONV])
+  else
+    dnl If $LIBICONV didn't lead to a usable library, we don't need $INCICONV
+    dnl either.
+    CPPFLAGS="$am_save_CPPFLAGS"
+    LIBICONV=
+    LTLIBICONV=
+  fi
+  AC_SUBST(LIBICONV)
+  AC_SUBST(LTLIBICONV)
+])
+
+AC_DEFUN([AM_ICONV],
+[
+  AM_ICONV_LINK
+  if test "$am_cv_func_iconv" = yes; then
+    AC_MSG_CHECKING([for iconv declaration])
+    AC_CACHE_VAL(am_cv_proto_iconv, [
+      AC_TRY_COMPILE([
+#include <stdlib.h>
+#include <iconv.h>
+extern
+#ifdef __cplusplus
+"C"
+#endif
+#if defined(__STDC__) || defined(__cplusplus)
+size_t iconv (iconv_t cd, char * *inbuf, size_t *inbytesleft, char * *outbuf, size_t *outbytesleft);
+#else
+size_t iconv();
+#endif
+], [], am_cv_proto_iconv_arg1="", am_cv_proto_iconv_arg1="const")
+      am_cv_proto_iconv="extern size_t iconv (iconv_t cd, $am_cv_proto_iconv_arg1 char * *inbuf, size_t *inbytesleft, char * *outbuf, size_t *outbytesleft);"])
+    am_cv_proto_iconv=`echo "[$]am_cv_proto_iconv" | tr -s ' ' | sed -e 's/( /(/'`
+    AC_MSG_RESULT([$]{ac_t:-
+         }[$]am_cv_proto_iconv)
+    AC_DEFINE_UNQUOTED(ICONV_CONST, $am_cv_proto_iconv_arg1,
+      [Define as const if the declaration of iconv() needs const.])
+  fi
+])
--- /dev/null
+++ b/m4/isc-posix.m4
@@ -0,0 +1,24 @@
+# isc-posix.m4 serial 2 (gettext-0.11.2)
+dnl Copyright (C) 1995-2002 Free Software Foundation, Inc.
+dnl This file is free software; the Free Software Foundation
+dnl gives unlimited permission to copy and/or distribute it,
+dnl with or without modifications, as long as this notice is preserved.
+
+# This file is not needed with autoconf-2.53 and newer.  Remove it in 2005.
+
+# This test replaces the one in autoconf.
+# Currently this macro should have the same name as the autoconf macro
+# because gettext's gettext.m4 (distributed in the automake package)
+# still uses it.  Otherwise, the use in gettext.m4 makes autoheader
+# give these diagnostics:
+#   configure.in:556: AC_TRY_COMPILE was called before AC_ISC_POSIX
+#   configure.in:556: AC_TRY_RUN was called before AC_ISC_POSIX
+
+undefine([AC_ISC_POSIX])
+
+AC_DEFUN([AC_ISC_POSIX],
+  [
+    dnl This test replaces the obsolescent AC_ISC_POSIX kludge.
+    AC_CHECK_LIB(cposix, strerror, [LIBS="$LIBS -lcposix"])
+  ]
+)
--- /dev/null
+++ b/m4/lcmessage.m4
@@ -0,0 +1,30 @@
+# lcmessage.m4 serial 4 (gettext-0.14.2)
+dnl Copyright (C) 1995-2002, 2004-2005 Free Software Foundation, Inc.
+dnl This file is free software; the Free Software Foundation
+dnl gives unlimited permission to copy and/or distribute it,
+dnl with or without modifications, as long as this notice is preserved.
+dnl
+dnl This file can can be used in projects which are not available under
+dnl the GNU General Public License or the GNU Library General Public
+dnl License but which still want to provide support for the GNU gettext
+dnl functionality.
+dnl Please note that the actual code of the GNU gettext library is covered
+dnl by the GNU Library General Public License, and the rest of the GNU
+dnl gettext package package is covered by the GNU General Public License.
+dnl They are *not* in the public domain.
+
+dnl Authors:
+dnl   Ulrich Drepper <drepper@cygnus.com>, 1995.
+
+# Check whether LC_MESSAGES is available in <locale.h>.
+
+AC_DEFUN([gt_LC_MESSAGES],
+[
+  AC_CACHE_CHECK([for LC_MESSAGES], gt_cv_val_LC_MESSAGES,
+    [AC_TRY_LINK([#include <locale.h>], [return LC_MESSAGES],
+       gt_cv_val_LC_MESSAGES=yes, gt_cv_val_LC_MESSAGES=no)])
+  if test $gt_cv_val_LC_MESSAGES = yes; then
+    AC_DEFINE(HAVE_LC_MESSAGES, 1,
+      [Define if your <locale.h> file defines LC_MESSAGES.])
+  fi
+])
--- /dev/null
+++ b/m4/lib-ld.m4
@@ -0,0 +1,110 @@
+# lib-ld.m4 serial 3 (gettext-0.13)
+dnl Copyright (C) 1996-2003 Free Software Foundation, Inc.
+dnl This file is free software; the Free Software Foundation
+dnl gives unlimited permission to copy and/or distribute it,
+dnl with or without modifications, as long as this notice is preserved.
+
+dnl Subroutines of libtool.m4,
+dnl with replacements s/AC_/AC_LIB/ and s/lt_cv/acl_cv/ to avoid collision
+dnl with libtool.m4.
+
+dnl From libtool-1.4. Sets the variable with_gnu_ld to yes or no.
+AC_DEFUN([AC_LIB_PROG_LD_GNU],
+[AC_CACHE_CHECK([if the linker ($LD) is GNU ld], acl_cv_prog_gnu_ld,
+[# I'd rather use --version here, but apparently some GNU ld's only accept -v.
+case `$LD -v 2>&1 </dev/null` in
+*GNU* | *'with BFD'*)
+  acl_cv_prog_gnu_ld=yes ;;
+*)
+  acl_cv_prog_gnu_ld=no ;;
+esac])
+with_gnu_ld=$acl_cv_prog_gnu_ld
+])
+
+dnl From libtool-1.4. Sets the variable LD.
+AC_DEFUN([AC_LIB_PROG_LD],
+[AC_ARG_WITH(gnu-ld,
+[  --with-gnu-ld           assume the C compiler uses GNU ld [default=no]],
+test "$withval" = no || with_gnu_ld=yes, with_gnu_ld=no)
+AC_REQUIRE([AC_PROG_CC])dnl
+AC_REQUIRE([AC_CANONICAL_HOST])dnl
+# Prepare PATH_SEPARATOR.
+# The user is always right.
+if test "${PATH_SEPARATOR+set}" != set; then
+  echo "#! /bin/sh" >conf$$.sh
+  echo  "exit 0"   >>conf$$.sh
+  chmod +x conf$$.sh
+  if (PATH="/nonexistent;."; conf$$.sh) >/dev/null 2>&1; then
+    PATH_SEPARATOR=';'
+  else
+    PATH_SEPARATOR=:
+  fi
+  rm -f conf$$.sh
+fi
+ac_prog=ld
+if test "$GCC" = yes; then
+  # Check if gcc -print-prog-name=ld gives a path.
+  AC_MSG_CHECKING([for ld used by GCC])
+  case $host in
+  *-*-mingw*)
+    # gcc leaves a trailing carriage return which upsets mingw
+    ac_prog=`($CC -print-prog-name=ld) 2>&5 | tr -d '\015'` ;;
+  *)
+    ac_prog=`($CC -print-prog-name=ld) 2>&5` ;;
+  esac
+  case $ac_prog in
+    # Accept absolute paths.
+    [[\\/]* | [A-Za-z]:[\\/]*)]
+      [re_direlt='/[^/][^/]*/\.\./']
+      # Canonicalize the path of ld
+      ac_prog=`echo $ac_prog| sed 's%\\\\%/%g'`
+      while echo $ac_prog | grep "$re_direlt" > /dev/null 2>&1; do
+	ac_prog=`echo $ac_prog| sed "s%$re_direlt%/%"`
+      done
+      test -z "$LD" && LD="$ac_prog"
+      ;;
+  "")
+    # If it fails, then pretend we aren't using GCC.
+    ac_prog=ld
+    ;;
+  *)
+    # If it is relative, then search for the first ld in PATH.
+    with_gnu_ld=unknown
+    ;;
+  esac
+elif test "$with_gnu_ld" = yes; then
+  AC_MSG_CHECKING([for GNU ld])
+else
+  AC_MSG_CHECKING([for non-GNU ld])
+fi
+AC_CACHE_VAL(acl_cv_path_LD,
+[if test -z "$LD"; then
+  IFS="${IFS= 	}"; ac_save_ifs="$IFS"; IFS="${IFS}${PATH_SEPARATOR-:}"
+  for ac_dir in $PATH; do
+    test -z "$ac_dir" && ac_dir=.
+    if test -f "$ac_dir/$ac_prog" || test -f "$ac_dir/$ac_prog$ac_exeext"; then
+      acl_cv_path_LD="$ac_dir/$ac_prog"
+      # Check to see if the program is GNU ld.  I'd rather use --version,
+      # but apparently some GNU ld's only accept -v.
+      # Break only if it was the GNU/non-GNU ld that we prefer.
+      case `"$acl_cv_path_LD" -v 2>&1 < /dev/null` in
+      *GNU* | *'with BFD'*)
+	test "$with_gnu_ld" != no && break ;;
+      *)
+	test "$with_gnu_ld" != yes && break ;;
+      esac
+    fi
+  done
+  IFS="$ac_save_ifs"
+else
+  acl_cv_path_LD="$LD" # Let the user override the test with a path.
+fi])
+LD="$acl_cv_path_LD"
+if test -n "$LD"; then
+  AC_MSG_RESULT($LD)
+else
+  AC_MSG_RESULT(no)
+fi
+test -z "$LD" && AC_MSG_ERROR([no acceptable ld found in \$PATH])
+AC_LIB_PROG_LD_GNU
+])
--- /dev/null
+++ b/m4/lib-link.m4
@@ -0,0 +1,709 @@
+# lib-link.m4 serial 13 (gettext-0.17)
+dnl Copyright (C) 2001-2007 Free Software Foundation, Inc.
+dnl This file is free software; the Free Software Foundation
+dnl gives unlimited permission to copy and/or distribute it,
+dnl with or without modifications, as long as this notice is preserved.
+
+dnl From Bruno Haible.
+
+AC_PREREQ(2.54)
+
+dnl AC_LIB_LINKFLAGS(name [, dependencies]) searches for libname and
+dnl the libraries corresponding to explicit and implicit dependencies.
+dnl Sets and AC_SUBSTs the LIB${NAME} and LTLIB${NAME} variables and
+dnl augments the CPPFLAGS variable.
+dnl Sets and AC_SUBSTs the LIB${NAME}_PREFIX variable to nonempty if libname
+dnl was found in ${LIB${NAME}_PREFIX}/$acl_libdirstem.
+AC_DEFUN([AC_LIB_LINKFLAGS],
+[
+  AC_REQUIRE([AC_LIB_PREPARE_PREFIX])
+  AC_REQUIRE([AC_LIB_RPATH])
+  define([Name],[translit([$1],[./-], [___])])
+  define([NAME],[translit([$1],[abcdefghijklmnopqrstuvwxyz./-],
+                               [ABCDEFGHIJKLMNOPQRSTUVWXYZ___])])
+  AC_CACHE_CHECK([how to link with lib[]$1], [ac_cv_lib[]Name[]_libs], [
+    AC_LIB_LINKFLAGS_BODY([$1], [$2])
+    ac_cv_lib[]Name[]_libs="$LIB[]NAME"
+    ac_cv_lib[]Name[]_ltlibs="$LTLIB[]NAME"
+    ac_cv_lib[]Name[]_cppflags="$INC[]NAME"
+    ac_cv_lib[]Name[]_prefix="$LIB[]NAME[]_PREFIX"
+  ])
+  LIB[]NAME="$ac_cv_lib[]Name[]_libs"
+  LTLIB[]NAME="$ac_cv_lib[]Name[]_ltlibs"
+  INC[]NAME="$ac_cv_lib[]Name[]_cppflags"
+  LIB[]NAME[]_PREFIX="$ac_cv_lib[]Name[]_prefix"
+  AC_LIB_APPENDTOVAR([CPPFLAGS], [$INC]NAME)
+  AC_SUBST([LIB]NAME)
+  AC_SUBST([LTLIB]NAME)
+  AC_SUBST([LIB]NAME[_PREFIX])
+  dnl Also set HAVE_LIB[]NAME so that AC_LIB_HAVE_LINKFLAGS can reuse the
+  dnl results of this search when this library appears as a dependency.
+  HAVE_LIB[]NAME=yes
+  undefine([Name])
+  undefine([NAME])
+])
+
+dnl AC_LIB_HAVE_LINKFLAGS(name, dependencies, includes, testcode)
+dnl searches for libname and the libraries corresponding to explicit and
+dnl implicit dependencies, together with the specified include files and
+dnl the ability to compile and link the specified testcode. If found, it
+dnl sets and AC_SUBSTs HAVE_LIB${NAME}=yes and the LIB${NAME} and
+dnl LTLIB${NAME} variables and augments the CPPFLAGS variable, and
+dnl #defines HAVE_LIB${NAME} to 1. Otherwise, it sets and AC_SUBSTs
+dnl HAVE_LIB${NAME}=no and LIB${NAME} and LTLIB${NAME} to empty.
+dnl Sets and AC_SUBSTs the LIB${NAME}_PREFIX variable to nonempty if libname
+dnl was found in ${LIB${NAME}_PREFIX}/$acl_libdirstem.
+AC_DEFUN([AC_LIB_HAVE_LINKFLAGS],
+[
+  AC_REQUIRE([AC_LIB_PREPARE_PREFIX])
+  AC_REQUIRE([AC_LIB_RPATH])
+  define([Name],[translit([$1],[./-], [___])])
+  define([NAME],[translit([$1],[abcdefghijklmnopqrstuvwxyz./-],
+                               [ABCDEFGHIJKLMNOPQRSTUVWXYZ___])])
+
+  dnl Search for lib[]Name and define LIB[]NAME, LTLIB[]NAME and INC[]NAME
+  dnl accordingly.
+  AC_LIB_LINKFLAGS_BODY([$1], [$2])
+
+  dnl Add $INC[]NAME to CPPFLAGS before performing the following checks,
+  dnl because if the user has installed lib[]Name and not disabled its use
+  dnl via --without-lib[]Name-prefix, he wants to use it.
+  ac_save_CPPFLAGS="$CPPFLAGS"
+  AC_LIB_APPENDTOVAR([CPPFLAGS], [$INC]NAME)
+
+  AC_CACHE_CHECK([for lib[]$1], [ac_cv_lib[]Name], [
+    ac_save_LIBS="$LIBS"
+    LIBS="$LIBS $LIB[]NAME"
+    AC_TRY_LINK([$3], [$4], [ac_cv_lib[]Name=yes], [ac_cv_lib[]Name=no])
+    LIBS="$ac_save_LIBS"
+  ])
+  if test "$ac_cv_lib[]Name" = yes; then
+    HAVE_LIB[]NAME=yes
+    AC_DEFINE([HAVE_LIB]NAME, 1, [Define if you have the $1 library.])
+    AC_MSG_CHECKING([how to link with lib[]$1])
+    AC_MSG_RESULT([$LIB[]NAME])
+  else
+    HAVE_LIB[]NAME=no
+    dnl If $LIB[]NAME didn't lead to a usable library, we don't need
+    dnl $INC[]NAME either.
+    CPPFLAGS="$ac_save_CPPFLAGS"
+    LIB[]NAME=
+    LTLIB[]NAME=
+    LIB[]NAME[]_PREFIX=
+  fi
+  AC_SUBST([HAVE_LIB]NAME)
+  AC_SUBST([LIB]NAME)
+  AC_SUBST([LTLIB]NAME)
+  AC_SUBST([LIB]NAME[_PREFIX])
+  undefine([Name])
+  undefine([NAME])
+])
+
+dnl Determine the platform dependent parameters needed to use rpath:
+dnl   acl_libext,
+dnl   acl_shlibext,
+dnl   acl_hardcode_libdir_flag_spec,
+dnl   acl_hardcode_libdir_separator,
+dnl   acl_hardcode_direct,
+dnl   acl_hardcode_minus_L.
+AC_DEFUN([AC_LIB_RPATH],
+[
+  dnl Tell automake >= 1.10 to complain if config.rpath is missing.
+  m4_ifdef([AC_REQUIRE_AUX_FILE], [AC_REQUIRE_AUX_FILE([config.rpath])])
+  AC_REQUIRE([AC_PROG_CC])                dnl we use $CC, $GCC, $LDFLAGS
+  AC_REQUIRE([AC_LIB_PROG_LD])            dnl we use $LD, $with_gnu_ld
+  AC_REQUIRE([AC_CANONICAL_HOST])         dnl we use $host
+  AC_REQUIRE([AC_CONFIG_AUX_DIR_DEFAULT]) dnl we use $ac_aux_dir
+  AC_CACHE_CHECK([for shared library run path origin], acl_cv_rpath, [
+    CC="$CC" GCC="$GCC" LDFLAGS="$LDFLAGS" LD="$LD" with_gnu_ld="$with_gnu_ld" \
+    ${CONFIG_SHELL-/bin/sh} "$ac_aux_dir/config.rpath" "$host" > conftest.sh
+    . ./conftest.sh
+    rm -f ./conftest.sh
+    acl_cv_rpath=done
+  ])
+  wl="$acl_cv_wl"
+  acl_libext="$acl_cv_libext"
+  acl_shlibext="$acl_cv_shlibext"
+  acl_libname_spec="$acl_cv_libname_spec"
+  acl_library_names_spec="$acl_cv_library_names_spec"
+  acl_hardcode_libdir_flag_spec="$acl_cv_hardcode_libdir_flag_spec"
+  acl_hardcode_libdir_separator="$acl_cv_hardcode_libdir_separator"
+  acl_hardcode_direct="$acl_cv_hardcode_direct"
+  acl_hardcode_minus_L="$acl_cv_hardcode_minus_L"
+  dnl Determine whether the user wants rpath handling at all.
+  AC_ARG_ENABLE(rpath,
+    [  --disable-rpath         do not hardcode runtime library paths],
+    :, enable_rpath=yes)
+])
+
+dnl AC_LIB_LINKFLAGS_BODY(name [, dependencies]) searches for libname and
+dnl the libraries corresponding to explicit and implicit dependencies.
+dnl Sets the LIB${NAME}, LTLIB${NAME} and INC${NAME} variables.
+dnl Also, sets the LIB${NAME}_PREFIX variable to nonempty if libname was found
+dnl in ${LIB${NAME}_PREFIX}/$acl_libdirstem.
+AC_DEFUN([AC_LIB_LINKFLAGS_BODY],
+[
+  AC_REQUIRE([AC_LIB_PREPARE_MULTILIB])
+  define([NAME],[translit([$1],[abcdefghijklmnopqrstuvwxyz./-],
+                               [ABCDEFGHIJKLMNOPQRSTUVWXYZ___])])
+  dnl Autoconf >= 2.61 supports dots in --with options.
+  define([N_A_M_E],[m4_if(m4_version_compare(m4_defn([m4_PACKAGE_VERSION]),[2.61]),[-1],[translit([$1],[.],[_])],[$1])])
+  dnl By default, look in $includedir and $libdir.
+  use_additional=yes
+  AC_LIB_WITH_FINAL_PREFIX([
+    eval additional_includedir=\"$includedir\"
+    eval additional_libdir=\"$libdir\"
+  ])
+  AC_LIB_ARG_WITH([lib]N_A_M_E[-prefix],
+[  --with-lib]N_A_M_E[-prefix[=DIR]  search for lib$1 in DIR/include and DIR/lib
+  --without-lib]N_A_M_E[-prefix     don't search for lib$1 in includedir and libdir],
+[
+    if test "X$withval" = "Xno"; then
+      use_additional=no
+    else
+      if test "X$withval" = "X"; then
+        AC_LIB_WITH_FINAL_PREFIX([
+          eval additional_includedir=\"$includedir\"
+          eval additional_libdir=\"$libdir\"
+        ])
+      else
+        additional_includedir="$withval/include"
+        additional_libdir="$withval/$acl_libdirstem"
+      fi
+    fi
+])
+  dnl Search the library and its dependencies in $additional_libdir and
+  dnl $LDFLAGS. Using breadth-first-seach.
+  LIB[]NAME=
+  LTLIB[]NAME=
+  INC[]NAME=
+  LIB[]NAME[]_PREFIX=
+  rpathdirs=
+  ltrpathdirs=
+  names_already_handled=
+  names_next_round='$1 $2'
+  while test -n "$names_next_round"; do
+    names_this_round="$names_next_round"
+    names_next_round=
+    for name in $names_this_round; do
+      already_handled=
+      for n in $names_already_handled; do
+        if test "$n" = "$name"; then
+          already_handled=yes
+          break
+        fi
+      done
+      if test -z "$already_handled"; then
+        names_already_handled="$names_already_handled $name"
+        dnl See if it was already located by an earlier AC_LIB_LINKFLAGS
+        dnl or AC_LIB_HAVE_LINKFLAGS call.
+        uppername=`echo "$name" | sed -e 'y|abcdefghijklmnopqrstuvwxyz./-|ABCDEFGHIJKLMNOPQRSTUVWXYZ___|'`
+        eval value=\"\$HAVE_LIB$uppername\"
+        if test -n "$value"; then
+          if test "$value" = yes; then
+            eval value=\"\$LIB$uppername\"
+            test -z "$value" || LIB[]NAME="${LIB[]NAME}${LIB[]NAME:+ }$value"
+            eval value=\"\$LTLIB$uppername\"
+            test -z "$value" || LTLIB[]NAME="${LTLIB[]NAME}${LTLIB[]NAME:+ }$value"
+          else
+            dnl An earlier call to AC_LIB_HAVE_LINKFLAGS has determined
+            dnl that this library doesn't exist. So just drop it.
+            :
+          fi
+        else
+          dnl Search the library lib$name in $additional_libdir and $LDFLAGS
+          dnl and the already constructed $LIBNAME/$LTLIBNAME.
+          found_dir=
+          found_la=
+          found_so=
+          found_a=
+          eval libname=\"$acl_libname_spec\"    # typically: libname=lib$name
+          if test -n "$acl_shlibext"; then
+            shrext=".$acl_shlibext"             # typically: shrext=.so
+          else
+            shrext=
+          fi
+          if test $use_additional = yes; then
+            dir="$additional_libdir"
+            dnl The same code as in the loop below:
+            dnl First look for a shared library.
+            if test -n "$acl_shlibext"; then
+              if test -f "$dir/$libname$shrext"; then
+                found_dir="$dir"
+                found_so="$dir/$libname$shrext"
+              else
+                if test "$acl_library_names_spec" = '$libname$shrext$versuffix'; then
+                  ver=`(cd "$dir" && \
+                        for f in "$libname$shrext".*; do echo "$f"; done \
+                        | sed -e "s,^$libname$shrext\\\\.,," \
+                        | sort -t '.' -n -r -k1,1 -k2,2 -k3,3 -k4,4 -k5,5 \
+                        | sed 1q ) 2>/dev/null`
+                  if test -n "$ver" && test -f "$dir/$libname$shrext.$ver"; then
+                    found_dir="$dir"
+                    found_so="$dir/$libname$shrext.$ver"
+                  fi
+                else
+                  eval library_names=\"$acl_library_names_spec\"
+                  for f in $library_names; do
+                    if test -f "$dir/$f"; then
+                      found_dir="$dir"
+                      found_so="$dir/$f"
+                      break
+                    fi
+                  done
+                fi
+              fi
+            fi
+            dnl Then look for a static library.
+            if test "X$found_dir" = "X"; then
+              if test -f "$dir/$libname.$acl_libext"; then
+                found_dir="$dir"
+                found_a="$dir/$libname.$acl_libext"
+              fi
+            fi
+            if test "X$found_dir" != "X"; then
+              if test -f "$dir/$libname.la"; then
+                found_la="$dir/$libname.la"
+              fi
+            fi
+          fi
+          if test "X$found_dir" = "X"; then
+            for x in $LDFLAGS $LTLIB[]NAME; do
+              AC_LIB_WITH_FINAL_PREFIX([eval x=\"$x\"])
+              case "$x" in
+                -L*)
+                  dir=`echo "X$x" | sed -e 's/^X-L//'`
+                  dnl First look for a shared library.
+                  if test -n "$acl_shlibext"; then
+                    if test -f "$dir/$libname$shrext"; then
+                      found_dir="$dir"
+                      found_so="$dir/$libname$shrext"
+                    else
+                      if test "$acl_library_names_spec" = '$libname$shrext$versuffix'; then
+                        ver=`(cd "$dir" && \
+                              for f in "$libname$shrext".*; do echo "$f"; done \
+                              | sed -e "s,^$libname$shrext\\\\.,," \
+                              | sort -t '.' -n -r -k1,1 -k2,2 -k3,3 -k4,4 -k5,5 \
+                              | sed 1q ) 2>/dev/null`
+                        if test -n "$ver" && test -f "$dir/$libname$shrext.$ver"; then
+                          found_dir="$dir"
+                          found_so="$dir/$libname$shrext.$ver"
+                        fi
+                      else
+                        eval library_names=\"$acl_library_names_spec\"
+                        for f in $library_names; do
+                          if test -f "$dir/$f"; then
+                            found_dir="$dir"
+                            found_so="$dir/$f"
+                            break
+                          fi
+                        done
+                      fi
+                    fi
+                  fi
+                  dnl Then look for a static library.
+                  if test "X$found_dir" = "X"; then
+                    if test -f "$dir/$libname.$acl_libext"; then
+                      found_dir="$dir"
+                      found_a="$dir/$libname.$acl_libext"
+                    fi
+                  fi
+                  if test "X$found_dir" != "X"; then
+                    if test -f "$dir/$libname.la"; then
+                      found_la="$dir/$libname.la"
+                    fi
+                  fi
+                  ;;
+              esac
+              if test "X$found_dir" != "X"; then
+                break
+              fi
+            done
+          fi
+          if test "X$found_dir" != "X"; then
+            dnl Found the library.
+            LTLIB[]NAME="${LTLIB[]NAME}${LTLIB[]NAME:+ }-L$found_dir -l$name"
+            if test "X$found_so" != "X"; then
+              dnl Linking with a shared library. We attempt to hardcode its
+              dnl directory into the executable's runpath, unless it's the
+              dnl standard /usr/lib.
+              if test "$enable_rpath" = no || test "X$found_dir" = "X/usr/$acl_libdirstem"; then
+                dnl No hardcoding is needed.
+                LIB[]NAME="${LIB[]NAME}${LIB[]NAME:+ }$found_so"
+              else
+                dnl Use an explicit option to hardcode DIR into the resulting
+                dnl binary.
+                dnl Potentially add DIR to ltrpathdirs.
+                dnl The ltrpathdirs will be appended to $LTLIBNAME at the end.
+                haveit=
+                for x in $ltrpathdirs; do
+                  if test "X$x" = "X$found_dir"; then
+                    haveit=yes
+                    break
+                  fi
+                done
+                if test -z "$haveit"; then
+                  ltrpathdirs="$ltrpathdirs $found_dir"
+                fi
+                dnl The hardcoding into $LIBNAME is system dependent.
+                if test "$acl_hardcode_direct" = yes; then
+                  dnl Using DIR/libNAME.so during linking hardcodes DIR into the
+                  dnl resulting binary.
+                  LIB[]NAME="${LIB[]NAME}${LIB[]NAME:+ }$found_so"
+                else
+                  if test -n "$acl_hardcode_libdir_flag_spec" && test "$acl_hardcode_minus_L" = no; then
+                    dnl Use an explicit option to hardcode DIR into the resulting
+                    dnl binary.
+                    LIB[]NAME="${LIB[]NAME}${LIB[]NAME:+ }$found_so"
+                    dnl Potentially add DIR to rpathdirs.
+                    dnl The rpathdirs will be appended to $LIBNAME at the end.
+                    haveit=
+                    for x in $rpathdirs; do
+                      if test "X$x" = "X$found_dir"; then
+                        haveit=yes
+                        break
+                      fi
+                    done
+                    if test -z "$haveit"; then
+                      rpathdirs="$rpathdirs $found_dir"
+                    fi
+                  else
+                    dnl Rely on "-L$found_dir".
+                    dnl But don't add it if it's already contained in the LDFLAGS
+                    dnl or the already constructed $LIBNAME
+                    haveit=
+                    for x in $LDFLAGS $LIB[]NAME; do
+                      AC_LIB_WITH_FINAL_PREFIX([eval x=\"$x\"])
+                      if test "X$x" = "X-L$found_dir"; then
+                        haveit=yes
+                        break
+                      fi
+                    done
+                    if test -z "$haveit"; then
+                      LIB[]NAME="${LIB[]NAME}${LIB[]NAME:+ }-L$found_dir"
+                    fi
+                    if test "$acl_hardcode_minus_L" != no; then
+                      dnl FIXME: Not sure whether we should use
+                      dnl "-L$found_dir -l$name" or "-L$found_dir $found_so"
+                      dnl here.
+                      LIB[]NAME="${LIB[]NAME}${LIB[]NAME:+ }$found_so"
+                    else
+                      dnl We cannot use $acl_hardcode_runpath_var and LD_RUN_PATH
+                      dnl here, because this doesn't fit in flags passed to the
+                      dnl compiler. So give up. No hardcoding. This affects only
+                      dnl very old systems.
+                      dnl FIXME: Not sure whether we should use
+                      dnl "-L$found_dir -l$name" or "-L$found_dir $found_so"
+                      dnl here.
+                      LIB[]NAME="${LIB[]NAME}${LIB[]NAME:+ }-l$name"
+                    fi
+                  fi
+                fi
+              fi
+            else
+              if test "X$found_a" != "X"; then
+                dnl Linking with a static library.
+                LIB[]NAME="${LIB[]NAME}${LIB[]NAME:+ }$found_a"
+              else
+                dnl We shouldn't come here, but anyway it's good to have a
+                dnl fallback.
+                LIB[]NAME="${LIB[]NAME}${LIB[]NAME:+ }-L$found_dir -l$name"
+              fi
+            fi
+            dnl Assume the include files are nearby.
+            additional_includedir=
+            case "$found_dir" in
+              */$acl_libdirstem | */$acl_libdirstem/)
+                basedir=`echo "X$found_dir" | sed -e 's,^X,,' -e "s,/$acl_libdirstem/"'*$,,'`
+                LIB[]NAME[]_PREFIX="$basedir"
+                additional_includedir="$basedir/include"
+                ;;
+            esac
+            if test "X$additional_includedir" != "X"; then
+              dnl Potentially add $additional_includedir to $INCNAME.
+              dnl But don't add it
+              dnl   1. if it's the standard /usr/include,
+              dnl   2. if it's /usr/local/include and we are using GCC on Linux,
+              dnl   3. if it's already present in $CPPFLAGS or the already
+              dnl      constructed $INCNAME,
+              dnl   4. if it doesn't exist as a directory.
+              if test "X$additional_includedir" != "X/usr/include"; then
+                haveit=
+                if test "X$additional_includedir" = "X/usr/local/include"; then
+                  if test -n "$GCC"; then
+                    case $host_os in
+                      linux* | gnu* | k*bsd*-gnu) haveit=yes;;
+                    esac
+                  fi
+                fi
+                if test -z "$haveit"; then
+                  for x in $CPPFLAGS $INC[]NAME; do
+                    AC_LIB_WITH_FINAL_PREFIX([eval x=\"$x\"])
+                    if test "X$x" = "X-I$additional_includedir"; then
+                      haveit=yes
+                      break
+                    fi
+                  done
+                  if test -z "$haveit"; then
+                    if test -d "$additional_includedir"; then
+                      dnl Really add $additional_includedir to $INCNAME.
+                      INC[]NAME="${INC[]NAME}${INC[]NAME:+ }-I$additional_includedir"
+                    fi
+                  fi
+                fi
+              fi
+            fi
+            dnl Look for dependencies.
+            if test -n "$found_la"; then
+              dnl Read the .la file. It defines the variables
+              dnl dlname, library_names, old_library, dependency_libs, current,
+              dnl age, revision, installed, dlopen, dlpreopen, libdir.
+              save_libdir="$libdir"
+              case "$found_la" in
+                */* | *\\*) . "$found_la" ;;
+                *) . "./$found_la" ;;
+              esac
+              libdir="$save_libdir"
+              dnl We use only dependency_libs.
+              for dep in $dependency_libs; do
+                case "$dep" in
+                  -L*)
+                    additional_libdir=`echo "X$dep" | sed -e 's/^X-L//'`
+                    dnl Potentially add $additional_libdir to $LIBNAME and $LTLIBNAME.
+                    dnl But don't add it
+                    dnl   1. if it's the standard /usr/lib,
+                    dnl   2. if it's /usr/local/lib and we are using GCC on Linux,
+                    dnl   3. if it's already present in $LDFLAGS or the already
+                    dnl      constructed $LIBNAME,
+                    dnl   4. if it doesn't exist as a directory.
+                    if test "X$additional_libdir" != "X/usr/$acl_libdirstem"; then
+                      haveit=
+                      if test "X$additional_libdir" = "X/usr/local/$acl_libdirstem"; then
+                        if test -n "$GCC"; then
+                          case $host_os in
+                            linux* | gnu* | k*bsd*-gnu) haveit=yes;;
+                          esac
+                        fi
+                      fi
+                      if test -z "$haveit"; then
+                        haveit=
+                        for x in $LDFLAGS $LIB[]NAME; do
+                          AC_LIB_WITH_FINAL_PREFIX([eval x=\"$x\"])
+                          if test "X$x" = "X-L$additional_libdir"; then
+                            haveit=yes
+                            break
+                          fi
+                        done
+                        if test -z "$haveit"; then
+                          if test -d "$additional_libdir"; then
+                            dnl Really add $additional_libdir to $LIBNAME.
+                            LIB[]NAME="${LIB[]NAME}${LIB[]NAME:+ }-L$additional_libdir"
+                          fi
+                        fi
+                        haveit=
+                        for x in $LDFLAGS $LTLIB[]NAME; do
+                          AC_LIB_WITH_FINAL_PREFIX([eval x=\"$x\"])
+                          if test "X$x" = "X-L$additional_libdir"; then
+                            haveit=yes
+                            break
+                          fi
+                        done
+                        if test -z "$haveit"; then
+                          if test -d "$additional_libdir"; then
+                            dnl Really add $additional_libdir to $LTLIBNAME.
+                            LTLIB[]NAME="${LTLIB[]NAME}${LTLIB[]NAME:+ }-L$additional_libdir"
+                          fi
+                        fi
+                      fi
+                    fi
+                    ;;
+                  -R*)
+                    dir=`echo "X$dep" | sed -e 's/^X-R//'`
+                    if test "$enable_rpath" != no; then
+                      dnl Potentially add DIR to rpathdirs.
+                      dnl The rpathdirs will be appended to $LIBNAME at the end.
+                      haveit=
+                      for x in $rpathdirs; do
+                        if test "X$x" = "X$dir"; then
+                          haveit=yes
+                          break
+                        fi
+                      done
+                      if test -z "$haveit"; then
+                        rpathdirs="$rpathdirs $dir"
+                      fi
+                      dnl Potentially add DIR to ltrpathdirs.
+                      dnl The ltrpathdirs will be appended to $LTLIBNAME at the end.
+                      haveit=
+                      for x in $ltrpathdirs; do
+                        if test "X$x" = "X$dir"; then
+                          haveit=yes
+                          break
+                        fi
+                      done
+                      if test -z "$haveit"; then
+                        ltrpathdirs="$ltrpathdirs $dir"
+                      fi
+                    fi
+                    ;;
+                  -l*)
+                    dnl Handle this in the next round.
+                    names_next_round="$names_next_round "`echo "X$dep" | sed -e 's/^X-l//'`
+                    ;;
+                  *.la)
+                    dnl Handle this in the next round. Throw away the .la's
+                    dnl directory; it is already contained in a preceding -L
+                    dnl option.
+                    names_next_round="$names_next_round "`echo "X$dep" | sed -e 's,^X.*/,,' -e 's,^lib,,' -e 's,\.la$,,'`
+                    ;;
+                  *)
+                    dnl Most likely an immediate library name.
+                    LIB[]NAME="${LIB[]NAME}${LIB[]NAME:+ }$dep"
+                    LTLIB[]NAME="${LTLIB[]NAME}${LTLIB[]NAME:+ }$dep"
+                    ;;
+                esac
+              done
+            fi
+          else
+            dnl Didn't find the library; assume it is in the system directories
+            dnl known to the linker and runtime loader. (All the system
+            dnl directories known to the linker should also be known to the
+            dnl runtime loader, otherwise the system is severely misconfigured.)
+            LIB[]NAME="${LIB[]NAME}${LIB[]NAME:+ }-l$name"
+            LTLIB[]NAME="${LTLIB[]NAME}${LTLIB[]NAME:+ }-l$name"
+          fi
+        fi
+      fi
+    done
+  done
+  if test "X$rpathdirs" != "X"; then
+    if test -n "$acl_hardcode_libdir_separator"; then
+      dnl Weird platform: only the last -rpath option counts, the user must
+      dnl pass all path elements in one option. We can arrange that for a
+      dnl single library, but not when more than one $LIBNAMEs are used.
+      alldirs=
+      for found_dir in $rpathdirs; do
+        alldirs="${alldirs}${alldirs:+$acl_hardcode_libdir_separator}$found_dir"
+      done
+      dnl Note: acl_hardcode_libdir_flag_spec uses $libdir and $wl.
+      acl_save_libdir="$libdir"
+      libdir="$alldirs"
+      eval flag=\"$acl_hardcode_libdir_flag_spec\"
+      libdir="$acl_save_libdir"
+      LIB[]NAME="${LIB[]NAME}${LIB[]NAME:+ }$flag"
+    else
+      dnl The -rpath options are cumulative.
+      for found_dir in $rpathdirs; do
+        acl_save_libdir="$libdir"
+        libdir="$found_dir"
+        eval flag=\"$acl_hardcode_libdir_flag_spec\"
+        libdir="$acl_save_libdir"
+        LIB[]NAME="${LIB[]NAME}${LIB[]NAME:+ }$flag"
+      done
+    fi
+  fi
+  if test "X$ltrpathdirs" != "X"; then
+    dnl When using libtool, the option that works for both libraries and
+    dnl executables is -R. The -R options are cumulative.
+    for found_dir in $ltrpathdirs; do
+      LTLIB[]NAME="${LTLIB[]NAME}${LTLIB[]NAME:+ }-R$found_dir"
+    done
+  fi
+])
+
+dnl AC_LIB_APPENDTOVAR(VAR, CONTENTS) appends the elements of CONTENTS to VAR,
+dnl unless already present in VAR.
+dnl Works only for CPPFLAGS, not for LIB* variables because that sometimes
+dnl contains two or three consecutive elements that belong together.
+AC_DEFUN([AC_LIB_APPENDTOVAR],
+[
+  for element in [$2]; do
+    haveit=
+    for x in $[$1]; do
+      AC_LIB_WITH_FINAL_PREFIX([eval x=\"$x\"])
+      if test "X$x" = "X$element"; then
+        haveit=yes
+        break
+      fi
+    done
+    if test -z "$haveit"; then
+      [$1]="${[$1]}${[$1]:+ }$element"
+    fi
+  done
+])
+
+dnl For those cases where a variable contains several -L and -l options
+dnl referring to unknown libraries and directories, this macro determines the
+dnl necessary additional linker options for the runtime path.
+dnl AC_LIB_LINKFLAGS_FROM_LIBS([LDADDVAR], [LIBSVALUE], [USE-LIBTOOL])
+dnl sets LDADDVAR to linker options needed together with LIBSVALUE.
+dnl If USE-LIBTOOL evaluates to non-empty, linking with libtool is assumed,
+dnl otherwise linking without libtool is assumed.
+AC_DEFUN([AC_LIB_LINKFLAGS_FROM_LIBS],
+[
+  AC_REQUIRE([AC_LIB_RPATH])
+  AC_REQUIRE([AC_LIB_PREPARE_MULTILIB])
+  $1=
+  if test "$enable_rpath" != no; then
+    if test -n "$acl_hardcode_libdir_flag_spec" && test "$acl_hardcode_minus_L" = no; then
+      dnl Use an explicit option to hardcode directories into the resulting
+      dnl binary.
+      rpathdirs=
+      next=
+      for opt in $2; do
+        if test -n "$next"; then
+          dir="$next"
+          dnl No need to hardcode the standard /usr/lib.
+          if test "X$dir" != "X/usr/$acl_libdirstem"; then
+            rpathdirs="$rpathdirs $dir"
+          fi
+          next=
+        else
+          case $opt in
+            -L) next=yes ;;
+            -L*) dir=`echo "X$opt" | sed -e 's,^X-L,,'`
+                 dnl No need to hardcode the standard /usr/lib.
+                 if test "X$dir" != "X/usr/$acl_libdirstem"; then
+                   rpathdirs="$rpathdirs $dir"
+                 fi
+                 next= ;;
+            *) next= ;;
+          esac
+        fi
+      done
+      if test "X$rpathdirs" != "X"; then
+        if test -n ""$3""; then
+          dnl libtool is used for linking. Use -R options.
+          for dir in $rpathdirs; do
+            $1="${$1}${$1:+ }-R$dir"
+          done
+        else
+          dnl The linker is used for linking directly.
+          if test -n "$acl_hardcode_libdir_separator"; then
+            dnl Weird platform: only the last -rpath option counts, the user
+            dnl must pass all path elements in one option.
+            alldirs=
+            for dir in $rpathdirs; do
+              alldirs="${alldirs}${alldirs:+$acl_hardcode_libdir_separator}$dir"
+            done
+            acl_save_libdir="$libdir"
+            libdir="$alldirs"
+            eval flag=\"$acl_hardcode_libdir_flag_spec\"
+            libdir="$acl_save_libdir"
+            $1="$flag"
+          else
+            dnl The -rpath options are cumulative.
+            for dir in $rpathdirs; do
+              acl_save_libdir="$libdir"
+              libdir="$dir"
+              eval flag=\"$acl_hardcode_libdir_flag_spec\"
+              libdir="$acl_save_libdir"
+              $1="${$1}${$1:+ }$flag"
+            done
+          fi
+        fi
+      fi
+    fi
+  fi
+  AC_SUBST([$1])
+])
--- /dev/null
+++ b/m4/lib-prefix.m4
@@ -0,0 +1,185 @@
+# lib-prefix.m4 serial 5 (gettext-0.15)
+dnl Copyright (C) 2001-2005 Free Software Foundation, Inc.
+dnl This file is free software; the Free Software Foundation
+dnl gives unlimited permission to copy and/or distribute it,
+dnl with or without modifications, as long as this notice is preserved.
+
+dnl From Bruno Haible.
+
+dnl AC_LIB_ARG_WITH is synonymous to AC_ARG_WITH in autoconf-2.13, and
+dnl similar to AC_ARG_WITH in autoconf 2.52...2.57 except that is doesn't
+dnl require excessive bracketing.
+ifdef([AC_HELP_STRING],
+[AC_DEFUN([AC_LIB_ARG_WITH], [AC_ARG_WITH([$1],[[$2]],[$3],[$4])])],
+[AC_DEFUN([AC_][LIB_ARG_WITH], [AC_ARG_WITH([$1],[$2],[$3],[$4])])])
+
+dnl AC_LIB_PREFIX adds to the CPPFLAGS and LDFLAGS the flags that are needed
+dnl to access previously installed libraries. The basic assumption is that
+dnl a user will want packages to use other packages he previously installed
+dnl with the same --prefix option.
+dnl This macro is not needed if only AC_LIB_LINKFLAGS is used to locate
+dnl libraries, but is otherwise very convenient.
+AC_DEFUN([AC_LIB_PREFIX],
+[
+  AC_BEFORE([$0], [AC_LIB_LINKFLAGS])
+  AC_REQUIRE([AC_PROG_CC])
+  AC_REQUIRE([AC_CANONICAL_HOST])
+  AC_REQUIRE([AC_LIB_PREPARE_MULTILIB])
+  AC_REQUIRE([AC_LIB_PREPARE_PREFIX])
+  dnl By default, look in $includedir and $libdir.
+  use_additional=yes
+  AC_LIB_WITH_FINAL_PREFIX([
+    eval additional_includedir=\"$includedir\"
+    eval additional_libdir=\"$libdir\"
+  ])
+  AC_LIB_ARG_WITH([lib-prefix],
+[  --with-lib-prefix[=DIR] search for libraries in DIR/include and DIR/lib
+  --without-lib-prefix    don't search for libraries in includedir and libdir],
+[
+    if test "X$withval" = "Xno"; then
+      use_additional=no
+    else
+      if test "X$withval" = "X"; then
+        AC_LIB_WITH_FINAL_PREFIX([
+          eval additional_includedir=\"$includedir\"
+          eval additional_libdir=\"$libdir\"
+        ])
+      else
+        additional_includedir="$withval/include"
+        additional_libdir="$withval/$acl_libdirstem"
+      fi
+    fi
+])
+  if test $use_additional = yes; then
+    dnl Potentially add $additional_includedir to $CPPFLAGS.
+    dnl But don't add it
+    dnl   1. if it's the standard /usr/include,
+    dnl   2. if it's already present in $CPPFLAGS,
+    dnl   3. if it's /usr/local/include and we are using GCC on Linux,
+    dnl   4. if it doesn't exist as a directory.
+    if test "X$additional_includedir" != "X/usr/include"; then
+      haveit=
+      for x in $CPPFLAGS; do
+        AC_LIB_WITH_FINAL_PREFIX([eval x=\"$x\"])
+        if test "X$x" = "X-I$additional_includedir"; then
+          haveit=yes
+          break
+        fi
+      done
+      if test -z "$haveit"; then
+        if test "X$additional_includedir" = "X/usr/local/include"; then
+          if test -n "$GCC"; then
+            case $host_os in
+              linux* | gnu* | k*bsd*-gnu) haveit=yes;;
+            esac
+          fi
+        fi
+        if test -z "$haveit"; then
+          if test -d "$additional_includedir"; then
+            dnl Really add $additional_includedir to $CPPFLAGS.
+            CPPFLAGS="${CPPFLAGS}${CPPFLAGS:+ }-I$additional_includedir"
+          fi
+        fi
+      fi
+    fi
+    dnl Potentially add $additional_libdir to $LDFLAGS.
+    dnl But don't add it
+    dnl   1. if it's the standard /usr/lib,
+    dnl   2. if it's already present in $LDFLAGS,
+    dnl   3. if it's /usr/local/lib and we are using GCC on Linux,
+    dnl   4. if it doesn't exist as a directory.
+    if test "X$additional_libdir" != "X/usr/$acl_libdirstem"; then
+      haveit=
+      for x in $LDFLAGS; do
+        AC_LIB_WITH_FINAL_PREFIX([eval x=\"$x\"])
+        if test "X$x" = "X-L$additional_libdir"; then
+          haveit=yes
+          break
+        fi
+      done
+      if test -z "$haveit"; then
+        if test "X$additional_libdir" = "X/usr/local/$acl_libdirstem"; then
+          if test -n "$GCC"; then
+            case $host_os in
+              linux*) haveit=yes;;
+            esac
+          fi
+        fi
+        if test -z "$haveit"; then
+          if test -d "$additional_libdir"; then
+            dnl Really add $additional_libdir to $LDFLAGS.
+            LDFLAGS="${LDFLAGS}${LDFLAGS:+ }-L$additional_libdir"
+          fi
+        fi
+      fi
+    fi
+  fi
+])
+
+dnl AC_LIB_PREPARE_PREFIX creates variables acl_final_prefix,
+dnl acl_final_exec_prefix, containing the values to which $prefix and
+dnl $exec_prefix will expand at the end of the configure script.
+AC_DEFUN([AC_LIB_PREPARE_PREFIX],
+[
+  dnl Unfortunately, prefix and exec_prefix get only finally determined
+  dnl at the end of configure.
+  if test "X$prefix" = "XNONE"; then
+    acl_final_prefix="$ac_default_prefix"
+  else
+    acl_final_prefix="$prefix"
+  fi
+  if test "X$exec_prefix" = "XNONE"; then
+    acl_final_exec_prefix='${prefix}'
+  else
+    acl_final_exec_prefix="$exec_prefix"
+  fi
+  acl_save_prefix="$prefix"
+  prefix="$acl_final_prefix"
+  eval acl_final_exec_prefix=\"$acl_final_exec_prefix\"
+  prefix="$acl_save_prefix"
+])
+
+dnl AC_LIB_WITH_FINAL_PREFIX([statement]) evaluates statement, with the
+dnl variables prefix and exec_prefix bound to the values they will have
+dnl at the end of the configure script.
+AC_DEFUN([AC_LIB_WITH_FINAL_PREFIX],
+[
+  acl_save_prefix="$prefix"
+  prefix="$acl_final_prefix"
+  acl_save_exec_prefix="$exec_prefix"
+  exec_prefix="$acl_final_exec_prefix"
+  $1
+  exec_prefix="$acl_save_exec_prefix"
+  prefix="$acl_save_prefix"
+])
+
+dnl AC_LIB_PREPARE_MULTILIB creates a variable acl_libdirstem, containing
+dnl the basename of the libdir, either "lib" or "lib64".
+AC_DEFUN([AC_LIB_PREPARE_MULTILIB],
+[
+  dnl There is no formal standard regarding lib and lib64. The current
+  dnl practice is that on a system supporting 32-bit and 64-bit instruction
+  dnl sets or ABIs, 64-bit libraries go under $prefix/lib64 and 32-bit
+  dnl libraries go under $prefix/lib. We determine the compiler's default
+  dnl mode by looking at the compiler's library search path. If at least
+  dnl of its elements ends in /lib64 or points to a directory whose absolute
+  dnl pathname ends in /lib64, we assume a 64-bit ABI. Otherwise we use the
+  dnl default, namely "lib".
+  acl_libdirstem=lib
+  searchpath=`(LC_ALL=C $CC -print-search-dirs) 2>/dev/null | sed -n -e 's,^libraries: ,,p' | sed -e 's,^=,,'`
+  if test -n "$searchpath"; then
+    acl_save_IFS="${IFS= 	}"; IFS=":"
+    for searchdir in $searchpath; do
+      if test -d "$searchdir"; then
+        case "$searchdir" in
+          */lib64/ | */lib64 ) acl_libdirstem=lib64 ;;
+          *) searchdir=`cd "$searchdir" && pwd`
+             case "$searchdir" in
+               */lib64 ) acl_libdirstem=lib64 ;;
+             esac ;;
+        esac
+      fi
+    done
+    IFS="$acl_save_IFS"
+  fi
+])
--- a/m4/libtool.m4
+++ b/m4/libtool.m4
@@ -2485,6 +2485,18 @@ linux* | k*bsd*-gnu)
   dynamic_linker='GNU/Linux ld.so'
   ;;
 
+netbsdelf*-gnu)
+  version_type=linux
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major ${libname}${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=no
+  hardcode_into_libs=yes
+  dynamic_linker='NetBSD ld.elf_so'
+  ;;
+
 netbsd*)
   version_type=sunos
   need_lib_prefix=no
@@ -3076,7 +3088,7 @@ linux* | k*bsd*-gnu)
   lt_cv_deplibs_check_method=pass_all
   ;;
 
-netbsd*)
+netbsd* | netbsdelf*-gnu)
   if echo __ELF__ | $CC -E - | $GREP __ELF__ > /dev/null; then
     lt_cv_deplibs_check_method='match_pattern /lib[[^/]]+(\.so\.[[0-9]]+\.[[0-9]]+|_pic\.a)$'
   else
@@ -3757,7 +3769,7 @@ m4_if([$1], [CXX], [
 	    ;;
 	esac
 	;;
-      netbsd*)
+      netbsd* | netbsdelf*-gnu)
 	;;
       *qnx* | *nto*)
         # QNX uses GNU C++, but need to define -shared option too, otherwise
@@ -4182,6 +4194,9 @@ m4_if([$1], [CXX], [
   cygwin* | mingw* | cegcc*)
     _LT_TAGVAR(export_symbols_cmds, $1)='$NM $libobjs $convenience | $global_symbol_pipe | $SED -e '\''/^[[BCDGRS]][[ ]]/s/.*[[ ]]\([[^ ]]*\)/\1 DATA/;/^.*[[ ]]__nm__/s/^.*[[ ]]__nm__\([[^ ]]*\)[[ ]][[^ ]]*/\1 DATA/;/^I[[ ]]/d;/^[[AITW]][[ ]]/s/.* //'\'' | sort | uniq > $export_symbols'
   ;;
+  linux* | k*bsd*-gnu)
+    _LT_TAGVAR(link_all_deplibs, $1)=no
+  ;;
   *)
     _LT_TAGVAR(export_symbols_cmds, $1)='$NM $libobjs $convenience | $global_symbol_pipe | $SED '\''s/.* //'\'' | sort | uniq > $export_symbols'
   ;;
@@ -4428,7 +4443,7 @@ _LT_EOF
       fi
       ;;
 
-    netbsd*)
+    netbsd* | netbsdelf*-gnu)
       if echo __ELF__ | $CC -E - | $GREP __ELF__ >/dev/null; then
 	_LT_TAGVAR(archive_cmds, $1)='$LD -Bshareable $libobjs $deplibs $linker_flags -o $lib'
 	wlarc=
@@ -4603,6 +4618,7 @@ _LT_EOF
 	if test "$aix_use_runtimelinking" = yes; then
 	  shared_flag="$shared_flag "'${wl}-G'
 	fi
+	_LT_TAGVAR(link_all_deplibs, $1)=no
       else
 	# not using gcc
 	if test "$host_cpu" = ia64; then
@@ -4841,7 +4857,7 @@ _LT_EOF
       _LT_TAGVAR(link_all_deplibs, $1)=yes
       ;;
 
-    netbsd*)
+    netbsd* | netbsdelf*-gnu)
       if echo __ELF__ | $CC -E - | $GREP __ELF__ >/dev/null; then
 	_LT_TAGVAR(archive_cmds, $1)='$LD -Bshareable -o $lib $libobjs $deplibs $linker_flags'  # a.out
       else
--- /dev/null
+++ b/m4/nls.m4
@@ -0,0 +1,31 @@
+# nls.m4 serial 3 (gettext-0.15)
+dnl Copyright (C) 1995-2003, 2005-2006 Free Software Foundation, Inc.
+dnl This file is free software; the Free Software Foundation
+dnl gives unlimited permission to copy and/or distribute it,
+dnl with or without modifications, as long as this notice is preserved.
+dnl
+dnl This file can can be used in projects which are not available under
+dnl the GNU General Public License or the GNU Library General Public
+dnl License but which still want to provide support for the GNU gettext
+dnl functionality.
+dnl Please note that the actual code of the GNU gettext library is covered
+dnl by the GNU Library General Public License, and the rest of the GNU
+dnl gettext package package is covered by the GNU General Public License.
+dnl They are *not* in the public domain.
+
+dnl Authors:
+dnl   Ulrich Drepper <drepper@cygnus.com>, 1995-2000.
+dnl   Bruno Haible <haible@clisp.cons.org>, 2000-2003.
+
+AC_PREREQ(2.50)
+
+AC_DEFUN([AM_NLS],
+[
+  AC_MSG_CHECKING([whether NLS is requested])
+  dnl Default is enabled NLS
+  AC_ARG_ENABLE(nls,
+    [  --disable-nls           do not use Native Language Support],
+    USE_NLS=$enableval, USE_NLS=yes)
+  AC_MSG_RESULT($USE_NLS)
+  AC_SUBST(USE_NLS)
+])
--- /dev/null
+++ b/m4/po.m4
@@ -0,0 +1,449 @@
+# po.m4 serial 15 (gettext-0.17)
+dnl Copyright (C) 1995-2007 Free Software Foundation, Inc.
+dnl This file is free software; the Free Software Foundation
+dnl gives unlimited permission to copy and/or distribute it,
+dnl with or without modifications, as long as this notice is preserved.
+dnl
+dnl This file can can be used in projects which are not available under
+dnl the GNU General Public License or the GNU Library General Public
+dnl License but which still want to provide support for the GNU gettext
+dnl functionality.
+dnl Please note that the actual code of the GNU gettext library is covered
+dnl by the GNU Library General Public License, and the rest of the GNU
+dnl gettext package package is covered by the GNU General Public License.
+dnl They are *not* in the public domain.
+
+dnl Authors:
+dnl   Ulrich Drepper <drepper@cygnus.com>, 1995-2000.
+dnl   Bruno Haible <haible@clisp.cons.org>, 2000-2003.
+
+AC_PREREQ(2.50)
+
+dnl Checks for all prerequisites of the po subdirectory.
+AC_DEFUN([AM_PO_SUBDIRS],
+[
+  AC_REQUIRE([AC_PROG_MAKE_SET])dnl
+  AC_REQUIRE([AC_PROG_INSTALL])dnl
+  AC_REQUIRE([AM_PROG_MKDIR_P])dnl defined by automake
+  AC_REQUIRE([AM_NLS])dnl
+
+  dnl Release version of the gettext macros. This is used to ensure that
+  dnl the gettext macros and po/Makefile.in.in are in sync.
+  AC_SUBST([GETTEXT_MACRO_VERSION], [0.17])
+
+  dnl Perform the following tests also if --disable-nls has been given,
+  dnl because they are needed for "make dist" to work.
+
+  dnl Search for GNU msgfmt in the PATH.
+  dnl The first test excludes Solaris msgfmt and early GNU msgfmt versions.
+  dnl The second test excludes FreeBSD msgfmt.
+  AM_PATH_PROG_WITH_TEST(MSGFMT, msgfmt,
+    [$ac_dir/$ac_word --statistics /dev/null >&]AS_MESSAGE_LOG_FD[ 2>&1 &&
+     (if $ac_dir/$ac_word --statistics /dev/null 2>&1 >/dev/null | grep usage >/dev/null; then exit 1; else exit 0; fi)],
+    :)
+  AC_PATH_PROG(GMSGFMT, gmsgfmt, $MSGFMT)
+
+  dnl Test whether it is GNU msgfmt >= 0.15.
+changequote(,)dnl
+  case `$MSGFMT --version | sed 1q | sed -e 's,^[^0-9]*,,'` in
+    '' | 0.[0-9] | 0.[0-9].* | 0.1[0-4] | 0.1[0-4].*) MSGFMT_015=: ;;
+    *) MSGFMT_015=$MSGFMT ;;
+  esac
+changequote([,])dnl
+  AC_SUBST([MSGFMT_015])
+changequote(,)dnl
+  case `$GMSGFMT --version | sed 1q | sed -e 's,^[^0-9]*,,'` in
+    '' | 0.[0-9] | 0.[0-9].* | 0.1[0-4] | 0.1[0-4].*) GMSGFMT_015=: ;;
+    *) GMSGFMT_015=$GMSGFMT ;;
+  esac
+changequote([,])dnl
+  AC_SUBST([GMSGFMT_015])
+
+  dnl Search for GNU xgettext 0.12 or newer in the PATH.
+  dnl The first test excludes Solaris xgettext and early GNU xgettext versions.
+  dnl The second test excludes FreeBSD xgettext.
+  AM_PATH_PROG_WITH_TEST(XGETTEXT, xgettext,
+    [$ac_dir/$ac_word --omit-header --copyright-holder= --msgid-bugs-address= /dev/null >&]AS_MESSAGE_LOG_FD[ 2>&1 &&
+     (if $ac_dir/$ac_word --omit-header --copyright-holder= --msgid-bugs-address= /dev/null 2>&1 >/dev/null | grep usage >/dev/null; then exit 1; else exit 0; fi)],
+    :)
+  dnl Remove leftover from FreeBSD xgettext call.
+  rm -f messages.po
+
+  dnl Test whether it is GNU xgettext >= 0.15.
+changequote(,)dnl
+  case `$XGETTEXT --version | sed 1q | sed -e 's,^[^0-9]*,,'` in
+    '' | 0.[0-9] | 0.[0-9].* | 0.1[0-4] | 0.1[0-4].*) XGETTEXT_015=: ;;
+    *) XGETTEXT_015=$XGETTEXT ;;
+  esac
+changequote([,])dnl
+  AC_SUBST([XGETTEXT_015])
+
+  dnl Search for GNU msgmerge 0.11 or newer in the PATH.
+  AM_PATH_PROG_WITH_TEST(MSGMERGE, msgmerge,
+    [$ac_dir/$ac_word --update -q /dev/null /dev/null >&]AS_MESSAGE_LOG_FD[ 2>&1], :)
+
+  dnl Installation directories.
+  dnl Autoconf >= 2.60 defines localedir. For older versions of autoconf, we
+  dnl have to define it here, so that it can be used in po/Makefile.
+  test -n "$localedir" || localedir='${datadir}/locale'
+  AC_SUBST([localedir])
+
+  dnl Support for AM_XGETTEXT_OPTION.
+  test -n "${XGETTEXT_EXTRA_OPTIONS+set}" || XGETTEXT_EXTRA_OPTIONS=
+  AC_SUBST([XGETTEXT_EXTRA_OPTIONS])
+
+  AC_CONFIG_COMMANDS([po-directories], [[
+    for ac_file in $CONFIG_FILES; do
+      # Support "outfile[:infile[:infile...]]"
+      case "$ac_file" in
+        *:*) ac_file=`echo "$ac_file"|sed 's%:.*%%'` ;;
+      esac
+      # PO directories have a Makefile.in generated from Makefile.in.in.
+      case "$ac_file" in */Makefile.in)
+        # Adjust a relative srcdir.
+        ac_dir=`echo "$ac_file"|sed 's%/[^/][^/]*$%%'`
+        ac_dir_suffix="/`echo "$ac_dir"|sed 's%^\./%%'`"
+        ac_dots=`echo "$ac_dir_suffix"|sed 's%/[^/]*%../%g'`
+        # In autoconf-2.13 it is called $ac_given_srcdir.
+        # In autoconf-2.50 it is called $srcdir.
+        test -n "$ac_given_srcdir" || ac_given_srcdir="$srcdir"
+        case "$ac_given_srcdir" in
+          .)  top_srcdir=`echo $ac_dots|sed 's%/$%%'` ;;
+          /*) top_srcdir="$ac_given_srcdir" ;;
+          *)  top_srcdir="$ac_dots$ac_given_srcdir" ;;
+        esac
+        # Treat a directory as a PO directory if and only if it has a
+        # POTFILES.in file. This allows packages to have multiple PO
+        # directories under different names or in different locations.
+        if test -f "$ac_given_srcdir/$ac_dir/POTFILES.in"; then
+          rm -f "$ac_dir/POTFILES"
+          test -n "$as_me" && echo "$as_me: creating $ac_dir/POTFILES" || echo "creating $ac_dir/POTFILES"
+          cat "$ac_given_srcdir/$ac_dir/POTFILES.in" | sed -e "/^#/d" -e "/^[ 	]*\$/d" -e "s,.*,     $top_srcdir/& \\\\," | sed -e "\$s/\(.*\) \\\\/\1/" > "$ac_dir/POTFILES"
+          POMAKEFILEDEPS="POTFILES.in"
+          # ALL_LINGUAS, POFILES, UPDATEPOFILES, DUMMYPOFILES, GMOFILES depend
+          # on $ac_dir but don't depend on user-specified configuration
+          # parameters.
+          if test -f "$ac_given_srcdir/$ac_dir/LINGUAS"; then
+            # The LINGUAS file contains the set of available languages.
+            if test -n "$OBSOLETE_ALL_LINGUAS"; then
+              test -n "$as_me" && echo "$as_me: setting ALL_LINGUAS in configure.in is obsolete" || echo "setting ALL_LINGUAS in configure.in is obsolete"
+            fi
+            ALL_LINGUAS_=`sed -e "/^#/d" -e "s/#.*//" "$ac_given_srcdir/$ac_dir/LINGUAS"`
+            # Hide the ALL_LINGUAS assigment from automake < 1.5.
+            eval 'ALL_LINGUAS''=$ALL_LINGUAS_'
+            POMAKEFILEDEPS="$POMAKEFILEDEPS LINGUAS"
+          else
+            # The set of available languages was given in configure.in.
+            # Hide the ALL_LINGUAS assigment from automake < 1.5.
+            eval 'ALL_LINGUAS''=$OBSOLETE_ALL_LINGUAS'
+          fi
+          # Compute POFILES
+          # as      $(foreach lang, $(ALL_LINGUAS), $(srcdir)/$(lang).po)
+          # Compute UPDATEPOFILES
+          # as      $(foreach lang, $(ALL_LINGUAS), $(lang).po-update)
+          # Compute DUMMYPOFILES
+          # as      $(foreach lang, $(ALL_LINGUAS), $(lang).nop)
+          # Compute GMOFILES
+          # as      $(foreach lang, $(ALL_LINGUAS), $(srcdir)/$(lang).gmo)
+          case "$ac_given_srcdir" in
+            .) srcdirpre= ;;
+            *) srcdirpre='$(srcdir)/' ;;
+          esac
+          POFILES=
+          UPDATEPOFILES=
+          DUMMYPOFILES=
+          GMOFILES=
+          for lang in $ALL_LINGUAS; do
+            POFILES="$POFILES $srcdirpre$lang.po"
+            UPDATEPOFILES="$UPDATEPOFILES $lang.po-update"
+            DUMMYPOFILES="$DUMMYPOFILES $lang.nop"
+            GMOFILES="$GMOFILES $srcdirpre$lang.gmo"
+          done
+          # CATALOGS depends on both $ac_dir and the user's LINGUAS
+          # environment variable.
+          INST_LINGUAS=
+          if test -n "$ALL_LINGUAS"; then
+            for presentlang in $ALL_LINGUAS; do
+              useit=no
+              if test "%UNSET%" != "$LINGUAS"; then
+                desiredlanguages="$LINGUAS"
+              else
+                desiredlanguages="$ALL_LINGUAS"
+              fi
+              for desiredlang in $desiredlanguages; do
+                # Use the presentlang catalog if desiredlang is
+                #   a. equal to presentlang, or
+                #   b. a variant of presentlang (because in this case,
+                #      presentlang can be used as a fallback for messages
+                #      which are not translated in the desiredlang catalog).
+                case "$desiredlang" in
+                  "$presentlang"*) useit=yes;;
+                esac
+              done
+              if test $useit = yes; then
+                INST_LINGUAS="$INST_LINGUAS $presentlang"
+              fi
+            done
+          fi
+          CATALOGS=
+          if test -n "$INST_LINGUAS"; then
+            for lang in $INST_LINGUAS; do
+              CATALOGS="$CATALOGS $lang.gmo"
+            done
+          fi
+          test -n "$as_me" && echo "$as_me: creating $ac_dir/Makefile" || echo "creating $ac_dir/Makefile"
+          sed -e "/^POTFILES =/r $ac_dir/POTFILES" -e "/^# Makevars/r $ac_given_srcdir/$ac_dir/Makevars" -e "s|@POFILES@|$POFILES|g" -e "s|@UPDATEPOFILES@|$UPDATEPOFILES|g" -e "s|@DUMMYPOFILES@|$DUMMYPOFILES|g" -e "s|@GMOFILES@|$GMOFILES|g" -e "s|@CATALOGS@|$CATALOGS|g" -e "s|@POMAKEFILEDEPS@|$POMAKEFILEDEPS|g" "$ac_dir/Makefile.in" > "$ac_dir/Makefile"
+          for f in "$ac_given_srcdir/$ac_dir"/Rules-*; do
+            if test -f "$f"; then
+              case "$f" in
+                *.orig | *.bak | *~) ;;
+                *) cat "$f" >> "$ac_dir/Makefile" ;;
+              esac
+            fi
+          done
+        fi
+        ;;
+      esac
+    done]],
+   [# Capture the value of obsolete ALL_LINGUAS because we need it to compute
+    # POFILES, UPDATEPOFILES, DUMMYPOFILES, GMOFILES, CATALOGS. But hide it
+    # from automake < 1.5.
+    eval 'OBSOLETE_ALL_LINGUAS''="$ALL_LINGUAS"'
+    # Capture the value of LINGUAS because we need it to compute CATALOGS.
+    LINGUAS="${LINGUAS-%UNSET%}"
+   ])
+])
+
+dnl Postprocesses a Makefile in a directory containing PO files.
+AC_DEFUN([AM_POSTPROCESS_PO_MAKEFILE],
+[
+  # When this code is run, in config.status, two variables have already been
+  # set:
+  # - OBSOLETE_ALL_LINGUAS is the value of LINGUAS set in configure.in,
+  # - LINGUAS is the value of the environment variable LINGUAS at configure
+  #   time.
+
+changequote(,)dnl
+  # Adjust a relative srcdir.
+  ac_dir=`echo "$ac_file"|sed 's%/[^/][^/]*$%%'`
+  ac_dir_suffix="/`echo "$ac_dir"|sed 's%^\./%%'`"
+  ac_dots=`echo "$ac_dir_suffix"|sed 's%/[^/]*%../%g'`
+  # In autoconf-2.13 it is called $ac_given_srcdir.
+  # In autoconf-2.50 it is called $srcdir.
+  test -n "$ac_given_srcdir" || ac_given_srcdir="$srcdir"
+  case "$ac_given_srcdir" in
+    .)  top_srcdir=`echo $ac_dots|sed 's%/$%%'` ;;
+    /*) top_srcdir="$ac_given_srcdir" ;;
+    *)  top_srcdir="$ac_dots$ac_given_srcdir" ;;
+  esac
+
+  # Find a way to echo strings without interpreting backslash.
+  if test "X`(echo '\t') 2>/dev/null`" = 'X\t'; then
+    gt_echo='echo'
+  else
+    if test "X`(printf '%s\n' '\t') 2>/dev/null`" = 'X\t'; then
+      gt_echo='printf %s\n'
+    else
+      echo_func () {
+        cat <<EOT
+$*
+EOT
+      }
+      gt_echo='echo_func'
+    fi
+  fi
+
+  # A sed script that extracts the value of VARIABLE from a Makefile.
+  sed_x_variable='
+# Test if the hold space is empty.
+x
+s/P/P/
+x
+ta
+# Yes it was empty. Look if we have the expected variable definition.
+/^[	 ]*VARIABLE[	 ]*=/{
+  # Seen the first line of the variable definition.
+  s/^[	 ]*VARIABLE[	 ]*=//
+  ba
+}
+bd
+:a
+# Here we are processing a line from the variable definition.
+# Remove comment, more precisely replace it with a space.
+s/#.*$/ /
+# See if the line ends in a backslash.
+tb
+:b
+s/\\$//
+# Print the line, without the trailing backslash.
+p
+tc
+# There was no trailing backslash. The end of the variable definition is
+# reached. Clear the hold space.
+s/^.*$//
+x
+bd
+:c
+# A trailing backslash means that the variable definition continues in the
+# next line. Put a nonempty string into the hold space to indicate this.
+s/^.*$/P/
+x
+:d
+'
+changequote([,])dnl
+
+  # Set POTFILES to the value of the Makefile variable POTFILES.
+  sed_x_POTFILES=`$gt_echo "$sed_x_variable" | sed -e '/^ *#/d' -e 's/VARIABLE/POTFILES/g'`
+  POTFILES=`sed -n -e "$sed_x_POTFILES" < "$ac_file"`
+  # Compute POTFILES_DEPS as
+  #   $(foreach file, $(POTFILES), $(top_srcdir)/$(file))
+  POTFILES_DEPS=
+  for file in $POTFILES; do
+    POTFILES_DEPS="$POTFILES_DEPS "'$(top_srcdir)/'"$file"
+  done
+  POMAKEFILEDEPS=""
+
+  if test -n "$OBSOLETE_ALL_LINGUAS"; then
+    test -n "$as_me" && echo "$as_me: setting ALL_LINGUAS in configure.in is obsolete" || echo "setting ALL_LINGUAS in configure.in is obsolete"
+  fi
+  if test -f "$ac_given_srcdir/$ac_dir/LINGUAS"; then
+    # The LINGUAS file contains the set of available languages.
+    ALL_LINGUAS_=`sed -e "/^#/d" -e "s/#.*//" "$ac_given_srcdir/$ac_dir/LINGUAS"`
+    POMAKEFILEDEPS="$POMAKEFILEDEPS LINGUAS"
+  else
+    # Set ALL_LINGUAS to the value of the Makefile variable LINGUAS.
+    sed_x_LINGUAS=`$gt_echo "$sed_x_variable" | sed -e '/^ *#/d' -e 's/VARIABLE/LINGUAS/g'`
+    ALL_LINGUAS_=`sed -n -e "$sed_x_LINGUAS" < "$ac_file"`
+  fi
+  # Hide the ALL_LINGUAS assigment from automake < 1.5.
+  eval 'ALL_LINGUAS''=$ALL_LINGUAS_'
+  # Compute POFILES
+  # as      $(foreach lang, $(ALL_LINGUAS), $(srcdir)/$(lang).po)
+  # Compute UPDATEPOFILES
+  # as      $(foreach lang, $(ALL_LINGUAS), $(lang).po-update)
+  # Compute DUMMYPOFILES
+  # as      $(foreach lang, $(ALL_LINGUAS), $(lang).nop)
+  # Compute GMOFILES
+  # as      $(foreach lang, $(ALL_LINGUAS), $(srcdir)/$(lang).gmo)
+  # Compute PROPERTIESFILES
+  # as      $(foreach lang, $(ALL_LINGUAS), $(top_srcdir)/$(DOMAIN)_$(lang).properties)
+  # Compute CLASSFILES
+  # as      $(foreach lang, $(ALL_LINGUAS), $(top_srcdir)/$(DOMAIN)_$(lang).class)
+  # Compute QMFILES
+  # as      $(foreach lang, $(ALL_LINGUAS), $(srcdir)/$(lang).qm)
+  # Compute MSGFILES
+  # as      $(foreach lang, $(ALL_LINGUAS), $(srcdir)/$(frob $(lang)).msg)
+  # Compute RESOURCESDLLFILES
+  # as      $(foreach lang, $(ALL_LINGUAS), $(srcdir)/$(frob $(lang))/$(DOMAIN).resources.dll)
+  case "$ac_given_srcdir" in
+    .) srcdirpre= ;;
+    *) srcdirpre='$(srcdir)/' ;;
+  esac
+  POFILES=
+  UPDATEPOFILES=
+  DUMMYPOFILES=
+  GMOFILES=
+  PROPERTIESFILES=
+  CLASSFILES=
+  QMFILES=
+  MSGFILES=
+  RESOURCESDLLFILES=
+  for lang in $ALL_LINGUAS; do
+    POFILES="$POFILES $srcdirpre$lang.po"
+    UPDATEPOFILES="$UPDATEPOFILES $lang.po-update"
+    DUMMYPOFILES="$DUMMYPOFILES $lang.nop"
+    GMOFILES="$GMOFILES $srcdirpre$lang.gmo"
+    PROPERTIESFILES="$PROPERTIESFILES \$(top_srcdir)/\$(DOMAIN)_$lang.properties"
+    CLASSFILES="$CLASSFILES \$(top_srcdir)/\$(DOMAIN)_$lang.class"
+    QMFILES="$QMFILES $srcdirpre$lang.qm"
+    frobbedlang=`echo $lang | sed -e 's/\..*$//' -e 'y/ABCDEFGHIJKLMNOPQRSTUVWXYZ/abcdefghijklmnopqrstuvwxyz/'`
+    MSGFILES="$MSGFILES $srcdirpre$frobbedlang.msg"
+    frobbedlang=`echo $lang | sed -e 's/_/-/g' -e 's/^sr-CS/sr-SP/' -e 's/@latin$/-Latn/' -e 's/@cyrillic$/-Cyrl/' -e 's/^sr-SP$/sr-SP-Latn/' -e 's/^uz-UZ$/uz-UZ-Latn/'`
+    RESOURCESDLLFILES="$RESOURCESDLLFILES $srcdirpre$frobbedlang/\$(DOMAIN).resources.dll"
+  done
+  # CATALOGS depends on both $ac_dir and the user's LINGUAS
+  # environment variable.
+  INST_LINGUAS=
+  if test -n "$ALL_LINGUAS"; then
+    for presentlang in $ALL_LINGUAS; do
+      useit=no
+      if test "%UNSET%" != "$LINGUAS"; then
+        desiredlanguages="$LINGUAS"
+      else
+        desiredlanguages="$ALL_LINGUAS"
+      fi
+      for desiredlang in $desiredlanguages; do
+        # Use the presentlang catalog if desiredlang is
+        #   a. equal to presentlang, or
+        #   b. a variant of presentlang (because in this case,
+        #      presentlang can be used as a fallback for messages
+        #      which are not translated in the desiredlang catalog).
+        case "$desiredlang" in
+          "$presentlang"*) useit=yes;;
+        esac
+      done
+      if test $useit = yes; then
+        INST_LINGUAS="$INST_LINGUAS $presentlang"
+      fi
+    done
+  fi
+  CATALOGS=
+  JAVACATALOGS=
+  QTCATALOGS=
+  TCLCATALOGS=
+  CSHARPCATALOGS=
+  if test -n "$INST_LINGUAS"; then
+    for lang in $INST_LINGUAS; do
+      CATALOGS="$CATALOGS $lang.gmo"
+      JAVACATALOGS="$JAVACATALOGS \$(DOMAIN)_$lang.properties"
+      QTCATALOGS="$QTCATALOGS $lang.qm"
+      frobbedlang=`echo $lang | sed -e 's/\..*$//' -e 'y/ABCDEFGHIJKLMNOPQRSTUVWXYZ/abcdefghijklmnopqrstuvwxyz/'`
+      TCLCATALOGS="$TCLCATALOGS $frobbedlang.msg"
+      frobbedlang=`echo $lang | sed -e 's/_/-/g' -e 's/^sr-CS/sr-SP/' -e 's/@latin$/-Latn/' -e 's/@cyrillic$/-Cyrl/' -e 's/^sr-SP$/sr-SP-Latn/' -e 's/^uz-UZ$/uz-UZ-Latn/'`
+      CSHARPCATALOGS="$CSHARPCATALOGS $frobbedlang/\$(DOMAIN).resources.dll"
+    done
+  fi
+
+  sed -e "s|@POTFILES_DEPS@|$POTFILES_DEPS|g" -e "s|@POFILES@|$POFILES|g" -e "s|@UPDATEPOFILES@|$UPDATEPOFILES|g" -e "s|@DUMMYPOFILES@|$DUMMYPOFILES|g" -e "s|@GMOFILES@|$GMOFILES|g" -e "s|@PROPERTIESFILES@|$PROPERTIESFILES|g" -e "s|@CLASSFILES@|$CLASSFILES|g" -e "s|@QMFILES@|$QMFILES|g" -e "s|@MSGFILES@|$MSGFILES|g" -e "s|@RESOURCESDLLFILES@|$RESOURCESDLLFILES|g" -e "s|@CATALOGS@|$CATALOGS|g" -e "s|@JAVACATALOGS@|$JAVACATALOGS|g" -e "s|@QTCATALOGS@|$QTCATALOGS|g" -e "s|@TCLCATALOGS@|$TCLCATALOGS|g" -e "s|@CSHARPCATALOGS@|$CSHARPCATALOGS|g" -e 's,^#distdir:,distdir:,' < "$ac_file" > "$ac_file.tmp"
+  if grep -l '@TCLCATALOGS@' "$ac_file" > /dev/null; then
+    # Add dependencies that cannot be formulated as a simple suffix rule.
+    for lang in $ALL_LINGUAS; do
+      frobbedlang=`echo $lang | sed -e 's/\..*$//' -e 'y/ABCDEFGHIJKLMNOPQRSTUVWXYZ/abcdefghijklmnopqrstuvwxyz/'`
+      cat >> "$ac_file.tmp" <<EOF
+$frobbedlang.msg: $lang.po
+	@echo "\$(MSGFMT) -c --tcl -d \$(srcdir) -l $lang $srcdirpre$lang.po"; \
+	\$(MSGFMT) -c --tcl -d "\$(srcdir)" -l $lang $srcdirpre$lang.po || { rm -f "\$(srcdir)/$frobbedlang.msg"; exit 1; }
+EOF
+    done
+  fi
+  if grep -l '@CSHARPCATALOGS@' "$ac_file" > /dev/null; then
+    # Add dependencies that cannot be formulated as a simple suffix rule.
+    for lang in $ALL_LINGUAS; do
+      frobbedlang=`echo $lang | sed -e 's/_/-/g' -e 's/^sr-CS/sr-SP/' -e 's/@latin$/-Latn/' -e 's/@cyrillic$/-Cyrl/' -e 's/^sr-SP$/sr-SP-Latn/' -e 's/^uz-UZ$/uz-UZ-Latn/'`
+      cat >> "$ac_file.tmp" <<EOF
+$frobbedlang/\$(DOMAIN).resources.dll: $lang.po
+	@echo "\$(MSGFMT) -c --csharp -d \$(srcdir) -l $lang $srcdirpre$lang.po -r \$(DOMAIN)"; \
+	\$(MSGFMT) -c --csharp -d "\$(srcdir)" -l $lang $srcdirpre$lang.po -r "\$(DOMAIN)" || { rm -f "\$(srcdir)/$frobbedlang.msg"; exit 1; }
+EOF
+    done
+  fi
+  if test -n "$POMAKEFILEDEPS"; then
+    cat >> "$ac_file.tmp" <<EOF
+Makefile: $POMAKEFILEDEPS
+EOF
+  fi
+  mv "$ac_file.tmp" "$ac_file"
+])
+
+dnl Initializes the accumulator used by AM_XGETTEXT_OPTION.
+AC_DEFUN([AM_XGETTEXT_OPTION_INIT],
+[
+  XGETTEXT_EXTRA_OPTIONS=
+])
+
+dnl Registers an option to be passed to xgettext in the po subdirectory.
+AC_DEFUN([AM_XGETTEXT_OPTION],
+[
+  AC_REQUIRE([AM_XGETTEXT_OPTION_INIT])
+  XGETTEXT_EXTRA_OPTIONS="$XGETTEXT_EXTRA_OPTIONS $1"
+])
--- /dev/null
+++ b/m4/progtest.m4
@@ -0,0 +1,92 @@
+# progtest.m4 serial 4 (gettext-0.14.2)
+dnl Copyright (C) 1996-2003, 2005 Free Software Foundation, Inc.
+dnl This file is free software; the Free Software Foundation
+dnl gives unlimited permission to copy and/or distribute it,
+dnl with or without modifications, as long as this notice is preserved.
+dnl
+dnl This file can can be used in projects which are not available under
+dnl the GNU General Public License or the GNU Library General Public
+dnl License but which still want to provide support for the GNU gettext
+dnl functionality.
+dnl Please note that the actual code of the GNU gettext library is covered
+dnl by the GNU Library General Public License, and the rest of the GNU
+dnl gettext package package is covered by the GNU General Public License.
+dnl They are *not* in the public domain.
+
+dnl Authors:
+dnl   Ulrich Drepper <drepper@cygnus.com>, 1996.
+
+AC_PREREQ(2.50)
+
+# Search path for a program which passes the given test.
+
+dnl AM_PATH_PROG_WITH_TEST(VARIABLE, PROG-TO-CHECK-FOR,
+dnl   TEST-PERFORMED-ON-FOUND_PROGRAM [, VALUE-IF-NOT-FOUND [, PATH]])
+AC_DEFUN([AM_PATH_PROG_WITH_TEST],
+[
+# Prepare PATH_SEPARATOR.
+# The user is always right.
+if test "${PATH_SEPARATOR+set}" != set; then
+  echo "#! /bin/sh" >conf$$.sh
+  echo  "exit 0"   >>conf$$.sh
+  chmod +x conf$$.sh
+  if (PATH="/nonexistent;."; conf$$.sh) >/dev/null 2>&1; then
+    PATH_SEPARATOR=';'
+  else
+    PATH_SEPARATOR=:
+  fi
+  rm -f conf$$.sh
+fi
+
+# Find out how to test for executable files. Don't use a zero-byte file,
+# as systems may use methods other than mode bits to determine executability.
+cat >conf$$.file <<_ASEOF
+#! /bin/sh
+exit 0
+_ASEOF
+chmod +x conf$$.file
+if test -x conf$$.file >/dev/null 2>&1; then
+  ac_executable_p="test -x"
+else
+  ac_executable_p="test -f"
+fi
+rm -f conf$$.file
+
+# Extract the first word of "$2", so it can be a program name with args.
+set dummy $2; ac_word=[$]2
+AC_MSG_CHECKING([for $ac_word])
+AC_CACHE_VAL(ac_cv_path_$1,
+[case "[$]$1" in
+  [[\\/]]* | ?:[[\\/]]*)
+    ac_cv_path_$1="[$]$1" # Let the user override the test with a path.
+    ;;
+  *)
+    ac_save_IFS="$IFS"; IFS=$PATH_SEPARATOR
+    for ac_dir in ifelse([$5], , $PATH, [$5]); do
+      IFS="$ac_save_IFS"
+      test -z "$ac_dir" && ac_dir=.
+      for ac_exec_ext in '' $ac_executable_extensions; do
+        if $ac_executable_p "$ac_dir/$ac_word$ac_exec_ext"; then
+          echo "$as_me: trying $ac_dir/$ac_word..." >&AS_MESSAGE_LOG_FD
+          if [$3]; then
+            ac_cv_path_$1="$ac_dir/$ac_word$ac_exec_ext"
+            break 2
+          fi
+        fi
+      done
+    done
+    IFS="$ac_save_IFS"
+dnl If no 4th arg is given, leave the cache variable unset,
+dnl so AC_PATH_PROGS will keep looking.
+ifelse([$4], , , [  test -z "[$]ac_cv_path_$1" && ac_cv_path_$1="$4"
+])dnl
+    ;;
+esac])dnl
+$1="$ac_cv_path_$1"
+if test ifelse([$4], , [-n "[$]$1"], ["[$]$1" != "$4"]); then
+  AC_MSG_RESULT([$]$1)
+else
+  AC_MSG_RESULT(no)
+fi
+AC_SUBST($1)dnl
+])
--- /dev/null
+++ b/release-plan.txt
@@ -0,0 +1,23 @@
+0.2: 16.01.2009
+  * New Plugin-based architecture.
+  * DVB Daemon integration though a plugin.
+  * Test plugin.
+  * Basic transcoding support.
+  * Tracker plugin improvements.
+
+0.3: 20.02.2009
+  * Export of correct DLNA profile strings.
+  * Standalone plugin.
+  * Configuration UI.
+
+0.4: 20.03.2009
+  * Filtered results.
+  * Search.
+  * Sort.
+  * Upload.
+
+0.5: 17.04.2009
+  * container update notifications.
+  * video thumbnails.
+  * 100% DLNA compliance.
+
--- /dev/null
+++ b/rygel.doap
@@ -0,0 +1,26 @@
+<Project xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
+         xmlns:rdfs="http://www.w3.org/2000/01/rdf-schema#"
+         xmlns:foaf="http://xmlns.com/foaf/0.1/"
+         xmlns:gnome="http://api.gnome.org/doap-extensions#"
+         xmlns="http://usefulinc.com/ns/doap#">
+
+  <name xml:lang="en">rygel</name>
+  <shortdesc xml:lang="en">Rygel is a collection of UPnP/DLNA devices, implemented through a plug-in mechanism.</shortdesc>
+
+  <homepage
+  rdf:resource="http://live.gnome.org/Rygel" />
+  <mailing-list
+  rdf:resource="http://mail.gnome.org/mailman/listinfo/rygel-list" />
+  <download-page
+  rdf:resource="http://download.gnome.org/sources/rygel/"/>
+  <bug-database
+  rdf:resource="http://bugzilla.gnome.org/browse.cgi?product=rygel"/>
+
+  <maintainer>
+    <foaf:Person>
+      <foaf:name>Zeeshan Ali (Khattak)</foaf:name>
+      <foaf:mbox rdf:resource="mailto:zeeshanak@gnome.org" />
+      <gnome:userid>zeeshanak</gnome:userid>
+    </foaf:Person>
+  </maintainer>
+</Project>
--- a/src/Makefile.in
+++ b/src/Makefile.in
@@ -36,7 +36,8 @@ host_triplet = @host@
 subdir = src
 DIST_COMMON = $(srcdir)/Makefile.am $(srcdir)/Makefile.in
 ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
-am__aclocal_m4_deps = $(top_srcdir)/m4/libtool.m4 \
+am__aclocal_m4_deps = $(top_srcdir)/m4/glib-gettext.m4 \
+	$(top_srcdir)/m4/isc-posix.m4 $(top_srcdir)/m4/libtool.m4 \
 	$(top_srcdir)/m4/ltoptions.m4 $(top_srcdir)/m4/ltsugar.m4 \
 	$(top_srcdir)/m4/ltversion.m4 $(top_srcdir)/m4/lt~obsolete.m4 \
 	$(top_srcdir)/configure.ac
@@ -131,8 +132,6 @@ GMSGFMT = @GMSGFMT@
 GREP = @GREP@
 GTK_CFLAGS = @GTK_CFLAGS@
 GTK_LIBS = @GTK_LIBS@
-GUPNP_VALA_CFLAGS = @GUPNP_VALA_CFLAGS@
-GUPNP_VALA_LIBS = @GUPNP_VALA_LIBS@
 HAVE_GTK = @HAVE_GTK@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
@@ -147,8 +146,8 @@ LIBDBUS_GLIB_CFLAGS = @LIBDBUS_GLIB_CFLA
 LIBDBUS_GLIB_LIBS = @LIBDBUS_GLIB_LIBS@
 LIBGIO_CFLAGS = @LIBGIO_CFLAGS@
 LIBGIO_LIBS = @LIBGIO_LIBS@
-LIBGSTREAMER_CFLAGS = @LIBGSTREAMER_CFLAGS@
-LIBGSTREAMER_LIBS = @LIBGSTREAMER_LIBS@
+LIBGLIB_CFLAGS = @LIBGLIB_CFLAGS@
+LIBGLIB_LIBS = @LIBGLIB_LIBS@
 LIBGUPNP_AV_CFLAGS = @LIBGUPNP_AV_CFLAGS@
 LIBGUPNP_AV_LIBS = @LIBGUPNP_AV_LIBS@
 LIBGUPNP_CFLAGS = @LIBGUPNP_CFLAGS@
@@ -160,6 +159,8 @@ LIBSOUP_LIBS = @LIBSOUP_LIBS@
 LIBSQLITE3_CFLAGS = @LIBSQLITE3_CFLAGS@
 LIBSQLITE3_LIBS = @LIBSQLITE3_LIBS@
 LIBTOOL = @LIBTOOL@
+LIBVLC_CFLAGS = @LIBVLC_CFLAGS@
+LIBVLC_LIBS = @LIBVLC_LIBS@
 LIPO = @LIPO@
 LN_S = @LN_S@
 LTLIBOBJS = @LTLIBOBJS@
@@ -180,6 +181,7 @@ PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
 PACKAGE_NAME = @PACKAGE_NAME@
 PACKAGE_STRING = @PACKAGE_STRING@
 PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_URL = @PACKAGE_URL@
 PACKAGE_VERSION = @PACKAGE_VERSION@
 PATH_SEPARATOR = @PATH_SEPARATOR@
 PKG_CONFIG = @PKG_CONFIG@
@@ -193,8 +195,6 @@ SET_MAKE = @SET_MAKE@
 SHELL = @SHELL@
 STRIP = @STRIP@
 USE_NLS = @USE_NLS@
-UUID_CFLAGS = @UUID_CFLAGS@
-UUID_LIBS = @UUID_LIBS@
 VALAC = @VALAC@
 VAPIDIR = @VAPIDIR@
 VERSION = @VERSION@
--- a/src/plugins/Makefile.in
+++ b/src/plugins/Makefile.in
@@ -36,7 +36,8 @@ host_triplet = @host@
 subdir = src/plugins
 DIST_COMMON = $(srcdir)/Makefile.am $(srcdir)/Makefile.in
 ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
-am__aclocal_m4_deps = $(top_srcdir)/m4/libtool.m4 \
+am__aclocal_m4_deps = $(top_srcdir)/m4/glib-gettext.m4 \
+	$(top_srcdir)/m4/isc-posix.m4 $(top_srcdir)/m4/libtool.m4 \
 	$(top_srcdir)/m4/ltoptions.m4 $(top_srcdir)/m4/ltsugar.m4 \
 	$(top_srcdir)/m4/ltversion.m4 $(top_srcdir)/m4/lt~obsolete.m4 \
 	$(top_srcdir)/configure.ac
@@ -68,7 +69,8 @@ AM_RECURSIVE_TARGETS = $(RECURSIVE_TARGE
 	distdir
 ETAGS = etags
 CTAGS = ctags
-DIST_SUBDIRS = test tracker mediathek media-export external gstlaunch
+DIST_SUBDIRS = test tracker mediathek media-export external gstlaunch \
+	gst-renderer
 DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
 am__relativize = \
   dir0=`pwd`; \
@@ -131,8 +133,6 @@ GMSGFMT = @GMSGFMT@
 GREP = @GREP@
 GTK_CFLAGS = @GTK_CFLAGS@
 GTK_LIBS = @GTK_LIBS@
-GUPNP_VALA_CFLAGS = @GUPNP_VALA_CFLAGS@
-GUPNP_VALA_LIBS = @GUPNP_VALA_LIBS@
 HAVE_GTK = @HAVE_GTK@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
@@ -147,8 +147,8 @@ LIBDBUS_GLIB_CFLAGS = @LIBDBUS_GLIB_CFLA
 LIBDBUS_GLIB_LIBS = @LIBDBUS_GLIB_LIBS@
 LIBGIO_CFLAGS = @LIBGIO_CFLAGS@
 LIBGIO_LIBS = @LIBGIO_LIBS@
-LIBGSTREAMER_CFLAGS = @LIBGSTREAMER_CFLAGS@
-LIBGSTREAMER_LIBS = @LIBGSTREAMER_LIBS@
+LIBGLIB_CFLAGS = @LIBGLIB_CFLAGS@
+LIBGLIB_LIBS = @LIBGLIB_LIBS@
 LIBGUPNP_AV_CFLAGS = @LIBGUPNP_AV_CFLAGS@
 LIBGUPNP_AV_LIBS = @LIBGUPNP_AV_LIBS@
 LIBGUPNP_CFLAGS = @LIBGUPNP_CFLAGS@
@@ -160,6 +160,8 @@ LIBSOUP_LIBS = @LIBSOUP_LIBS@
 LIBSQLITE3_CFLAGS = @LIBSQLITE3_CFLAGS@
 LIBSQLITE3_LIBS = @LIBSQLITE3_LIBS@
 LIBTOOL = @LIBTOOL@
+LIBVLC_CFLAGS = @LIBVLC_CFLAGS@
+LIBVLC_LIBS = @LIBVLC_LIBS@
 LIPO = @LIPO@
 LN_S = @LN_S@
 LTLIBOBJS = @LTLIBOBJS@
@@ -180,6 +182,7 @@ PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
 PACKAGE_NAME = @PACKAGE_NAME@
 PACKAGE_STRING = @PACKAGE_STRING@
 PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_URL = @PACKAGE_URL@
 PACKAGE_VERSION = @PACKAGE_VERSION@
 PATH_SEPARATOR = @PATH_SEPARATOR@
 PKG_CONFIG = @PKG_CONFIG@
@@ -193,8 +196,6 @@ SET_MAKE = @SET_MAKE@
 SHELL = @SHELL@
 STRIP = @STRIP@
 USE_NLS = @USE_NLS@
-UUID_CFLAGS = @UUID_CFLAGS@
-UUID_LIBS = @UUID_LIBS@
 VALAC = @VALAC@
 VAPIDIR = @VAPIDIR@
 VERSION = @VERSION@
@@ -257,12 +258,14 @@ top_srcdir = @top_srcdir@
 @BUILD_MEDIA_EXPORT_PLUGIN_TRUE@MEDIA_EXPORT_PLUGIN = media-export
 @BUILD_EXTERNAL_PLUGIN_TRUE@EXTERNAL_PLUGIN = external
 @BUILD_GSTLAUNCH_PLUGIN_TRUE@GSTLAUNCH_PLUGIN = gstlaunch
+@BUILD_GST_RENDERER_PLUGIN_TRUE@GST_RENDERER = gst-renderer
 SUBDIRS = $(TEST_PLUGIN) \
 	  $(TRACKER_PLUGIN) \
 	  $(MEDIATHEK_PLUGIN) \
 	  $(MEDIA_EXPORT_PLUGIN) \
 	  $(EXTERNAL_PLUGIN) \
-	  $(GSTLAUNCH_PLUGIN)
+	  $(GSTLAUNCH_PLUGIN) \
+          $(GST_RENDERER)
 
 MAINTAINERCLEANFILES = Makefile.in
 all: all-recursive
--- a/src/plugins/external/Makefile.in
+++ b/src/plugins/external/Makefile.in
@@ -40,7 +40,8 @@ DIST_COMMON = $(srcdir)/Makefile.am $(sr
 	rygel-external-content-dir.c rygel-external-item.c \
 	rygel-external-plugin-factory.c rygel-external-plugin.c
 ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
-am__aclocal_m4_deps = $(top_srcdir)/m4/libtool.m4 \
+am__aclocal_m4_deps = $(top_srcdir)/m4/glib-gettext.m4 \
+	$(top_srcdir)/m4/isc-posix.m4 $(top_srcdir)/m4/libtool.m4 \
 	$(top_srcdir)/m4/ltoptions.m4 $(top_srcdir)/m4/ltsugar.m4 \
 	$(top_srcdir)/m4/ltversion.m4 $(top_srcdir)/m4/lt~obsolete.m4 \
 	$(top_srcdir)/configure.ac
@@ -76,7 +77,7 @@ LTLIBRARIES = $(plugin_LTLIBRARIES)
 am__DEPENDENCIES_1 =
 librygel_external_la_DEPENDENCIES = $(am__DEPENDENCIES_1) \
 	$(am__DEPENDENCIES_1) $(am__DEPENDENCIES_1) \
-	$(am__DEPENDENCIES_1) $(am__DEPENDENCIES_1)
+	$(am__DEPENDENCIES_1)
 am_librygel_external_la_OBJECTS = rygel-external-content-dir.lo \
 	rygel-external-container.lo rygel-external-item.lo \
 	rygel-external-plugin.lo rygel-external-plugin-factory.lo
@@ -162,8 +163,6 @@ GMSGFMT = @GMSGFMT@
 GREP = @GREP@
 GTK_CFLAGS = @GTK_CFLAGS@
 GTK_LIBS = @GTK_LIBS@
-GUPNP_VALA_CFLAGS = @GUPNP_VALA_CFLAGS@
-GUPNP_VALA_LIBS = @GUPNP_VALA_LIBS@
 HAVE_GTK = @HAVE_GTK@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
@@ -178,8 +177,8 @@ LIBDBUS_GLIB_CFLAGS = @LIBDBUS_GLIB_CFLA
 LIBDBUS_GLIB_LIBS = @LIBDBUS_GLIB_LIBS@
 LIBGIO_CFLAGS = @LIBGIO_CFLAGS@
 LIBGIO_LIBS = @LIBGIO_LIBS@
-LIBGSTREAMER_CFLAGS = @LIBGSTREAMER_CFLAGS@
-LIBGSTREAMER_LIBS = @LIBGSTREAMER_LIBS@
+LIBGLIB_CFLAGS = @LIBGLIB_CFLAGS@
+LIBGLIB_LIBS = @LIBGLIB_LIBS@
 LIBGUPNP_AV_CFLAGS = @LIBGUPNP_AV_CFLAGS@
 LIBGUPNP_AV_LIBS = @LIBGUPNP_AV_LIBS@
 LIBGUPNP_CFLAGS = @LIBGUPNP_CFLAGS@
@@ -191,6 +190,8 @@ LIBSOUP_LIBS = @LIBSOUP_LIBS@
 LIBSQLITE3_CFLAGS = @LIBSQLITE3_CFLAGS@
 LIBSQLITE3_LIBS = @LIBSQLITE3_LIBS@
 LIBTOOL = @LIBTOOL@
+LIBVLC_CFLAGS = @LIBVLC_CFLAGS@
+LIBVLC_LIBS = @LIBVLC_LIBS@
 LIPO = @LIPO@
 LN_S = @LN_S@
 LTLIBOBJS = @LTLIBOBJS@
@@ -211,6 +212,7 @@ PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
 PACKAGE_NAME = @PACKAGE_NAME@
 PACKAGE_STRING = @PACKAGE_STRING@
 PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_URL = @PACKAGE_URL@
 PACKAGE_VERSION = @PACKAGE_VERSION@
 PATH_SEPARATOR = @PATH_SEPARATOR@
 PKG_CONFIG = @PKG_CONFIG@
@@ -224,8 +226,6 @@ SET_MAKE = @SET_MAKE@
 SHELL = @SHELL@
 STRIP = @STRIP@
 USE_NLS = @USE_NLS@
-UUID_CFLAGS = @UUID_CFLAGS@
-UUID_LIBS = @UUID_LIBS@
 VALAC = @VALAC@
 VAPIDIR = @VAPIDIR@
 VERSION = @VERSION@
--- a/src/plugins/external/rygel-external-container.c
+++ /dev/null
@@ -1,686 +0,0 @@
-/* rygel-external-container.c generated by valac, the Vala compiler
- * generated from rygel-external-container.vala, do not modify */
-
-/*
- * Copyright (C) 2009 Zeeshan Ali (Khattak) <zeeshanak@gnome.org>.
- * Copyright (C) 2009 Nokia Corporation.
- *
- * Author: Zeeshan Ali (Khattak) <zeeshanak@gnome.org>
- *                               <zeeshan.ali@nokia.com>
- *
- * This file is part of Rygel.
- *
- * Rygel is free software; you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * Rygel is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this program; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
- */
-
-#include <glib.h>
-#include <glib-object.h>
-#include <rygel.h>
-#include <dbus/dbus-glib-lowlevel.h>
-#include <dbus/dbus-glib.h>
-#include <stdlib.h>
-#include <string.h>
-#include <gee.h>
-#include <gio/gio.h>
-
-
-#define RYGEL_TYPE_EXTERNAL_CONTAINER (rygel_external_container_get_type ())
-#define RYGEL_EXTERNAL_CONTAINER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_EXTERNAL_CONTAINER, RygelExternalContainer))
-#define RYGEL_EXTERNAL_CONTAINER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_EXTERNAL_CONTAINER, RygelExternalContainerClass))
-#define RYGEL_IS_EXTERNAL_CONTAINER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_EXTERNAL_CONTAINER))
-#define RYGEL_IS_EXTERNAL_CONTAINER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_EXTERNAL_CONTAINER))
-#define RYGEL_EXTERNAL_CONTAINER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_EXTERNAL_CONTAINER, RygelExternalContainerClass))
-
-typedef struct _RygelExternalContainer RygelExternalContainer;
-typedef struct _RygelExternalContainerClass RygelExternalContainerClass;
-typedef struct _RygelExternalContainerPrivate RygelExternalContainerPrivate;
-#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
-#define _g_free0(var) (var = (g_free (var), NULL))
-#define _dbus_g_connection_unref0(var) ((var == NULL) ? NULL : (var = (dbus_g_connection_unref (var), NULL)))
-#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
-
-#define RYGEL_TYPE_EXTERNAL_ITEM (rygel_external_item_get_type ())
-#define RYGEL_EXTERNAL_ITEM(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_EXTERNAL_ITEM, RygelExternalItem))
-#define RYGEL_EXTERNAL_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_EXTERNAL_ITEM, RygelExternalItemClass))
-#define RYGEL_IS_EXTERNAL_ITEM(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_EXTERNAL_ITEM))
-#define RYGEL_IS_EXTERNAL_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_EXTERNAL_ITEM))
-#define RYGEL_EXTERNAL_ITEM_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_EXTERNAL_ITEM, RygelExternalItemClass))
-
-typedef struct _RygelExternalItem RygelExternalItem;
-typedef struct _RygelExternalItemClass RygelExternalItemClass;
-#define _g_regex_unref0(var) ((var == NULL) ? NULL : (var = (g_regex_unref (var), NULL)))
-
-struct _RygelExternalContainer {
-	RygelMediaContainer parent_instance;
-	RygelExternalContainerPrivate * priv;
-	DBusGProxy* actual_container;
-	DBusGProxy* props;
-	char* host_ip;
-	char* service_name;
-};
-
-struct _RygelExternalContainerClass {
-	RygelMediaContainerClass parent_class;
-};
-
-struct _RygelExternalContainerPrivate {
-	char* object_path;
-	GeeArrayList* containers;
-};
-
-
-static char* rygel_external_container_PROPS_IFACE;
-static char* rygel_external_container_PROPS_IFACE = NULL;
-static gpointer rygel_external_container_parent_class = NULL;
-
-GType rygel_external_container_get_type (void);
-#define RYGEL_EXTERNAL_CONTAINER_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), RYGEL_TYPE_EXTERNAL_CONTAINER, RygelExternalContainerPrivate))
-enum  {
-	RYGEL_EXTERNAL_CONTAINER_DUMMY_PROPERTY
-};
-#define RYGEL_EXTERNAL_CONTAINER_OBJECT_IFACE "org.gnome.UPnP.MediaObject1"
-#define RYGEL_EXTERNAL_CONTAINER_CONTAINER_IFACE "org.gnome.UPnP.MediaContainer1"
-#define RYGEL_EXTERNAL_CONTAINER_ITEM_IFACE "org.gnome.UPnP.MediaItem1"
-void _dynamic_Get0 (DBusGProxy* self, const char* param1, const char* param2, GValue* param3, GError** error);
-char* rygel_external_container_substitute_keywords (RygelExternalContainer* self, const char* title);
-static void rygel_external_container_update_container (RygelExternalContainer* self, GError** error);
-static void rygel_external_container_on_container_updated (RygelExternalContainer* self, DBusGProxy* actual_container);
-static void _rygel_external_container_on_container_updated_dynamic_Updated0_ (DBusGProxy* _sender, gpointer self);
-void _dynamic_Updated1_connect (gpointer obj, const char * signal_name, GCallback handler, gpointer data);
-RygelExternalContainer* rygel_external_container_new (const char* id, const char* service_name, const char* object_path, const char* host_ip, RygelExternalContainer* parent);
-RygelExternalContainer* rygel_external_container_construct (GType object_type, const char* id, const char* service_name, const char* object_path, const char* host_ip, RygelExternalContainer* parent);
-void _dynamic_Get1 (DBusGProxy* self, const char* param1, const char* param2, GValue* param3, GError** error);
-RygelExternalItem* rygel_external_item_new_for_path (const char* object_path, RygelExternalContainer* parent, GError** error);
-RygelExternalItem* rygel_external_item_construct_for_path (GType object_type, const char* object_path, RygelExternalContainer* parent, GError** error);
-GType rygel_external_item_get_type (void);
-static void rygel_external_container_real_get_children (RygelMediaContainer* base, guint offset, guint max_count, GCancellable* cancellable, GAsyncReadyCallback callback, void* callback_target);
-static GeeList* rygel_external_container_real_get_children_finish (RygelMediaContainer* base, GAsyncResult* res, GError** error);
-static RygelMediaContainer* rygel_external_container_find_container (RygelExternalContainer* self, const char* id);
-gboolean rygel_external_item_id_valid (const char* id);
-RygelExternalItem* rygel_external_item_new_for_id (const char* id, RygelExternalContainer* parent, GError** error);
-RygelExternalItem* rygel_external_item_construct_for_id (GType object_type, const char* id, RygelExternalContainer* parent, GError** error);
-static void rygel_external_container_real_find_object (RygelMediaContainer* base, const char* id, GCancellable* cancellable, GAsyncReadyCallback callback, void* callback_target);
-static RygelMediaObject* rygel_external_container_real_find_object_finish (RygelMediaContainer* base, GAsyncResult* res, GError** error);
-void _dynamic_Get2 (DBusGProxy* self, const char* param1, const char* param2, GValue* param3, GError** error);
-void _dynamic_Get3 (DBusGProxy* self, const char* param1, const char* param2, GValue* param3, GError** error);
-static void rygel_external_container_finalize (GObject* obj);
-static int _vala_strcmp0 (const char * str1, const char * str2);
-
-
-
-void _dynamic_Get0 (DBusGProxy* self, const char* param1, const char* param2, GValue* param3, GError** error) {
-	dbus_g_proxy_call (self, "Get", error, G_TYPE_STRING, param1, G_TYPE_STRING, param2, G_TYPE_INVALID, G_TYPE_VALUE, param3, G_TYPE_INVALID);
-	if (*error) {
-		return;
-	}
-}
-
-
-static void _rygel_external_container_on_container_updated_dynamic_Updated0_ (DBusGProxy* _sender, gpointer self) {
-	rygel_external_container_on_container_updated (self, _sender);
-}
-
-
-void _dynamic_Updated1_connect (gpointer obj, const char * signal_name, GCallback handler, gpointer data) {
-	dbus_g_object_register_marshaller (g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, G_TYPE_INVALID);
-	dbus_g_proxy_add_signal (obj, "Updated", G_TYPE_INVALID);
-	dbus_g_proxy_connect_signal (obj, signal_name, handler, data, NULL);
-}
-
-
-RygelExternalContainer* rygel_external_container_construct (GType object_type, const char* id, const char* service_name, const char* object_path, const char* host_ip, RygelExternalContainer* parent) {
-	GError * _inner_error_;
-	RygelExternalContainer * self;
-	char* _tmp0_;
-	char* _tmp1_;
-	char* _tmp2_;
-	GeeArrayList* _tmp3_;
-	g_return_val_if_fail (id != NULL, NULL);
-	g_return_val_if_fail (service_name != NULL, NULL);
-	g_return_val_if_fail (object_path != NULL, NULL);
-	g_return_val_if_fail (host_ip != NULL, NULL);
-	_inner_error_ = NULL;
-	self = (RygelExternalContainer*) rygel_media_container_construct (object_type, id, (RygelMediaContainer*) parent, "Uknown", (guint) 0);
-	self->service_name = (_tmp0_ = g_strdup (service_name), _g_free0 (self->service_name), _tmp0_);
-	self->priv->object_path = (_tmp1_ = g_strdup (object_path), _g_free0 (self->priv->object_path), _tmp1_);
-	self->host_ip = (_tmp2_ = g_strdup (host_ip), _g_free0 (self->host_ip), _tmp2_);
-	self->priv->containers = (_tmp3_ = gee_array_list_new (RYGEL_TYPE_EXTERNAL_CONTAINER, (GBoxedCopyFunc) g_object_ref, g_object_unref, g_direct_equal), _g_object_unref0 (self->priv->containers), _tmp3_);
-	{
-		DBusGConnection* connection;
-		DBusGProxy* _tmp4_;
-		GValue value = {0};
-		GValue _tmp6_;
-		GValue _tmp5_ = {0};
-		char* _tmp7_;
-		DBusGProxy* _tmp8_;
-		connection = dbus_g_bus_get (DBUS_BUS_SESSION, &_inner_error_);
-		if (_inner_error_ != NULL) {
-			goto __catch0_g_error;
-			goto __finally0;
-		}
-		self->props = (_tmp4_ = dbus_g_proxy_new_for_name (connection, service_name, object_path, rygel_external_container_PROPS_IFACE), _g_object_unref0 (self->props), _tmp4_);
-		_dynamic_Get0 (self->props, RYGEL_EXTERNAL_CONTAINER_OBJECT_IFACE, "DisplayName", &_tmp5_, &_inner_error_);
-		value = (_tmp6_ = _tmp5_, G_IS_VALUE (&value) ? (g_value_unset (&value), NULL) : NULL, _tmp6_);
-		if (_inner_error_ != NULL) {
-			_dbus_g_connection_unref0 (connection);
-			G_IS_VALUE (&value) ? (g_value_unset (&value), NULL) : NULL;
-			goto __catch0_g_error;
-			goto __finally0;
-		}
-		((RygelMediaObject*) self)->title = (_tmp7_ = rygel_external_container_substitute_keywords (self, g_value_get_string (&value)), _g_free0 (((RygelMediaObject*) self)->title), _tmp7_);
-		self->actual_container = (_tmp8_ = dbus_g_proxy_new_for_name (connection, service_name, object_path, RYGEL_EXTERNAL_CONTAINER_CONTAINER_IFACE), _g_object_unref0 (self->actual_container), _tmp8_);
-		rygel_external_container_update_container (self, &_inner_error_);
-		if (_inner_error_ != NULL) {
-			_dbus_g_connection_unref0 (connection);
-			G_IS_VALUE (&value) ? (g_value_unset (&value), NULL) : NULL;
-			goto __catch0_g_error;
-			goto __finally0;
-		}
-		_dynamic_Updated1_connect (self->actual_container, "Updated", (GCallback) _rygel_external_container_on_container_updated_dynamic_Updated0_, self);
-		_dbus_g_connection_unref0 (connection);
-		G_IS_VALUE (&value) ? (g_value_unset (&value), NULL) : NULL;
-	}
-	goto __finally0;
-	__catch0_g_error:
-	{
-		GError * err;
-		err = _inner_error_;
-		_inner_error_ = NULL;
-		{
-			g_critical ("rygel-external-container.vala:82: Failed to fetch information about container '%s': %s\n", ((RygelMediaObject*) self)->id, err->message);
-			_g_error_free0 (err);
-		}
-	}
-	__finally0:
-	if (_inner_error_ != NULL) {
-		g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
-		g_clear_error (&_inner_error_);
-		return NULL;
-	}
-	return self;
-}
-
-
-RygelExternalContainer* rygel_external_container_new (const char* id, const char* service_name, const char* object_path, const char* host_ip, RygelExternalContainer* parent) {
-	return rygel_external_container_construct (RYGEL_TYPE_EXTERNAL_CONTAINER, id, service_name, object_path, host_ip, parent);
-}
-
-
-void _dynamic_Get1 (DBusGProxy* self, const char* param1, const char* param2, GValue* param3, GError** error) {
-	dbus_g_proxy_call (self, "Get", error, G_TYPE_STRING, param1, G_TYPE_STRING, param2, G_TYPE_INVALID, G_TYPE_VALUE, param3, G_TYPE_INVALID);
-	if (*error) {
-		return;
-	}
-}
-
-
-static gpointer _g_object_ref0 (gpointer self) {
-	return self ? g_object_ref (self) : NULL;
-}
-
-
-static void rygel_external_container_real_get_children (RygelMediaContainer* base, guint offset, guint max_count, GCancellable* cancellable, GAsyncReadyCallback callback, void* callback_target) {
-	RygelExternalContainer * self;
-	GError * _inner_error_;
-	GeeArrayList* media_objects;
-	GValue value = {0};
-	GValue _tmp1_;
-	GValue _tmp0_ = {0};
-	GPtrArray* obj_paths;
-	guint stop;
-	GeeList* children;
-	RygelSimpleAsyncResult* res;
-	GeeList* _tmp3_;
-	self = (RygelExternalContainer*) base;
-	_inner_error_ = NULL;
-	media_objects = gee_array_list_new (RYGEL_TYPE_MEDIA_OBJECT, (GBoxedCopyFunc) g_object_ref, g_object_unref, g_direct_equal);
-	gee_abstract_collection_add_all ((GeeAbstractCollection*) media_objects, (GeeCollection*) self->priv->containers);
-	_dynamic_Get1 (self->props, RYGEL_EXTERNAL_CONTAINER_CONTAINER_IFACE, "Items", &_tmp0_, &_inner_error_);
-	value = (_tmp1_ = _tmp0_, G_IS_VALUE (&value) ? (g_value_unset (&value), NULL) : NULL, _tmp1_);
-	if (_inner_error_ != NULL) {
-		_g_object_unref0 (media_objects);
-		G_IS_VALUE (&value) ? (g_value_unset (&value), NULL) : NULL;
-		g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
-		g_clear_error (&_inner_error_);
-		return;
-	}
-	obj_paths = (GPtrArray*) g_value_get_boxed (&value);
-	if (obj_paths->len > 0) {
-		{
-			gint i;
-			i = 0;
-			{
-				gboolean _tmp2_;
-				_tmp2_ = TRUE;
-				while (TRUE) {
-					char* obj_path;
-					if (!_tmp2_) {
-						i++;
-					}
-					_tmp2_ = FALSE;
-					if (!(i < obj_paths->len)) {
-						break;
-					}
-					obj_path = g_strdup ((const char*) obj_paths->pdata[i]);
-					{
-						RygelExternalItem* item;
-						item = rygel_external_item_new_for_path (obj_path, self, &_inner_error_);
-						if (_inner_error_ != NULL) {
-							goto __catch1_g_error;
-							goto __finally1;
-						}
-						gee_abstract_collection_add ((GeeAbstractCollection*) media_objects, (RygelMediaObject*) item);
-						_g_object_unref0 (item);
-					}
-					goto __finally1;
-					__catch1_g_error:
-					{
-						GError * err;
-						err = _inner_error_;
-						_inner_error_ = NULL;
-						{
-							g_warning ("rygel-external-container.vala:111: Error initializable item at '%s': %s. Ignoring..", obj_path, err->message);
-							_g_error_free0 (err);
-						}
-					}
-					__finally1:
-					if (_inner_error_ != NULL) {
-						_g_free0 (obj_path);
-						_g_object_unref0 (media_objects);
-						G_IS_VALUE (&value) ? (g_value_unset (&value), NULL) : NULL;
-						g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
-						g_clear_error (&_inner_error_);
-						return;
-					}
-					_g_free0 (obj_path);
-				}
-			}
-		}
-	}
-	stop = offset + max_count;
-	stop = CLAMP (stop, (guint) 0, ((RygelMediaContainer*) self)->child_count);
-	children = gee_abstract_list_slice ((GeeAbstractList*) media_objects, (gint) offset, (gint) stop);
-	res = rygel_simple_async_result_new (GEE_TYPE_LIST, (GBoxedCopyFunc) g_object_ref, g_object_unref, (GObject*) self, callback, callback_target);
-	res->data = (_tmp3_ = _g_object_ref0 (children), _g_object_unref0 (res->data), _tmp3_);
-	rygel_simple_async_result_complete_in_idle (res);
-	_g_object_unref0 (media_objects);
-	G_IS_VALUE (&value) ? (g_value_unset (&value), NULL) : NULL;
-	_g_object_unref0 (children);
-	_g_object_unref0 (res);
-}
-
-
-static GeeList* rygel_external_container_real_get_children_finish (RygelMediaContainer* base, GAsyncResult* res, GError** error) {
-	RygelExternalContainer * self;
-	GeeList* result;
-	RygelSimpleAsyncResult* simple_res;
-	self = (RygelExternalContainer*) base;
-	g_return_val_if_fail (res != NULL, NULL);
-	simple_res = _g_object_ref0 (RYGEL_SIMPLE_ASYNC_RESULT (res));
-	result = _g_object_ref0 ((GeeList*) simple_res->data);
-	_g_object_unref0 (simple_res);
-	return result;
-}
-
-
-static gpointer _g_error_copy0 (gpointer self) {
-	return self ? g_error_copy (self) : NULL;
-}
-
-
-static void rygel_external_container_real_find_object (RygelMediaContainer* base, const char* id, GCancellable* cancellable, GAsyncReadyCallback callback, void* callback_target) {
-	RygelExternalContainer * self;
-	GError * _inner_error_;
-	RygelSimpleAsyncResult* res;
-	RygelMediaObject* media_object;
-	gboolean _tmp0_ = FALSE;
-	RygelMediaObject* _tmp4_;
-	self = (RygelExternalContainer*) base;
-	g_return_if_fail (id != NULL);
-	_inner_error_ = NULL;
-	res = rygel_simple_async_result_new (RYGEL_TYPE_MEDIA_OBJECT, (GBoxedCopyFunc) g_object_ref, g_object_unref, (GObject*) self, callback, callback_target);
-	media_object = (RygelMediaObject*) rygel_external_container_find_container (self, id);
-	if (media_object == NULL) {
-		_tmp0_ = rygel_external_item_id_valid (id);
-	} else {
-		_tmp0_ = FALSE;
-	}
-	if (_tmp0_) {
-		{
-			RygelExternalItem* _tmp1_;
-			RygelMediaObject* _tmp2_;
-			_tmp1_ = rygel_external_item_new_for_id (id, self, &_inner_error_);
-			if (_inner_error_ != NULL) {
-				goto __catch2_g_error;
-				goto __finally2;
-			}
-			media_object = (_tmp2_ = (RygelMediaObject*) _tmp1_, _g_object_unref0 (media_object), _tmp2_);
-		}
-		goto __finally2;
-		__catch2_g_error:
-		{
-			GError * err;
-			err = _inner_error_;
-			_inner_error_ = NULL;
-			{
-				GError* _tmp3_;
-				res->error = (_tmp3_ = _g_error_copy0 (err), _g_error_free0 (res->error), _tmp3_);
-				_g_error_free0 (err);
-			}
-		}
-		__finally2:
-		if (_inner_error_ != NULL) {
-			_g_object_unref0 (res);
-			_g_object_unref0 (media_object);
-			g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
-			g_clear_error (&_inner_error_);
-			return;
-		}
-	}
-	res->data = (_tmp4_ = _g_object_ref0 (media_object), _g_object_unref0 (res->data), _tmp4_);
-	rygel_simple_async_result_complete_in_idle (res);
-	_g_object_unref0 (res);
-	_g_object_unref0 (media_object);
-}
-
-
-static RygelMediaObject* rygel_external_container_real_find_object_finish (RygelMediaContainer* base, GAsyncResult* res, GError** error) {
-	RygelExternalContainer * self;
-	RygelMediaObject* result;
-	GError * _inner_error_;
-	RygelSimpleAsyncResult* simple_res;
-	self = (RygelExternalContainer*) base;
-	g_return_val_if_fail (res != NULL, NULL);
-	_inner_error_ = NULL;
-	simple_res = _g_object_ref0 (RYGEL_SIMPLE_ASYNC_RESULT (res));
-	if (simple_res->error != NULL) {
-		_inner_error_ = _g_error_copy0 (simple_res->error);
-		if (_inner_error_ != NULL) {
-			g_propagate_error (error, _inner_error_);
-			_g_object_unref0 (simple_res);
-			return NULL;
-		}
-	} else {
-		result = _g_object_ref0 ((RygelMediaObject*) simple_res->data);
-		_g_object_unref0 (simple_res);
-		return result;
-	}
-	_g_object_unref0 (simple_res);
-}
-
-
-static char* string_replace (const char* self, const char* old, const char* replacement) {
-	char* result;
-	GError * _inner_error_;
-	g_return_val_if_fail (self != NULL, NULL);
-	g_return_val_if_fail (old != NULL, NULL);
-	g_return_val_if_fail (replacement != NULL, NULL);
-	_inner_error_ = NULL;
-	{
-		char* _tmp0_;
-		GRegex* _tmp1_;
-		GRegex* regex;
-		char* _tmp2_;
-		regex = (_tmp1_ = g_regex_new (_tmp0_ = g_regex_escape_string (old, -1), 0, 0, &_inner_error_), _g_free0 (_tmp0_), _tmp1_);
-		if (_inner_error_ != NULL) {
-			if (_inner_error_->domain == G_REGEX_ERROR) {
-				goto __catch3_g_regex_error;
-			}
-			goto __finally3;
-		}
-		_tmp2_ = g_regex_replace_literal (regex, self, (glong) (-1), 0, replacement, 0, &_inner_error_);
-		if (_inner_error_ != NULL) {
-			_g_regex_unref0 (regex);
-			if (_inner_error_->domain == G_REGEX_ERROR) {
-				goto __catch3_g_regex_error;
-			}
-			goto __finally3;
-		}
-		result = _tmp2_;
-		_g_regex_unref0 (regex);
-		return result;
-	}
-	goto __finally3;
-	__catch3_g_regex_error:
-	{
-		GError * e;
-		e = _inner_error_;
-		_inner_error_ = NULL;
-		{
-			g_assert_not_reached ();
-			_g_error_free0 (e);
-		}
-	}
-	__finally3:
-	if (_inner_error_ != NULL) {
-		g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
-		g_clear_error (&_inner_error_);
-		return NULL;
-	}
-}
-
-
-char* rygel_external_container_substitute_keywords (RygelExternalContainer* self, const char* title) {
-	char* result;
-	char* new_title;
-	char* _tmp0_;
-	char* _tmp1_;
-	g_return_val_if_fail (self != NULL, NULL);
-	g_return_val_if_fail (title != NULL, NULL);
-	new_title = string_replace (title, "@REALNAME@", g_get_real_name ());
-	new_title = (_tmp0_ = string_replace (new_title, "@USERNAME@", g_get_user_name ()), _g_free0 (new_title), _tmp0_);
-	new_title = (_tmp1_ = string_replace (new_title, "@HOSTNAME@", g_get_host_name ()), _g_free0 (new_title), _tmp1_);
-	result = new_title;
-	return result;
-}
-
-
-static RygelMediaContainer* rygel_external_container_find_container (RygelExternalContainer* self, const char* id) {
-	RygelMediaContainer* result;
-	RygelMediaContainer* container;
-	g_return_val_if_fail (self != NULL, NULL);
-	g_return_val_if_fail (id != NULL, NULL);
-	container = NULL;
-	{
-		GeeIterator* _tmp_it;
-		_tmp_it = gee_abstract_collection_iterator ((GeeAbstractCollection*) self->priv->containers);
-		while (TRUE) {
-			RygelExternalContainer* tmp;
-			if (!gee_iterator_next (_tmp_it)) {
-				break;
-			}
-			tmp = (RygelExternalContainer*) gee_iterator_get (_tmp_it);
-			if (_vala_strcmp0 (id, ((RygelMediaObject*) tmp)->id) == 0) {
-				RygelMediaContainer* _tmp0_;
-				container = (_tmp0_ = _g_object_ref0 ((RygelMediaContainer*) tmp), _g_object_unref0 (container), _tmp0_);
-			} else {
-				RygelMediaContainer* _tmp1_;
-				container = (_tmp1_ = rygel_external_container_find_container (tmp, id), _g_object_unref0 (container), _tmp1_);
-			}
-			if (container != NULL) {
-				_g_object_unref0 (tmp);
-				break;
-			}
-			_g_object_unref0 (tmp);
-		}
-		_g_object_unref0 (_tmp_it);
-	}
-	result = container;
-	return result;
-}
-
-
-void _dynamic_Get2 (DBusGProxy* self, const char* param1, const char* param2, GValue* param3, GError** error) {
-	dbus_g_proxy_call (self, "Get", error, G_TYPE_STRING, param1, G_TYPE_STRING, param2, G_TYPE_INVALID, G_TYPE_VALUE, param3, G_TYPE_INVALID);
-	if (*error) {
-		return;
-	}
-}
-
-
-void _dynamic_Get3 (DBusGProxy* self, const char* param1, const char* param2, GValue* param3, GError** error) {
-	dbus_g_proxy_call (self, "Get", error, G_TYPE_STRING, param1, G_TYPE_STRING, param2, G_TYPE_INVALID, G_TYPE_VALUE, param3, G_TYPE_INVALID);
-	if (*error) {
-		return;
-	}
-}
-
-
-static void rygel_external_container_update_container (RygelExternalContainer* self, GError** error) {
-	GError * _inner_error_;
-	GValue value = {0};
-	GValue _tmp1_;
-	GValue _tmp0_ = {0};
-	GPtrArray* obj_paths;
-	GValue _tmp6_;
-	GValue _tmp5_ = {0};
-	g_return_if_fail (self != NULL);
-	_inner_error_ = NULL;
-	gee_abstract_collection_clear ((GeeAbstractCollection*) self->priv->containers);
-	_dynamic_Get2 (self->props, RYGEL_EXTERNAL_CONTAINER_CONTAINER_IFACE, "Containers", &_tmp0_, &_inner_error_);
-	value = (_tmp1_ = _tmp0_, G_IS_VALUE (&value) ? (g_value_unset (&value), NULL) : NULL, _tmp1_);
-	if (_inner_error_ != NULL) {
-		g_propagate_error (error, _inner_error_);
-		G_IS_VALUE (&value) ? (g_value_unset (&value), NULL) : NULL;
-		return;
-	}
-	obj_paths = (GPtrArray*) g_value_get_boxed (&value);
-	if (obj_paths->len > 0) {
-		{
-			gint i;
-			i = 0;
-			{
-				gboolean _tmp2_;
-				_tmp2_ = TRUE;
-				while (TRUE) {
-					char* obj_path;
-					char* _tmp3_;
-					RygelExternalContainer* _tmp4_;
-					RygelExternalContainer* container;
-					if (!_tmp2_) {
-						i++;
-					}
-					_tmp2_ = FALSE;
-					if (!(i < obj_paths->len)) {
-						break;
-					}
-					obj_path = g_strdup ((const char*) obj_paths->pdata[i]);
-					container = (_tmp4_ = rygel_external_container_new (_tmp3_ = g_strconcat ("container:", (const char*) obj_path, NULL), self->service_name, obj_path, self->host_ip, self), _g_free0 (_tmp3_), _tmp4_);
-					gee_abstract_collection_add ((GeeAbstractCollection*) self->priv->containers, container);
-					_g_free0 (obj_path);
-					_g_object_unref0 (container);
-				}
-			}
-		}
-	}
-	((RygelMediaContainer*) self)->child_count = (guint) gee_collection_get_size ((GeeCollection*) self->priv->containers);
-	_dynamic_Get3 (self->props, RYGEL_EXTERNAL_CONTAINER_CONTAINER_IFACE, "ItemCount", &_tmp5_, &_inner_error_);
-	value = (_tmp6_ = _tmp5_, G_IS_VALUE (&value) ? (g_value_unset (&value), NULL) : NULL, _tmp6_);
-	if (_inner_error_ != NULL) {
-		g_propagate_error (error, _inner_error_);
-		G_IS_VALUE (&value) ? (g_value_unset (&value), NULL) : NULL;
-		return;
-	}
-	((RygelMediaContainer*) self)->child_count = ((RygelMediaContainer*) self)->child_count + g_value_get_uint (&value);
-	G_IS_VALUE (&value) ? (g_value_unset (&value), NULL) : NULL;
-}
-
-
-static void rygel_external_container_on_container_updated (RygelExternalContainer* self, DBusGProxy* actual_container) {
-	GError * _inner_error_;
-	g_return_if_fail (self != NULL);
-	g_return_if_fail (actual_container != NULL);
-	_inner_error_ = NULL;
-	{
-		rygel_external_container_update_container (self, &_inner_error_);
-		if (_inner_error_ != NULL) {
-			goto __catch4_g_error;
-			goto __finally4;
-		}
-	}
-	goto __finally4;
-	__catch4_g_error:
-	{
-		GError * err;
-		err = _inner_error_;
-		_inner_error_ = NULL;
-		{
-			g_warning ("rygel-external-container.vala:226: Failed to update information about container '%s': %s\n", ((RygelMediaObject*) self)->id, err->message);
-			_g_error_free0 (err);
-		}
-	}
-	__finally4:
-	if (_inner_error_ != NULL) {
-		g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
-		g_clear_error (&_inner_error_);
-		return;
-	}
-	rygel_media_container_updated ((RygelMediaContainer*) self);
-}
-
-
-static void rygel_external_container_class_init (RygelExternalContainerClass * klass) {
-	rygel_external_container_parent_class = g_type_class_peek_parent (klass);
-	g_type_class_add_private (klass, sizeof (RygelExternalContainerPrivate));
-	RYGEL_MEDIA_CONTAINER_CLASS (klass)->get_children = rygel_external_container_real_get_children;
-	RYGEL_MEDIA_CONTAINER_CLASS (klass)->get_children_finish = rygel_external_container_real_get_children_finish;
-	RYGEL_MEDIA_CONTAINER_CLASS (klass)->find_object = rygel_external_container_real_find_object;
-	RYGEL_MEDIA_CONTAINER_CLASS (klass)->find_object_finish = rygel_external_container_real_find_object_finish;
-	G_OBJECT_CLASS (klass)->finalize = rygel_external_container_finalize;
-	rygel_external_container_PROPS_IFACE = g_strdup ("org.freedesktop.DBus.Properties");
-}
-
-
-static void rygel_external_container_instance_init (RygelExternalContainer * self) {
-	self->priv = RYGEL_EXTERNAL_CONTAINER_GET_PRIVATE (self);
-}
-
-
-static void rygel_external_container_finalize (GObject* obj) {
-	RygelExternalContainer * self;
-	self = RYGEL_EXTERNAL_CONTAINER (obj);
-	_g_object_unref0 (self->actual_container);
-	_g_object_unref0 (self->props);
-	_g_free0 (self->host_ip);
-	_g_free0 (self->service_name);
-	_g_free0 (self->priv->object_path);
-	_g_object_unref0 (self->priv->containers);
-	G_OBJECT_CLASS (rygel_external_container_parent_class)->finalize (obj);
-}
-
-
-GType rygel_external_container_get_type (void) {
-	static GType rygel_external_container_type_id = 0;
-	if (rygel_external_container_type_id == 0) {
-		static const GTypeInfo g_define_type_info = { sizeof (RygelExternalContainerClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) rygel_external_container_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (RygelExternalContainer), 0, (GInstanceInitFunc) rygel_external_container_instance_init, NULL };
-		rygel_external_container_type_id = g_type_register_static (RYGEL_TYPE_MEDIA_CONTAINER, "RygelExternalContainer", &g_define_type_info, 0);
-	}
-	return rygel_external_container_type_id;
-}
-
-
-static int _vala_strcmp0 (const char * str1, const char * str2) {
-	if (str1 == NULL) {
-		return -(str1 != str2);
-	}
-	if (str2 == NULL) {
-		return str1 != str2;
-	}
-	return strcmp (str1, str2);
-}
-
-
-
-
--- a/src/plugins/external/rygel-external-content-dir.c
+++ /dev/null
@@ -1,160 +0,0 @@
-/* rygel-external-content-dir.c generated by valac, the Vala compiler
- * generated from rygel-external-content-dir.vala, do not modify */
-
-/*
- * Copyright (C) 2009 Zeeshan Ali (Khattak) <zeeshanak@gnome.org>.
- * Copyright (C) 2009 Nokia Corporation.
- *
- * Author: Zeeshan Ali (Khattak) <zeeshanak@gnome.org>
- *                               <zeeshan.ali@nokia.com>
- *
- * This file is part of Rygel.
- *
- * Rygel is free software; you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * Rygel is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this program; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
- */
-
-#include <glib.h>
-#include <glib-object.h>
-#include <rygel.h>
-#include <libgupnp/gupnp.h>
-#include <stdlib.h>
-#include <string.h>
-#include <libgssdp/gssdp.h>
-
-
-#define RYGEL_TYPE_EXTERNAL_CONTENT_DIR (rygel_external_content_dir_get_type ())
-#define RYGEL_EXTERNAL_CONTENT_DIR(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_EXTERNAL_CONTENT_DIR, RygelExternalContentDir))
-#define RYGEL_EXTERNAL_CONTENT_DIR_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_EXTERNAL_CONTENT_DIR, RygelExternalContentDirClass))
-#define RYGEL_IS_EXTERNAL_CONTENT_DIR(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_EXTERNAL_CONTENT_DIR))
-#define RYGEL_IS_EXTERNAL_CONTENT_DIR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_EXTERNAL_CONTENT_DIR))
-#define RYGEL_EXTERNAL_CONTENT_DIR_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_EXTERNAL_CONTENT_DIR, RygelExternalContentDirClass))
-
-typedef struct _RygelExternalContentDir RygelExternalContentDir;
-typedef struct _RygelExternalContentDirClass RygelExternalContentDirClass;
-typedef struct _RygelExternalContentDirPrivate RygelExternalContentDirPrivate;
-#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
-
-#define RYGEL_TYPE_EXTERNAL_PLUGIN (rygel_external_plugin_get_type ())
-#define RYGEL_EXTERNAL_PLUGIN(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_EXTERNAL_PLUGIN, RygelExternalPlugin))
-#define RYGEL_EXTERNAL_PLUGIN_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_EXTERNAL_PLUGIN, RygelExternalPluginClass))
-#define RYGEL_IS_EXTERNAL_PLUGIN(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_EXTERNAL_PLUGIN))
-#define RYGEL_IS_EXTERNAL_PLUGIN_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_EXTERNAL_PLUGIN))
-#define RYGEL_EXTERNAL_PLUGIN_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_EXTERNAL_PLUGIN, RygelExternalPluginClass))
-
-typedef struct _RygelExternalPlugin RygelExternalPlugin;
-typedef struct _RygelExternalPluginClass RygelExternalPluginClass;
-typedef struct _RygelExternalPluginPrivate RygelExternalPluginPrivate;
-
-#define RYGEL_TYPE_EXTERNAL_CONTAINER (rygel_external_container_get_type ())
-#define RYGEL_EXTERNAL_CONTAINER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_EXTERNAL_CONTAINER, RygelExternalContainer))
-#define RYGEL_EXTERNAL_CONTAINER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_EXTERNAL_CONTAINER, RygelExternalContainerClass))
-#define RYGEL_IS_EXTERNAL_CONTAINER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_EXTERNAL_CONTAINER))
-#define RYGEL_IS_EXTERNAL_CONTAINER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_EXTERNAL_CONTAINER))
-#define RYGEL_EXTERNAL_CONTAINER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_EXTERNAL_CONTAINER, RygelExternalContainerClass))
-
-typedef struct _RygelExternalContainer RygelExternalContainer;
-typedef struct _RygelExternalContainerClass RygelExternalContainerClass;
-
-struct _RygelExternalContentDir {
-	RygelContentDirectory parent_instance;
-	RygelExternalContentDirPrivate * priv;
-};
-
-struct _RygelExternalContentDirClass {
-	RygelContentDirectoryClass parent_class;
-};
-
-struct _RygelExternalPlugin {
-	RygelPlugin parent_instance;
-	RygelExternalPluginPrivate * priv;
-	char* service_name;
-	char* root_object;
-};
-
-struct _RygelExternalPluginClass {
-	RygelPluginClass parent_class;
-};
-
-
-static gpointer rygel_external_content_dir_parent_class = NULL;
-
-GType rygel_external_content_dir_get_type (void);
-enum  {
-	RYGEL_EXTERNAL_CONTENT_DIR_DUMMY_PROPERTY
-};
-GType rygel_external_plugin_get_type (void);
-GType rygel_external_container_get_type (void);
-RygelExternalContainer* rygel_external_container_new (const char* id, const char* service_name, const char* object_path, const char* host_ip, RygelExternalContainer* parent);
-RygelExternalContainer* rygel_external_container_construct (GType object_type, const char* id, const char* service_name, const char* object_path, const char* host_ip, RygelExternalContainer* parent);
-static RygelMediaContainer* rygel_external_content_dir_real_create_root_container (RygelContentDirectory* base);
-RygelExternalContentDir* rygel_external_content_dir_new (void);
-RygelExternalContentDir* rygel_external_content_dir_construct (GType object_type);
-
-
-
-static gpointer _g_object_ref0 (gpointer self) {
-	return self ? g_object_ref (self) : NULL;
-}
-
-
-static RygelMediaContainer* rygel_external_content_dir_real_create_root_container (RygelContentDirectory* base) {
-	RygelExternalContentDir * self;
-	RygelMediaContainer* result;
-	GUPnPRootDevice* _tmp1_;
-	GUPnPRootDevice* _tmp0_ = NULL;
-	RygelExternalPlugin* _tmp2_;
-	RygelExternalPlugin* plugin;
-	self = (RygelExternalContentDir*) base;
-	plugin = (_tmp2_ = _g_object_ref0 (RYGEL_EXTERNAL_PLUGIN (gupnp_device_info_get_resource_factory ((GUPnPDeviceInfo*) (_tmp1_ = (g_object_get ((GUPnPService*) self, "root-device", &_tmp0_, NULL), _tmp0_))))), _g_object_unref0 (_tmp1_), _tmp2_);
-	result = (RygelMediaContainer*) rygel_external_container_new ("0", plugin->service_name, plugin->root_object, gssdp_client_get_host_ip ((GSSDPClient*) gupnp_service_info_get_context ((GUPnPServiceInfo*) self)), NULL);
-	_g_object_unref0 (plugin);
-	return result;
-}
-
-
-RygelExternalContentDir* rygel_external_content_dir_construct (GType object_type) {
-	RygelExternalContentDir * self;
-	self = (RygelExternalContentDir*) rygel_content_directory_construct (object_type);
-	return self;
-}
-
-
-RygelExternalContentDir* rygel_external_content_dir_new (void) {
-	return rygel_external_content_dir_construct (RYGEL_TYPE_EXTERNAL_CONTENT_DIR);
-}
-
-
-static void rygel_external_content_dir_class_init (RygelExternalContentDirClass * klass) {
-	rygel_external_content_dir_parent_class = g_type_class_peek_parent (klass);
-	RYGEL_CONTENT_DIRECTORY_CLASS (klass)->create_root_container = rygel_external_content_dir_real_create_root_container;
-}
-
-
-static void rygel_external_content_dir_instance_init (RygelExternalContentDir * self) {
-}
-
-
-GType rygel_external_content_dir_get_type (void) {
-	static GType rygel_external_content_dir_type_id = 0;
-	if (rygel_external_content_dir_type_id == 0) {
-		static const GTypeInfo g_define_type_info = { sizeof (RygelExternalContentDirClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) rygel_external_content_dir_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (RygelExternalContentDir), 0, (GInstanceInitFunc) rygel_external_content_dir_instance_init, NULL };
-		rygel_external_content_dir_type_id = g_type_register_static (RYGEL_TYPE_CONTENT_DIRECTORY, "RygelExternalContentDir", &g_define_type_info, 0);
-	}
-	return rygel_external_content_dir_type_id;
-}
-
-
-
-
--- a/src/plugins/external/rygel-external-item.c
+++ /dev/null
@@ -1,455 +0,0 @@
-/* rygel-external-item.c generated by valac, the Vala compiler
- * generated from rygel-external-item.vala, do not modify */
-
-/*
- * Copyright (C) 2009 Zeeshan Ali (Khattak) <zeeshanak@gnome.org>.
- * Copyright (C) 2009 Nokia Corporation.
- *
- * Author: Zeeshan Ali (Khattak) <zeeshanak@gnome.org>
- *                               <zeeshan.ali@nokia.com>
- *
- * This file is part of Rygel.
- *
- * Rygel is free software; you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * Rygel is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this program; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
- */
-
-#include <glib.h>
-#include <glib-object.h>
-#include <rygel.h>
-#include <stdlib.h>
-#include <string.h>
-#include <dbus/dbus-glib-lowlevel.h>
-#include <dbus/dbus-glib.h>
-
-
-#define RYGEL_TYPE_EXTERNAL_ITEM (rygel_external_item_get_type ())
-#define RYGEL_EXTERNAL_ITEM(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_EXTERNAL_ITEM, RygelExternalItem))
-#define RYGEL_EXTERNAL_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_EXTERNAL_ITEM, RygelExternalItemClass))
-#define RYGEL_IS_EXTERNAL_ITEM(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_EXTERNAL_ITEM))
-#define RYGEL_IS_EXTERNAL_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_EXTERNAL_ITEM))
-#define RYGEL_EXTERNAL_ITEM_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_EXTERNAL_ITEM, RygelExternalItemClass))
-
-typedef struct _RygelExternalItem RygelExternalItem;
-typedef struct _RygelExternalItemClass RygelExternalItemClass;
-typedef struct _RygelExternalItemPrivate RygelExternalItemPrivate;
-
-#define RYGEL_TYPE_EXTERNAL_CONTAINER (rygel_external_container_get_type ())
-#define RYGEL_EXTERNAL_CONTAINER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_EXTERNAL_CONTAINER, RygelExternalContainer))
-#define RYGEL_EXTERNAL_CONTAINER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_EXTERNAL_CONTAINER, RygelExternalContainerClass))
-#define RYGEL_IS_EXTERNAL_CONTAINER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_EXTERNAL_CONTAINER))
-#define RYGEL_IS_EXTERNAL_CONTAINER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_EXTERNAL_CONTAINER))
-#define RYGEL_EXTERNAL_CONTAINER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_EXTERNAL_CONTAINER, RygelExternalContainerClass))
-
-typedef struct _RygelExternalContainer RygelExternalContainer;
-typedef struct _RygelExternalContainerClass RygelExternalContainerClass;
-#define _g_free0(var) (var = (g_free (var), NULL))
-typedef struct _RygelExternalContainerPrivate RygelExternalContainerPrivate;
-#define _dbus_g_connection_unref0(var) ((var == NULL) ? NULL : (var = (dbus_g_connection_unref (var), NULL)))
-#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
-#define _g_hash_table_unref0(var) ((var == NULL) ? NULL : (var = (g_hash_table_unref (var), NULL)))
-#define _g_regex_unref0(var) ((var == NULL) ? NULL : (var = (g_regex_unref (var), NULL)))
-#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
-
-struct _RygelExternalItem {
-	RygelMediaItem parent_instance;
-	RygelExternalItemPrivate * priv;
-};
-
-struct _RygelExternalItemClass {
-	RygelMediaItemClass parent_class;
-};
-
-struct _RygelExternalContainer {
-	RygelMediaContainer parent_instance;
-	RygelExternalContainerPrivate * priv;
-	DBusGProxy* actual_container;
-	DBusGProxy* props;
-	char* host_ip;
-	char* service_name;
-};
-
-struct _RygelExternalContainerClass {
-	RygelMediaContainerClass parent_class;
-};
-
-
-static char* rygel_external_item_PROPS_IFACE;
-static char* rygel_external_item_PROPS_IFACE = NULL;
-static char* rygel_external_item_OBJECT_IFACE;
-static char* rygel_external_item_OBJECT_IFACE = NULL;
-static char* rygel_external_item_ITEM_IFACE;
-static char* rygel_external_item_ITEM_IFACE = NULL;
-static gpointer rygel_external_item_parent_class = NULL;
-
-GType rygel_external_item_get_type (void);
-enum  {
-	RYGEL_EXTERNAL_ITEM_DUMMY_PROPERTY
-};
-GType rygel_external_container_get_type (void);
-static RygelExternalItem* rygel_external_item_new (const char* id, const char* object_path, RygelExternalContainer* parent, GError** error);
-static RygelExternalItem* rygel_external_item_construct (GType object_type, const char* id, const char* object_path, RygelExternalContainer* parent, GError** error);
-RygelExternalItem* rygel_external_item_new_for_path (const char* object_path, RygelExternalContainer* parent, GError** error);
-RygelExternalItem* rygel_external_item_construct_for_path (GType object_type, const char* object_path, RygelExternalContainer* parent, GError** error);
-RygelExternalItem* rygel_external_item_new_for_id (const char* id, RygelExternalContainer* parent, GError** error);
-RygelExternalItem* rygel_external_item_construct_for_id (GType object_type, const char* id, RygelExternalContainer* parent, GError** error);
-GHashTable* _dynamic_GetAll4 (DBusGProxy* self, const char* param1, GError** error);
-static GValue* _g_value_dup (GValue* self);
-char* rygel_external_container_substitute_keywords (RygelExternalContainer* self, const char* title);
-void _dynamic_GetAll5 (DBusGProxy* self, const char* param1, GHashTable** param2, GError** error);
-gboolean rygel_external_item_id_valid (const char* id);
-static void rygel_external_item_finalize (GObject* obj);
-static int _vala_strcmp0 (const char * str1, const char * str2);
-
-
-
-RygelExternalItem* rygel_external_item_construct_for_path (GType object_type, const char* object_path, RygelExternalContainer* parent, GError** error) {
-	RygelExternalItem * self;
-	char* _tmp0_;
-	g_return_val_if_fail (object_path != NULL, NULL);
-	g_return_val_if_fail (parent != NULL, NULL);
-	self = (RygelExternalItem*) rygel_external_item_construct (object_type, _tmp0_ = g_strconcat ("item:", object_path, NULL), object_path, parent, error);
-	_g_free0 (_tmp0_);
-	return self;
-}
-
-
-RygelExternalItem* rygel_external_item_new_for_path (const char* object_path, RygelExternalContainer* parent, GError** error) {
-	return rygel_external_item_construct_for_path (RYGEL_TYPE_EXTERNAL_ITEM, object_path, parent, error);
-}
-
-
-RygelExternalItem* rygel_external_item_construct_for_id (GType object_type, const char* id, RygelExternalContainer* parent, GError** error) {
-	RygelExternalItem * self;
-	char* object_path;
-	g_return_val_if_fail (id != NULL, NULL);
-	g_return_val_if_fail (parent != NULL, NULL);
-	object_path = g_strdup (strstr (id, "/"));
-	g_assert (object_path != NULL);
-	self = (RygelExternalItem*) rygel_external_item_construct (object_type, id, object_path, parent, error);
-	_g_free0 (object_path);
-	return self;
-}
-
-
-RygelExternalItem* rygel_external_item_new_for_id (const char* id, RygelExternalContainer* parent, GError** error) {
-	return rygel_external_item_construct_for_id (RYGEL_TYPE_EXTERNAL_ITEM, id, parent, error);
-}
-
-
-GHashTable* _dynamic_GetAll4 (DBusGProxy* self, const char* param1, GError** error) {
-	GHashTable* result;
-	dbus_g_proxy_call (self, "GetAll", error, G_TYPE_STRING, param1, G_TYPE_INVALID, dbus_g_type_get_map ("GHashTable", G_TYPE_STRING, G_TYPE_VALUE), &result, G_TYPE_INVALID);
-	if (*error) {
-		return NULL;
-	}
-	return result;
-}
-
-
-static GValue* _g_value_dup (GValue* self) {
-	return g_boxed_copy (G_TYPE_VALUE, self);
-}
-
-
-static gpointer __g_value_dup0 (gpointer self) {
-	return self ? _g_value_dup (self) : NULL;
-}
-
-
-void _dynamic_GetAll5 (DBusGProxy* self, const char* param1, GHashTable** param2, GError** error) {
-	dbus_g_proxy_call (self, "GetAll", error, G_TYPE_STRING, param1, G_TYPE_INVALID, dbus_g_type_get_map ("GHashTable", G_TYPE_STRING, G_TYPE_VALUE), param2, G_TYPE_INVALID);
-	if (*error) {
-		return;
-	}
-}
-
-
-static char* string_replace (const char* self, const char* old, const char* replacement) {
-	char* result;
-	GError * _inner_error_;
-	g_return_val_if_fail (self != NULL, NULL);
-	g_return_val_if_fail (old != NULL, NULL);
-	g_return_val_if_fail (replacement != NULL, NULL);
-	_inner_error_ = NULL;
-	{
-		char* _tmp0_;
-		GRegex* _tmp1_;
-		GRegex* regex;
-		char* _tmp2_;
-		regex = (_tmp1_ = g_regex_new (_tmp0_ = g_regex_escape_string (old, -1), 0, 0, &_inner_error_), _g_free0 (_tmp0_), _tmp1_);
-		if (_inner_error_ != NULL) {
-			if (_inner_error_->domain == G_REGEX_ERROR) {
-				goto __catch5_g_regex_error;
-			}
-			goto __finally5;
-		}
-		_tmp2_ = g_regex_replace_literal (regex, self, (glong) (-1), 0, replacement, 0, &_inner_error_);
-		if (_inner_error_ != NULL) {
-			_g_regex_unref0 (regex);
-			if (_inner_error_->domain == G_REGEX_ERROR) {
-				goto __catch5_g_regex_error;
-			}
-			goto __finally5;
-		}
-		result = _tmp2_;
-		_g_regex_unref0 (regex);
-		return result;
-	}
-	goto __finally5;
-	__catch5_g_regex_error:
-	{
-		GError * e;
-		e = _inner_error_;
-		_inner_error_ = NULL;
-		{
-			g_assert_not_reached ();
-			_g_error_free0 (e);
-		}
-	}
-	__finally5:
-	if (_inner_error_ != NULL) {
-		g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
-		g_clear_error (&_inner_error_);
-		return NULL;
-	}
-}
-
-
-static RygelExternalItem* rygel_external_item_construct (GType object_type, const char* id, const char* object_path, RygelExternalContainer* parent, GError** error) {
-	GError * _inner_error_;
-	RygelExternalItem * self;
-	DBusGConnection* connection;
-	DBusGProxy* props;
-	GHashTable* object_props;
-	GValue* value;
-	char* _tmp0_;
-	GHashTable* item_props;
-	GHashTable* _tmp2_;
-	GHashTable* _tmp1_ = NULL;
-	GValue* _tmp3_;
-	char* type;
-	GValue* _tmp8_;
-	char* _tmp9_;
-	GValue* _tmp10_;
-	char** _tmp11_;
-	gint uris_size;
-	gint uris_length1;
-	char** uris;
-	GValue* _tmp13_;
-	GValue* _tmp15_;
-	GValue* _tmp16_;
-	GValue* _tmp18_;
-	GValue* _tmp20_;
-	GValue* _tmp22_;
-	GValue* _tmp23_;
-	GValue* _tmp24_;
-	GValue* _tmp25_;
-	GValue* _tmp26_;
-	GValue* _tmp27_;
-	GValue* _tmp28_;
-	g_return_val_if_fail (id != NULL, NULL);
-	g_return_val_if_fail (object_path != NULL, NULL);
-	g_return_val_if_fail (parent != NULL, NULL);
-	_inner_error_ = NULL;
-	self = (RygelExternalItem*) rygel_media_item_construct (object_type, id, (RygelMediaContainer*) parent, "Unknown", "Unknown");
-	connection = dbus_g_bus_get (DBUS_BUS_SESSION, &_inner_error_);
-	if (_inner_error_ != NULL) {
-		g_propagate_error (error, _inner_error_);
-		return;
-	}
-	props = dbus_g_proxy_new_for_name (connection, parent->service_name, object_path, rygel_external_item_PROPS_IFACE);
-	object_props = _dynamic_GetAll4 (props, rygel_external_item_OBJECT_IFACE, &_inner_error_);
-	if (_inner_error_ != NULL) {
-		g_propagate_error (error, _inner_error_);
-		_dbus_g_connection_unref0 (connection);
-		_g_object_unref0 (props);
-		return;
-	}
-	value = __g_value_dup0 ((GValue*) g_hash_table_lookup (object_props, "DisplayName"));
-	((RygelMediaObject*) self)->title = (_tmp0_ = rygel_external_container_substitute_keywords (parent, g_value_get_string (value)), _g_free0 (((RygelMediaObject*) self)->title), _tmp0_);
-	item_props = NULL;
-	_dynamic_GetAll5 (props, rygel_external_item_ITEM_IFACE, &_tmp1_, &_inner_error_);
-	item_props = (_tmp2_ = _tmp1_, _g_hash_table_unref0 (item_props), _tmp2_);
-	if (_inner_error_ != NULL) {
-		g_propagate_error (error, _inner_error_);
-		_dbus_g_connection_unref0 (connection);
-		_g_object_unref0 (props);
-		_g_hash_table_unref0 (object_props);
-		_g_free0 (value);
-		_g_hash_table_unref0 (item_props);
-		return;
-	}
-	value = (_tmp3_ = __g_value_dup0 ((GValue*) g_hash_table_lookup (item_props, "Type")), _g_free0 (value), _tmp3_);
-	type = g_strdup (g_value_get_string (value));
-	if (_vala_strcmp0 (type, "audio") == 0) {
-		char* _tmp4_;
-		((RygelMediaItem*) self)->upnp_class = (_tmp4_ = g_strdup (RYGEL_MEDIA_ITEM_AUDIO_CLASS), _g_free0 (((RygelMediaItem*) self)->upnp_class), _tmp4_);
-	} else {
-		if (_vala_strcmp0 (type, "music") == 0) {
-			char* _tmp5_;
-			((RygelMediaItem*) self)->upnp_class = (_tmp5_ = g_strdup (RYGEL_MEDIA_ITEM_MUSIC_CLASS), _g_free0 (((RygelMediaItem*) self)->upnp_class), _tmp5_);
-		} else {
-			if (_vala_strcmp0 (type, "video") == 0) {
-				char* _tmp6_;
-				((RygelMediaItem*) self)->upnp_class = (_tmp6_ = g_strdup (RYGEL_MEDIA_ITEM_VIDEO_CLASS), _g_free0 (((RygelMediaItem*) self)->upnp_class), _tmp6_);
-			} else {
-				char* _tmp7_;
-				((RygelMediaItem*) self)->upnp_class = (_tmp7_ = g_strdup (RYGEL_MEDIA_ITEM_IMAGE_CLASS), _g_free0 (((RygelMediaItem*) self)->upnp_class), _tmp7_);
-			}
-		}
-	}
-	value = (_tmp8_ = __g_value_dup0 ((GValue*) g_hash_table_lookup (item_props, "MIMEType")), _g_free0 (value), _tmp8_);
-	((RygelMediaItem*) self)->mime_type = (_tmp9_ = g_strdup (g_value_get_string (value)), _g_free0 (((RygelMediaItem*) self)->mime_type), _tmp9_);
-	value = (_tmp10_ = __g_value_dup0 ((GValue*) g_hash_table_lookup (item_props, "URLs")), _g_free0 (value), _tmp10_);
-	uris = (_tmp11_ = (char**) g_value_get_boxed (value), uris_length1 = -1, uris_size = uris_length1, _tmp11_);
-	{
-		gint i;
-		i = 0;
-		{
-			gboolean _tmp12_;
-			_tmp12_ = TRUE;
-			while (TRUE) {
-				char* tmp;
-				if (!_tmp12_) {
-					i++;
-				}
-				_tmp12_ = FALSE;
-				if (!(uris[i] != NULL)) {
-					break;
-				}
-				tmp = string_replace (uris[i], "@ADDRESS@", parent->host_ip);
-				rygel_media_item_add_uri ((RygelMediaItem*) self, tmp, NULL);
-				_g_free0 (tmp);
-			}
-		}
-	}
-	value = (_tmp13_ = __g_value_dup0 ((GValue*) g_hash_table_lookup (item_props, "DLNAProfile")), _g_free0 (value), _tmp13_);
-	if (value != NULL) {
-		char* _tmp14_;
-		((RygelMediaItem*) self)->dlna_profile = (_tmp14_ = g_strdup (g_value_get_string (value)), _g_free0 (((RygelMediaItem*) self)->dlna_profile), _tmp14_);
-	}
-	value = (_tmp15_ = __g_value_dup0 ((GValue*) g_hash_table_lookup (item_props, "Size")), _g_free0 (value), _tmp15_);
-	if (value != NULL) {
-		((RygelMediaItem*) self)->size = (glong) g_value_get_int (value);
-	}
-	value = (_tmp16_ = __g_value_dup0 ((GValue*) g_hash_table_lookup (item_props, "Artist")), _g_free0 (value), _tmp16_);
-	if (value != NULL) {
-		char* _tmp17_;
-		((RygelMediaItem*) self)->author = (_tmp17_ = g_strdup (g_value_get_string (value)), _g_free0 (((RygelMediaItem*) self)->author), _tmp17_);
-	}
-	value = (_tmp18_ = __g_value_dup0 ((GValue*) g_hash_table_lookup (item_props, "Album")), _g_free0 (value), _tmp18_);
-	if (value != NULL) {
-		char* _tmp19_;
-		((RygelMediaItem*) self)->album = (_tmp19_ = g_strdup (g_value_get_string (value)), _g_free0 (((RygelMediaItem*) self)->album), _tmp19_);
-	}
-	value = (_tmp20_ = __g_value_dup0 ((GValue*) g_hash_table_lookup (item_props, "Date")), _g_free0 (value), _tmp20_);
-	if (value != NULL) {
-		char* _tmp21_;
-		((RygelMediaItem*) self)->date = (_tmp21_ = g_strdup (g_value_get_string (value)), _g_free0 (((RygelMediaItem*) self)->date), _tmp21_);
-	}
-	value = (_tmp22_ = __g_value_dup0 ((GValue*) g_hash_table_lookup (item_props, "Duration")), _g_free0 (value), _tmp22_);
-	if (value != NULL) {
-		((RygelMediaItem*) self)->duration = (glong) g_value_get_int (value);
-	}
-	value = (_tmp23_ = __g_value_dup0 ((GValue*) g_hash_table_lookup (item_props, "Bitrate")), _g_free0 (value), _tmp23_);
-	if (value != NULL) {
-		((RygelMediaItem*) self)->bitrate = g_value_get_int (value);
-	}
-	value = (_tmp24_ = __g_value_dup0 ((GValue*) g_hash_table_lookup (item_props, "SampleRate")), _g_free0 (value), _tmp24_);
-	if (value != NULL) {
-		((RygelMediaItem*) self)->sample_freq = g_value_get_int (value);
-	}
-	value = (_tmp25_ = __g_value_dup0 ((GValue*) g_hash_table_lookup (item_props, "BitsPerSample")), _g_free0 (value), _tmp25_);
-	if (value != NULL) {
-		((RygelMediaItem*) self)->bits_per_sample = g_value_get_int (value);
-	}
-	value = (_tmp26_ = __g_value_dup0 ((GValue*) g_hash_table_lookup (item_props, "Width")), _g_free0 (value), _tmp26_);
-	if (value != NULL) {
-		((RygelMediaItem*) self)->width = g_value_get_int (value);
-	}
-	value = (_tmp27_ = __g_value_dup0 ((GValue*) g_hash_table_lookup (item_props, "Height")), _g_free0 (value), _tmp27_);
-	if (value != NULL) {
-		((RygelMediaItem*) self)->height = g_value_get_int (value);
-	}
-	value = (_tmp28_ = __g_value_dup0 ((GValue*) g_hash_table_lookup (item_props, "ColorDepth")), _g_free0 (value), _tmp28_);
-	if (value != NULL) {
-		((RygelMediaItem*) self)->color_depth = g_value_get_int (value);
-	}
-	_dbus_g_connection_unref0 (connection);
-	_g_object_unref0 (props);
-	_g_hash_table_unref0 (object_props);
-	_g_free0 (value);
-	_g_hash_table_unref0 (item_props);
-	_g_free0 (type);
-	return self;
-}
-
-
-static RygelExternalItem* rygel_external_item_new (const char* id, const char* object_path, RygelExternalContainer* parent, GError** error) {
-	return rygel_external_item_construct (RYGEL_TYPE_EXTERNAL_ITEM, id, object_path, parent, error);
-}
-
-
-gboolean rygel_external_item_id_valid (const char* id) {
-	gboolean result;
-	g_return_val_if_fail (id != NULL, FALSE);
-	result = g_str_has_prefix (id, "item:/");
-	return result;
-}
-
-
-static void rygel_external_item_class_init (RygelExternalItemClass * klass) {
-	rygel_external_item_parent_class = g_type_class_peek_parent (klass);
-	G_OBJECT_CLASS (klass)->finalize = rygel_external_item_finalize;
-	rygel_external_item_PROPS_IFACE = g_strdup ("org.freedesktop.DBus.Properties");
-	rygel_external_item_OBJECT_IFACE = g_strdup ("org.gnome.UPnP.MediaObject1");
-	rygel_external_item_ITEM_IFACE = g_strdup ("org.gnome.UPnP.MediaItem1");
-}
-
-
-static void rygel_external_item_instance_init (RygelExternalItem * self) {
-}
-
-
-static void rygel_external_item_finalize (GObject* obj) {
-	RygelExternalItem * self;
-	self = RYGEL_EXTERNAL_ITEM (obj);
-	G_OBJECT_CLASS (rygel_external_item_parent_class)->finalize (obj);
-}
-
-
-GType rygel_external_item_get_type (void) {
-	static GType rygel_external_item_type_id = 0;
-	if (rygel_external_item_type_id == 0) {
-		static const GTypeInfo g_define_type_info = { sizeof (RygelExternalItemClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) rygel_external_item_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (RygelExternalItem), 0, (GInstanceInitFunc) rygel_external_item_instance_init, NULL };
-		rygel_external_item_type_id = g_type_register_static (RYGEL_TYPE_MEDIA_ITEM, "RygelExternalItem", &g_define_type_info, 0);
-	}
-	return rygel_external_item_type_id;
-}
-
-
-static int _vala_strcmp0 (const char * str1, const char * str2) {
-	if (str1 == NULL) {
-		return -(str1 != str2);
-	}
-	if (str2 == NULL) {
-		return str1 != str2;
-	}
-	return strcmp (str1, str2);
-}
-
-
-
-
--- a/src/plugins/external/rygel-external-plugin-factory.c
+++ /dev/null
@@ -1,513 +0,0 @@
-/* rygel-external-plugin-factory.c generated by valac, the Vala compiler
- * generated from rygel-external-plugin-factory.vala, do not modify */
-
-/*
- * Copyright (C) 2009 Zeeshan Ali (Khattak) <zeeshanak@gnome.org>.
- * Copyright (C) 2009 Nokia Corporation.
- *
- * Author: Zeeshan Ali (Khattak) <zeeshanak@gnome.org>
- *                               <zeeshan.ali@nokia.com>
- *
- * This file is part of Rygel.
- *
- * Rygel is free software; you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * Rygel is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this program; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
- */
-
-#include <glib.h>
-#include <glib-object.h>
-#include <rygel.h>
-#include <dbus/dbus-glib-lowlevel.h>
-#include <dbus/dbus-glib.h>
-#include <stdlib.h>
-#include <string.h>
-#include <gobject/gvaluecollector.h>
-
-
-#define TYPE_EXTERNAL_PLUGIN_FACTORY (external_plugin_factory_get_type ())
-#define EXTERNAL_PLUGIN_FACTORY(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_EXTERNAL_PLUGIN_FACTORY, ExternalPluginFactory))
-#define EXTERNAL_PLUGIN_FACTORY_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_EXTERNAL_PLUGIN_FACTORY, ExternalPluginFactoryClass))
-#define IS_EXTERNAL_PLUGIN_FACTORY(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_EXTERNAL_PLUGIN_FACTORY))
-#define IS_EXTERNAL_PLUGIN_FACTORY_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_EXTERNAL_PLUGIN_FACTORY))
-#define EXTERNAL_PLUGIN_FACTORY_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_EXTERNAL_PLUGIN_FACTORY, ExternalPluginFactoryClass))
-
-typedef struct _ExternalPluginFactory ExternalPluginFactory;
-typedef struct _ExternalPluginFactoryClass ExternalPluginFactoryClass;
-#define _external_plugin_factory_unref0(var) ((var == NULL) ? NULL : (var = (external_plugin_factory_unref (var), NULL)))
-#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
-typedef struct _ExternalPluginFactoryPrivate ExternalPluginFactoryPrivate;
-#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
-#define _dbus_g_connection_unref0(var) ((var == NULL) ? NULL : (var = (dbus_g_connection_unref (var), NULL)))
-
-#define RYGEL_TYPE_EXTERNAL_PLUGIN (rygel_external_plugin_get_type ())
-#define RYGEL_EXTERNAL_PLUGIN(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_EXTERNAL_PLUGIN, RygelExternalPlugin))
-#define RYGEL_EXTERNAL_PLUGIN_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_EXTERNAL_PLUGIN, RygelExternalPluginClass))
-#define RYGEL_IS_EXTERNAL_PLUGIN(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_EXTERNAL_PLUGIN))
-#define RYGEL_IS_EXTERNAL_PLUGIN_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_EXTERNAL_PLUGIN))
-#define RYGEL_EXTERNAL_PLUGIN_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_EXTERNAL_PLUGIN, RygelExternalPluginClass))
-
-typedef struct _RygelExternalPlugin RygelExternalPlugin;
-typedef struct _RygelExternalPluginClass RygelExternalPluginClass;
-#define _g_free0(var) (var = (g_free (var), NULL))
-typedef struct _ParamSpecExternalPluginFactory ParamSpecExternalPluginFactory;
-
-struct _ExternalPluginFactory {
-	GTypeInstance parent_instance;
-	volatile int ref_count;
-	ExternalPluginFactoryPrivate * priv;
-};
-
-struct _ExternalPluginFactoryClass {
-	GTypeClass parent_class;
-	void (*finalize) (ExternalPluginFactory *self);
-};
-
-struct _ExternalPluginFactoryPrivate {
-	DBusGProxy* dbus_obj;
-	DBusGConnection* connection;
-	RygelPluginLoader* loader;
-	gboolean activatable;
-};
-
-struct _ParamSpecExternalPluginFactory {
-	GParamSpec parent_instance;
-};
-
-
-extern ExternalPluginFactory* plugin_factory;
-ExternalPluginFactory* plugin_factory = NULL;
-static gpointer external_plugin_factory_parent_class = NULL;
-
-gpointer external_plugin_factory_ref (gpointer instance);
-void external_plugin_factory_unref (gpointer instance);
-GParamSpec* param_spec_external_plugin_factory (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
-void value_set_external_plugin_factory (GValue* value, gpointer v_object);
-gpointer value_get_external_plugin_factory (const GValue* value);
-GType external_plugin_factory_get_type (void);
-ExternalPluginFactory* external_plugin_factory_new (RygelPluginLoader* loader, GError** error);
-ExternalPluginFactory* external_plugin_factory_construct (GType object_type, RygelPluginLoader* loader, GError** error);
-void module_init (RygelPluginLoader* loader);
-#define EXTERNAL_PLUGIN_FACTORY_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_EXTERNAL_PLUGIN_FACTORY, ExternalPluginFactoryPrivate))
-enum  {
-	EXTERNAL_PLUGIN_FACTORY_DUMMY_PROPERTY
-};
-#define EXTERNAL_PLUGIN_FACTORY_DBUS_SERVICE "org.freedesktop.DBus"
-#define EXTERNAL_PLUGIN_FACTORY_DBUS_OBJECT "/org/freedesktop/DBus"
-#define EXTERNAL_PLUGIN_FACTORY_DBUS_IFACE "org.freedesktop.DBus"
-#define EXTERNAL_PLUGIN_FACTORY_SERVICE_PREFIX "org.gnome.UPnP.MediaServer1."
-static void external_plugin_factory_list_names_cb (ExternalPluginFactory* self, char** services, int services_length1, GError* err);
-void _dynamic_ListNames7 (DBusGProxy* self, gpointer param1, void* param1_target, GError** error);
-RygelExternalPlugin* rygel_external_plugin_new (DBusGConnection* connection, const char* service_name);
-RygelExternalPlugin* rygel_external_plugin_construct (GType object_type, DBusGConnection* connection, const char* service_name);
-GType rygel_external_plugin_get_type (void);
-static void external_plugin_factory_name_owner_changed (ExternalPluginFactory* self, DBusGProxy* dbus_obj, const char* name, const char* old_owner, const char* new_owner);
-static void _external_plugin_factory_name_owner_changed_dynamic_NameOwnerChanged2_ (DBusGProxy* _sender, const char* name, const char* old_owner, const char* new_owner, gpointer self);
-void _dynamic_NameOwnerChanged3_connect (gpointer obj, const char * signal_name, GCallback handler, gpointer data);
-void _dynamic_ListActivatableNames8 (DBusGProxy* self, gpointer param1, void* param1_target, GError** error);
-static void external_plugin_factory_finalize (ExternalPluginFactory* obj);
-static int _vala_strcmp0 (const char * str1, const char * str2);
-
-
-static void g_cclosure_user_marshal_VOID__STRING_STRING_STRING (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data);
-
-void module_init (RygelPluginLoader* loader) {
-	GError * _inner_error_;
-	g_return_if_fail (loader != NULL);
-	_inner_error_ = NULL;
-	{
-		ExternalPluginFactory* _tmp0_;
-		ExternalPluginFactory* _tmp1_;
-		_tmp0_ = external_plugin_factory_new (loader, &_inner_error_);
-		if (_inner_error_ != NULL) {
-			if (_inner_error_->domain == DBUS_GERROR) {
-				goto __catch7_dbus_gerror;
-			}
-			goto __finally7;
-		}
-		plugin_factory = (_tmp1_ = _tmp0_, _external_plugin_factory_unref0 (plugin_factory), _tmp1_);
-	}
-	goto __finally7;
-	__catch7_dbus_gerror:
-	{
-		GError * _error_;
-		_error_ = _inner_error_;
-		_inner_error_ = NULL;
-		{
-			g_critical ("rygel-external-plugin-factory.vala:36: Failed to fetch list of external services: %s\n", _error_->message);
-			_g_error_free0 (_error_);
-		}
-	}
-	__finally7:
-	if (_inner_error_ != NULL) {
-		g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
-		g_clear_error (&_inner_error_);
-		return;
-	}
-}
-
-
-static gpointer _g_object_ref0 (gpointer self) {
-	return self ? g_object_ref (self) : NULL;
-}
-
-
-static void _external_plugin_factory_list_names_cb_cb (DBusGProxy* proxy, DBusGProxyCall* call, void* user_data) {
-	GError* error;
-	char** services;
-	error = NULL;
-	dbus_g_proxy_end_call (proxy, call, &error, G_TYPE_STRV, &services, G_TYPE_INVALID);
-	external_plugin_factory_list_names_cb (user_data, services, g_strv_length (services), error);
-}
-
-
-void _dynamic_ListNames7 (DBusGProxy* self, gpointer param1, void* param1_target, GError** error) {
-	dbus_g_proxy_begin_call (self, "ListNames", _external_plugin_factory_list_names_cb_cb, param1_target, NULL, G_TYPE_INVALID, G_TYPE_INVALID);
-	if (*error) {
-		return;
-	}
-}
-
-
-ExternalPluginFactory* external_plugin_factory_construct (GType object_type, RygelPluginLoader* loader, GError** error) {
-	GError * _inner_error_;
-	ExternalPluginFactory* self;
-	DBusGConnection* _tmp0_;
-	DBusGConnection* _tmp1_;
-	DBusGProxy* _tmp2_;
-	RygelPluginLoader* _tmp3_;
-	g_return_val_if_fail (loader != NULL, NULL);
-	_inner_error_ = NULL;
-	self = (ExternalPluginFactory*) g_type_create_instance (object_type);
-	_tmp0_ = dbus_g_bus_get (DBUS_BUS_SESSION, &_inner_error_);
-	if (_inner_error_ != NULL) {
-		if (_inner_error_->domain == DBUS_GERROR) {
-			g_propagate_error (error, _inner_error_);
-			return;
-		} else {
-			g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
-			g_clear_error (&_inner_error_);
-			return NULL;
-		}
-	}
-	self->priv->connection = (_tmp1_ = _tmp0_, _dbus_g_connection_unref0 (self->priv->connection), _tmp1_);
-	self->priv->dbus_obj = (_tmp2_ = dbus_g_proxy_new_for_name (self->priv->connection, EXTERNAL_PLUGIN_FACTORY_DBUS_SERVICE, EXTERNAL_PLUGIN_FACTORY_DBUS_OBJECT, EXTERNAL_PLUGIN_FACTORY_DBUS_IFACE), _g_object_unref0 (self->priv->dbus_obj), _tmp2_);
-	self->priv->loader = (_tmp3_ = _g_object_ref0 (loader), _g_object_unref0 (self->priv->loader), _tmp3_);
-	self->priv->activatable = FALSE;
-	_dynamic_ListNames7 (self->priv->dbus_obj, external_plugin_factory_list_names_cb, self, &_inner_error_);
-	if (_inner_error_ != NULL) {
-		if (_inner_error_->domain == DBUS_GERROR) {
-			g_propagate_error (error, _inner_error_);
-			return;
-		} else {
-			g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
-			g_clear_error (&_inner_error_);
-			return NULL;
-		}
-	}
-	return self;
-}
-
-
-ExternalPluginFactory* external_plugin_factory_new (RygelPluginLoader* loader, GError** error) {
-	return external_plugin_factory_construct (TYPE_EXTERNAL_PLUGIN_FACTORY, loader, error);
-}
-
-
-static void _external_plugin_factory_name_owner_changed_dynamic_NameOwnerChanged2_ (DBusGProxy* _sender, const char* name, const char* old_owner, const char* new_owner, gpointer self) {
-	external_plugin_factory_name_owner_changed (self, _sender, name, old_owner, new_owner);
-}
-
-
-void _dynamic_NameOwnerChanged3_connect (gpointer obj, const char * signal_name, GCallback handler, gpointer data) {
-	dbus_g_object_register_marshaller (g_cclosure_user_marshal_VOID__STRING_STRING_STRING, G_TYPE_NONE, G_TYPE_STRING, G_TYPE_STRING, G_TYPE_STRING, G_TYPE_INVALID);
-	dbus_g_proxy_add_signal (obj, "NameOwnerChanged", G_TYPE_STRING, G_TYPE_STRING, G_TYPE_STRING, G_TYPE_INVALID);
-	dbus_g_proxy_connect_signal (obj, signal_name, handler, data, NULL);
-}
-
-
-void _dynamic_ListActivatableNames8 (DBusGProxy* self, gpointer param1, void* param1_target, GError** error) {
-	dbus_g_proxy_begin_call (self, "ListActivatableNames", _external_plugin_factory_list_names_cb_cb, param1_target, NULL, G_TYPE_INVALID, G_TYPE_INVALID);
-	if (*error) {
-		return;
-	}
-}
-
-
-static void external_plugin_factory_list_names_cb (ExternalPluginFactory* self, char** services, int services_length1, GError* err) {
-	GError * _inner_error_;
-	g_return_if_fail (self != NULL);
-	_inner_error_ = NULL;
-	if (err != NULL) {
-		g_critical ("rygel-external-plugin-factory.vala:69: Failed to fetch list of external services: %s\n", err->message);
-		return;
-	}
-	{
-		char** service_collection;
-		int service_collection_length1;
-		int service_it;
-		service_collection = services;
-		service_collection_length1 = services_length1;
-		for (service_it = 0; service_it < services_length1; service_it = service_it + 1) {
-			char* service;
-			service = g_strdup (service_collection[service_it]);
-			{
-				gboolean _tmp0_ = FALSE;
-				if (g_str_has_prefix (service, EXTERNAL_PLUGIN_FACTORY_SERVICE_PREFIX)) {
-					RygelPlugin* _tmp1_;
-					_tmp0_ = (_tmp1_ = rygel_plugin_loader_get_plugin_by_name (self->priv->loader, service)) == NULL;
-					_g_object_unref0 (_tmp1_);
-				} else {
-					_tmp0_ = FALSE;
-				}
-				if (_tmp0_) {
-					RygelExternalPlugin* _tmp2_;
-					rygel_plugin_loader_add_plugin (self->priv->loader, (RygelPlugin*) (_tmp2_ = rygel_external_plugin_new (self->priv->connection, service)));
-					_g_object_unref0 (_tmp2_);
-				}
-				_g_free0 (service);
-			}
-		}
-	}
-	if (self->priv->activatable) {
-		_dynamic_NameOwnerChanged3_connect (self->priv->dbus_obj, "NameOwnerChanged", (GCallback) _external_plugin_factory_name_owner_changed_dynamic_NameOwnerChanged2_, self);
-	} else {
-		_dynamic_ListActivatableNames8 (self->priv->dbus_obj, external_plugin_factory_list_names_cb, self, &_inner_error_);
-		if (_inner_error_ != NULL) {
-			g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
-			g_clear_error (&_inner_error_);
-			return;
-		}
-		self->priv->activatable = TRUE;
-	}
-}
-
-
-static void external_plugin_factory_name_owner_changed (ExternalPluginFactory* self, DBusGProxy* dbus_obj, const char* name, const char* old_owner, const char* new_owner) {
-	RygelPlugin* plugin;
-	g_return_if_fail (self != NULL);
-	g_return_if_fail (dbus_obj != NULL);
-	g_return_if_fail (name != NULL);
-	g_return_if_fail (old_owner != NULL);
-	g_return_if_fail (new_owner != NULL);
-	plugin = rygel_plugin_loader_get_plugin_by_name (self->priv->loader, name);
-	if (plugin != NULL) {
-		gboolean _tmp0_ = FALSE;
-		if (_vala_strcmp0 (old_owner, "") != 0) {
-			_tmp0_ = _vala_strcmp0 (new_owner, "") == 0;
-		} else {
-			_tmp0_ = FALSE;
-		}
-		if (_tmp0_) {
-			g_debug ("rygel-external-plugin-factory.vala:102: Service '%s' going down, marking it as unavailable", name);
-			rygel_plugin_set_available (plugin, FALSE);
-		} else {
-			gboolean _tmp1_ = FALSE;
-			if (_vala_strcmp0 (old_owner, "") == 0) {
-				_tmp1_ = _vala_strcmp0 (new_owner, "") != 0;
-			} else {
-				_tmp1_ = FALSE;
-			}
-			if (_tmp1_) {
-				g_debug ("rygel-external-plugin-factory.vala:106: Service '%s' up again, marking it as available", name);
-				rygel_plugin_set_available (plugin, TRUE);
-			}
-		}
-	} else {
-		if (g_str_has_prefix (name, EXTERNAL_PLUGIN_FACTORY_SERVICE_PREFIX)) {
-			RygelExternalPlugin* _tmp2_;
-			rygel_plugin_loader_add_plugin (self->priv->loader, (RygelPlugin*) (_tmp2_ = rygel_external_plugin_new (self->priv->connection, name)));
-			_g_object_unref0 (_tmp2_);
-		}
-	}
-	_g_object_unref0 (plugin);
-}
-
-
-static void value_external_plugin_factory_init (GValue* value) {
-	value->data[0].v_pointer = NULL;
-}
-
-
-static void value_external_plugin_factory_free_value (GValue* value) {
-	if (value->data[0].v_pointer) {
-		external_plugin_factory_unref (value->data[0].v_pointer);
-	}
-}
-
-
-static void value_external_plugin_factory_copy_value (const GValue* src_value, GValue* dest_value) {
-	if (src_value->data[0].v_pointer) {
-		dest_value->data[0].v_pointer = external_plugin_factory_ref (src_value->data[0].v_pointer);
-	} else {
-		dest_value->data[0].v_pointer = NULL;
-	}
-}
-
-
-static gpointer value_external_plugin_factory_peek_pointer (const GValue* value) {
-	return value->data[0].v_pointer;
-}
-
-
-static gchar* value_external_plugin_factory_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
-	if (collect_values[0].v_pointer) {
-		ExternalPluginFactory* object;
-		object = collect_values[0].v_pointer;
-		if (object->parent_instance.g_class == NULL) {
-			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
-		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
-			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
-		}
-		value->data[0].v_pointer = external_plugin_factory_ref (object);
-	} else {
-		value->data[0].v_pointer = NULL;
-	}
-	return NULL;
-}
-
-
-static gchar* value_external_plugin_factory_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
-	ExternalPluginFactory** object_p;
-	object_p = collect_values[0].v_pointer;
-	if (!object_p) {
-		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
-	}
-	if (!value->data[0].v_pointer) {
-		*object_p = NULL;
-	} else if (collect_flags && G_VALUE_NOCOPY_CONTENTS) {
-		*object_p = value->data[0].v_pointer;
-	} else {
-		*object_p = external_plugin_factory_ref (value->data[0].v_pointer);
-	}
-	return NULL;
-}
-
-
-GParamSpec* param_spec_external_plugin_factory (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
-	ParamSpecExternalPluginFactory* spec;
-	g_return_val_if_fail (g_type_is_a (object_type, TYPE_EXTERNAL_PLUGIN_FACTORY), NULL);
-	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
-	G_PARAM_SPEC (spec)->value_type = object_type;
-	return G_PARAM_SPEC (spec);
-}
-
-
-gpointer value_get_external_plugin_factory (const GValue* value) {
-	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_EXTERNAL_PLUGIN_FACTORY), NULL);
-	return value->data[0].v_pointer;
-}
-
-
-void value_set_external_plugin_factory (GValue* value, gpointer v_object) {
-	ExternalPluginFactory* old;
-	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_EXTERNAL_PLUGIN_FACTORY));
-	old = value->data[0].v_pointer;
-	if (v_object) {
-		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_EXTERNAL_PLUGIN_FACTORY));
-		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
-		value->data[0].v_pointer = v_object;
-		external_plugin_factory_ref (value->data[0].v_pointer);
-	} else {
-		value->data[0].v_pointer = NULL;
-	}
-	if (old) {
-		external_plugin_factory_unref (old);
-	}
-}
-
-
-static void external_plugin_factory_class_init (ExternalPluginFactoryClass * klass) {
-	external_plugin_factory_parent_class = g_type_class_peek_parent (klass);
-	EXTERNAL_PLUGIN_FACTORY_CLASS (klass)->finalize = external_plugin_factory_finalize;
-	g_type_class_add_private (klass, sizeof (ExternalPluginFactoryPrivate));
-}
-
-
-static void external_plugin_factory_instance_init (ExternalPluginFactory * self) {
-	self->priv = EXTERNAL_PLUGIN_FACTORY_GET_PRIVATE (self);
-	self->ref_count = 1;
-}
-
-
-static void external_plugin_factory_finalize (ExternalPluginFactory* obj) {
-	ExternalPluginFactory * self;
-	self = EXTERNAL_PLUGIN_FACTORY (obj);
-	_g_object_unref0 (self->priv->dbus_obj);
-	_dbus_g_connection_unref0 (self->priv->connection);
-	_g_object_unref0 (self->priv->loader);
-}
-
-
-GType external_plugin_factory_get_type (void) {
-	static GType external_plugin_factory_type_id = 0;
-	if (external_plugin_factory_type_id == 0) {
-		static const GTypeValueTable g_define_type_value_table = { value_external_plugin_factory_init, value_external_plugin_factory_free_value, value_external_plugin_factory_copy_value, value_external_plugin_factory_peek_pointer, "p", value_external_plugin_factory_collect_value, "p", value_external_plugin_factory_lcopy_value };
-		static const GTypeInfo g_define_type_info = { sizeof (ExternalPluginFactoryClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) external_plugin_factory_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (ExternalPluginFactory), 0, (GInstanceInitFunc) external_plugin_factory_instance_init, &g_define_type_value_table };
-		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
-		external_plugin_factory_type_id = g_type_register_fundamental (g_type_fundamental_next (), "ExternalPluginFactory", &g_define_type_info, &g_define_type_fundamental_info, 0);
-	}
-	return external_plugin_factory_type_id;
-}
-
-
-gpointer external_plugin_factory_ref (gpointer instance) {
-	ExternalPluginFactory* self;
-	self = instance;
-	g_atomic_int_inc (&self->ref_count);
-	return instance;
-}
-
-
-void external_plugin_factory_unref (gpointer instance) {
-	ExternalPluginFactory* self;
-	self = instance;
-	if (g_atomic_int_dec_and_test (&self->ref_count)) {
-		EXTERNAL_PLUGIN_FACTORY_GET_CLASS (self)->finalize (self);
-		g_type_free_instance ((GTypeInstance *) self);
-	}
-}
-
-
-static int _vala_strcmp0 (const char * str1, const char * str2) {
-	if (str1 == NULL) {
-		return -(str1 != str2);
-	}
-	if (str2 == NULL) {
-		return str1 != str2;
-	}
-	return strcmp (str1, str2);
-}
-
-
-
-static void g_cclosure_user_marshal_VOID__STRING_STRING_STRING (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data) {
-	typedef void (*GMarshalFunc_VOID__STRING_STRING_STRING) (gpointer data1, const char* arg_1, const char* arg_2, const char* arg_3, gpointer data2);
-	register GMarshalFunc_VOID__STRING_STRING_STRING callback;
-	register GCClosure * cc;
-	register gpointer data1, data2;
-	cc = (GCClosure *) closure;
-	g_return_if_fail (n_param_values == 4);
-	if (G_CCLOSURE_SWAP_DATA (closure)) {
-		data1 = closure->data;
-		data2 = param_values->data[0].v_pointer;
-	} else {
-		data1 = param_values->data[0].v_pointer;
-		data2 = closure->data;
-	}
-	callback = (GMarshalFunc_VOID__STRING_STRING_STRING) (marshal_data ? marshal_data : cc->callback);
-	callback (data1, g_value_get_string (param_values + 1), g_value_get_string (param_values + 2), g_value_get_string (param_values + 3), data2);
-}
-
-
-
--- a/src/plugins/external/rygel-external-plugin.c
+++ /dev/null
@@ -1,229 +0,0 @@
-/* rygel-external-plugin.c generated by valac, the Vala compiler
- * generated from rygel-external-plugin.vala, do not modify */
-
-/*
- * Copyright (C) 2009 Zeeshan Ali (Khattak) <zeeshanak@gnome.org>.
- * Copyright (C) 2009 Nokia Corporation.
- *
- * Author: Zeeshan Ali (Khattak) <zeeshanak@gnome.org>
- *                               <zeeshan.ali@nokia.com>
- *
- * This file is part of Rygel.
- *
- * Rygel is free software; you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * Rygel is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this program; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
- */
-
-#include <glib.h>
-#include <glib-object.h>
-#include <rygel.h>
-#include <stdlib.h>
-#include <string.h>
-#include <dbus/dbus-glib-lowlevel.h>
-#include <dbus/dbus-glib.h>
-
-
-#define RYGEL_TYPE_EXTERNAL_PLUGIN (rygel_external_plugin_get_type ())
-#define RYGEL_EXTERNAL_PLUGIN(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_EXTERNAL_PLUGIN, RygelExternalPlugin))
-#define RYGEL_EXTERNAL_PLUGIN_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_EXTERNAL_PLUGIN, RygelExternalPluginClass))
-#define RYGEL_IS_EXTERNAL_PLUGIN(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_EXTERNAL_PLUGIN))
-#define RYGEL_IS_EXTERNAL_PLUGIN_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_EXTERNAL_PLUGIN))
-#define RYGEL_EXTERNAL_PLUGIN_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_EXTERNAL_PLUGIN, RygelExternalPluginClass))
-
-typedef struct _RygelExternalPlugin RygelExternalPlugin;
-typedef struct _RygelExternalPluginClass RygelExternalPluginClass;
-typedef struct _RygelExternalPluginPrivate RygelExternalPluginPrivate;
-#define _g_free0(var) (var = (g_free (var), NULL))
-#define _g_regex_unref0(var) ((var == NULL) ? NULL : (var = (g_regex_unref (var), NULL)))
-#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
-#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
-
-#define RYGEL_TYPE_EXTERNAL_CONTENT_DIR (rygel_external_content_dir_get_type ())
-#define RYGEL_EXTERNAL_CONTENT_DIR(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_EXTERNAL_CONTENT_DIR, RygelExternalContentDir))
-#define RYGEL_EXTERNAL_CONTENT_DIR_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_EXTERNAL_CONTENT_DIR, RygelExternalContentDirClass))
-#define RYGEL_IS_EXTERNAL_CONTENT_DIR(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_EXTERNAL_CONTENT_DIR))
-#define RYGEL_IS_EXTERNAL_CONTENT_DIR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_EXTERNAL_CONTENT_DIR))
-#define RYGEL_EXTERNAL_CONTENT_DIR_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_EXTERNAL_CONTENT_DIR, RygelExternalContentDirClass))
-
-typedef struct _RygelExternalContentDir RygelExternalContentDir;
-typedef struct _RygelExternalContentDirClass RygelExternalContentDirClass;
-#define _rygel_resource_info_unref0(var) ((var == NULL) ? NULL : (var = (rygel_resource_info_unref (var), NULL)))
-
-struct _RygelExternalPlugin {
-	RygelPlugin parent_instance;
-	RygelExternalPluginPrivate * priv;
-	char* service_name;
-	char* root_object;
-};
-
-struct _RygelExternalPluginClass {
-	RygelPluginClass parent_class;
-};
-
-
-static gpointer rygel_external_plugin_parent_class = NULL;
-
-GType rygel_external_plugin_get_type (void);
-enum  {
-	RYGEL_EXTERNAL_PLUGIN_DUMMY_PROPERTY
-};
-#define RYGEL_EXTERNAL_PLUGIN_PROPS_IFACE "org.freedesktop.DBus.Properties"
-#define RYGEL_EXTERNAL_PLUGIN_OBJECT_IFACE "org.gnome.UPnP.MediaObject1"
-void _dynamic_Get6 (DBusGProxy* self, const char* param1, const char* param2, GValue* param3, GError** error);
-GType rygel_external_content_dir_get_type (void);
-RygelExternalPlugin* rygel_external_plugin_new (DBusGConnection* connection, const char* service_name);
-RygelExternalPlugin* rygel_external_plugin_construct (GType object_type, DBusGConnection* connection, const char* service_name);
-static void rygel_external_plugin_finalize (GObject* obj);
-
-
-
-static char* string_replace (const char* self, const char* old, const char* replacement) {
-	char* result;
-	GError * _inner_error_;
-	g_return_val_if_fail (self != NULL, NULL);
-	g_return_val_if_fail (old != NULL, NULL);
-	g_return_val_if_fail (replacement != NULL, NULL);
-	_inner_error_ = NULL;
-	{
-		char* _tmp0_;
-		GRegex* _tmp1_;
-		GRegex* regex;
-		char* _tmp2_;
-		regex = (_tmp1_ = g_regex_new (_tmp0_ = g_regex_escape_string (old, -1), 0, 0, &_inner_error_), _g_free0 (_tmp0_), _tmp1_);
-		if (_inner_error_ != NULL) {
-			if (_inner_error_->domain == G_REGEX_ERROR) {
-				goto __catch6_g_regex_error;
-			}
-			goto __finally6;
-		}
-		_tmp2_ = g_regex_replace_literal (regex, self, (glong) (-1), 0, replacement, 0, &_inner_error_);
-		if (_inner_error_ != NULL) {
-			_g_regex_unref0 (regex);
-			if (_inner_error_->domain == G_REGEX_ERROR) {
-				goto __catch6_g_regex_error;
-			}
-			goto __finally6;
-		}
-		result = _tmp2_;
-		_g_regex_unref0 (regex);
-		return result;
-	}
-	goto __finally6;
-	__catch6_g_regex_error:
-	{
-		GError * e;
-		e = _inner_error_;
-		_inner_error_ = NULL;
-		{
-			g_assert_not_reached ();
-			_g_error_free0 (e);
-		}
-	}
-	__finally6:
-	if (_inner_error_ != NULL) {
-		g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
-		g_clear_error (&_inner_error_);
-		return NULL;
-	}
-}
-
-
-void _dynamic_Get6 (DBusGProxy* self, const char* param1, const char* param2, GValue* param3, GError** error) {
-	dbus_g_proxy_call (self, "Get", error, G_TYPE_STRING, param1, G_TYPE_STRING, param2, G_TYPE_INVALID, G_TYPE_VALUE, param3, G_TYPE_INVALID);
-	if (*error) {
-		return;
-	}
-}
-
-
-RygelExternalPlugin* rygel_external_plugin_construct (GType object_type, DBusGConnection* connection, const char* service_name) {
-	GError * _inner_error_;
-	RygelExternalPlugin * self;
-	char* _tmp0_;
-	char* _tmp1_;
-	char* root_object;
-	DBusGProxy* props;
-	GValue value = {0};
-	GValue _tmp3_;
-	GValue _tmp2_ = {0};
-	char* title;
-	char* _tmp4_;
-	char* _tmp5_;
-	RygelResourceInfo* resource_info;
-	g_return_val_if_fail (connection != NULL, NULL);
-	g_return_val_if_fail (service_name != NULL, NULL);
-	_inner_error_ = NULL;
-	root_object = (_tmp1_ = g_strconcat ("/", _tmp0_ = string_replace (service_name, ".", "/"), NULL), _g_free0 (_tmp0_), _tmp1_);
-	props = dbus_g_proxy_new_for_name (connection, service_name, root_object, RYGEL_EXTERNAL_PLUGIN_PROPS_IFACE);
-	_dynamic_Get6 (props, RYGEL_EXTERNAL_PLUGIN_OBJECT_IFACE, "DisplayName", &_tmp2_, &_inner_error_);
-	value = (_tmp3_ = _tmp2_, G_IS_VALUE (&value) ? (g_value_unset (&value), NULL) : NULL, _tmp3_);
-	if (_inner_error_ != NULL) {
-		_g_free0 (root_object);
-		_g_object_unref0 (props);
-		G_IS_VALUE (&value) ? (g_value_unset (&value), NULL) : NULL;
-		g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
-		g_clear_error (&_inner_error_);
-		return NULL;
-	}
-	title = g_strdup (g_value_get_string (&value));
-	self = (RygelExternalPlugin*) rygel_plugin_construct_MediaServer (object_type, service_name, title);
-	self->service_name = (_tmp4_ = g_strdup (service_name), _g_free0 (self->service_name), _tmp4_);
-	self->root_object = (_tmp5_ = g_strdup (root_object), _g_free0 (self->root_object), _tmp5_);
-	resource_info = rygel_resource_info_new (RYGEL_CONTENT_DIRECTORY_UPNP_ID, RYGEL_CONTENT_DIRECTORY_UPNP_TYPE, RYGEL_CONTENT_DIRECTORY_DESCRIPTION_PATH, RYGEL_TYPE_EXTERNAL_CONTENT_DIR);
-	rygel_plugin_add_resource ((RygelPlugin*) self, resource_info);
-	_g_free0 (root_object);
-	_g_object_unref0 (props);
-	G_IS_VALUE (&value) ? (g_value_unset (&value), NULL) : NULL;
-	_g_free0 (title);
-	_rygel_resource_info_unref0 (resource_info);
-	return self;
-}
-
-
-RygelExternalPlugin* rygel_external_plugin_new (DBusGConnection* connection, const char* service_name) {
-	return rygel_external_plugin_construct (RYGEL_TYPE_EXTERNAL_PLUGIN, connection, service_name);
-}
-
-
-static void rygel_external_plugin_class_init (RygelExternalPluginClass * klass) {
-	rygel_external_plugin_parent_class = g_type_class_peek_parent (klass);
-	G_OBJECT_CLASS (klass)->finalize = rygel_external_plugin_finalize;
-}
-
-
-static void rygel_external_plugin_instance_init (RygelExternalPlugin * self) {
-}
-
-
-static void rygel_external_plugin_finalize (GObject* obj) {
-	RygelExternalPlugin * self;
-	self = RYGEL_EXTERNAL_PLUGIN (obj);
-	_g_free0 (self->service_name);
-	_g_free0 (self->root_object);
-	G_OBJECT_CLASS (rygel_external_plugin_parent_class)->finalize (obj);
-}
-
-
-GType rygel_external_plugin_get_type (void) {
-	static GType rygel_external_plugin_type_id = 0;
-	if (rygel_external_plugin_type_id == 0) {
-		static const GTypeInfo g_define_type_info = { sizeof (RygelExternalPluginClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) rygel_external_plugin_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (RygelExternalPlugin), 0, (GInstanceInitFunc) rygel_external_plugin_instance_init, NULL };
-		rygel_external_plugin_type_id = g_type_register_static (RYGEL_TYPE_PLUGIN, "RygelExternalPlugin", &g_define_type_info, 0);
-	}
-	return rygel_external_plugin_type_id;
-}
-
-
-
-
--- /dev/null
+++ b/src/plugins/gst-renderer/Makefile.in
@@ -0,0 +1,718 @@
+# Makefile.in generated by automake 1.11 from Makefile.am.
+# @configure_input@
+
+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
+# 2003, 2004, 2005, 2006, 2007, 2008, 2009  Free Software Foundation,
+# Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+@SET_MAKE@
+
+VPATH = @srcdir@
+pkgdatadir = $(datadir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkglibexecdir = $(libexecdir)/@PACKAGE@
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+build_triplet = @build@
+host_triplet = @host@
+subdir = src/plugins/gst-renderer
+DIST_COMMON = $(srcdir)/Makefile.am $(srcdir)/Makefile.in \
+	librygel_gst_la_vala.stamp rygel-gst-audio-player-instance.c \
+	rygel-gst-av-transport.c rygel-gst-changelog.c \
+	rygel-gst-connection-manager.c rygel-gst-metadata-parser.c \
+	rygel-gst-player-states.c rygel-gst-plugin.c \
+	rygel-gst-rendering-control.c rygel-helper-gst-time.c
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps = $(top_srcdir)/m4/glib-gettext.m4 \
+	$(top_srcdir)/m4/isc-posix.m4 $(top_srcdir)/m4/libtool.m4 \
+	$(top_srcdir)/m4/ltoptions.m4 $(top_srcdir)/m4/ltsugar.m4 \
+	$(top_srcdir)/m4/ltversion.m4 $(top_srcdir)/m4/lt~obsolete.m4 \
+	$(top_srcdir)/configure.ac
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+mkinstalldirs = $(SHELL) $(top_srcdir)/build-aux/mkinstalldirs
+CONFIG_HEADER = $(top_builddir)/config.h
+CONFIG_CLEAN_FILES =
+CONFIG_CLEAN_VPATH_FILES =
+am__vpath_adj_setup = srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`;
+am__vpath_adj = case $$p in \
+    $(srcdir)/*) f=`echo "$$p" | sed "s|^$$srcdirstrip/||"`;; \
+    *) f=$$p;; \
+  esac;
+am__strip_dir = f=`echo $$p | sed -e 's|^.*/||'`;
+am__install_max = 40
+am__nobase_strip_setup = \
+  srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*|]/\\\\&/g'`
+am__nobase_strip = \
+  for p in $$list; do echo "$$p"; done | sed -e "s|$$srcdirstrip/||"
+am__nobase_list = $(am__nobase_strip_setup); \
+  for p in $$list; do echo "$$p $$p"; done | \
+  sed "s| $$srcdirstrip/| |;"' / .*\//!s/ .*/ ./; s,\( .*\)/[^/]*$$,\1,' | \
+  $(AWK) 'BEGIN { files["."] = "" } { files[$$2] = files[$$2] " " $$1; \
+    if (++n[$$2] == $(am__install_max)) \
+      { print $$2, files[$$2]; n[$$2] = 0; files[$$2] = "" } } \
+    END { for (dir in files) print dir, files[dir] }'
+am__base_list = \
+  sed '$$!N;$$!N;$$!N;$$!N;$$!N;$$!N;$$!N;s/\n/ /g' | \
+  sed '$$!N;$$!N;$$!N;$$!N;s/\n/ /g'
+am__installdirs = "$(DESTDIR)$(plugindir)"
+LTLIBRARIES = $(plugin_LTLIBRARIES)
+am__DEPENDENCIES_1 =
+librygel_gst_la_DEPENDENCIES = $(am__DEPENDENCIES_1) \
+	$(am__DEPENDENCIES_1) $(am__DEPENDENCIES_1) \
+	$(am__DEPENDENCIES_1) $(am__DEPENDENCIES_1) \
+	$(am__DEPENDENCIES_1)
+am_librygel_gst_la_OBJECTS = rygel-gst-connection-manager.lo \
+	rygel-gst-rendering-control.lo rygel-gst-av-transport.lo \
+	rygel-gst-changelog.lo rygel-gst-plugin.lo \
+	rygel-gst-audio-player-instance.lo rygel-helper-gst-time.lo \
+	rygel-gst-metadata-parser.lo rygel-gst-player-states.lo \
+	owl-audio-player.lo
+librygel_gst_la_OBJECTS = $(am_librygel_gst_la_OBJECTS)
+AM_V_lt = $(am__v_lt_$(V))
+am__v_lt_ = $(am__v_lt_$(AM_DEFAULT_VERBOSITY))
+am__v_lt_0 = --silent
+librygel_gst_la_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC \
+	$(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=link $(CCLD) \
+	$(AM_CFLAGS) $(CFLAGS) $(librygel_gst_la_LDFLAGS) $(LDFLAGS) \
+	-o $@
+DEFAULT_INCLUDES = -I.@am__isrc@ -I$(top_builddir)
+depcomp = $(SHELL) $(top_srcdir)/build-aux/depcomp
+am__depfiles_maybe = depfiles
+am__mv = mv -f
+COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
+	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+LTCOMPILE = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
+	$(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) \
+	$(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) \
+	$(AM_CFLAGS) $(CFLAGS)
+AM_V_CC = $(am__v_CC_$(V))
+am__v_CC_ = $(am__v_CC_$(AM_DEFAULT_VERBOSITY))
+am__v_CC_0 = @echo "  CC    " $@;
+AM_V_at = $(am__v_at_$(V))
+am__v_at_ = $(am__v_at_$(AM_DEFAULT_VERBOSITY))
+am__v_at_0 = @
+CCLD = $(CC)
+LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
+	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \
+	$(AM_LDFLAGS) $(LDFLAGS) -o $@
+AM_V_CCLD = $(am__v_CCLD_$(V))
+am__v_CCLD_ = $(am__v_CCLD_$(AM_DEFAULT_VERBOSITY))
+am__v_CCLD_0 = @echo "  CCLD  " $@;
+VALACOMPILE = $(VALAC) $(AM_VALAFLAGS) $(VALAFLAGS)
+LTVALACOMPILE = $(LIBTOOL) $(AM_V_lt) $(AM_LIBTOOLFLAGS) \
+	$(LIBTOOLFLAGS) --mode=compile $(VALAC) $(AM_VALAFLAGS) \
+	$(VALAFLAGS)
+AM_V_VALAC = $(am__v_VALAC_$(V))
+am__v_VALAC_ = $(am__v_VALAC_$(AM_DEFAULT_VERBOSITY))
+am__v_VALAC_0 = @echo "  VALAC " $@;
+AM_V_GEN = $(am__v_GEN_$(V))
+am__v_GEN_ = $(am__v_GEN_$(AM_DEFAULT_VERBOSITY))
+am__v_GEN_0 = @echo "  GEN   " $@;
+SOURCES = $(librygel_gst_la_SOURCES)
+DIST_SOURCES = $(librygel_gst_la_SOURCES)
+ETAGS = etags
+CTAGS = ctags
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+ACLOCAL = @ACLOCAL@
+AMTAR = @AMTAR@
+AM_DEFAULT_VERBOSITY = @AM_DEFAULT_VERBOSITY@
+AR = @AR@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
+AWK = @AWK@
+CATALOGS = @CATALOGS@
+CATOBJEXT = @CATOBJEXT@
+CC = @CC@
+CCDEPMODE = @CCDEPMODE@
+CFLAGS = @CFLAGS@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CYGPATH_W = @CYGPATH_W@
+DATADIRNAME = @DATADIRNAME@
+DEFS = @DEFS@
+DEPDIR = @DEPDIR@
+DSYMUTIL = @DSYMUTIL@
+DUMPBIN = @DUMPBIN@
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+EXEEXT = @EXEEXT@
+FGREP = @FGREP@
+GEE_CFLAGS = @GEE_CFLAGS@
+GEE_LIBS = @GEE_LIBS@
+GETTEXT_PACKAGE = @GETTEXT_PACKAGE@
+GLIB_GENMARSHAL = @GLIB_GENMARSHAL@
+GMOFILES = @GMOFILES@
+GMSGFMT = @GMSGFMT@
+GREP = @GREP@
+GTK_CFLAGS = @GTK_CFLAGS@
+GTK_LIBS = @GTK_LIBS@
+HAVE_GTK = @HAVE_GTK@
+INSTALL = @INSTALL@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+INSTOBJEXT = @INSTOBJEXT@
+INTLLIBS = @INTLLIBS@
+LD = @LD@
+LDFLAGS = @LDFLAGS@
+LIBDBUS_GLIB_CFLAGS = @LIBDBUS_GLIB_CFLAGS@
+LIBDBUS_GLIB_LIBS = @LIBDBUS_GLIB_LIBS@
+LIBGIO_CFLAGS = @LIBGIO_CFLAGS@
+LIBGIO_LIBS = @LIBGIO_LIBS@
+LIBGLIB_CFLAGS = @LIBGLIB_CFLAGS@
+LIBGLIB_LIBS = @LIBGLIB_LIBS@
+LIBGUPNP_AV_CFLAGS = @LIBGUPNP_AV_CFLAGS@
+LIBGUPNP_AV_LIBS = @LIBGUPNP_AV_LIBS@
+LIBGUPNP_CFLAGS = @LIBGUPNP_CFLAGS@
+LIBGUPNP_LIBS = @LIBGUPNP_LIBS@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LIBSOUP_CFLAGS = @LIBSOUP_CFLAGS@
+LIBSOUP_LIBS = @LIBSOUP_LIBS@
+LIBSQLITE3_CFLAGS = @LIBSQLITE3_CFLAGS@
+LIBSQLITE3_LIBS = @LIBSQLITE3_LIBS@
+LIBTOOL = @LIBTOOL@
+LIBVLC_CFLAGS = @LIBVLC_CFLAGS@
+LIBVLC_LIBS = @LIBVLC_LIBS@
+LIPO = @LIPO@
+LN_S = @LN_S@
+LTLIBOBJS = @LTLIBOBJS@
+MAINT = @MAINT@
+MAKEINFO = @MAKEINFO@
+MKDIR_P = @MKDIR_P@
+MKINSTALLDIRS = @MKINSTALLDIRS@
+MSGFMT = @MSGFMT@
+MSGFMT_OPTS = @MSGFMT_OPTS@
+NM = @NM@
+NMEDIT = @NMEDIT@
+OBJDUMP = @OBJDUMP@
+OBJEXT = @OBJEXT@
+OTOOL = @OTOOL@
+OTOOL64 = @OTOOL64@
+PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_URL = @PACKAGE_URL@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
+PKG_CONFIG = @PKG_CONFIG@
+POFILES = @POFILES@
+POSUB = @POSUB@
+PO_IN_DATADIR_FALSE = @PO_IN_DATADIR_FALSE@
+PO_IN_DATADIR_TRUE = @PO_IN_DATADIR_TRUE@
+RANLIB = @RANLIB@
+SED = @SED@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
+STRIP = @STRIP@
+USE_NLS = @USE_NLS@
+VALAC = @VALAC@
+VAPIDIR = @VAPIDIR@
+VERSION = @VERSION@
+XGETTEXT = @XGETTEXT@
+abs_builddir = @abs_builddir@
+abs_srcdir = @abs_srcdir@
+abs_top_builddir = @abs_top_builddir@
+abs_top_srcdir = @abs_top_srcdir@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_DUMPBIN = @ac_ct_DUMPBIN@
+am__include = @am__include@
+am__leading_dot = @am__leading_dot@
+am__quote = @am__quote@
+am__tar = @am__tar@
+am__untar = @am__untar@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+builddir = @builddir@
+datadir = @datadir@
+datarootdir = @datarootdir@
+docdir = @docdir@
+dvidir = @dvidir@
+exec_prefix = @exec_prefix@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+htmldir = @htmldir@
+includedir = @includedir@
+infodir = @infodir@
+install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localedir = @localedir@
+localstatedir = @localstatedir@
+lt_ECHO = @lt_ECHO@
+mandir = @mandir@
+mkdir_p = @mkdir_p@
+oldincludedir = @oldincludedir@
+pdfdir = @pdfdir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+psdir = @psdir@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+srcdir = @srcdir@
+sysconfdir = @sysconfdir@
+target_alias = @target_alias@
+top_build_prefix = @top_build_prefix@
+top_builddir = @top_builddir@
+top_srcdir = @top_srcdir@
+@UNINSTALLED_FALSE@shareddir = $(datadir)/rygel
+@UNINSTALLED_TRUE@shareddir = $(abs_top_builddir)/data
+plugindir = $(libdir)/rygel-1.0
+plugin_LTLIBRARIES = librygel-gst.la
+DATA_DIR = $(shareddir:$(prefix)%=%)
+AM_CFLAGS = $(LIBGUPNP_CFLAGS) \
+	    $(LIBGUPNP_AV_CFLAGS) \
+	    $(GEE_CFLAGS) \
+	    $(GTK_CFLAGS) \
+	    $(LIBVLC_CFLAGS) \
+	    $(LIBDBUS_GLIB_CFLAGS) \
+	    -I$(top_srcdir)/src/rygel -DDATA_DIR='"$(DATA_DIR)"'
+
+librygel_gst_la_SOURCES = rygel-gst-connection-manager.vala \
+			  rygel-gst-rendering-control.vala \
+			  rygel-gst-av-transport.vala \
+			  rygel-gst-changelog.vala \
+			  rygel-gst-plugin.vala \
+			  rygel-gst-audio-player-instance.vala \
+			  rygel-helper-gst-time.vala \
+			  rygel-gst-metadata-parser.vala \
+			  rygel-gst-player-states.vala \
+			  owl-audio-player.c
+
+librygel_gst_la_VALAFLAGS = --vapidir=$(srcdir) \
+				--vapidir=$(top_srcdir)/src/rygel \
+				--vapidir=$(top_srcdir)/vapi \
+				--pkg rygel-1.0 \
+				--pkg cstuff \
+				--pkg gupnp-1.0 \
+				--pkg gupnp-av-1.0 \
+				--pkg owl-audio-player \
+				--pkg gee-1.0 \
+				--pkg gconf-2.0 \
+				--pkg gtk+-2.0
+
+librygel_gst_la_LIBADD = $(LIBGUPNP_LIBS) \
+			 $(LIBGUPNP_AV_LIBS) \
+			 $(LIBVLC_LIBS) \
+			 $(GEE_LIBS) \
+			 $(GTK_LIBS) \
+			 $(LIBDBUS_GLIB_LIBS) \
+			 $(LIBGCONF_LIBS)
+
+librygel_gst_la_LDFLAGS = -shared -fPIC -module -avoid-version
+CLEANFILES = $(BUILT_SOURCES)
+MAINTAINERCLEANFILES = Makefile.in
+EXTRA_DIST = $(BUILT_SOURCES) owl-audio-player.vapi
+all: all-am
+
+.SUFFIXES:
+.SUFFIXES: .c .lo .o .obj
+$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      ( cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh ) \
+	        && { if test -f $@; then exit 0; else break; fi; }; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --gnu src/plugins/gst-renderer/Makefile'; \
+	$(am__cd) $(top_srcdir) && \
+	  $(AUTOMAKE) --gnu src/plugins/gst-renderer/Makefile
+.PRECIOUS: Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	esac;
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(am__aclocal_m4_deps):
+install-pluginLTLIBRARIES: $(plugin_LTLIBRARIES)
+	@$(NORMAL_INSTALL)
+	test -z "$(plugindir)" || $(MKDIR_P) "$(DESTDIR)$(plugindir)"
+	@list='$(plugin_LTLIBRARIES)'; test -n "$(plugindir)" || list=; \
+	list2=; for p in $$list; do \
+	  if test -f $$p; then \
+	    list2="$$list2 $$p"; \
+	  else :; fi; \
+	done; \
+	test -z "$$list2" || { \
+	  echo " $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=install $(INSTALL) $(INSTALL_STRIP_FLAG) $$list2 '$(DESTDIR)$(plugindir)'"; \
+	  $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=install $(INSTALL) $(INSTALL_STRIP_FLAG) $$list2 "$(DESTDIR)$(plugindir)"; \
+	}
+
+uninstall-pluginLTLIBRARIES:
+	@$(NORMAL_UNINSTALL)
+	@list='$(plugin_LTLIBRARIES)'; test -n "$(plugindir)" || list=; \
+	for p in $$list; do \
+	  $(am__strip_dir) \
+	  echo " $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=uninstall rm -f '$(DESTDIR)$(plugindir)/$$f'"; \
+	  $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=uninstall rm -f "$(DESTDIR)$(plugindir)/$$f"; \
+	done
+
+clean-pluginLTLIBRARIES:
+	-test -z "$(plugin_LTLIBRARIES)" || rm -f $(plugin_LTLIBRARIES)
+	@list='$(plugin_LTLIBRARIES)'; for p in $$list; do \
+	  dir="`echo $$p | sed -e 's|/[^/]*$$||'`"; \
+	  test "$$dir" != "$$p" || dir=.; \
+	  echo "rm -f \"$${dir}/so_locations\""; \
+	  rm -f "$${dir}/so_locations"; \
+	done
+librygel-gst.la: $(librygel_gst_la_OBJECTS) $(librygel_gst_la_DEPENDENCIES) 
+	$(AM_V_CCLD)$(librygel_gst_la_LINK) -rpath $(plugindir) $(librygel_gst_la_OBJECTS) $(librygel_gst_la_LIBADD) $(LIBS)
+
+mostlyclean-compile:
+	-rm -f *.$(OBJEXT)
+
+distclean-compile:
+	-rm -f *.tab.c
+
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/owl-audio-player.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/rygel-gst-audio-player-instance.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/rygel-gst-av-transport.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/rygel-gst-changelog.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/rygel-gst-connection-manager.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/rygel-gst-metadata-parser.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/rygel-gst-player-states.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/rygel-gst-plugin.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/rygel-gst-rendering-control.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/rygel-helper-gst-time.Plo@am__quote@
+
+.c.o:
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@am__fastdepCC_FALSE@	$(AM_V_CC) @AM_BACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(COMPILE) -c $<
+
+.c.obj:
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ `$(CYGPATH_W) '$<'`
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@am__fastdepCC_FALSE@	$(AM_V_CC) @AM_BACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(COMPILE) -c `$(CYGPATH_W) '$<'`
+
+.c.lo:
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(LTCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Plo
+@am__fastdepCC_FALSE@	$(AM_V_CC) @AM_BACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(LTCOMPILE) -c -o $@ $<
+$(srcdir)/rygel-gst-connection-manager.c: $(srcdir)/librygel_gst_la_vala.stamp
+	@if test -f $@; then :; else \
+	  rm -f $(srcdir)/librygel_gst_la_vala.stamp; \
+	  $(am__cd) $(srcdir) && $(MAKE) $(AM_MAKEFLAGS) librygel_gst_la_vala.stamp; \
+	fi
+$(srcdir)/rygel-gst-rendering-control.c: $(srcdir)/librygel_gst_la_vala.stamp
+	@if test -f $@; then :; else \
+	  rm -f $(srcdir)/librygel_gst_la_vala.stamp; \
+	  $(am__cd) $(srcdir) && $(MAKE) $(AM_MAKEFLAGS) librygel_gst_la_vala.stamp; \
+	fi
+$(srcdir)/rygel-gst-av-transport.c: $(srcdir)/librygel_gst_la_vala.stamp
+	@if test -f $@; then :; else \
+	  rm -f $(srcdir)/librygel_gst_la_vala.stamp; \
+	  $(am__cd) $(srcdir) && $(MAKE) $(AM_MAKEFLAGS) librygel_gst_la_vala.stamp; \
+	fi
+$(srcdir)/rygel-gst-changelog.c: $(srcdir)/librygel_gst_la_vala.stamp
+	@if test -f $@; then :; else \
+	  rm -f $(srcdir)/librygel_gst_la_vala.stamp; \
+	  $(am__cd) $(srcdir) && $(MAKE) $(AM_MAKEFLAGS) librygel_gst_la_vala.stamp; \
+	fi
+$(srcdir)/rygel-gst-plugin.c: $(srcdir)/librygel_gst_la_vala.stamp
+	@if test -f $@; then :; else \
+	  rm -f $(srcdir)/librygel_gst_la_vala.stamp; \
+	  $(am__cd) $(srcdir) && $(MAKE) $(AM_MAKEFLAGS) librygel_gst_la_vala.stamp; \
+	fi
+$(srcdir)/rygel-gst-audio-player-instance.c: $(srcdir)/librygel_gst_la_vala.stamp
+	@if test -f $@; then :; else \
+	  rm -f $(srcdir)/librygel_gst_la_vala.stamp; \
+	  $(am__cd) $(srcdir) && $(MAKE) $(AM_MAKEFLAGS) librygel_gst_la_vala.stamp; \
+	fi
+$(srcdir)/rygel-helper-gst-time.c: $(srcdir)/librygel_gst_la_vala.stamp
+	@if test -f $@; then :; else \
+	  rm -f $(srcdir)/librygel_gst_la_vala.stamp; \
+	  $(am__cd) $(srcdir) && $(MAKE) $(AM_MAKEFLAGS) librygel_gst_la_vala.stamp; \
+	fi
+$(srcdir)/rygel-gst-metadata-parser.c: $(srcdir)/librygel_gst_la_vala.stamp
+	@if test -f $@; then :; else \
+	  rm -f $(srcdir)/librygel_gst_la_vala.stamp; \
+	  $(am__cd) $(srcdir) && $(MAKE) $(AM_MAKEFLAGS) librygel_gst_la_vala.stamp; \
+	fi
+$(srcdir)/rygel-gst-player-states.c: $(srcdir)/librygel_gst_la_vala.stamp
+	@if test -f $@; then :; else \
+	  rm -f $(srcdir)/librygel_gst_la_vala.stamp; \
+	  $(am__cd) $(srcdir) && $(MAKE) $(AM_MAKEFLAGS) librygel_gst_la_vala.stamp; \
+	fi
+librygel_gst_la_vala.stamp: $(librygel_gst_la_SOURCES)
+	$(AM_V_VALAC)$(VALAC) $(librygel_gst_la_VALAFLAGS) $(VALAFLAGS) -C $(librygel_gst_la_SOURCES)
+	$(AM_V_at)touch $@
+
+mostlyclean-libtool:
+	-rm -f *.lo
+
+clean-libtool:
+	-rm -rf .libs _libs
+
+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
+	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	mkid -fID $$unique
+tags: TAGS
+
+TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	set x; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	shift; \
+	if test -z "$(ETAGS_ARGS)$$*$$unique"; then :; else \
+	  test -n "$$unique" || unique=$$empty_fix; \
+	  if test $$# -gt 0; then \
+	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	      "$$@" $$unique; \
+	  else \
+	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	      $$unique; \
+	  fi; \
+	fi
+ctags: CTAGS
+CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	test -z "$(CTAGS_ARGS)$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
+	     $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && $(am__cd) $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) "$$here"
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+
+distdir: $(DISTFILES)
+	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	list='$(DISTFILES)'; \
+	  dist_files=`for file in $$list; do echo $$file; done | \
+	  sed -e "s|^$$srcdirstrip/||;t" \
+	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
+	case $$dist_files in \
+	  */*) $(MKDIR_P) `echo "$$dist_files" | \
+			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
+			   sort -u` ;; \
+	esac; \
+	for file in $$dist_files; do \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  if test -d $$d/$$file; then \
+	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
+	    if test -d "$(distdir)/$$file"; then \
+	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
+	    fi; \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -fpR $(srcdir)/$$file "$(distdir)$$dir" || exit 1; \
+	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
+	    fi; \
+	    cp -fpR $$d/$$file "$(distdir)$$dir" || exit 1; \
+	  else \
+	    test -f "$(distdir)/$$file" \
+	    || cp -p $$d/$$file "$(distdir)/$$file" \
+	    || exit 1; \
+	  fi; \
+	done
+check-am: all-am
+check: check-am
+all-am: Makefile $(LTLIBRARIES)
+installdirs:
+	for dir in "$(DESTDIR)$(plugindir)"; do \
+	  test -z "$$dir" || $(MKDIR_P) "$$dir"; \
+	done
+install: install-am
+install-exec: install-exec-am
+install-data: install-data-am
+uninstall: uninstall-am
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-am
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	  `test -z '$(STRIP)' || \
+	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+mostlyclean-generic:
+
+clean-generic:
+	-test -z "$(CLEANFILES)" || rm -f $(CLEANFILES)
+
+distclean-generic:
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
+	-test . = "$(srcdir)" || test -z "$(CONFIG_CLEAN_VPATH_FILES)" || rm -f $(CONFIG_CLEAN_VPATH_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+	-rm -f librygel_gst_la_vala.stamp
+	-rm -f rygel-gst-audio-player-instance.c
+	-rm -f rygel-gst-av-transport.c
+	-rm -f rygel-gst-changelog.c
+	-rm -f rygel-gst-connection-manager.c
+	-rm -f rygel-gst-metadata-parser.c
+	-rm -f rygel-gst-player-states.c
+	-rm -f rygel-gst-plugin.c
+	-rm -f rygel-gst-rendering-control.c
+	-rm -f rygel-helper-gst-time.c
+	-test -z "$(MAINTAINERCLEANFILES)" || rm -f $(MAINTAINERCLEANFILES)
+clean: clean-am
+
+clean-am: clean-generic clean-libtool clean-pluginLTLIBRARIES \
+	mostlyclean-am
+
+distclean: distclean-am
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+distclean-am: clean-am distclean-compile distclean-generic \
+	distclean-tags
+
+dvi: dvi-am
+
+dvi-am:
+
+html: html-am
+
+html-am:
+
+info: info-am
+
+info-am:
+
+install-data-am: install-pluginLTLIBRARIES
+
+install-dvi: install-dvi-am
+
+install-dvi-am:
+
+install-exec-am:
+
+install-html: install-html-am
+
+install-html-am:
+
+install-info: install-info-am
+
+install-info-am:
+
+install-man:
+
+install-pdf: install-pdf-am
+
+install-pdf-am:
+
+install-ps: install-ps-am
+
+install-ps-am:
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-am
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-am
+
+mostlyclean-am: mostlyclean-compile mostlyclean-generic \
+	mostlyclean-libtool
+
+pdf: pdf-am
+
+pdf-am:
+
+ps: ps-am
+
+ps-am:
+
+uninstall-am: uninstall-pluginLTLIBRARIES
+
+.MAKE: install-am install-strip
+
+.PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
+	clean-libtool clean-pluginLTLIBRARIES ctags distclean \
+	distclean-compile distclean-generic distclean-libtool \
+	distclean-tags distdir dvi dvi-am html html-am info info-am \
+	install install-am install-data install-data-am install-dvi \
+	install-dvi-am install-exec install-exec-am install-html \
+	install-html-am install-info install-info-am install-man \
+	install-pdf install-pdf-am install-pluginLTLIBRARIES \
+	install-ps install-ps-am install-strip installcheck \
+	installcheck-am installdirs maintainer-clean \
+	maintainer-clean-generic mostlyclean mostlyclean-compile \
+	mostlyclean-generic mostlyclean-libtool pdf pdf-am ps ps-am \
+	tags uninstall uninstall-am uninstall-pluginLTLIBRARIES
+
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
--- a/src/plugins/gstlaunch/Makefile.in
+++ b/src/plugins/gstlaunch/Makefile.in
@@ -40,7 +40,8 @@ DIST_COMMON = $(srcdir)/Makefile.am $(sr
 	rygel-gstlaunch-item.c rygel-gstlaunch-plugin.c \
 	rygel-gstlaunch-root-container.c
 ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
-am__aclocal_m4_deps = $(top_srcdir)/m4/libtool.m4 \
+am__aclocal_m4_deps = $(top_srcdir)/m4/glib-gettext.m4 \
+	$(top_srcdir)/m4/isc-posix.m4 $(top_srcdir)/m4/libtool.m4 \
 	$(top_srcdir)/m4/ltoptions.m4 $(top_srcdir)/m4/ltsugar.m4 \
 	$(top_srcdir)/m4/ltversion.m4 $(top_srcdir)/m4/lt~obsolete.m4 \
 	$(top_srcdir)/configure.ac
@@ -76,7 +77,7 @@ LTLIBRARIES = $(plugin_LTLIBRARIES)
 am__DEPENDENCIES_1 =
 librygel_gstlaunch_la_DEPENDENCIES = $(am__DEPENDENCIES_1) \
 	$(am__DEPENDENCIES_1) $(am__DEPENDENCIES_1) \
-	$(am__DEPENDENCIES_1) $(am__DEPENDENCIES_1)
+	$(am__DEPENDENCIES_1)
 am_librygel_gstlaunch_la_OBJECTS = rygel-gstlaunch-plugin.lo \
 	rygel-gstlaunch-root-container.lo \
 	rygel-gstlaunch-content-dir.lo rygel-gstlaunch-item.lo
@@ -162,8 +163,6 @@ GMSGFMT = @GMSGFMT@
 GREP = @GREP@
 GTK_CFLAGS = @GTK_CFLAGS@
 GTK_LIBS = @GTK_LIBS@
-GUPNP_VALA_CFLAGS = @GUPNP_VALA_CFLAGS@
-GUPNP_VALA_LIBS = @GUPNP_VALA_LIBS@
 HAVE_GTK = @HAVE_GTK@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
@@ -178,8 +177,8 @@ LIBDBUS_GLIB_CFLAGS = @LIBDBUS_GLIB_CFLA
 LIBDBUS_GLIB_LIBS = @LIBDBUS_GLIB_LIBS@
 LIBGIO_CFLAGS = @LIBGIO_CFLAGS@
 LIBGIO_LIBS = @LIBGIO_LIBS@
-LIBGSTREAMER_CFLAGS = @LIBGSTREAMER_CFLAGS@
-LIBGSTREAMER_LIBS = @LIBGSTREAMER_LIBS@
+LIBGLIB_CFLAGS = @LIBGLIB_CFLAGS@
+LIBGLIB_LIBS = @LIBGLIB_LIBS@
 LIBGUPNP_AV_CFLAGS = @LIBGUPNP_AV_CFLAGS@
 LIBGUPNP_AV_LIBS = @LIBGUPNP_AV_LIBS@
 LIBGUPNP_CFLAGS = @LIBGUPNP_CFLAGS@
@@ -191,6 +190,8 @@ LIBSOUP_LIBS = @LIBSOUP_LIBS@
 LIBSQLITE3_CFLAGS = @LIBSQLITE3_CFLAGS@
 LIBSQLITE3_LIBS = @LIBSQLITE3_LIBS@
 LIBTOOL = @LIBTOOL@
+LIBVLC_CFLAGS = @LIBVLC_CFLAGS@
+LIBVLC_LIBS = @LIBVLC_LIBS@
 LIPO = @LIPO@
 LN_S = @LN_S@
 LTLIBOBJS = @LTLIBOBJS@
@@ -211,6 +212,7 @@ PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
 PACKAGE_NAME = @PACKAGE_NAME@
 PACKAGE_STRING = @PACKAGE_STRING@
 PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_URL = @PACKAGE_URL@
 PACKAGE_VERSION = @PACKAGE_VERSION@
 PATH_SEPARATOR = @PATH_SEPARATOR@
 PKG_CONFIG = @PKG_CONFIG@
@@ -224,8 +226,6 @@ SET_MAKE = @SET_MAKE@
 SHELL = @SHELL@
 STRIP = @STRIP@
 USE_NLS = @USE_NLS@
-UUID_CFLAGS = @UUID_CFLAGS@
-UUID_LIBS = @UUID_LIBS@
 VALAC = @VALAC@
 VAPIDIR = @VAPIDIR@
 VERSION = @VERSION@
--- a/src/plugins/gstlaunch/rygel-gstlaunch-content-dir.c
+++ /dev/null
@@ -1,130 +0,0 @@
-/* rygel-gstlaunch-content-dir.c generated by valac, the Vala compiler
- * generated from rygel-gstlaunch-content-dir.vala, do not modify */
-
-/*
- * Copyright (C) 2009 Thijs Vermeir <thijsvermeir@gmail.com>
- *
- * Author: Thijs Vermeir <thijsvermeir@gmail.com>
- *
- * This file is part of Rygel.
- *
- * Rygel is free software; you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * Rygel is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this program; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
- */
-
-#include <glib.h>
-#include <glib-object.h>
-#include <rygel.h>
-#include <libgupnp/gupnp.h>
-#include <stdlib.h>
-#include <string.h>
-
-
-#define RYGEL_TYPE_GST_LAUNCH_CONTENT_DIR (rygel_gst_launch_content_dir_get_type ())
-#define RYGEL_GST_LAUNCH_CONTENT_DIR(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_GST_LAUNCH_CONTENT_DIR, RygelGstLaunchContentDir))
-#define RYGEL_GST_LAUNCH_CONTENT_DIR_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_GST_LAUNCH_CONTENT_DIR, RygelGstLaunchContentDirClass))
-#define RYGEL_IS_GST_LAUNCH_CONTENT_DIR(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_GST_LAUNCH_CONTENT_DIR))
-#define RYGEL_IS_GST_LAUNCH_CONTENT_DIR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_GST_LAUNCH_CONTENT_DIR))
-#define RYGEL_GST_LAUNCH_CONTENT_DIR_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_GST_LAUNCH_CONTENT_DIR, RygelGstLaunchContentDirClass))
-
-typedef struct _RygelGstLaunchContentDir RygelGstLaunchContentDir;
-typedef struct _RygelGstLaunchContentDirClass RygelGstLaunchContentDirClass;
-typedef struct _RygelGstLaunchContentDirPrivate RygelGstLaunchContentDirPrivate;
-#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
-
-#define RYGEL_TYPE_GST_LAUNCH_ROOT_CONTAINER (rygel_gst_launch_root_container_get_type ())
-#define RYGEL_GST_LAUNCH_ROOT_CONTAINER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_GST_LAUNCH_ROOT_CONTAINER, RygelGstLaunchRootContainer))
-#define RYGEL_GST_LAUNCH_ROOT_CONTAINER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_GST_LAUNCH_ROOT_CONTAINER, RygelGstLaunchRootContainerClass))
-#define RYGEL_IS_GST_LAUNCH_ROOT_CONTAINER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_GST_LAUNCH_ROOT_CONTAINER))
-#define RYGEL_IS_GST_LAUNCH_ROOT_CONTAINER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_GST_LAUNCH_ROOT_CONTAINER))
-#define RYGEL_GST_LAUNCH_ROOT_CONTAINER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_GST_LAUNCH_ROOT_CONTAINER, RygelGstLaunchRootContainerClass))
-
-typedef struct _RygelGstLaunchRootContainer RygelGstLaunchRootContainer;
-typedef struct _RygelGstLaunchRootContainerClass RygelGstLaunchRootContainerClass;
-#define _g_free0(var) (var = (g_free (var), NULL))
-
-struct _RygelGstLaunchContentDir {
-	RygelContentDirectory parent_instance;
-	RygelGstLaunchContentDirPrivate * priv;
-};
-
-struct _RygelGstLaunchContentDirClass {
-	RygelContentDirectoryClass parent_class;
-};
-
-
-static gpointer rygel_gst_launch_content_dir_parent_class = NULL;
-
-GType rygel_gst_launch_content_dir_get_type (void);
-enum  {
-	RYGEL_GST_LAUNCH_CONTENT_DIR_DUMMY_PROPERTY
-};
-RygelGstLaunchRootContainer* rygel_gst_launch_root_container_new (const char* title);
-RygelGstLaunchRootContainer* rygel_gst_launch_root_container_construct (GType object_type, const char* title);
-GType rygel_gst_launch_root_container_get_type (void);
-static RygelMediaContainer* rygel_gst_launch_content_dir_real_create_root_container (RygelContentDirectory* base);
-RygelGstLaunchContentDir* rygel_gst_launch_content_dir_new (void);
-RygelGstLaunchContentDir* rygel_gst_launch_content_dir_construct (GType object_type);
-
-
-
-static RygelMediaContainer* rygel_gst_launch_content_dir_real_create_root_container (RygelContentDirectory* base) {
-	RygelGstLaunchContentDir * self;
-	RygelMediaContainer* result;
-	GUPnPRootDevice* _tmp1_;
-	GUPnPRootDevice* _tmp0_ = NULL;
-	char* _tmp2_;
-	char* friendly_name;
-	self = (RygelGstLaunchContentDir*) base;
-	friendly_name = (_tmp2_ = gupnp_device_info_get_friendly_name ((GUPnPDeviceInfo*) (_tmp1_ = (g_object_get ((GUPnPService*) self, "root-device", &_tmp0_, NULL), _tmp0_))), _g_object_unref0 (_tmp1_), _tmp2_);
-	result = (RygelMediaContainer*) rygel_gst_launch_root_container_new (friendly_name);
-	_g_free0 (friendly_name);
-	return result;
-}
-
-
-RygelGstLaunchContentDir* rygel_gst_launch_content_dir_construct (GType object_type) {
-	RygelGstLaunchContentDir * self;
-	self = (RygelGstLaunchContentDir*) rygel_content_directory_construct (object_type);
-	return self;
-}
-
-
-RygelGstLaunchContentDir* rygel_gst_launch_content_dir_new (void) {
-	return rygel_gst_launch_content_dir_construct (RYGEL_TYPE_GST_LAUNCH_CONTENT_DIR);
-}
-
-
-static void rygel_gst_launch_content_dir_class_init (RygelGstLaunchContentDirClass * klass) {
-	rygel_gst_launch_content_dir_parent_class = g_type_class_peek_parent (klass);
-	RYGEL_CONTENT_DIRECTORY_CLASS (klass)->create_root_container = rygel_gst_launch_content_dir_real_create_root_container;
-}
-
-
-static void rygel_gst_launch_content_dir_instance_init (RygelGstLaunchContentDir * self) {
-}
-
-
-GType rygel_gst_launch_content_dir_get_type (void) {
-	static GType rygel_gst_launch_content_dir_type_id = 0;
-	if (rygel_gst_launch_content_dir_type_id == 0) {
-		static const GTypeInfo g_define_type_info = { sizeof (RygelGstLaunchContentDirClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) rygel_gst_launch_content_dir_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (RygelGstLaunchContentDir), 0, (GInstanceInitFunc) rygel_gst_launch_content_dir_instance_init, NULL };
-		rygel_gst_launch_content_dir_type_id = g_type_register_static (RYGEL_TYPE_CONTENT_DIRECTORY, "RygelGstLaunchContentDir", &g_define_type_info, 0);
-	}
-	return rygel_gst_launch_content_dir_type_id;
-}
-
-
-
-
--- a/src/plugins/gstlaunch/rygel-gstlaunch-item.c
+++ /dev/null
@@ -1,173 +0,0 @@
-/* rygel-gstlaunch-item.c generated by valac, the Vala compiler
- * generated from rygel-gstlaunch-item.vala, do not modify */
-
-/*
- * Copyright (C) 2009 Thijs Vermeir <thijsvermeir@gmail.com>
- *
- * Author: Thijs Vermeir <thijsvermeir@gmail.com>
- *
- * This file is part of Rygel.
- *
- * Rygel is free software; you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * Rygel is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this program; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
- */
-
-#include <glib.h>
-#include <glib-object.h>
-#include <rygel.h>
-#include <stdlib.h>
-#include <string.h>
-#include <gst/gst.h>
-
-
-#define RYGEL_TYPE_GST_LAUNCH_ITEM (rygel_gst_launch_item_get_type ())
-#define RYGEL_GST_LAUNCH_ITEM(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_GST_LAUNCH_ITEM, RygelGstLaunchItem))
-#define RYGEL_GST_LAUNCH_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_GST_LAUNCH_ITEM, RygelGstLaunchItemClass))
-#define RYGEL_IS_GST_LAUNCH_ITEM(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_GST_LAUNCH_ITEM))
-#define RYGEL_IS_GST_LAUNCH_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_GST_LAUNCH_ITEM))
-#define RYGEL_GST_LAUNCH_ITEM_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_GST_LAUNCH_ITEM, RygelGstLaunchItemClass))
-
-typedef struct _RygelGstLaunchItem RygelGstLaunchItem;
-typedef struct _RygelGstLaunchItemClass RygelGstLaunchItemClass;
-typedef struct _RygelGstLaunchItemPrivate RygelGstLaunchItemPrivate;
-#define _g_free0(var) (var = (g_free (var), NULL))
-#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
-
-struct _RygelGstLaunchItem {
-	RygelMediaItem parent_instance;
-	RygelGstLaunchItemPrivate * priv;
-};
-
-struct _RygelGstLaunchItemClass {
-	RygelMediaItemClass parent_class;
-};
-
-struct _RygelGstLaunchItemPrivate {
-	char* launch_line;
-};
-
-
-static gpointer rygel_gst_launch_item_parent_class = NULL;
-
-GType rygel_gst_launch_item_get_type (void);
-#define RYGEL_GST_LAUNCH_ITEM_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), RYGEL_TYPE_GST_LAUNCH_ITEM, RygelGstLaunchItemPrivate))
-enum  {
-	RYGEL_GST_LAUNCH_ITEM_DUMMY_PROPERTY
-};
-RygelGstLaunchItem* rygel_gst_launch_item_new (const char* id, RygelMediaContainer* parent, const char* title, const char* mime_type, const char* launch_line);
-RygelGstLaunchItem* rygel_gst_launch_item_construct (GType object_type, const char* id, RygelMediaContainer* parent, const char* title, const char* mime_type, const char* launch_line);
-static GstElement* rygel_gst_launch_item_real_create_stream_source (RygelMediaItem* base);
-static void rygel_gst_launch_item_finalize (GObject* obj);
-
-
-
-RygelGstLaunchItem* rygel_gst_launch_item_construct (GType object_type, const char* id, RygelMediaContainer* parent, const char* title, const char* mime_type, const char* launch_line) {
-	RygelGstLaunchItem * self;
-	const char* _tmp0_;
-	char* _tmp1_;
-	char* _tmp2_;
-	g_return_val_if_fail (id != NULL, NULL);
-	g_return_val_if_fail (parent != NULL, NULL);
-	g_return_val_if_fail (title != NULL, NULL);
-	g_return_val_if_fail (mime_type != NULL, NULL);
-	g_return_val_if_fail (launch_line != NULL, NULL);
-	_tmp0_ = NULL;
-	if (g_str_has_prefix (mime_type, "audio")) {
-		_tmp0_ = RYGEL_MEDIA_ITEM_AUDIO_CLASS;
-	} else {
-		_tmp0_ = RYGEL_MEDIA_ITEM_VIDEO_CLASS;
-	}
-	self = (RygelGstLaunchItem*) rygel_media_item_construct (object_type, id, parent, title, _tmp0_);
-	((RygelMediaItem*) self)->mime_type = (_tmp1_ = g_strdup (mime_type), _g_free0 (((RygelMediaItem*) self)->mime_type), _tmp1_);
-	self->priv->launch_line = (_tmp2_ = g_strdup (launch_line), _g_free0 (self->priv->launch_line), _tmp2_);
-	return self;
-}
-
-
-RygelGstLaunchItem* rygel_gst_launch_item_new (const char* id, RygelMediaContainer* parent, const char* title, const char* mime_type, const char* launch_line) {
-	return rygel_gst_launch_item_construct (RYGEL_TYPE_GST_LAUNCH_ITEM, id, parent, title, mime_type, launch_line);
-}
-
-
-static GstElement* rygel_gst_launch_item_real_create_stream_source (RygelMediaItem* base) {
-	RygelGstLaunchItem * self;
-	GstElement* result;
-	GError * _inner_error_;
-	self = (RygelGstLaunchItem*) base;
-	_inner_error_ = NULL;
-	{
-		GstElement* _tmp0_;
-		_tmp0_ = gst_parse_bin_from_description (self->priv->launch_line, TRUE, &_inner_error_);
-		if (_inner_error_ != NULL) {
-			goto __catch2_g_error;
-			goto __finally2;
-		}
-		result = _tmp0_;
-		return result;
-	}
-	goto __finally2;
-	__catch2_g_error:
-	{
-		GError * err;
-		err = _inner_error_;
-		_inner_error_ = NULL;
-		{
-			g_warning ("rygel-gstlaunch-item.vala:51: parse launchline failed: %s", err->message);
-			result = NULL;
-			_g_error_free0 (err);
-			return result;
-		}
-	}
-	__finally2:
-	if (_inner_error_ != NULL) {
-		g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
-		g_clear_error (&_inner_error_);
-		return NULL;
-	}
-}
-
-
-static void rygel_gst_launch_item_class_init (RygelGstLaunchItemClass * klass) {
-	rygel_gst_launch_item_parent_class = g_type_class_peek_parent (klass);
-	g_type_class_add_private (klass, sizeof (RygelGstLaunchItemPrivate));
-	RYGEL_MEDIA_ITEM_CLASS (klass)->create_stream_source = rygel_gst_launch_item_real_create_stream_source;
-	G_OBJECT_CLASS (klass)->finalize = rygel_gst_launch_item_finalize;
-}
-
-
-static void rygel_gst_launch_item_instance_init (RygelGstLaunchItem * self) {
-	self->priv = RYGEL_GST_LAUNCH_ITEM_GET_PRIVATE (self);
-}
-
-
-static void rygel_gst_launch_item_finalize (GObject* obj) {
-	RygelGstLaunchItem * self;
-	self = RYGEL_GST_LAUNCH_ITEM (obj);
-	_g_free0 (self->priv->launch_line);
-	G_OBJECT_CLASS (rygel_gst_launch_item_parent_class)->finalize (obj);
-}
-
-
-GType rygel_gst_launch_item_get_type (void) {
-	static GType rygel_gst_launch_item_type_id = 0;
-	if (rygel_gst_launch_item_type_id == 0) {
-		static const GTypeInfo g_define_type_info = { sizeof (RygelGstLaunchItemClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) rygel_gst_launch_item_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (RygelGstLaunchItem), 0, (GInstanceInitFunc) rygel_gst_launch_item_instance_init, NULL };
-		rygel_gst_launch_item_type_id = g_type_register_static (RYGEL_TYPE_MEDIA_ITEM, "RygelGstLaunchItem", &g_define_type_info, 0);
-	}
-	return rygel_gst_launch_item_type_id;
-}
-
-
-
-
--- a/src/plugins/gstlaunch/rygel-gstlaunch-plugin.c
+++ /dev/null
@@ -1,64 +0,0 @@
-/* rygel-gstlaunch-plugin.c generated by valac, the Vala compiler
- * generated from rygel-gstlaunch-plugin.vala, do not modify */
-
-/*
- * Copyright (C) 2009 Thijs Vermeir <thijsvermeir@gmail.com>
- *
- * Author: Thijs Vermeir <thijsvermeir@gmail.com>
- *
- * This file is part of Rygel.
- *
- * Rygel is free software; you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * Rygel is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this program; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
- */
-
-#include <glib.h>
-#include <glib-object.h>
-#include <rygel.h>
-
-
-#define RYGEL_TYPE_GST_LAUNCH_CONTENT_DIR (rygel_gst_launch_content_dir_get_type ())
-#define RYGEL_GST_LAUNCH_CONTENT_DIR(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_GST_LAUNCH_CONTENT_DIR, RygelGstLaunchContentDir))
-#define RYGEL_GST_LAUNCH_CONTENT_DIR_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_GST_LAUNCH_CONTENT_DIR, RygelGstLaunchContentDirClass))
-#define RYGEL_IS_GST_LAUNCH_CONTENT_DIR(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_GST_LAUNCH_CONTENT_DIR))
-#define RYGEL_IS_GST_LAUNCH_CONTENT_DIR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_GST_LAUNCH_CONTENT_DIR))
-#define RYGEL_GST_LAUNCH_CONTENT_DIR_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_GST_LAUNCH_CONTENT_DIR, RygelGstLaunchContentDirClass))
-
-typedef struct _RygelGstLaunchContentDir RygelGstLaunchContentDir;
-typedef struct _RygelGstLaunchContentDirClass RygelGstLaunchContentDirClass;
-#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
-#define _rygel_resource_info_unref0(var) ((var == NULL) ? NULL : (var = (rygel_resource_info_unref (var), NULL)))
-
-
-
-GType rygel_gst_launch_content_dir_get_type (void);
-void module_init (RygelPluginLoader* loader);
-
-
-
-void module_init (RygelPluginLoader* loader) {
-	RygelPlugin* plugin;
-	RygelResourceInfo* resource_info;
-	g_return_if_fail (loader != NULL);
-	plugin = rygel_plugin_new_MediaServer ("GstLaunch", "Gst Launch");
-	resource_info = rygel_resource_info_new (RYGEL_CONTENT_DIRECTORY_UPNP_ID, RYGEL_CONTENT_DIRECTORY_UPNP_TYPE, RYGEL_CONTENT_DIRECTORY_DESCRIPTION_PATH, RYGEL_TYPE_GST_LAUNCH_CONTENT_DIR);
-	rygel_plugin_add_resource (plugin, resource_info);
-	rygel_plugin_loader_add_plugin (loader, plugin);
-	_g_object_unref0 (plugin);
-	_rygel_resource_info_unref0 (resource_info);
-}
-
-
-
-
--- a/src/plugins/gstlaunch/rygel-gstlaunch-root-container.c
+++ /dev/null
@@ -1,239 +0,0 @@
-/* rygel-gstlaunch-root-container.c generated by valac, the Vala compiler
- * generated from rygel-gstlaunch-root-container.vala, do not modify */
-
-/*
- * Copyright (C) 2009 Thijs Vermeir <thijsvermeir@gmail.com>
- *
- * Author: Thijs Vermeir <thijsvermeir@gmail.com>
- *
- * This file is part of Rygel.
- *
- * Rygel is free software; you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * Rygel is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this program; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
- */
-
-#include <glib.h>
-#include <glib-object.h>
-#include <rygel.h>
-#include <gee.h>
-#include <stdlib.h>
-#include <string.h>
-
-
-#define RYGEL_TYPE_GST_LAUNCH_ROOT_CONTAINER (rygel_gst_launch_root_container_get_type ())
-#define RYGEL_GST_LAUNCH_ROOT_CONTAINER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_GST_LAUNCH_ROOT_CONTAINER, RygelGstLaunchRootContainer))
-#define RYGEL_GST_LAUNCH_ROOT_CONTAINER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_GST_LAUNCH_ROOT_CONTAINER, RygelGstLaunchRootContainerClass))
-#define RYGEL_IS_GST_LAUNCH_ROOT_CONTAINER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_GST_LAUNCH_ROOT_CONTAINER))
-#define RYGEL_IS_GST_LAUNCH_ROOT_CONTAINER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_GST_LAUNCH_ROOT_CONTAINER))
-#define RYGEL_GST_LAUNCH_ROOT_CONTAINER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_GST_LAUNCH_ROOT_CONTAINER, RygelGstLaunchRootContainerClass))
-
-typedef struct _RygelGstLaunchRootContainer RygelGstLaunchRootContainer;
-typedef struct _RygelGstLaunchRootContainerClass RygelGstLaunchRootContainerClass;
-typedef struct _RygelGstLaunchRootContainerPrivate RygelGstLaunchRootContainerPrivate;
-#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
-#define _g_free0(var) (var = (g_free (var), NULL))
-#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
-
-#define RYGEL_TYPE_GST_LAUNCH_ITEM (rygel_gst_launch_item_get_type ())
-#define RYGEL_GST_LAUNCH_ITEM(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_GST_LAUNCH_ITEM, RygelGstLaunchItem))
-#define RYGEL_GST_LAUNCH_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_GST_LAUNCH_ITEM, RygelGstLaunchItemClass))
-#define RYGEL_IS_GST_LAUNCH_ITEM(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_GST_LAUNCH_ITEM))
-#define RYGEL_IS_GST_LAUNCH_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_GST_LAUNCH_ITEM))
-#define RYGEL_GST_LAUNCH_ITEM_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_GST_LAUNCH_ITEM, RygelGstLaunchItemClass))
-
-typedef struct _RygelGstLaunchItem RygelGstLaunchItem;
-typedef struct _RygelGstLaunchItemClass RygelGstLaunchItemClass;
-
-struct _RygelGstLaunchRootContainer {
-	RygelSimpleContainer parent_instance;
-	RygelGstLaunchRootContainerPrivate * priv;
-};
-
-struct _RygelGstLaunchRootContainerClass {
-	RygelSimpleContainerClass parent_class;
-};
-
-struct _RygelGstLaunchRootContainerPrivate {
-	RygelMetaConfig* config;
-};
-
-
-static gpointer rygel_gst_launch_root_container_parent_class = NULL;
-
-GType rygel_gst_launch_root_container_get_type (void);
-#define RYGEL_GST_LAUNCH_ROOT_CONTAINER_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), RYGEL_TYPE_GST_LAUNCH_ROOT_CONTAINER, RygelGstLaunchRootContainerPrivate))
-enum  {
-	RYGEL_GST_LAUNCH_ROOT_CONTAINER_DUMMY_PROPERTY
-};
-#define RYGEL_GST_LAUNCH_ROOT_CONTAINER_CONFIG_GROUP "GstLaunch"
-#define RYGEL_GST_LAUNCH_ROOT_CONTAINER_ITEM_NAMES "launch_items"
-static void rygel_gst_launch_root_container_add_launch_item (RygelGstLaunchRootContainer* self, const char* name);
-RygelGstLaunchRootContainer* rygel_gst_launch_root_container_new (const char* title);
-RygelGstLaunchRootContainer* rygel_gst_launch_root_container_construct (GType object_type, const char* title);
-RygelGstLaunchItem* rygel_gst_launch_item_new (const char* id, RygelMediaContainer* parent, const char* title, const char* mime_type, const char* launch_line);
-RygelGstLaunchItem* rygel_gst_launch_item_construct (GType object_type, const char* id, RygelMediaContainer* parent, const char* title, const char* mime_type, const char* launch_line);
-GType rygel_gst_launch_item_get_type (void);
-static void rygel_gst_launch_root_container_finalize (GObject* obj);
-
-
-
-RygelGstLaunchRootContainer* rygel_gst_launch_root_container_construct (GType object_type, const char* title) {
-	GError * _inner_error_;
-	RygelGstLaunchRootContainer * self;
-	g_return_val_if_fail (title != NULL, NULL);
-	_inner_error_ = NULL;
-	self = (RygelGstLaunchRootContainer*) rygel_simple_container_construct_root (object_type, title);
-	{
-		RygelMetaConfig* _tmp0_;
-		GeeArrayList* item_names;
-		self->priv->config = (_tmp0_ = rygel_meta_config_get_default (), _g_object_unref0 (self->priv->config), _tmp0_);
-		item_names = rygel_configuration_get_string_list ((RygelConfiguration*) self->priv->config, RYGEL_GST_LAUNCH_ROOT_CONTAINER_CONFIG_GROUP, RYGEL_GST_LAUNCH_ROOT_CONTAINER_ITEM_NAMES, &_inner_error_);
-		if (_inner_error_ != NULL) {
-			goto __catch0_g_error;
-			goto __finally0;
-		}
-		{
-			GeeIterator* _name_it;
-			_name_it = gee_abstract_collection_iterator ((GeeAbstractCollection*) item_names);
-			while (TRUE) {
-				char* name;
-				if (!gee_iterator_next (_name_it)) {
-					break;
-				}
-				name = (char*) gee_iterator_get (_name_it);
-				rygel_gst_launch_root_container_add_launch_item (self, name);
-				_g_free0 (name);
-			}
-			_g_object_unref0 (_name_it);
-		}
-		_g_object_unref0 (item_names);
-	}
-	goto __finally0;
-	__catch0_g_error:
-	{
-		GError * err;
-		err = _inner_error_;
-		_inner_error_ = NULL;
-		{
-			g_debug ("rygel-gstlaunch-root-container.vala:49: GstLaunch init failed: %s", err->message);
-			_g_error_free0 (err);
-		}
-	}
-	__finally0:
-	if (_inner_error_ != NULL) {
-		g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
-		g_clear_error (&_inner_error_);
-		return NULL;
-	}
-	return self;
-}
-
-
-RygelGstLaunchRootContainer* rygel_gst_launch_root_container_new (const char* title) {
-	return rygel_gst_launch_root_container_construct (RYGEL_TYPE_GST_LAUNCH_ROOT_CONTAINER, title);
-}
-
-
-static void rygel_gst_launch_root_container_add_launch_item (RygelGstLaunchRootContainer* self, const char* name) {
-	GError * _inner_error_;
-	g_return_if_fail (self != NULL);
-	g_return_if_fail (name != NULL);
-	_inner_error_ = NULL;
-	{
-		char* _tmp0_;
-		char* _tmp1_;
-		char* title;
-		char* _tmp2_;
-		char* _tmp3_;
-		char* mime_type;
-		char* _tmp4_;
-		char* _tmp5_;
-		char* launch_line;
-		RygelGstLaunchItem* _tmp6_;
-		title = (_tmp1_ = rygel_configuration_get_string ((RygelConfiguration*) self->priv->config, RYGEL_GST_LAUNCH_ROOT_CONTAINER_CONFIG_GROUP, _tmp0_ = g_strdup_printf ("%s_title", name), &_inner_error_), _g_free0 (_tmp0_), _tmp1_);
-		if (_inner_error_ != NULL) {
-			goto __catch1_g_error;
-			goto __finally1;
-		}
-		mime_type = (_tmp3_ = rygel_configuration_get_string ((RygelConfiguration*) self->priv->config, RYGEL_GST_LAUNCH_ROOT_CONTAINER_CONFIG_GROUP, _tmp2_ = g_strdup_printf ("%s_mime", name), &_inner_error_), _g_free0 (_tmp2_), _tmp3_);
-		if (_inner_error_ != NULL) {
-			_g_free0 (title);
-			goto __catch1_g_error;
-			goto __finally1;
-		}
-		launch_line = (_tmp5_ = rygel_configuration_get_string ((RygelConfiguration*) self->priv->config, RYGEL_GST_LAUNCH_ROOT_CONTAINER_CONFIG_GROUP, _tmp4_ = g_strdup_printf ("%s_launch", name), &_inner_error_), _g_free0 (_tmp4_), _tmp5_);
-		if (_inner_error_ != NULL) {
-			_g_free0 (title);
-			_g_free0 (mime_type);
-			goto __catch1_g_error;
-			goto __finally1;
-		}
-		rygel_simple_container_add_child ((RygelSimpleContainer*) self, (RygelMediaObject*) (_tmp6_ = rygel_gst_launch_item_new (name, (RygelMediaContainer*) self, title, mime_type, launch_line)));
-		_g_object_unref0 (_tmp6_);
-		_g_free0 (title);
-		_g_free0 (mime_type);
-		_g_free0 (launch_line);
-	}
-	goto __finally1;
-	__catch1_g_error:
-	{
-		GError * err;
-		err = _inner_error_;
-		_inner_error_ = NULL;
-		{
-			g_debug ("rygel-gstlaunch-root-container.vala:68: GstLaunch failed item '%s': %s", name, err->message);
-			_g_error_free0 (err);
-		}
-	}
-	__finally1:
-	if (_inner_error_ != NULL) {
-		g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
-		g_clear_error (&_inner_error_);
-		return;
-	}
-}
-
-
-static void rygel_gst_launch_root_container_class_init (RygelGstLaunchRootContainerClass * klass) {
-	rygel_gst_launch_root_container_parent_class = g_type_class_peek_parent (klass);
-	g_type_class_add_private (klass, sizeof (RygelGstLaunchRootContainerPrivate));
-	G_OBJECT_CLASS (klass)->finalize = rygel_gst_launch_root_container_finalize;
-}
-
-
-static void rygel_gst_launch_root_container_instance_init (RygelGstLaunchRootContainer * self) {
-	self->priv = RYGEL_GST_LAUNCH_ROOT_CONTAINER_GET_PRIVATE (self);
-}
-
-
-static void rygel_gst_launch_root_container_finalize (GObject* obj) {
-	RygelGstLaunchRootContainer * self;
-	self = RYGEL_GST_LAUNCH_ROOT_CONTAINER (obj);
-	_g_object_unref0 (self->priv->config);
-	G_OBJECT_CLASS (rygel_gst_launch_root_container_parent_class)->finalize (obj);
-}
-
-
-GType rygel_gst_launch_root_container_get_type (void) {
-	static GType rygel_gst_launch_root_container_type_id = 0;
-	if (rygel_gst_launch_root_container_type_id == 0) {
-		static const GTypeInfo g_define_type_info = { sizeof (RygelGstLaunchRootContainerClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) rygel_gst_launch_root_container_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (RygelGstLaunchRootContainer), 0, (GInstanceInitFunc) rygel_gst_launch_root_container_instance_init, NULL };
-		rygel_gst_launch_root_container_type_id = g_type_register_static (RYGEL_TYPE_SIMPLE_CONTAINER, "RygelGstLaunchRootContainer", &g_define_type_info, 0);
-	}
-	return rygel_gst_launch_root_container_type_id;
-}
-
-
-
-
--- a/src/plugins/media-export/Makefile.in
+++ b/src/plugins/media-export/Makefile.in
@@ -44,7 +44,8 @@ DIST_COMMON = $(srcdir)/Makefile.am $(sr
 	rygel-media-export-recursive-file-monitor.c \
 	rygel-media-export-root-container.c
 ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
-am__aclocal_m4_deps = $(top_srcdir)/m4/libtool.m4 \
+am__aclocal_m4_deps = $(top_srcdir)/m4/glib-gettext.m4 \
+	$(top_srcdir)/m4/isc-posix.m4 $(top_srcdir)/m4/libtool.m4 \
 	$(top_srcdir)/m4/ltoptions.m4 $(top_srcdir)/m4/ltsugar.m4 \
 	$(top_srcdir)/m4/ltversion.m4 $(top_srcdir)/m4/lt~obsolete.m4 \
 	$(top_srcdir)/configure.ac
@@ -80,7 +81,7 @@ LTLIBRARIES = $(plugin_LTLIBRARIES)
 am__DEPENDENCIES_1 =
 librygel_media_export_la_DEPENDENCIES = $(am__DEPENDENCIES_1) \
 	$(am__DEPENDENCIES_1) $(am__DEPENDENCIES_1) \
-	$(am__DEPENDENCIES_1) $(am__DEPENDENCIES_1)
+	$(am__DEPENDENCIES_1)
 am_librygel_media_export_la_OBJECTS = rygel-media-export-plugin.lo \
 	rygel-media-export-null-container.lo \
 	rygel-media-export-root-container.lo \
@@ -170,8 +171,6 @@ GMSGFMT = @GMSGFMT@
 GREP = @GREP@
 GTK_CFLAGS = @GTK_CFLAGS@
 GTK_LIBS = @GTK_LIBS@
-GUPNP_VALA_CFLAGS = @GUPNP_VALA_CFLAGS@
-GUPNP_VALA_LIBS = @GUPNP_VALA_LIBS@
 HAVE_GTK = @HAVE_GTK@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
@@ -186,8 +185,8 @@ LIBDBUS_GLIB_CFLAGS = @LIBDBUS_GLIB_CFLA
 LIBDBUS_GLIB_LIBS = @LIBDBUS_GLIB_LIBS@
 LIBGIO_CFLAGS = @LIBGIO_CFLAGS@
 LIBGIO_LIBS = @LIBGIO_LIBS@
-LIBGSTREAMER_CFLAGS = @LIBGSTREAMER_CFLAGS@
-LIBGSTREAMER_LIBS = @LIBGSTREAMER_LIBS@
+LIBGLIB_CFLAGS = @LIBGLIB_CFLAGS@
+LIBGLIB_LIBS = @LIBGLIB_LIBS@
 LIBGUPNP_AV_CFLAGS = @LIBGUPNP_AV_CFLAGS@
 LIBGUPNP_AV_LIBS = @LIBGUPNP_AV_LIBS@
 LIBGUPNP_CFLAGS = @LIBGUPNP_CFLAGS@
@@ -199,6 +198,8 @@ LIBSOUP_LIBS = @LIBSOUP_LIBS@
 LIBSQLITE3_CFLAGS = @LIBSQLITE3_CFLAGS@
 LIBSQLITE3_LIBS = @LIBSQLITE3_LIBS@
 LIBTOOL = @LIBTOOL@
+LIBVLC_CFLAGS = @LIBVLC_CFLAGS@
+LIBVLC_LIBS = @LIBVLC_LIBS@
 LIPO = @LIPO@
 LN_S = @LN_S@
 LTLIBOBJS = @LTLIBOBJS@
@@ -219,6 +220,7 @@ PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
 PACKAGE_NAME = @PACKAGE_NAME@
 PACKAGE_STRING = @PACKAGE_STRING@
 PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_URL = @PACKAGE_URL@
 PACKAGE_VERSION = @PACKAGE_VERSION@
 PATH_SEPARATOR = @PATH_SEPARATOR@
 PKG_CONFIG = @PKG_CONFIG@
@@ -232,8 +234,6 @@ SET_MAKE = @SET_MAKE@
 SHELL = @SHELL@
 STRIP = @STRIP@
 USE_NLS = @USE_NLS@
-UUID_CFLAGS = @UUID_CFLAGS@
-UUID_LIBS = @UUID_LIBS@
 VALAC = @VALAC@
 VAPIDIR = @VAPIDIR@
 VERSION = @VERSION@
--- a/src/plugins/media-export/rygel-media-export-dbus-service.c
+++ /dev/null
@@ -1,449 +0,0 @@
-/* rygel-media-export-dbus-service.c generated by valac, the Vala compiler
- * generated from rygel-media-export-dbus-service.vala, do not modify */
-
-/*
- * Copyright (C) 2009 Jens Georg <mail@jensge.org>.
- *
- * This file is part of Rygel.
- *
- * Rygel is free software; you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * Rygel is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this program; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
- */
-
-#include <glib.h>
-#include <glib-object.h>
-#include <rygel.h>
-#include <dbus/dbus-glib-lowlevel.h>
-#include <dbus/dbus-glib.h>
-#include <stdlib.h>
-#include <string.h>
-#include <dbus/dbus.h>
-
-
-#define RYGEL_TYPE_MEDIA_EXPORT_DBUS_SERVICE (rygel_media_export_dbus_service_get_type ())
-#define RYGEL_MEDIA_EXPORT_DBUS_SERVICE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_MEDIA_EXPORT_DBUS_SERVICE, RygelMediaExportDBusService))
-#define RYGEL_MEDIA_EXPORT_DBUS_SERVICE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_MEDIA_EXPORT_DBUS_SERVICE, RygelMediaExportDBusServiceClass))
-#define RYGEL_IS_MEDIA_EXPORT_DBUS_SERVICE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_MEDIA_EXPORT_DBUS_SERVICE))
-#define RYGEL_IS_MEDIA_EXPORT_DBUS_SERVICE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_MEDIA_EXPORT_DBUS_SERVICE))
-#define RYGEL_MEDIA_EXPORT_DBUS_SERVICE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_MEDIA_EXPORT_DBUS_SERVICE, RygelMediaExportDBusServiceClass))
-
-typedef struct _RygelMediaExportDBusService RygelMediaExportDBusService;
-typedef struct _RygelMediaExportDBusServiceClass RygelMediaExportDBusServiceClass;
-typedef struct _RygelMediaExportDBusServicePrivate RygelMediaExportDBusServicePrivate;
-
-#define RYGEL_TYPE_MEDIA_EXPORT_ROOT_CONTAINER (rygel_media_export_root_container_get_type ())
-#define RYGEL_MEDIA_EXPORT_ROOT_CONTAINER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_MEDIA_EXPORT_ROOT_CONTAINER, RygelMediaExportRootContainer))
-#define RYGEL_MEDIA_EXPORT_ROOT_CONTAINER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_MEDIA_EXPORT_ROOT_CONTAINER, RygelMediaExportRootContainerClass))
-#define RYGEL_IS_MEDIA_EXPORT_ROOT_CONTAINER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_MEDIA_EXPORT_ROOT_CONTAINER))
-#define RYGEL_IS_MEDIA_EXPORT_ROOT_CONTAINER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_MEDIA_EXPORT_ROOT_CONTAINER))
-#define RYGEL_MEDIA_EXPORT_ROOT_CONTAINER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_MEDIA_EXPORT_ROOT_CONTAINER, RygelMediaExportRootContainerClass))
-
-typedef struct _RygelMediaExportRootContainer RygelMediaExportRootContainer;
-typedef struct _RygelMediaExportRootContainerClass RygelMediaExportRootContainerClass;
-#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
-#define _dbus_g_connection_unref0(var) ((var == NULL) ? NULL : (var = (dbus_g_connection_unref (var), NULL)))
-#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
-#define _g_free0(var) (var = (g_free (var), NULL))
-typedef struct _DBusObjectVTable _DBusObjectVTable;
-
-struct _RygelMediaExportDBusService {
-	GObject parent_instance;
-	RygelMediaExportDBusServicePrivate * priv;
-};
-
-struct _RygelMediaExportDBusServiceClass {
-	GObjectClass parent_class;
-};
-
-struct _RygelMediaExportDBusServicePrivate {
-	RygelMediaExportRootContainer* root_container;
-};
-
-struct _DBusObjectVTable {
-	void (*register_object) (DBusConnection*, const char*, void*);
-};
-
-
-static gpointer rygel_media_export_dbus_service_parent_class = NULL;
-
-GType rygel_media_export_dbus_service_get_type (void);
-GType rygel_media_export_root_container_get_type (void);
-#define RYGEL_MEDIA_EXPORT_DBUS_SERVICE_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), RYGEL_TYPE_MEDIA_EXPORT_DBUS_SERVICE, RygelMediaExportDBusServicePrivate))
-enum  {
-	RYGEL_MEDIA_EXPORT_DBUS_SERVICE_DUMMY_PROPERTY
-};
-#define RYGEL_MEDIA_EXPORT_DBUS_SERVICE_RYGEL_MEDIA_EXPORT_PATH "/org/gnome/Rygel/MediaExport1"
-RygelMediaExportDBusService* rygel_media_export_dbus_service_new (RygelMediaExportRootContainer* root_container, GError** error);
-RygelMediaExportDBusService* rygel_media_export_dbus_service_construct (GType object_type, RygelMediaExportRootContainer* root_container, GError** error);
-void rygel_media_export_root_container_add_uri (RygelMediaExportRootContainer* self, const char* uri);
-void rygel_media_export_dbus_service_AddUri (RygelMediaExportDBusService* self, const char* uri);
-void rygel_media_export_root_container_remove_uri (RygelMediaExportRootContainer* self, const char* uri);
-void rygel_media_export_dbus_service_RemoveUri (RygelMediaExportDBusService* self, const char* uri);
-char** rygel_media_export_root_container_get_dynamic_uris (RygelMediaExportRootContainer* self, int* result_length1);
-char** rygel_media_export_dbus_service_GetUris (RygelMediaExportDBusService* self, int* result_length1);
-void rygel_media_export_dbus_service_dbus_register_object (DBusConnection* connection, const char* path, void* object);
-void _rygel_media_export_dbus_service_dbus_unregister (DBusConnection* connection, void* _user_data_);
-DBusHandlerResult rygel_media_export_dbus_service_dbus_message (DBusConnection* connection, DBusMessage* message, void* object);
-static DBusHandlerResult _dbus_rygel_media_export_dbus_service_introspect (RygelMediaExportDBusService* self, DBusConnection* connection, DBusMessage* message);
-static DBusHandlerResult _dbus_rygel_media_export_dbus_service_property_get_all (RygelMediaExportDBusService* self, DBusConnection* connection, DBusMessage* message);
-static DBusHandlerResult _dbus_rygel_media_export_dbus_service_AddUri (RygelMediaExportDBusService* self, DBusConnection* connection, DBusMessage* message);
-static DBusHandlerResult _dbus_rygel_media_export_dbus_service_RemoveUri (RygelMediaExportDBusService* self, DBusConnection* connection, DBusMessage* message);
-static DBusHandlerResult _dbus_rygel_media_export_dbus_service_GetUris (RygelMediaExportDBusService* self, DBusConnection* connection, DBusMessage* message);
-static void rygel_media_export_dbus_service_finalize (GObject* obj);
-static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
-static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);
-static void _vala_dbus_register_object (DBusConnection* connection, const char* path, void* object);
-static void _vala_dbus_unregister_object (gpointer connection, GObject* object);
-
-static const DBusObjectPathVTable _rygel_media_export_dbus_service_dbus_path_vtable = {_rygel_media_export_dbus_service_dbus_unregister, rygel_media_export_dbus_service_dbus_message};
-static const _DBusObjectVTable _rygel_media_export_dbus_service_dbus_vtable = {rygel_media_export_dbus_service_dbus_register_object};
-
-
-static gpointer _g_object_ref0 (gpointer self) {
-	return self ? g_object_ref (self) : NULL;
-}
-
-
-RygelMediaExportDBusService* rygel_media_export_dbus_service_construct (GType object_type, RygelMediaExportRootContainer* root_container, GError** error) {
-	GError * _inner_error_;
-	RygelMediaExportDBusService * self;
-	RygelMediaExportRootContainer* _tmp0_;
-	g_return_val_if_fail (root_container != NULL, NULL);
-	_inner_error_ = NULL;
-	self = (RygelMediaExportDBusService*) g_object_new (object_type, NULL);
-	self->priv->root_container = (_tmp0_ = _g_object_ref0 (root_container), _g_object_unref0 (self->priv->root_container), _tmp0_);
-	{
-		DBusGConnection* conn;
-		conn = dbus_g_bus_get (DBUS_BUS_SESSION, &_inner_error_);
-		if (_inner_error_ != NULL) {
-			if (_inner_error_->domain == DBUS_GERROR) {
-				goto __catch7_dbus_gerror;
-			}
-			goto __finally7;
-		}
-		if (conn != NULL) {
-			_vala_dbus_register_object (dbus_g_connection_get_connection (conn), RYGEL_MEDIA_EXPORT_DBUS_SERVICE_RYGEL_MEDIA_EXPORT_PATH, (GObject*) self);
-		}
-		_dbus_g_connection_unref0 (conn);
-	}
-	goto __finally7;
-	__catch7_dbus_gerror:
-	{
-		GError * err;
-		err = _inner_error_;
-		_inner_error_ = NULL;
-		{
-			g_warning ("rygel-media-export-dbus-service.vala:37: Failed to attach to DBus session bus: %s", err->message);
-			_g_error_free0 (err);
-		}
-	}
-	__finally7:
-	if (_inner_error_ != NULL) {
-		g_propagate_error (error, _inner_error_);
-		return;
-	}
-	return self;
-}
-
-
-RygelMediaExportDBusService* rygel_media_export_dbus_service_new (RygelMediaExportRootContainer* root_container, GError** error) {
-	return rygel_media_export_dbus_service_construct (RYGEL_TYPE_MEDIA_EXPORT_DBUS_SERVICE, root_container, error);
-}
-
-
-void rygel_media_export_dbus_service_AddUri (RygelMediaExportDBusService* self, const char* uri) {
-	g_return_if_fail (self != NULL);
-	g_return_if_fail (uri != NULL);
-	rygel_media_export_root_container_add_uri (self->priv->root_container, uri);
-}
-
-
-void rygel_media_export_dbus_service_RemoveUri (RygelMediaExportDBusService* self, const char* uri) {
-	g_return_if_fail (self != NULL);
-	g_return_if_fail (uri != NULL);
-	rygel_media_export_root_container_remove_uri (self->priv->root_container, uri);
-}
-
-
-char** rygel_media_export_dbus_service_GetUris (RygelMediaExportDBusService* self, int* result_length1) {
-	char** result;
-	gint _tmp0_;
-	char** _tmp1_;
-	g_return_val_if_fail (self != NULL, NULL);
-	result = (_tmp1_ = rygel_media_export_root_container_get_dynamic_uris (self->priv->root_container, &_tmp0_), *result_length1 = _tmp0_, _tmp1_);
-	return result;
-}
-
-
-void _rygel_media_export_dbus_service_dbus_unregister (DBusConnection* connection, void* _user_data_) {
-}
-
-
-static DBusHandlerResult _dbus_rygel_media_export_dbus_service_introspect (RygelMediaExportDBusService* self, DBusConnection* connection, DBusMessage* message) {
-	DBusMessage* reply;
-	DBusMessageIter iter;
-	GString* xml_data;
-	char** children;
-	int i;
-	reply = dbus_message_new_method_return (message);
-	dbus_message_iter_init_append (reply, &iter);
-	xml_data = g_string_new ("<!DOCTYPE node PUBLIC \"-//freedesktop//DTD D-BUS Object Introspection 1.0//EN\" \"http://www.freedesktop.org/standards/dbus/1.0/introspect.dtd\">\n");
-	g_string_append (xml_data, "<node>\n<interface name=\"org.freedesktop.DBus.Introspectable\">\n  <method name=\"Introspect\">\n    <arg name=\"data\" direction=\"out\" type=\"s\"/>\n  </method>\n</interface>\n<interface name=\"org.freedesktop.DBus.Properties\">\n  <method name=\"Get\">\n    <arg name=\"interface\" direction=\"in\" type=\"s\"/>\n    <arg name=\"propname\" direction=\"in\" type=\"s\"/>\n    <arg name=\"value\" direction=\"out\" type=\"v\"/>\n  </method>\n  <method name=\"Set\">\n    <arg name=\"interface\" direction=\"in\" type=\"s\"/>\n    <arg name=\"propname\" direction=\"in\" type=\"s\"/>\n    <arg name=\"value\" direction=\"in\" type=\"v\"/>\n  </method>\n  <method name=\"GetAll\">\n    <arg name=\"interface\" direction=\"in\" type=\"s\"/>\n    <arg name=\"props\" direction=\"out\" type=\"a{sv}\"/>\n  </method>\n</interface>\n<interface name=\"org.gnome.Rygel.MediaExport1\">\n  <method name=\"AddUri\">\n    <arg name=\"uri\" type=\"s\" direction=\"in\"/>\n  </method>\n  <method name=\"RemoveUri\">\n    <arg name=\"uri\" type=\"s\" direction=\"in\"/>\n  </method>\n  <method name=\"GetUris\">\n    <arg name=\"result\" type=\"as\" direction=\"out\"/>\n  </method>\n</interface>\n");
-	dbus_connection_list_registered (connection, g_object_get_data ((GObject *) self, "dbus_object_path"), &children);
-	for (i = 0; children[i]; i++) {
-		g_string_append_printf (xml_data, "<node name=\"%s\"/>\n", children[i]);
-	}
-	dbus_free_string_array (children);
-	g_string_append (xml_data, "</node>\n");
-	dbus_message_iter_append_basic (&iter, DBUS_TYPE_STRING, &xml_data->str);
-	g_string_free (xml_data, TRUE);
-	if (reply) {
-		dbus_connection_send (connection, reply, NULL);
-		dbus_message_unref (reply);
-		return DBUS_HANDLER_RESULT_HANDLED;
-	} else {
-		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
-	}
-}
-
-
-static DBusHandlerResult _dbus_rygel_media_export_dbus_service_property_get_all (RygelMediaExportDBusService* self, DBusConnection* connection, DBusMessage* message) {
-	DBusMessage* reply;
-	DBusMessageIter iter, reply_iter, subiter;
-	char* interface_name;
-	const char* _tmp0_;
-	if (strcmp (dbus_message_get_signature (message), "s")) {
-		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
-	}
-	dbus_message_iter_init (message, &iter);
-	reply = dbus_message_new_method_return (message);
-	dbus_message_iter_init_append (reply, &reply_iter);
-	dbus_message_iter_get_basic (&iter, &_tmp0_);
-	dbus_message_iter_next (&iter);
-	interface_name = g_strdup (_tmp0_);
-	if (strcmp (interface_name, "org.gnome.Rygel.MediaExport1") == 0) {
-		dbus_message_iter_open_container (&reply_iter, DBUS_TYPE_ARRAY, "{sv}", &subiter);
-		dbus_message_iter_close_container (&reply_iter, &subiter);
-	} else {
-		dbus_message_unref (reply);
-		reply = NULL;
-	}
-	g_free (interface_name);
-	if (reply) {
-		dbus_connection_send (connection, reply, NULL);
-		dbus_message_unref (reply);
-		return DBUS_HANDLER_RESULT_HANDLED;
-	} else {
-		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
-	}
-}
-
-
-static DBusHandlerResult _dbus_rygel_media_export_dbus_service_AddUri (RygelMediaExportDBusService* self, DBusConnection* connection, DBusMessage* message) {
-	DBusMessageIter iter;
-	GError* error;
-	char* uri;
-	const char* _tmp1_;
-	DBusMessage* reply;
-	error = NULL;
-	if (strcmp (dbus_message_get_signature (message), "s")) {
-		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
-	}
-	dbus_message_iter_init (message, &iter);
-	uri = NULL;
-	dbus_message_iter_get_basic (&iter, &_tmp1_);
-	dbus_message_iter_next (&iter);
-	uri = g_strdup (_tmp1_);
-	rygel_media_export_dbus_service_AddUri (self, uri);
-	reply = dbus_message_new_method_return (message);
-	dbus_message_iter_init_append (reply, &iter);
-	_g_free0 (uri);
-	if (reply) {
-		dbus_connection_send (connection, reply, NULL);
-		dbus_message_unref (reply);
-		return DBUS_HANDLER_RESULT_HANDLED;
-	} else {
-		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
-	}
-}
-
-
-static DBusHandlerResult _dbus_rygel_media_export_dbus_service_RemoveUri (RygelMediaExportDBusService* self, DBusConnection* connection, DBusMessage* message) {
-	DBusMessageIter iter;
-	GError* error;
-	char* uri;
-	const char* _tmp2_;
-	DBusMessage* reply;
-	error = NULL;
-	if (strcmp (dbus_message_get_signature (message), "s")) {
-		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
-	}
-	dbus_message_iter_init (message, &iter);
-	uri = NULL;
-	dbus_message_iter_get_basic (&iter, &_tmp2_);
-	dbus_message_iter_next (&iter);
-	uri = g_strdup (_tmp2_);
-	rygel_media_export_dbus_service_RemoveUri (self, uri);
-	reply = dbus_message_new_method_return (message);
-	dbus_message_iter_init_append (reply, &iter);
-	_g_free0 (uri);
-	if (reply) {
-		dbus_connection_send (connection, reply, NULL);
-		dbus_message_unref (reply);
-		return DBUS_HANDLER_RESULT_HANDLED;
-	} else {
-		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
-	}
-}
-
-
-static DBusHandlerResult _dbus_rygel_media_export_dbus_service_GetUris (RygelMediaExportDBusService* self, DBusConnection* connection, DBusMessage* message) {
-	DBusMessageIter iter;
-	GError* error;
-	char** result;
-	int result_length1;
-	DBusMessage* reply;
-	char** _tmp3_;
-	DBusMessageIter _tmp4_;
-	int _tmp5_;
-	error = NULL;
-	if (strcmp (dbus_message_get_signature (message), "")) {
-		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
-	}
-	dbus_message_iter_init (message, &iter);
-	result_length1 = 0;
-	result = rygel_media_export_dbus_service_GetUris (self, &result_length1);
-	reply = dbus_message_new_method_return (message);
-	dbus_message_iter_init_append (reply, &iter);
-	_tmp3_ = result;
-	dbus_message_iter_open_container (&iter, DBUS_TYPE_ARRAY, "s", &_tmp4_);
-	for (_tmp5_ = 0; _tmp5_ < result_length1; _tmp5_++) {
-		const char* _tmp6_;
-		_tmp6_ = *_tmp3_;
-		dbus_message_iter_append_basic (&_tmp4_, DBUS_TYPE_STRING, &_tmp6_);
-		_tmp3_++;
-	}
-	dbus_message_iter_close_container (&iter, &_tmp4_);
-	result = (_vala_array_free (result,  result_length1, (GDestroyNotify) g_free), NULL);
-	if (reply) {
-		dbus_connection_send (connection, reply, NULL);
-		dbus_message_unref (reply);
-		return DBUS_HANDLER_RESULT_HANDLED;
-	} else {
-		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
-	}
-}
-
-
-DBusHandlerResult rygel_media_export_dbus_service_dbus_message (DBusConnection* connection, DBusMessage* message, void* object) {
-	DBusHandlerResult result;
-	result = DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
-	if (dbus_message_is_method_call (message, "org.freedesktop.DBus.Introspectable", "Introspect")) {
-		result = _dbus_rygel_media_export_dbus_service_introspect (object, connection, message);
-	} else if (dbus_message_is_method_call (message, "org.freedesktop.DBus.Properties", "GetAll")) {
-		result = _dbus_rygel_media_export_dbus_service_property_get_all (object, connection, message);
-	} else if (dbus_message_is_method_call (message, "org.gnome.Rygel.MediaExport1", "AddUri")) {
-		result = _dbus_rygel_media_export_dbus_service_AddUri (object, connection, message);
-	} else if (dbus_message_is_method_call (message, "org.gnome.Rygel.MediaExport1", "RemoveUri")) {
-		result = _dbus_rygel_media_export_dbus_service_RemoveUri (object, connection, message);
-	} else if (dbus_message_is_method_call (message, "org.gnome.Rygel.MediaExport1", "GetUris")) {
-		result = _dbus_rygel_media_export_dbus_service_GetUris (object, connection, message);
-	}
-	if (result == DBUS_HANDLER_RESULT_HANDLED) {
-		return result;
-	} else {
-		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
-	}
-}
-
-
-void rygel_media_export_dbus_service_dbus_register_object (DBusConnection* connection, const char* path, void* object) {
-	if (!g_object_get_data (object, "dbus_object_path")) {
-		g_object_set_data (object, "dbus_object_path", g_strdup (path));
-		dbus_connection_register_object_path (connection, path, &_rygel_media_export_dbus_service_dbus_path_vtable, object);
-		g_object_weak_ref (object, _vala_dbus_unregister_object, connection);
-	}
-}
-
-
-static void rygel_media_export_dbus_service_class_init (RygelMediaExportDBusServiceClass * klass) {
-	rygel_media_export_dbus_service_parent_class = g_type_class_peek_parent (klass);
-	g_type_class_add_private (klass, sizeof (RygelMediaExportDBusServicePrivate));
-	G_OBJECT_CLASS (klass)->finalize = rygel_media_export_dbus_service_finalize;
-	g_type_set_qdata (RYGEL_TYPE_MEDIA_EXPORT_DBUS_SERVICE, g_quark_from_static_string ("DBusObjectVTable"), (void*) (&_rygel_media_export_dbus_service_dbus_vtable));
-}
-
-
-static void rygel_media_export_dbus_service_instance_init (RygelMediaExportDBusService * self) {
-	self->priv = RYGEL_MEDIA_EXPORT_DBUS_SERVICE_GET_PRIVATE (self);
-}
-
-
-static void rygel_media_export_dbus_service_finalize (GObject* obj) {
-	RygelMediaExportDBusService * self;
-	self = RYGEL_MEDIA_EXPORT_DBUS_SERVICE (obj);
-	_g_object_unref0 (self->priv->root_container);
-	G_OBJECT_CLASS (rygel_media_export_dbus_service_parent_class)->finalize (obj);
-}
-
-
-GType rygel_media_export_dbus_service_get_type (void) {
-	static GType rygel_media_export_dbus_service_type_id = 0;
-	if (rygel_media_export_dbus_service_type_id == 0) {
-		static const GTypeInfo g_define_type_info = { sizeof (RygelMediaExportDBusServiceClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) rygel_media_export_dbus_service_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (RygelMediaExportDBusService), 0, (GInstanceInitFunc) rygel_media_export_dbus_service_instance_init, NULL };
-		rygel_media_export_dbus_service_type_id = g_type_register_static (G_TYPE_OBJECT, "RygelMediaExportDBusService", &g_define_type_info, 0);
-	}
-	return rygel_media_export_dbus_service_type_id;
-}
-
-
-static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
-	if ((array != NULL) && (destroy_func != NULL)) {
-		int i;
-		for (i = 0; i < array_length; i = i + 1) {
-			if (((gpointer*) array)[i] != NULL) {
-				destroy_func (((gpointer*) array)[i]);
-			}
-		}
-	}
-}
-
-
-static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
-	_vala_array_destroy (array, array_length, destroy_func);
-	g_free (array);
-}
-
-
-static void _vala_dbus_register_object (DBusConnection* connection, const char* path, void* object) {
-	const _DBusObjectVTable * vtable;
-	vtable = g_type_get_qdata (G_TYPE_FROM_INSTANCE (object), g_quark_from_static_string ("DBusObjectVTable"));
-	if (vtable) {
-		vtable->register_object (connection, path, object);
-	} else {
-		g_warning ("Object does not implement any D-Bus interface");
-	}
-}
-
-
-static void _vala_dbus_unregister_object (gpointer connection, GObject* object) {
-	char* path;
-	path = g_object_steal_data ((GObject*) object, "dbus_object_path");
-	dbus_connection_unregister_object_path (connection, path);
-	g_free (path);
-}
-
-
-
-
--- a/src/plugins/media-export/rygel-media-export-harvester.c
+++ /dev/null
@@ -1,1069 +0,0 @@
-/* rygel-media-export-harvester.c generated by valac, the Vala compiler
- * generated from rygel-media-export-harvester.vala, do not modify */
-
-/*
- * Copyright (C) 2009 Jens Georg <mail@jensge.org>.
- *
- * This file is part of Rygel.
- *
- * Rygel is free software; you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * Rygel is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this program; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
- */
-
-#include <glib.h>
-#include <glib-object.h>
-#include <rygel.h>
-#include <gio/gio.h>
-#include <gee.h>
-#include <stdlib.h>
-#include <string.h>
-#include <gst/gst.h>
-#include <gobject/gvaluecollector.h>
-
-
-#define RYGEL_TYPE_NULL_CONTAINER (rygel_null_container_get_type ())
-#define RYGEL_NULL_CONTAINER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_NULL_CONTAINER, RygelNullContainer))
-#define RYGEL_NULL_CONTAINER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_NULL_CONTAINER, RygelNullContainerClass))
-#define RYGEL_IS_NULL_CONTAINER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_NULL_CONTAINER))
-#define RYGEL_IS_NULL_CONTAINER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_NULL_CONTAINER))
-#define RYGEL_NULL_CONTAINER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_NULL_CONTAINER, RygelNullContainerClass))
-
-typedef struct _RygelNullContainer RygelNullContainer;
-typedef struct _RygelNullContainerClass RygelNullContainerClass;
-typedef struct _RygelNullContainerPrivate RygelNullContainerPrivate;
-
-#define RYGEL_TYPE_DUMMY_CONTAINER (rygel_dummy_container_get_type ())
-#define RYGEL_DUMMY_CONTAINER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_DUMMY_CONTAINER, RygelDummyContainer))
-#define RYGEL_DUMMY_CONTAINER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_DUMMY_CONTAINER, RygelDummyContainerClass))
-#define RYGEL_IS_DUMMY_CONTAINER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_DUMMY_CONTAINER))
-#define RYGEL_IS_DUMMY_CONTAINER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_DUMMY_CONTAINER))
-#define RYGEL_DUMMY_CONTAINER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_DUMMY_CONTAINER, RygelDummyContainerClass))
-
-typedef struct _RygelDummyContainer RygelDummyContainer;
-typedef struct _RygelDummyContainerClass RygelDummyContainerClass;
-typedef struct _RygelDummyContainerPrivate RygelDummyContainerPrivate;
-#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
-#define _g_free0(var) (var = (g_free (var), NULL))
-
-#define RYGEL_TYPE_FILE_QUEUE_ENTRY (rygel_file_queue_entry_get_type ())
-#define RYGEL_FILE_QUEUE_ENTRY(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_FILE_QUEUE_ENTRY, RygelFileQueueEntry))
-#define RYGEL_FILE_QUEUE_ENTRY_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_FILE_QUEUE_ENTRY, RygelFileQueueEntryClass))
-#define RYGEL_IS_FILE_QUEUE_ENTRY(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_FILE_QUEUE_ENTRY))
-#define RYGEL_IS_FILE_QUEUE_ENTRY_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_FILE_QUEUE_ENTRY))
-#define RYGEL_FILE_QUEUE_ENTRY_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_FILE_QUEUE_ENTRY, RygelFileQueueEntryClass))
-
-typedef struct _RygelFileQueueEntry RygelFileQueueEntry;
-typedef struct _RygelFileQueueEntryClass RygelFileQueueEntryClass;
-typedef struct _RygelFileQueueEntryPrivate RygelFileQueueEntryPrivate;
-typedef struct _RygelParamSpecFileQueueEntry RygelParamSpecFileQueueEntry;
-
-#define RYGEL_TYPE_MEDIA_EXPORT_HARVESTER (rygel_media_export_harvester_get_type ())
-#define RYGEL_MEDIA_EXPORT_HARVESTER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_MEDIA_EXPORT_HARVESTER, RygelMediaExportHarvester))
-#define RYGEL_MEDIA_EXPORT_HARVESTER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_MEDIA_EXPORT_HARVESTER, RygelMediaExportHarvesterClass))
-#define RYGEL_IS_MEDIA_EXPORT_HARVESTER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_MEDIA_EXPORT_HARVESTER))
-#define RYGEL_IS_MEDIA_EXPORT_HARVESTER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_MEDIA_EXPORT_HARVESTER))
-#define RYGEL_MEDIA_EXPORT_HARVESTER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_MEDIA_EXPORT_HARVESTER, RygelMediaExportHarvesterClass))
-
-typedef struct _RygelMediaExportHarvester RygelMediaExportHarvester;
-typedef struct _RygelMediaExportHarvesterClass RygelMediaExportHarvesterClass;
-typedef struct _RygelMediaExportHarvesterPrivate RygelMediaExportHarvesterPrivate;
-
-#define RYGEL_TYPE_MEDIA_EXPORT_RECURSIVE_FILE_MONITOR (rygel_media_export_recursive_file_monitor_get_type ())
-#define RYGEL_MEDIA_EXPORT_RECURSIVE_FILE_MONITOR(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_MEDIA_EXPORT_RECURSIVE_FILE_MONITOR, RygelMediaExportRecursiveFileMonitor))
-#define RYGEL_MEDIA_EXPORT_RECURSIVE_FILE_MONITOR_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_MEDIA_EXPORT_RECURSIVE_FILE_MONITOR, RygelMediaExportRecursiveFileMonitorClass))
-#define RYGEL_IS_MEDIA_EXPORT_RECURSIVE_FILE_MONITOR(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_MEDIA_EXPORT_RECURSIVE_FILE_MONITOR))
-#define RYGEL_IS_MEDIA_EXPORT_RECURSIVE_FILE_MONITOR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_MEDIA_EXPORT_RECURSIVE_FILE_MONITOR))
-#define RYGEL_MEDIA_EXPORT_RECURSIVE_FILE_MONITOR_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_MEDIA_EXPORT_RECURSIVE_FILE_MONITOR, RygelMediaExportRecursiveFileMonitorClass))
-
-typedef struct _RygelMediaExportRecursiveFileMonitor RygelMediaExportRecursiveFileMonitor;
-typedef struct _RygelMediaExportRecursiveFileMonitorClass RygelMediaExportRecursiveFileMonitorClass;
-#define _g_queue_free0(var) ((var == NULL) ? NULL : (var = (g_queue_free (var), NULL)))
-#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
-#define __g_list_free_g_object_unref0(var) ((var == NULL) ? NULL : (var = (_g_list_free_g_object_unref (var), NULL)))
-#define _rygel_file_queue_entry_unref0(var) ((var == NULL) ? NULL : (var = (rygel_file_queue_entry_unref (var), NULL)))
-
-struct _RygelNullContainer {
-	RygelMediaContainer parent_instance;
-	RygelNullContainerPrivate * priv;
-};
-
-struct _RygelNullContainerClass {
-	RygelMediaContainerClass parent_class;
-};
-
-struct _RygelDummyContainer {
-	RygelNullContainer parent_instance;
-	RygelDummyContainerPrivate * priv;
-	GFile* file;
-	GeeArrayList* seen_children;
-};
-
-struct _RygelDummyContainerClass {
-	RygelNullContainerClass parent_class;
-};
-
-struct _RygelFileQueueEntry {
-	GTypeInstance parent_instance;
-	volatile int ref_count;
-	RygelFileQueueEntryPrivate * priv;
-	GFile* file;
-	gboolean update;
-};
-
-struct _RygelFileQueueEntryClass {
-	GTypeClass parent_class;
-	void (*finalize) (RygelFileQueueEntry *self);
-};
-
-struct _RygelParamSpecFileQueueEntry {
-	GParamSpec parent_instance;
-};
-
-struct _RygelMediaExportHarvester {
-	GObject parent_instance;
-	RygelMediaExportHarvesterPrivate * priv;
-};
-
-struct _RygelMediaExportHarvesterClass {
-	GObjectClass parent_class;
-};
-
-struct _RygelMediaExportHarvesterPrivate {
-	RygelMetadataExtractor* extractor;
-	RygelMediaDB* media_db;
-	GQueue* containers;
-	GQueue* files;
-	GFile* origin;
-	RygelMediaContainer* parent;
-	RygelMediaExportRecursiveFileMonitor* monitor;
-};
-
-
-static gpointer rygel_dummy_container_parent_class = NULL;
-static gpointer rygel_file_queue_entry_parent_class = NULL;
-static gpointer rygel_media_export_harvester_parent_class = NULL;
-
-GType rygel_null_container_get_type (void);
-GType rygel_dummy_container_get_type (void);
-enum  {
-	RYGEL_DUMMY_CONTAINER_DUMMY_PROPERTY
-};
-RygelNullContainer* rygel_null_container_new (void);
-RygelNullContainer* rygel_null_container_construct (GType object_type);
-RygelDummyContainer* rygel_dummy_container_new (GFile* file, RygelMediaContainer* parent);
-RygelDummyContainer* rygel_dummy_container_construct (GType object_type, GFile* file, RygelMediaContainer* parent);
-void rygel_dummy_container_seen (RygelDummyContainer* self, const char* id);
-static void rygel_dummy_container_finalize (GObject* obj);
-gpointer rygel_file_queue_entry_ref (gpointer instance);
-void rygel_file_queue_entry_unref (gpointer instance);
-GParamSpec* rygel_param_spec_file_queue_entry (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
-void rygel_value_set_file_queue_entry (GValue* value, gpointer v_object);
-gpointer rygel_value_get_file_queue_entry (const GValue* value);
-GType rygel_file_queue_entry_get_type (void);
-enum  {
-	RYGEL_FILE_QUEUE_ENTRY_DUMMY_PROPERTY
-};
-RygelFileQueueEntry* rygel_file_queue_entry_new (GFile* file, gboolean update);
-RygelFileQueueEntry* rygel_file_queue_entry_construct (GType object_type, GFile* file, gboolean update);
-static void rygel_file_queue_entry_finalize (RygelFileQueueEntry* obj);
-GType rygel_media_export_harvester_get_type (void);
-GType rygel_media_export_recursive_file_monitor_get_type (void);
-#define RYGEL_MEDIA_EXPORT_HARVESTER_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), RYGEL_TYPE_MEDIA_EXPORT_HARVESTER, RygelMediaExportHarvesterPrivate))
-enum  {
-	RYGEL_MEDIA_EXPORT_HARVESTER_DUMMY_PROPERTY
-};
-static void rygel_media_export_harvester_on_extracted_cb (RygelMediaExportHarvester* self, GFile* file, GstTagList* tag_list);
-static void _rygel_media_export_harvester_on_extracted_cb_rygel_metadata_extractor_extraction_done (RygelMetadataExtractor* _sender, GFile* file, GstTagList* tag_list, gpointer self);
-static void rygel_media_export_harvester_on_extractor_error_cb (RygelMediaExportHarvester* self, GFile* file, GError* _error_);
-static void _rygel_media_export_harvester_on_extractor_error_cb_rygel_metadata_extractor_error (RygelMetadataExtractor* _sender, GFile* file, GError* err, gpointer self);
-RygelMediaExportHarvester* rygel_media_export_harvester_new (RygelMediaContainer* parent, RygelMediaDB* media_db, RygelMetadataExtractor* extractor, RygelMediaExportRecursiveFileMonitor* monitor);
-RygelMediaExportHarvester* rygel_media_export_harvester_construct (GType object_type, RygelMediaContainer* parent, RygelMediaDB* media_db, RygelMetadataExtractor* extractor, RygelMediaExportRecursiveFileMonitor* monitor);
-static void rygel_media_export_harvester_do_update (RygelMediaExportHarvester* self);
-static gboolean rygel_media_export_harvester_on_idle (RygelMediaExportHarvester* self);
-static gboolean _rygel_media_export_harvester_on_idle_gsource_func (gpointer self);
-static void rygel_media_export_harvester_on_close_async (RygelMediaExportHarvester* self, GObject* obj, GAsyncResult* res);
-static gboolean rygel_media_export_harvester_push_if_changed_or_unknown (RygelMediaExportHarvester* self, GFile* file, GFileInfo* info, char** id);
-void rygel_media_export_recursive_file_monitor_monitor (RygelMediaExportRecursiveFileMonitor* self, GFile* file);
-static void _g_list_free_g_object_unref (GList* self);
-static void rygel_media_export_harvester_on_next_files_ready (RygelMediaExportHarvester* self, GObject* obj, GAsyncResult* res);
-static void _rygel_media_export_harvester_on_next_files_ready_gasync_ready_callback (GObject* source_object, GAsyncResult* res, gpointer self);
-static void _rygel_media_export_harvester_on_close_async_gasync_ready_callback (GObject* source_object, GAsyncResult* res, gpointer self);
-static void rygel_media_export_harvester_on_enumerate_ready (RygelMediaExportHarvester* self, GObject* obj, GAsyncResult* res);
-static void _rygel_media_export_harvester_on_enumerate_ready_gasync_ready_callback (GObject* source_object, GAsyncResult* res, gpointer self);
-static void rygel_media_export_harvester_on_initial_info_ready (RygelMediaExportHarvester* self, GObject* source, GAsyncResult* _result_);
-static void _rygel_media_export_harvester_on_initial_info_ready_gasync_ready_callback (GObject* source_object, GAsyncResult* res, gpointer self);
-void rygel_media_export_harvester_harvest (RygelMediaExportHarvester* self, GFile* file);
-RygelMediaItem* rygel_media_export_item_create_from_taglist (RygelMediaContainer* parent, GFile* file, GstTagList* tag_list);
-static void rygel_media_export_harvester_finalize (GObject* obj);
-
-
-
-static gpointer _g_object_ref0 (gpointer self) {
-	return self ? g_object_ref (self) : NULL;
-}
-
-
-RygelDummyContainer* rygel_dummy_container_construct (GType object_type, GFile* file, RygelMediaContainer* parent) {
-	RygelDummyContainer * self;
-	char* _tmp0_;
-	char* _tmp1_;
-	char* id;
-	char* _tmp2_;
-	char* _tmp3_;
-	RygelMediaContainer* _tmp4_;
-	GFile* _tmp5_;
-	char* _tmp6_;
-	GeeArrayList* _tmp7_;
-	g_return_val_if_fail (file != NULL, NULL);
-	g_return_val_if_fail (parent != NULL, NULL);
-	self = (RygelDummyContainer*) rygel_null_container_construct (object_type);
-	id = (_tmp1_ = g_compute_checksum_for_string (G_CHECKSUM_MD5, _tmp0_ = g_file_get_uri (file), -1), _g_free0 (_tmp0_), _tmp1_);
-	((RygelMediaObject*) self)->id = (_tmp2_ = g_strdup (id), _g_free0 (((RygelMediaObject*) self)->id), _tmp2_);
-	((RygelMediaObject*) self)->parent = parent;
-	((RygelMediaObject*) self)->title = (_tmp3_ = g_file_get_basename (file), _g_free0 (((RygelMediaObject*) self)->title), _tmp3_);
-	((RygelMediaContainer*) self)->child_count = (guint) 0;
-	((RygelMediaObject*) self)->parent_ref = (_tmp4_ = _g_object_ref0 (parent), _g_object_unref0 (((RygelMediaObject*) self)->parent_ref), _tmp4_);
-	self->file = (_tmp5_ = _g_object_ref0 (file), _g_object_unref0 (self->file), _tmp5_);
-	gee_abstract_collection_add ((GeeAbstractCollection*) ((RygelMediaObject*) self)->uris, _tmp6_ = g_file_get_uri (file));
-	_g_free0 (_tmp6_);
-	self->seen_children = (_tmp7_ = gee_array_list_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, g_str_equal), _g_object_unref0 (self->seen_children), _tmp7_);
-	_g_free0 (id);
-	return self;
-}
-
-
-RygelDummyContainer* rygel_dummy_container_new (GFile* file, RygelMediaContainer* parent) {
-	return rygel_dummy_container_construct (RYGEL_TYPE_DUMMY_CONTAINER, file, parent);
-}
-
-
-void rygel_dummy_container_seen (RygelDummyContainer* self, const char* id) {
-	g_return_if_fail (self != NULL);
-	g_return_if_fail (id != NULL);
-	gee_abstract_collection_add ((GeeAbstractCollection*) self->seen_children, id);
-}
-
-
-static void rygel_dummy_container_class_init (RygelDummyContainerClass * klass) {
-	rygel_dummy_container_parent_class = g_type_class_peek_parent (klass);
-	G_OBJECT_CLASS (klass)->finalize = rygel_dummy_container_finalize;
-}
-
-
-static void rygel_dummy_container_instance_init (RygelDummyContainer * self) {
-}
-
-
-static void rygel_dummy_container_finalize (GObject* obj) {
-	RygelDummyContainer * self;
-	self = RYGEL_DUMMY_CONTAINER (obj);
-	_g_object_unref0 (self->file);
-	_g_object_unref0 (self->seen_children);
-	G_OBJECT_CLASS (rygel_dummy_container_parent_class)->finalize (obj);
-}
-
-
-GType rygel_dummy_container_get_type (void) {
-	static GType rygel_dummy_container_type_id = 0;
-	if (rygel_dummy_container_type_id == 0) {
-		static const GTypeInfo g_define_type_info = { sizeof (RygelDummyContainerClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) rygel_dummy_container_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (RygelDummyContainer), 0, (GInstanceInitFunc) rygel_dummy_container_instance_init, NULL };
-		rygel_dummy_container_type_id = g_type_register_static (RYGEL_TYPE_NULL_CONTAINER, "RygelDummyContainer", &g_define_type_info, 0);
-	}
-	return rygel_dummy_container_type_id;
-}
-
-
-RygelFileQueueEntry* rygel_file_queue_entry_construct (GType object_type, GFile* file, gboolean update) {
-	RygelFileQueueEntry* self;
-	GFile* _tmp0_;
-	g_return_val_if_fail (file != NULL, NULL);
-	self = (RygelFileQueueEntry*) g_type_create_instance (object_type);
-	self->file = (_tmp0_ = _g_object_ref0 (file), _g_object_unref0 (self->file), _tmp0_);
-	self->update = update;
-	return self;
-}
-
-
-RygelFileQueueEntry* rygel_file_queue_entry_new (GFile* file, gboolean update) {
-	return rygel_file_queue_entry_construct (RYGEL_TYPE_FILE_QUEUE_ENTRY, file, update);
-}
-
-
-static void rygel_value_file_queue_entry_init (GValue* value) {
-	value->data[0].v_pointer = NULL;
-}
-
-
-static void rygel_value_file_queue_entry_free_value (GValue* value) {
-	if (value->data[0].v_pointer) {
-		rygel_file_queue_entry_unref (value->data[0].v_pointer);
-	}
-}
-
-
-static void rygel_value_file_queue_entry_copy_value (const GValue* src_value, GValue* dest_value) {
-	if (src_value->data[0].v_pointer) {
-		dest_value->data[0].v_pointer = rygel_file_queue_entry_ref (src_value->data[0].v_pointer);
-	} else {
-		dest_value->data[0].v_pointer = NULL;
-	}
-}
-
-
-static gpointer rygel_value_file_queue_entry_peek_pointer (const GValue* value) {
-	return value->data[0].v_pointer;
-}
-
-
-static gchar* rygel_value_file_queue_entry_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
-	if (collect_values[0].v_pointer) {
-		RygelFileQueueEntry* object;
-		object = collect_values[0].v_pointer;
-		if (object->parent_instance.g_class == NULL) {
-			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
-		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
-			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
-		}
-		value->data[0].v_pointer = rygel_file_queue_entry_ref (object);
-	} else {
-		value->data[0].v_pointer = NULL;
-	}
-	return NULL;
-}
-
-
-static gchar* rygel_value_file_queue_entry_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
-	RygelFileQueueEntry** object_p;
-	object_p = collect_values[0].v_pointer;
-	if (!object_p) {
-		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
-	}
-	if (!value->data[0].v_pointer) {
-		*object_p = NULL;
-	} else if (collect_flags && G_VALUE_NOCOPY_CONTENTS) {
-		*object_p = value->data[0].v_pointer;
-	} else {
-		*object_p = rygel_file_queue_entry_ref (value->data[0].v_pointer);
-	}
-	return NULL;
-}
-
-
-GParamSpec* rygel_param_spec_file_queue_entry (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
-	RygelParamSpecFileQueueEntry* spec;
-	g_return_val_if_fail (g_type_is_a (object_type, RYGEL_TYPE_FILE_QUEUE_ENTRY), NULL);
-	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
-	G_PARAM_SPEC (spec)->value_type = object_type;
-	return G_PARAM_SPEC (spec);
-}
-
-
-gpointer rygel_value_get_file_queue_entry (const GValue* value) {
-	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, RYGEL_TYPE_FILE_QUEUE_ENTRY), NULL);
-	return value->data[0].v_pointer;
-}
-
-
-void rygel_value_set_file_queue_entry (GValue* value, gpointer v_object) {
-	RygelFileQueueEntry* old;
-	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, RYGEL_TYPE_FILE_QUEUE_ENTRY));
-	old = value->data[0].v_pointer;
-	if (v_object) {
-		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, RYGEL_TYPE_FILE_QUEUE_ENTRY));
-		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
-		value->data[0].v_pointer = v_object;
-		rygel_file_queue_entry_ref (value->data[0].v_pointer);
-	} else {
-		value->data[0].v_pointer = NULL;
-	}
-	if (old) {
-		rygel_file_queue_entry_unref (old);
-	}
-}
-
-
-static void rygel_file_queue_entry_class_init (RygelFileQueueEntryClass * klass) {
-	rygel_file_queue_entry_parent_class = g_type_class_peek_parent (klass);
-	RYGEL_FILE_QUEUE_ENTRY_CLASS (klass)->finalize = rygel_file_queue_entry_finalize;
-}
-
-
-static void rygel_file_queue_entry_instance_init (RygelFileQueueEntry * self) {
-	self->ref_count = 1;
-}
-
-
-static void rygel_file_queue_entry_finalize (RygelFileQueueEntry* obj) {
-	RygelFileQueueEntry * self;
-	self = RYGEL_FILE_QUEUE_ENTRY (obj);
-	_g_object_unref0 (self->file);
-}
-
-
-GType rygel_file_queue_entry_get_type (void) {
-	static GType rygel_file_queue_entry_type_id = 0;
-	if (rygel_file_queue_entry_type_id == 0) {
-		static const GTypeValueTable g_define_type_value_table = { rygel_value_file_queue_entry_init, rygel_value_file_queue_entry_free_value, rygel_value_file_queue_entry_copy_value, rygel_value_file_queue_entry_peek_pointer, "p", rygel_value_file_queue_entry_collect_value, "p", rygel_value_file_queue_entry_lcopy_value };
-		static const GTypeInfo g_define_type_info = { sizeof (RygelFileQueueEntryClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) rygel_file_queue_entry_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (RygelFileQueueEntry), 0, (GInstanceInitFunc) rygel_file_queue_entry_instance_init, &g_define_type_value_table };
-		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
-		rygel_file_queue_entry_type_id = g_type_register_fundamental (g_type_fundamental_next (), "RygelFileQueueEntry", &g_define_type_info, &g_define_type_fundamental_info, 0);
-	}
-	return rygel_file_queue_entry_type_id;
-}
-
-
-gpointer rygel_file_queue_entry_ref (gpointer instance) {
-	RygelFileQueueEntry* self;
-	self = instance;
-	g_atomic_int_inc (&self->ref_count);
-	return instance;
-}
-
-
-void rygel_file_queue_entry_unref (gpointer instance) {
-	RygelFileQueueEntry* self;
-	self = instance;
-	if (g_atomic_int_dec_and_test (&self->ref_count)) {
-		RYGEL_FILE_QUEUE_ENTRY_GET_CLASS (self)->finalize (self);
-		g_type_free_instance ((GTypeInstance *) self);
-	}
-}
-
-
-static void _rygel_media_export_harvester_on_extracted_cb_rygel_metadata_extractor_extraction_done (RygelMetadataExtractor* _sender, GFile* file, GstTagList* tag_list, gpointer self) {
-	rygel_media_export_harvester_on_extracted_cb (self, file, tag_list);
-}
-
-
-static void _rygel_media_export_harvester_on_extractor_error_cb_rygel_metadata_extractor_error (RygelMetadataExtractor* _sender, GFile* file, GError* err, gpointer self) {
-	rygel_media_export_harvester_on_extractor_error_cb (self, file, err);
-}
-
-
-RygelMediaExportHarvester* rygel_media_export_harvester_construct (GType object_type, RygelMediaContainer* parent, RygelMediaDB* media_db, RygelMetadataExtractor* extractor, RygelMediaExportRecursiveFileMonitor* monitor) {
-	RygelMediaExportHarvester * self;
-	RygelMediaContainer* _tmp0_;
-	RygelMetadataExtractor* _tmp1_;
-	RygelMediaDB* _tmp2_;
-	GQueue* _tmp3_;
-	GQueue* _tmp4_;
-	GFile* _tmp5_;
-	RygelMediaExportRecursiveFileMonitor* _tmp6_;
-	g_return_val_if_fail (parent != NULL, NULL);
-	g_return_val_if_fail (media_db != NULL, NULL);
-	g_return_val_if_fail (extractor != NULL, NULL);
-	g_return_val_if_fail (monitor != NULL, NULL);
-	self = (RygelMediaExportHarvester*) g_object_new (object_type, NULL);
-	self->priv->parent = (_tmp0_ = _g_object_ref0 (parent), _g_object_unref0 (self->priv->parent), _tmp0_);
-	self->priv->extractor = (_tmp1_ = _g_object_ref0 (extractor), _g_object_unref0 (self->priv->extractor), _tmp1_);
-	self->priv->media_db = (_tmp2_ = _g_object_ref0 (media_db), _g_object_unref0 (self->priv->media_db), _tmp2_);
-	g_signal_connect_object (self->priv->extractor, "extraction-done", (GCallback) _rygel_media_export_harvester_on_extracted_cb_rygel_metadata_extractor_extraction_done, self, 0);
-	g_signal_connect_object (self->priv->extractor, "error", (GCallback) _rygel_media_export_harvester_on_extractor_error_cb_rygel_metadata_extractor_error, self, 0);
-	self->priv->files = (_tmp3_ = g_queue_new (), _g_queue_free0 (self->priv->files), _tmp3_);
-	self->priv->containers = (_tmp4_ = g_queue_new (), _g_queue_free0 (self->priv->containers), _tmp4_);
-	self->priv->origin = (_tmp5_ = NULL, _g_object_unref0 (self->priv->origin), _tmp5_);
-	self->priv->monitor = (_tmp6_ = _g_object_ref0 (monitor), _g_object_unref0 (self->priv->monitor), _tmp6_);
-	return self;
-}
-
-
-RygelMediaExportHarvester* rygel_media_export_harvester_new (RygelMediaContainer* parent, RygelMediaDB* media_db, RygelMetadataExtractor* extractor, RygelMediaExportRecursiveFileMonitor* monitor) {
-	return rygel_media_export_harvester_construct (RYGEL_TYPE_MEDIA_EXPORT_HARVESTER, parent, media_db, extractor, monitor);
-}
-
-
-static gboolean _rygel_media_export_harvester_on_idle_gsource_func (gpointer self) {
-	return rygel_media_export_harvester_on_idle (self);
-}
-
-
-static void rygel_media_export_harvester_on_close_async (RygelMediaExportHarvester* self, GObject* obj, GAsyncResult* res) {
-	GError * _inner_error_;
-	GFileEnumerator* enumerator;
-	RygelDummyContainer* container;
-	g_return_if_fail (self != NULL);
-	g_return_if_fail (res != NULL);
-	_inner_error_ = NULL;
-	enumerator = _g_object_ref0 (G_FILE_ENUMERATOR (obj));
-	{
-		g_file_enumerator_close_finish (enumerator, res, &_inner_error_);
-		if (_inner_error_ != NULL) {
-			goto __catch9_g_error;
-			goto __finally9;
-		}
-	}
-	goto __finally9;
-	__catch9_g_error:
-	{
-		GError * _error_;
-		_error_ = _inner_error_;
-		_inner_error_ = NULL;
-		{
-			_g_error_free0 (_error_);
-		}
-	}
-	__finally9:
-	if (_inner_error_ != NULL) {
-		_g_object_unref0 (enumerator);
-		g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
-		g_clear_error (&_inner_error_);
-		return;
-	}
-	container = _g_object_ref0 (RYGEL_DUMMY_CONTAINER ((RygelMediaContainer*) g_queue_peek_head (self->priv->containers)));
-	{
-		GeeArrayList* children;
-		children = rygel_media_db_get_child_ids (self->priv->media_db, ((RygelMediaObject*) container)->id, &_inner_error_);
-		if (_inner_error_ != NULL) {
-			if (_inner_error_->domain == RYGEL_MEDIA_DB_ERROR) {
-				goto __catch10_rygel_media_db_error;
-			}
-			goto __finally10;
-		}
-		{
-			GeeIterator* _seen_id_it;
-			_seen_id_it = gee_abstract_collection_iterator ((GeeAbstractCollection*) container->seen_children);
-			while (TRUE) {
-				char* seen_id;
-				if (!gee_iterator_next (_seen_id_it)) {
-					break;
-				}
-				seen_id = (char*) gee_iterator_get (_seen_id_it);
-				gee_abstract_collection_remove ((GeeAbstractCollection*) children, seen_id);
-				_g_free0 (seen_id);
-			}
-			_g_object_unref0 (_seen_id_it);
-		}
-		{
-			GeeIterator* _child_it;
-			_child_it = gee_abstract_collection_iterator ((GeeAbstractCollection*) children);
-			while (TRUE) {
-				char* child;
-				if (!gee_iterator_next (_child_it)) {
-					break;
-				}
-				child = (char*) gee_iterator_get (_child_it);
-				rygel_media_db_remove_by_id (self->priv->media_db, child, &_inner_error_);
-				if (_inner_error_ != NULL) {
-					_g_free0 (child);
-					_g_object_unref0 (_child_it);
-					_g_object_unref0 (children);
-					if (_inner_error_->domain == RYGEL_MEDIA_DB_ERROR) {
-						goto __catch10_rygel_media_db_error;
-					}
-					goto __finally10;
-				}
-				_g_free0 (child);
-			}
-			_g_object_unref0 (_child_it);
-		}
-		rygel_media_export_harvester_do_update (self);
-		_g_object_unref0 (children);
-	}
-	goto __finally10;
-	__catch10_rygel_media_db_error:
-	{
-		GError * err;
-		err = _inner_error_;
-		_inner_error_ = NULL;
-		{
-			g_warning ("rygel-media-export-harvester.vala:103: Failed to get children of container %s: %s", ((RygelMediaObject*) container)->id, err->message);
-			_g_error_free0 (err);
-		}
-	}
-	__finally10:
-	if (_inner_error_ != NULL) {
-		_g_object_unref0 (enumerator);
-		_g_object_unref0 (container);
-		g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
-		g_clear_error (&_inner_error_);
-		return;
-	}
-	g_idle_add_full (G_PRIORITY_DEFAULT_IDLE, _rygel_media_export_harvester_on_idle_gsource_func, g_object_ref (self), g_object_unref);
-	_g_object_unref0 (enumerator);
-	_g_object_unref0 (container);
-}
-
-
-static gboolean rygel_media_export_harvester_push_if_changed_or_unknown (RygelMediaExportHarvester* self, GFile* file, GFileInfo* info, char** id) {
-	gboolean result;
-	GError * _inner_error_;
-	char* _tmp1_;
-	char* _tmp0_;
-	gint64 timestamp = 0LL;
-	gboolean _tmp2_;
-	g_return_val_if_fail (self != NULL, FALSE);
-	g_return_val_if_fail (file != NULL, FALSE);
-	g_return_val_if_fail (info != NULL, FALSE);
-	if (id != NULL) {
-		*id = NULL;
-	}
-	_inner_error_ = NULL;
-	*id = (_tmp1_ = g_compute_checksum_for_string (G_CHECKSUM_MD5, _tmp0_ = g_file_get_uri (file), -1), _g_free0 (*id), _tmp1_);
-	_g_free0 (_tmp0_);
-	_tmp2_ = rygel_media_db_exists (self->priv->media_db, *id, &timestamp, &_inner_error_);
-	if (_inner_error_ != NULL) {
-		g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
-		g_clear_error (&_inner_error_);
-		return FALSE;
-	}
-	if (_tmp2_) {
-		gint64 mtime;
-		mtime = (gint64) g_file_info_get_attribute_uint64 (info, G_FILE_ATTRIBUTE_TIME_MODIFIED);
-		if (mtime > timestamp) {
-			g_queue_push_tail (self->priv->files, rygel_file_queue_entry_new (file, TRUE));
-			result = TRUE;
-			return result;
-		}
-	} else {
-		g_queue_push_tail (self->priv->files, rygel_file_queue_entry_new (file, FALSE));
-		result = TRUE;
-		return result;
-	}
-	result = FALSE;
-	return result;
-}
-
-
-static void _g_list_free_g_object_unref (GList* self) {
-	g_list_foreach (self, (GFunc) g_object_unref, NULL);
-	g_list_free (self);
-}
-
-
-static void _rygel_media_export_harvester_on_next_files_ready_gasync_ready_callback (GObject* source_object, GAsyncResult* res, gpointer self) {
-	rygel_media_export_harvester_on_next_files_ready (self, source_object, res);
-}
-
-
-static void _rygel_media_export_harvester_on_close_async_gasync_ready_callback (GObject* source_object, GAsyncResult* res, gpointer self) {
-	rygel_media_export_harvester_on_close_async (self, source_object, res);
-}
-
-
-static void rygel_media_export_harvester_on_next_files_ready (RygelMediaExportHarvester* self, GObject* obj, GAsyncResult* res) {
-	GError * _inner_error_;
-	GFileEnumerator* enumerator;
-	g_return_if_fail (self != NULL);
-	g_return_if_fail (res != NULL);
-	_inner_error_ = NULL;
-	enumerator = _g_object_ref0 (G_FILE_ENUMERATOR (obj));
-	{
-		GList* list;
-		list = g_file_enumerator_next_files_finish (enumerator, res, &_inner_error_);
-		if (_inner_error_ != NULL) {
-			goto __catch11_g_error;
-			goto __finally11;
-		}
-		if (list != NULL) {
-			{
-				GList* info_collection;
-				GList* info_it;
-				info_collection = list;
-				for (info_it = info_collection; info_it != NULL; info_it = info_it->next) {
-					GFileInfo* info;
-					info = _g_object_ref0 ((GFileInfo*) info_it->data);
-					{
-						RygelDummyContainer* parent_container;
-						GFile* dir;
-						GFile* file;
-						if (g_utf8_get_char (g_utf8_offset_to_pointer (g_file_info_get_name (info), 0)) == '.') {
-							_g_object_unref0 (info);
-							continue;
-						}
-						parent_container = _g_object_ref0 (RYGEL_DUMMY_CONTAINER ((RygelMediaContainer*) g_queue_peek_head (self->priv->containers)));
-						dir = _g_object_ref0 (parent_container->file);
-						file = g_file_get_child (dir, g_file_info_get_name (info));
-						if (g_file_info_get_file_type (info) == G_FILE_TYPE_DIRECTORY) {
-							RygelDummyContainer* container;
-							gint64 timestamp = 0LL;
-							gboolean _tmp0_;
-							rygel_media_export_recursive_file_monitor_monitor (self->priv->monitor, file);
-							container = rygel_dummy_container_new (file, (RygelMediaContainer*) parent_container);
-							g_queue_push_tail (self->priv->containers, _g_object_ref0 ((RygelMediaContainer*) container));
-							rygel_dummy_container_seen (parent_container, ((RygelMediaObject*) container)->id);
-							_tmp0_ = rygel_media_db_exists (self->priv->media_db, ((RygelMediaObject*) container)->id, &timestamp, &_inner_error_);
-							if (_inner_error_ != NULL) {
-								_g_object_unref0 (container);
-								_g_object_unref0 (info);
-								_g_object_unref0 (parent_container);
-								_g_object_unref0 (dir);
-								_g_object_unref0 (file);
-								__g_list_free_g_object_unref0 (list);
-								goto __catch11_g_error;
-								goto __finally11;
-							}
-							if (!_tmp0_) {
-								rygel_media_db_save_object (self->priv->media_db, (RygelMediaObject*) container, &_inner_error_);
-								if (_inner_error_ != NULL) {
-									_g_object_unref0 (container);
-									_g_object_unref0 (info);
-									_g_object_unref0 (parent_container);
-									_g_object_unref0 (dir);
-									_g_object_unref0 (file);
-									__g_list_free_g_object_unref0 (list);
-									goto __catch11_g_error;
-									goto __finally11;
-								}
-							}
-							_g_object_unref0 (container);
-						} else {
-							char* id;
-							char* _tmp3_;
-							gboolean _tmp2_;
-							char* _tmp1_ = NULL;
-							id = NULL;
-							_tmp2_ = rygel_media_export_harvester_push_if_changed_or_unknown (self, file, info, &_tmp1_);
-							id = (_tmp3_ = _tmp1_, _g_free0 (id), _tmp3_);
-							_tmp2_;
-							rygel_dummy_container_seen (parent_container, id);
-							_g_free0 (id);
-						}
-						_g_object_unref0 (info);
-						_g_object_unref0 (parent_container);
-						_g_object_unref0 (dir);
-						_g_object_unref0 (file);
-					}
-				}
-			}
-			g_file_enumerator_next_files_async (enumerator, 10, G_PRIORITY_DEFAULT, NULL, _rygel_media_export_harvester_on_next_files_ready_gasync_ready_callback, self);
-		} else {
-			g_file_enumerator_close_async (enumerator, G_PRIORITY_DEFAULT, NULL, _rygel_media_export_harvester_on_close_async_gasync_ready_callback, self);
-		}
-		__g_list_free_g_object_unref0 (list);
-	}
-	goto __finally11;
-	__catch11_g_error:
-	{
-		GError * _error_;
-		_error_ = _inner_error_;
-		_inner_error_ = NULL;
-		{
-			_g_error_free0 (_error_);
-		}
-	}
-	__finally11:
-	if (_inner_error_ != NULL) {
-		_g_object_unref0 (enumerator);
-		g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
-		g_clear_error (&_inner_error_);
-		return;
-	}
-	_g_object_unref0 (enumerator);
-}
-
-
-static void rygel_media_export_harvester_on_enumerate_ready (RygelMediaExportHarvester* self, GObject* obj, GAsyncResult* res) {
-	GError * _inner_error_;
-	GFile* file;
-	g_return_if_fail (self != NULL);
-	g_return_if_fail (res != NULL);
-	_inner_error_ = NULL;
-	file = _g_object_ref0 (G_FILE (obj));
-	{
-		GFileEnumerator* enumerator;
-		enumerator = g_file_enumerate_children_finish (file, res, &_inner_error_);
-		if (_inner_error_ != NULL) {
-			goto __catch12_g_error;
-			goto __finally12;
-		}
-		g_file_enumerator_next_files_async (enumerator, 10, G_PRIORITY_DEFAULT, NULL, _rygel_media_export_harvester_on_next_files_ready_gasync_ready_callback, self);
-		_g_object_unref0 (enumerator);
-	}
-	goto __finally12;
-	__catch12_g_error:
-	{
-		GError * _error_;
-		_error_ = _inner_error_;
-		_inner_error_ = NULL;
-		{
-			_g_error_free0 (_error_);
-		}
-	}
-	__finally12:
-	if (_inner_error_ != NULL) {
-		_g_object_unref0 (file);
-		g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
-		g_clear_error (&_inner_error_);
-		return;
-	}
-	_g_object_unref0 (file);
-}
-
-
-static void _rygel_media_export_harvester_on_enumerate_ready_gasync_ready_callback (GObject* source_object, GAsyncResult* res, gpointer self) {
-	rygel_media_export_harvester_on_enumerate_ready (self, source_object, res);
-}
-
-
-static gboolean rygel_media_export_harvester_on_idle (RygelMediaExportHarvester* self) {
-	gboolean result;
-	g_return_val_if_fail (self != NULL, FALSE);
-	if (g_queue_get_length (self->priv->files) > 0) {
-		GFile* candidate;
-		candidate = _g_object_ref0 (((RygelFileQueueEntry*) g_queue_peek_head (self->priv->files))->file);
-		rygel_metadata_extractor_extract (self->priv->extractor, candidate);
-		_g_object_unref0 (candidate);
-	} else {
-		if (g_queue_get_length (self->priv->containers) > 0) {
-			GFile* directory;
-			directory = _g_object_ref0 (RYGEL_DUMMY_CONTAINER ((RygelMediaContainer*) g_queue_peek_head (self->priv->containers))->file);
-			g_file_enumerate_children_async (directory, G_FILE_ATTRIBUTE_STANDARD_TYPE "," G_FILE_ATTRIBUTE_STANDARD_NAME "," G_FILE_ATTRIBUTE_TIME_MODIFIED, G_FILE_QUERY_INFO_NONE, G_PRIORITY_DEFAULT, NULL, _rygel_media_export_harvester_on_enumerate_ready_gasync_ready_callback, self);
-			_g_object_unref0 (directory);
-		} else {
-			g_signal_emit_by_name (self, "harvested", self->priv->origin);
-		}
-	}
-	result = FALSE;
-	return result;
-}
-
-
-static void rygel_media_export_harvester_on_initial_info_ready (RygelMediaExportHarvester* self, GObject* source, GAsyncResult* _result_) {
-	GError * _inner_error_;
-	GFile* file;
-	g_return_if_fail (self != NULL);
-	g_return_if_fail (_result_ != NULL);
-	_inner_error_ = NULL;
-	file = _g_object_ref0 (G_FILE (source));
-	{
-		GFileInfo* info;
-		info = g_file_query_info_finish (file, _result_, &_inner_error_);
-		if (_inner_error_ != NULL) {
-			goto __catch13_g_error;
-			goto __finally13;
-		}
-		if (g_file_info_get_file_type (info) == G_FILE_TYPE_DIRECTORY) {
-			GFile* _tmp0_;
-			RygelDummyContainer* container;
-			gint64 timestamp = 0LL;
-			gboolean _tmp1_;
-			self->priv->origin = (_tmp0_ = _g_object_ref0 (file), _g_object_unref0 (self->priv->origin), _tmp0_);
-			rygel_media_export_recursive_file_monitor_monitor (self->priv->monitor, file);
-			container = rygel_dummy_container_new (file, self->priv->parent);
-			g_queue_push_tail (self->priv->containers, _g_object_ref0 ((RygelMediaContainer*) container));
-			_tmp1_ = rygel_media_db_exists (self->priv->media_db, ((RygelMediaObject*) container)->id, &timestamp, &_inner_error_);
-			if (_inner_error_ != NULL) {
-				_g_object_unref0 (container);
-				_g_object_unref0 (info);
-				goto __catch13_g_error;
-				goto __finally13;
-			}
-			if (!_tmp1_) {
-				rygel_media_db_save_object (self->priv->media_db, (RygelMediaObject*) container, &_inner_error_);
-				if (_inner_error_ != NULL) {
-					_g_object_unref0 (container);
-					_g_object_unref0 (info);
-					goto __catch13_g_error;
-					goto __finally13;
-				}
-			}
-			g_idle_add_full (G_PRIORITY_DEFAULT_IDLE, _rygel_media_export_harvester_on_idle_gsource_func, g_object_ref (self), g_object_unref);
-			_g_object_unref0 (container);
-		} else {
-			char* id;
-			char* _tmp4_;
-			gboolean _tmp3_;
-			char* _tmp2_ = NULL;
-			id = NULL;
-			if ((_tmp3_ = rygel_media_export_harvester_push_if_changed_or_unknown (self, file, info, &_tmp2_), id = (_tmp4_ = _tmp2_, _g_free0 (id), _tmp4_), _tmp3_)) {
-				GFile* _tmp5_;
-				g_idle_add_full (G_PRIORITY_DEFAULT_IDLE, _rygel_media_export_harvester_on_idle_gsource_func, g_object_ref (self), g_object_unref);
-				self->priv->origin = (_tmp5_ = _g_object_ref0 (file), _g_object_unref0 (self->priv->origin), _tmp5_);
-				g_queue_push_tail (self->priv->containers, _g_object_ref0 (self->priv->parent));
-			}
-			_g_free0 (id);
-		}
-		_g_object_unref0 (info);
-	}
-	goto __finally13;
-	__catch13_g_error:
-	{
-		GError * err;
-		err = _inner_error_;
-		_inner_error_ = NULL;
-		{
-			char* _tmp6_;
-			g_warning ("rygel-media-export-harvester.vala:240: Failed to harvest file %s: %s", _tmp6_ = g_file_get_uri (file), err->message);
-			_g_free0 (_tmp6_);
-			g_signal_emit_by_name (self, "harvested", file);
-			_g_error_free0 (err);
-		}
-	}
-	__finally13:
-	if (_inner_error_ != NULL) {
-		_g_object_unref0 (file);
-		g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
-		g_clear_error (&_inner_error_);
-		return;
-	}
-	_g_object_unref0 (file);
-}
-
-
-static void _rygel_media_export_harvester_on_initial_info_ready_gasync_ready_callback (GObject* source_object, GAsyncResult* res, gpointer self) {
-	rygel_media_export_harvester_on_initial_info_ready (self, source_object, res);
-}
-
-
-void rygel_media_export_harvester_harvest (RygelMediaExportHarvester* self, GFile* file) {
-	g_return_if_fail (self != NULL);
-	g_return_if_fail (file != NULL);
-	g_file_query_info_async (file, G_FILE_ATTRIBUTE_STANDARD_NAME "," G_FILE_ATTRIBUTE_STANDARD_TYPE "," G_FILE_ATTRIBUTE_TIME_MODIFIED, G_FILE_QUERY_INFO_NONE, G_PRIORITY_DEFAULT, NULL, _rygel_media_export_harvester_on_initial_info_ready_gasync_ready_callback, self);
-}
-
-
-static gpointer _rygel_file_queue_entry_ref0 (gpointer self) {
-	return self ? rygel_file_queue_entry_ref (self) : NULL;
-}
-
-
-static void rygel_media_export_harvester_on_extracted_cb (RygelMediaExportHarvester* self, GFile* file, GstTagList* tag_list) {
-	GError * _inner_error_;
-	RygelFileQueueEntry* entry;
-	g_return_if_fail (self != NULL);
-	g_return_if_fail (file != NULL);
-	g_return_if_fail (tag_list != NULL);
-	_inner_error_ = NULL;
-	entry = _rygel_file_queue_entry_ref0 ((RygelFileQueueEntry*) g_queue_peek_head (self->priv->files));
-	if (entry == NULL) {
-		_rygel_file_queue_entry_unref0 (entry);
-		return;
-	}
-	if (file == entry->file) {
-		RygelMediaItem* item;
-		RygelFileQueueEntry* _tmp1_;
-		item = rygel_media_export_item_create_from_taglist ((RygelMediaContainer*) g_queue_peek_head (self->priv->containers), file, tag_list);
-		if (item != NULL) {
-			RygelMediaContainer* _tmp0_;
-			((RygelMediaObject*) item)->parent_ref = (_tmp0_ = _g_object_ref0 ((RygelMediaContainer*) g_queue_peek_head (self->priv->containers)), _g_object_unref0 (((RygelMediaObject*) item)->parent_ref), _tmp0_);
-			{
-				if (entry->update) {
-					rygel_media_db_update_object (self->priv->media_db, (RygelMediaObject*) item, &_inner_error_);
-					if (_inner_error_ != NULL) {
-						goto __catch14_g_error;
-						goto __finally14;
-					}
-				} else {
-					rygel_media_db_save_object (self->priv->media_db, (RygelMediaObject*) item, &_inner_error_);
-					if (_inner_error_ != NULL) {
-						goto __catch14_g_error;
-						goto __finally14;
-					}
-				}
-			}
-			goto __finally14;
-			__catch14_g_error:
-			{
-				GError * _error_;
-				_error_ = _inner_error_;
-				_inner_error_ = NULL;
-				{
-					_g_error_free0 (_error_);
-				}
-			}
-			__finally14:
-			if (_inner_error_ != NULL) {
-				_g_object_unref0 (item);
-				_rygel_file_queue_entry_unref0 (entry);
-				g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
-				g_clear_error (&_inner_error_);
-				return;
-			}
-		}
-		_tmp1_ = (RygelFileQueueEntry*) g_queue_pop_head (self->priv->files);
-		_rygel_file_queue_entry_unref0 (_tmp1_);
-		rygel_media_export_harvester_do_update (self);
-		g_idle_add_full (G_PRIORITY_DEFAULT_IDLE, _rygel_media_export_harvester_on_idle_gsource_func, g_object_ref (self), g_object_unref);
-		_g_object_unref0 (item);
-	}
-	_rygel_file_queue_entry_unref0 (entry);
-}
-
-
-static void rygel_media_export_harvester_on_extractor_error_cb (RygelMediaExportHarvester* self, GFile* file, GError* _error_) {
-	RygelFileQueueEntry* entry;
-	g_return_if_fail (self != NULL);
-	g_return_if_fail (file != NULL);
-	entry = _rygel_file_queue_entry_ref0 ((RygelFileQueueEntry*) g_queue_peek_head (self->priv->files));
-	if (entry == NULL) {
-		_rygel_file_queue_entry_unref0 (entry);
-		return;
-	}
-	if (file == entry->file) {
-		RygelFileQueueEntry* _tmp0_;
-		_tmp0_ = (RygelFileQueueEntry*) g_queue_pop_head (self->priv->files);
-		_rygel_file_queue_entry_unref0 (_tmp0_);
-		rygel_media_export_harvester_do_update (self);
-		g_idle_add_full (G_PRIORITY_DEFAULT_IDLE, _rygel_media_export_harvester_on_idle_gsource_func, g_object_ref (self), g_object_unref);
-	}
-	_rygel_file_queue_entry_unref0 (entry);
-}
-
-
-static void rygel_media_export_harvester_do_update (RygelMediaExportHarvester* self) {
-	gboolean _tmp0_ = FALSE;
-	g_return_if_fail (self != NULL);
-	if (g_queue_get_length (self->priv->files) == 0) {
-		_tmp0_ = g_queue_get_length (self->priv->containers) != 0;
-	} else {
-		_tmp0_ = FALSE;
-	}
-	if (_tmp0_) {
-		RygelMediaContainer* _tmp1_;
-		rygel_media_container_updated ((RygelMediaContainer*) g_queue_peek_head (self->priv->containers));
-		_tmp1_ = (RygelMediaContainer*) g_queue_pop_head (self->priv->containers);
-		_g_object_unref0 (_tmp1_);
-	}
-}
-
-
-static void rygel_media_export_harvester_class_init (RygelMediaExportHarvesterClass * klass) {
-	rygel_media_export_harvester_parent_class = g_type_class_peek_parent (klass);
-	g_type_class_add_private (klass, sizeof (RygelMediaExportHarvesterPrivate));
-	G_OBJECT_CLASS (klass)->finalize = rygel_media_export_harvester_finalize;
-	g_signal_new ("harvested", RYGEL_TYPE_MEDIA_EXPORT_HARVESTER, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__OBJECT, G_TYPE_NONE, 1, G_TYPE_FILE);
-}
-
-
-static void rygel_media_export_harvester_instance_init (RygelMediaExportHarvester * self) {
-	self->priv = RYGEL_MEDIA_EXPORT_HARVESTER_GET_PRIVATE (self);
-}
-
-
-static void rygel_media_export_harvester_finalize (GObject* obj) {
-	RygelMediaExportHarvester * self;
-	self = RYGEL_MEDIA_EXPORT_HARVESTER (obj);
-	_g_object_unref0 (self->priv->extractor);
-	_g_object_unref0 (self->priv->media_db);
-	_g_queue_free0 (self->priv->containers);
-	_g_queue_free0 (self->priv->files);
-	_g_object_unref0 (self->priv->origin);
-	_g_object_unref0 (self->priv->parent);
-	_g_object_unref0 (self->priv->monitor);
-	G_OBJECT_CLASS (rygel_media_export_harvester_parent_class)->finalize (obj);
-}
-
-
-GType rygel_media_export_harvester_get_type (void) {
-	static GType rygel_media_export_harvester_type_id = 0;
-	if (rygel_media_export_harvester_type_id == 0) {
-		static const GTypeInfo g_define_type_info = { sizeof (RygelMediaExportHarvesterClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) rygel_media_export_harvester_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (RygelMediaExportHarvester), 0, (GInstanceInitFunc) rygel_media_export_harvester_instance_init, NULL };
-		rygel_media_export_harvester_type_id = g_type_register_static (G_TYPE_OBJECT, "RygelMediaExportHarvester", &g_define_type_info, 0);
-	}
-	return rygel_media_export_harvester_type_id;
-}
-
-
-
-
--- a/src/plugins/media-export/rygel-media-export-item.c
+++ /dev/null
@@ -1,349 +0,0 @@
-/* rygel-media-export-item.c generated by valac, the Vala compiler
- * generated from rygel-media-export-item.vala, do not modify */
-
-/*
- * Copyright (C) 2008 Zeeshan Ali <zeenix@gmail.com>.
- * Copyright (C) 2008 Nokia Corporation.
- *
- * Author: Zeeshan Ali <zeenix@gmail.com>
- *
- * This file is part of Rygel.
- *
- * Rygel is free software; you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * Rygel is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this program; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
- */
-
-#include <glib.h>
-#include <glib-object.h>
-#include <rygel.h>
-#include <gio/gio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <gst/gst.h>
-
-
-#define RYGEL_TYPE_MEDIA_EXPORT_ITEM (rygel_media_export_item_get_type ())
-#define RYGEL_MEDIA_EXPORT_ITEM(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_MEDIA_EXPORT_ITEM, RygelMediaExportItem))
-#define RYGEL_MEDIA_EXPORT_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_MEDIA_EXPORT_ITEM, RygelMediaExportItemClass))
-#define RYGEL_IS_MEDIA_EXPORT_ITEM(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_MEDIA_EXPORT_ITEM))
-#define RYGEL_IS_MEDIA_EXPORT_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_MEDIA_EXPORT_ITEM))
-#define RYGEL_MEDIA_EXPORT_ITEM_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_MEDIA_EXPORT_ITEM, RygelMediaExportItemClass))
-
-typedef struct _RygelMediaExportItem RygelMediaExportItem;
-typedef struct _RygelMediaExportItemClass RygelMediaExportItemClass;
-typedef struct _RygelMediaExportItemPrivate RygelMediaExportItemPrivate;
-#define _g_free0(var) (var = (g_free (var), NULL))
-
-struct _RygelMediaExportItem {
-	RygelMediaItem parent_instance;
-	RygelMediaExportItemPrivate * priv;
-};
-
-struct _RygelMediaExportItemClass {
-	RygelMediaItemClass parent_class;
-};
-
-
-static gpointer rygel_media_export_item_parent_class = NULL;
-
-GType rygel_media_export_item_get_type (void);
-enum  {
-	RYGEL_MEDIA_EXPORT_ITEM_DUMMY_PROPERTY
-};
-RygelMediaExportItem* rygel_media_export_item_new (RygelMediaContainer* parent, GFile* file, GFileInfo* info);
-RygelMediaExportItem* rygel_media_export_item_construct (GType object_type, RygelMediaContainer* parent, GFile* file, GFileInfo* info);
-static RygelMediaExportItem* rygel_media_export_item_new_from_taglist (RygelMediaContainer* parent, const char* id, GFile* file, GstTagList* tag_list, const char* upnp_class);
-static RygelMediaExportItem* rygel_media_export_item_construct_from_taglist (GType object_type, RygelMediaContainer* parent, const char* id, GFile* file, GstTagList* tag_list, const char* upnp_class);
-RygelMediaItem* rygel_media_export_item_create_from_taglist (RygelMediaContainer* parent, GFile* file, GstTagList* tag_list);
-static int _vala_strcmp0 (const char * str1, const char * str2);
-
-
-
-RygelMediaExportItem* rygel_media_export_item_construct (GType object_type, RygelMediaContainer* parent, GFile* file, GFileInfo* info) {
-	RygelMediaExportItem * self;
-	char* content_type;
-	char* item_class;
-	char* id;
-	char* _tmp5_;
-	char* _tmp6_;
-	g_return_val_if_fail (parent != NULL, NULL);
-	g_return_val_if_fail (file != NULL, NULL);
-	g_return_val_if_fail (info != NULL, NULL);
-	content_type = g_strdup (g_file_info_get_content_type (info));
-	item_class = NULL;
-	id = g_compute_checksum_for_string (G_CHECKSUM_MD5, g_file_info_get_name (info), -1);
-	if (g_str_has_prefix (content_type, "video/")) {
-		char* _tmp0_;
-		item_class = (_tmp0_ = g_strdup (RYGEL_MEDIA_ITEM_VIDEO_CLASS), _g_free0 (item_class), _tmp0_);
-	} else {
-		if (g_str_has_prefix (content_type, "audio/")) {
-			char* _tmp1_;
-			item_class = (_tmp1_ = g_strdup (RYGEL_MEDIA_ITEM_AUDIO_CLASS), _g_free0 (item_class), _tmp1_);
-		} else {
-			if (g_str_has_prefix (content_type, "image/")) {
-				char* _tmp2_;
-				item_class = (_tmp2_ = g_strdup (RYGEL_MEDIA_ITEM_IMAGE_CLASS), _g_free0 (item_class), _tmp2_);
-			}
-		}
-	}
-	if (item_class == NULL) {
-		char* _tmp3_;
-		char* _tmp4_;
-		item_class = (_tmp3_ = g_strdup (RYGEL_MEDIA_ITEM_AUDIO_CLASS), _g_free0 (item_class), _tmp3_);
-		g_warning ("rygel-media-export-item.vala:52: Failed to detect UPnP class for '%s', assuming it's '%s'", _tmp4_ = g_file_get_uri (file), item_class);
-		_g_free0 (_tmp4_);
-	}
-	self = (RygelMediaExportItem*) rygel_media_item_construct (object_type, id, parent, g_file_info_get_name (info), item_class);
-	((RygelMediaItem*) self)->mime_type = (_tmp5_ = g_strdup (content_type), _g_free0 (((RygelMediaItem*) self)->mime_type), _tmp5_);
-	rygel_media_item_add_uri ((RygelMediaItem*) self, _tmp6_ = g_file_get_uri (file), NULL);
-	_g_free0 (_tmp6_);
-	_g_free0 (content_type);
-	_g_free0 (item_class);
-	_g_free0 (id);
-	return self;
-}
-
-
-RygelMediaExportItem* rygel_media_export_item_new (RygelMediaContainer* parent, GFile* file, GFileInfo* info) {
-	return rygel_media_export_item_construct (RYGEL_TYPE_MEDIA_EXPORT_ITEM, parent, file, info);
-}
-
-
-RygelMediaItem* rygel_media_export_item_create_from_taglist (RygelMediaContainer* parent, GFile* file, GstTagList* tag_list) {
-	RygelMediaItem* result;
-	char* _tmp0_;
-	char* _tmp1_;
-	char* id;
-	gint width;
-	gint height;
-	char* class_guessed;
-	g_return_val_if_fail (parent != NULL, NULL);
-	g_return_val_if_fail (file != NULL, NULL);
-	g_return_val_if_fail (tag_list != NULL, NULL);
-	id = (_tmp1_ = g_compute_checksum_for_string (G_CHECKSUM_MD5, _tmp0_ = g_file_get_uri (file), -1), _g_free0 (_tmp0_), _tmp1_);
-	width = -1;
-	height = -1;
-	class_guessed = NULL;
-	if (tag_list != NULL) {
-		char* codec;
-		char* _tmp4_;
-		gboolean _tmp3_;
-		char* _tmp2_ = NULL;
-		codec = NULL;
-		if (!(_tmp3_ = gst_tag_list_get_string (tag_list, GST_TAG_VIDEO_CODEC, &_tmp2_), codec = (_tmp4_ = _tmp2_, _g_free0 (codec), _tmp4_), _tmp3_)) {
-			char* _tmp7_;
-			gboolean _tmp6_;
-			char* _tmp5_ = NULL;
-			if (!(_tmp6_ = gst_tag_list_get_string (tag_list, GST_TAG_AUDIO_CODEC, &_tmp5_), codec = (_tmp7_ = _tmp5_, _g_free0 (codec), _tmp7_), _tmp6_)) {
-				gboolean _tmp8_ = FALSE;
-				if (gst_tag_list_get_int (tag_list, RYGEL_METADATA_EXTRACTOR_TAG_RYGEL_WIDTH, &width)) {
-					_tmp8_ = TRUE;
-				} else {
-					_tmp8_ = gst_tag_list_get_int (tag_list, RYGEL_METADATA_EXTRACTOR_TAG_RYGEL_HEIGHT, &height);
-				}
-				if (_tmp8_) {
-					char* _tmp9_;
-					class_guessed = (_tmp9_ = g_strdup (RYGEL_MEDIA_ITEM_IMAGE_CLASS), _g_free0 (class_guessed), _tmp9_);
-				} else {
-					gint64 duration = 0LL;
-					if (gst_tag_list_get_int64 (tag_list, RYGEL_METADATA_EXTRACTOR_TAG_RYGEL_DURATION, &duration)) {
-						char* _tmp10_;
-						class_guessed = (_tmp10_ = g_strdup (RYGEL_MEDIA_ITEM_VIDEO_CLASS), _g_free0 (class_guessed), _tmp10_);
-					} else {
-						char* _tmp11_;
-						g_warning ("There's no codec inside and file is no image: " "%s", _tmp11_ = g_file_get_uri (file));
-						_g_free0 (_tmp11_);
-						result = NULL;
-						_g_free0 (codec);
-						_g_free0 (id);
-						_g_free0 (class_guessed);
-						return result;
-					}
-				}
-			} else {
-				gboolean _tmp12_ = FALSE;
-				if (gst_tag_list_get_int (tag_list, RYGEL_METADATA_EXTRACTOR_TAG_RYGEL_WIDTH, &width)) {
-					_tmp12_ = TRUE;
-				} else {
-					_tmp12_ = gst_tag_list_get_int (tag_list, RYGEL_METADATA_EXTRACTOR_TAG_RYGEL_HEIGHT, &height);
-				}
-				if (_tmp12_) {
-					char* _tmp13_;
-					class_guessed = (_tmp13_ = g_strdup (RYGEL_MEDIA_ITEM_VIDEO_CLASS), _g_free0 (class_guessed), _tmp13_);
-				} else {
-					char* _tmp14_;
-					class_guessed = (_tmp14_ = g_strdup (RYGEL_MEDIA_ITEM_AUDIO_CLASS), _g_free0 (class_guessed), _tmp14_);
-				}
-			}
-		} else {
-			char* _tmp15_;
-			class_guessed = (_tmp15_ = g_strdup (RYGEL_MEDIA_ITEM_VIDEO_CLASS), _g_free0 (class_guessed), _tmp15_);
-		}
-		_g_free0 (codec);
-	} else {
-		char* _tmp16_;
-		g_warning ("rygel-media-export-item.vala:109: Got empty taglist for file %s", _tmp16_ = g_file_get_uri (file));
-		_g_free0 (_tmp16_);
-		result = NULL;
-		_g_free0 (id);
-		_g_free0 (class_guessed);
-		return result;
-	}
-	result = (RygelMediaItem*) rygel_media_export_item_new_from_taglist (parent, id, file, tag_list, class_guessed);
-	_g_free0 (id);
-	_g_free0 (class_guessed);
-	return result;
-}
-
-
-static RygelMediaExportItem* rygel_media_export_item_construct_from_taglist (GType object_type, RygelMediaContainer* parent, const char* id, GFile* file, GstTagList* tag_list, const char* upnp_class) {
-	RygelMediaExportItem * self;
-	char* title;
-	gboolean _tmp0_ = FALSE;
-	gint64 duration = 0LL;
-	glong _tmp6_ = 0L;
-	char* _tmp9_;
-	gboolean _tmp8_;
-	char* _tmp7_ = NULL;
-	char* _tmp12_;
-	gboolean _tmp11_;
-	char* _tmp10_ = NULL;
-	guint tmp = 0U;
-	gint64 size = 0LL;
-	guint64 mtime = 0ULL;
-	GDate* date = NULL;
-	GDate* _tmp15_;
-	gboolean _tmp14_;
-	GDate* _tmp13_ = NULL;
-	char* _tmp22_;
-	gboolean _tmp21_;
-	char* _tmp20_ = NULL;
-	char* _tmp23_;
-	g_return_val_if_fail (parent != NULL, NULL);
-	g_return_val_if_fail (id != NULL, NULL);
-	g_return_val_if_fail (file != NULL, NULL);
-	g_return_val_if_fail (tag_list != NULL, NULL);
-	g_return_val_if_fail (upnp_class != NULL, NULL);
-	title = NULL;
-	if (_vala_strcmp0 (upnp_class, RYGEL_MEDIA_ITEM_AUDIO_CLASS) == 0) {
-		_tmp0_ = TRUE;
-	} else {
-		_tmp0_ = _vala_strcmp0 (upnp_class, RYGEL_MEDIA_ITEM_MUSIC_CLASS) == 0;
-	}
-	if (_tmp0_) {
-		char* _tmp3_;
-		gboolean _tmp2_;
-		char* _tmp1_ = NULL;
-		if (!(_tmp2_ = gst_tag_list_get_string (tag_list, GST_TAG_TITLE, &_tmp1_), title = (_tmp3_ = _tmp1_, _g_free0 (title), _tmp3_), _tmp2_)) {
-			char* _tmp4_;
-			title = (_tmp4_ = g_file_get_basename (file), _g_free0 (title), _tmp4_);
-		}
-	} else {
-		char* _tmp5_;
-		title = (_tmp5_ = g_file_get_basename (file), _g_free0 (title), _tmp5_);
-	}
-	self = (RygelMediaExportItem*) rygel_media_item_construct (object_type, id, parent, title, upnp_class);
-	gst_tag_list_get_int (tag_list, RYGEL_METADATA_EXTRACTOR_TAG_RYGEL_WIDTH, &((RygelMediaItem*) self)->width);
-	gst_tag_list_get_int (tag_list, RYGEL_METADATA_EXTRACTOR_TAG_RYGEL_HEIGHT, &((RygelMediaItem*) self)->height);
-	gst_tag_list_get_int (tag_list, RYGEL_METADATA_EXTRACTOR_TAG_RYGEL_DEPTH, &((RygelMediaItem*) self)->color_depth);
-	gst_tag_list_get_int64 (tag_list, RYGEL_METADATA_EXTRACTOR_TAG_RYGEL_DURATION, &duration);
-	if (duration == (-1)) {
-		_tmp6_ = (glong) (-1);
-	} else {
-		_tmp6_ = (glong) (duration / 1000000000);
-	}
-	((RygelMediaItem*) self)->duration = _tmp6_;
-	gst_tag_list_get_int (tag_list, RYGEL_METADATA_EXTRACTOR_TAG_RYGEL_CHANNELS, &((RygelMediaItem*) self)->n_audio_channels);
-	_tmp8_ = gst_tag_list_get_string (tag_list, GST_TAG_ARTIST, &_tmp7_);
-	((RygelMediaItem*) self)->author = (_tmp9_ = _tmp7_, _g_free0 (((RygelMediaItem*) self)->author), _tmp9_);
-	_tmp8_;
-	_tmp11_ = gst_tag_list_get_string (tag_list, GST_TAG_ALBUM, &_tmp10_);
-	((RygelMediaItem*) self)->album = (_tmp12_ = _tmp10_, _g_free0 (((RygelMediaItem*) self)->album), _tmp12_);
-	_tmp11_;
-	gst_tag_list_get_uint (tag_list, GST_TAG_TRACK_NUMBER, &tmp);
-	((RygelMediaItem*) self)->track_number = (gint) tmp;
-	gst_tag_list_get_uint (tag_list, GST_TAG_BITRATE, &tmp);
-	((RygelMediaItem*) self)->bitrate = ((gint) tmp) / 8;
-	gst_tag_list_get_int (tag_list, RYGEL_METADATA_EXTRACTOR_TAG_RYGEL_RATE, &((RygelMediaItem*) self)->sample_freq);
-	gst_tag_list_get_int64 (tag_list, RYGEL_METADATA_EXTRACTOR_TAG_RYGEL_SIZE, &size);
-	((RygelMediaItem*) self)->size = (glong) size;
-	gst_tag_list_get_uint64 (tag_list, RYGEL_METADATA_EXTRACTOR_TAG_RYGEL_MTIME, &mtime);
-	((RygelMediaObject*) self)->modified = (guint64) ((gint64) mtime);
-	if ((_tmp14_ = gst_tag_list_get_date (tag_list, GST_TAG_DATE, &_tmp13_), date = (_tmp15_ = _tmp13_, _g_free0 (date), _tmp15_), _tmp14_)) {
-		gchar* _tmp16_;
-		gint datestr_size;
-		gint datestr_length1;
-		gchar* datestr;
-		char* _tmp17_;
-		datestr = (_tmp16_ = g_new0 (gchar, 30), datestr_length1 = 30, datestr_size = datestr_length1, _tmp16_);
-		g_date_strftime (datestr, datestr_length1, "%F", date);
-		((RygelMediaItem*) self)->date = (_tmp17_ = g_strdup ((const char*) datestr), _g_free0 (((RygelMediaItem*) self)->date), _tmp17_);
-		datestr = (g_free (datestr), NULL);
-	} else {
-		GTimeVal _tmp18_ = {0};
-		GTimeVal tv;
-		char* _tmp19_;
-		tv = (g_get_current_time (&_tmp18_), _tmp18_);
-		tv.tv_usec = (glong) 0;
-		tv.tv_sec = (glong) mtime;
-		((RygelMediaItem*) self)->date = (_tmp19_ = g_time_val_to_iso8601 (&tv), _g_free0 (((RygelMediaItem*) self)->date), _tmp19_);
-	}
-	_tmp21_ = gst_tag_list_get_string (tag_list, RYGEL_METADATA_EXTRACTOR_TAG_RYGEL_MIME, &_tmp20_);
-	((RygelMediaItem*) self)->mime_type = (_tmp22_ = _tmp20_, _g_free0 (((RygelMediaItem*) self)->mime_type), _tmp22_);
-	_tmp21_;
-	rygel_media_item_add_uri ((RygelMediaItem*) self, _tmp23_ = g_file_get_uri (file), NULL);
-	_g_free0 (_tmp23_);
-	_g_free0 (title);
-	_g_free0 (date);
-	return self;
-}
-
-
-static RygelMediaExportItem* rygel_media_export_item_new_from_taglist (RygelMediaContainer* parent, const char* id, GFile* file, GstTagList* tag_list, const char* upnp_class) {
-	return rygel_media_export_item_construct_from_taglist (RYGEL_TYPE_MEDIA_EXPORT_ITEM, parent, id, file, tag_list, upnp_class);
-}
-
-
-static void rygel_media_export_item_class_init (RygelMediaExportItemClass * klass) {
-	rygel_media_export_item_parent_class = g_type_class_peek_parent (klass);
-}
-
-
-static void rygel_media_export_item_instance_init (RygelMediaExportItem * self) {
-}
-
-
-GType rygel_media_export_item_get_type (void) {
-	static GType rygel_media_export_item_type_id = 0;
-	if (rygel_media_export_item_type_id == 0) {
-		static const GTypeInfo g_define_type_info = { sizeof (RygelMediaExportItemClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) rygel_media_export_item_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (RygelMediaExportItem), 0, (GInstanceInitFunc) rygel_media_export_item_instance_init, NULL };
-		rygel_media_export_item_type_id = g_type_register_static (RYGEL_TYPE_MEDIA_ITEM, "RygelMediaExportItem", &g_define_type_info, 0);
-	}
-	return rygel_media_export_item_type_id;
-}
-
-
-static int _vala_strcmp0 (const char * str1, const char * str2) {
-	if (str1 == NULL) {
-		return -(str1 != str2);
-	}
-	if (str2 == NULL) {
-		return str1 != str2;
-	}
-	return strcmp (str1, str2);
-}
-
-
-
-
--- a/src/plugins/media-export/rygel-media-export-null-container.c
+++ /dev/null
@@ -1,147 +0,0 @@
-/* rygel-media-export-null-container.c generated by valac, the Vala compiler
- * generated from rygel-media-export-null-container.vala, do not modify */
-
-/*
- * Copyright (C) 2009 Jens Georg <mail@jensge.org>.
- *
- * This file is part of Rygel.
- *
- * Rygel is free software; you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * Rygel is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this program; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
- */
-
-#include <glib.h>
-#include <glib-object.h>
-#include <rygel.h>
-#include <gio/gio.h>
-#include <gee.h>
-#include <stdlib.h>
-#include <string.h>
-
-
-#define RYGEL_TYPE_NULL_CONTAINER (rygel_null_container_get_type ())
-#define RYGEL_NULL_CONTAINER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_NULL_CONTAINER, RygelNullContainer))
-#define RYGEL_NULL_CONTAINER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_NULL_CONTAINER, RygelNullContainerClass))
-#define RYGEL_IS_NULL_CONTAINER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_NULL_CONTAINER))
-#define RYGEL_IS_NULL_CONTAINER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_NULL_CONTAINER))
-#define RYGEL_NULL_CONTAINER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_NULL_CONTAINER, RygelNullContainerClass))
-
-typedef struct _RygelNullContainer RygelNullContainer;
-typedef struct _RygelNullContainerClass RygelNullContainerClass;
-typedef struct _RygelNullContainerPrivate RygelNullContainerPrivate;
-#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
-
-struct _RygelNullContainer {
-	RygelMediaContainer parent_instance;
-	RygelNullContainerPrivate * priv;
-};
-
-struct _RygelNullContainerClass {
-	RygelMediaContainerClass parent_class;
-};
-
-
-static gpointer rygel_null_container_parent_class = NULL;
-
-GType rygel_null_container_get_type (void);
-enum  {
-	RYGEL_NULL_CONTAINER_DUMMY_PROPERTY
-};
-RygelNullContainer* rygel_null_container_new (void);
-RygelNullContainer* rygel_null_container_construct (GType object_type);
-static void rygel_null_container_real_get_children (RygelMediaContainer* base, guint offset, guint max_count, GCancellable* cancellable, GAsyncReadyCallback callback, void* callback_target);
-static GeeList* rygel_null_container_real_get_children_finish (RygelMediaContainer* base, GAsyncResult* res, GError** error);
-static void rygel_null_container_real_find_object (RygelMediaContainer* base, const char* id, GCancellable* cancellable, GAsyncReadyCallback callback, void* callback_target);
-static RygelMediaObject* rygel_null_container_real_find_object_finish (RygelMediaContainer* base, GAsyncResult* res, GError** error);
-
-
-
-RygelNullContainer* rygel_null_container_construct (GType object_type) {
-	RygelNullContainer * self;
-	self = (RygelNullContainer*) rygel_media_container_construct_root (object_type, "MediaExport", (guint) 0);
-	return self;
-}
-
-
-RygelNullContainer* rygel_null_container_new (void) {
-	return rygel_null_container_construct (RYGEL_TYPE_NULL_CONTAINER);
-}
-
-
-static void rygel_null_container_real_get_children (RygelMediaContainer* base, guint offset, guint max_count, GCancellable* cancellable, GAsyncReadyCallback callback, void* callback_target) {
-	RygelNullContainer * self;
-	RygelSimpleAsyncResult* res;
-	self = (RygelNullContainer*) base;
-	res = rygel_simple_async_result_new (G_TYPE_INT, NULL, NULL, (GObject*) self, callback, callback_target);
-	rygel_simple_async_result_complete_in_idle (res);
-	_g_object_unref0 (res);
-}
-
-
-static GeeList* rygel_null_container_real_get_children_finish (RygelMediaContainer* base, GAsyncResult* res, GError** error) {
-	RygelNullContainer * self;
-	GeeList* result;
-	self = (RygelNullContainer*) base;
-	g_return_val_if_fail (res != NULL, NULL);
-	result = (GeeList*) gee_array_list_new (RYGEL_TYPE_MEDIA_OBJECT, (GBoxedCopyFunc) g_object_ref, g_object_unref, g_direct_equal);
-	return result;
-}
-
-
-static void rygel_null_container_real_find_object (RygelMediaContainer* base, const char* id, GCancellable* cancellable, GAsyncReadyCallback callback, void* callback_target) {
-	RygelNullContainer * self;
-	RygelSimpleAsyncResult* res;
-	self = (RygelNullContainer*) base;
-	g_return_if_fail (id != NULL);
-	res = rygel_simple_async_result_new (G_TYPE_INT, NULL, NULL, (GObject*) self, callback, callback_target);
-	rygel_simple_async_result_complete_in_idle (res);
-	_g_object_unref0 (res);
-}
-
-
-static RygelMediaObject* rygel_null_container_real_find_object_finish (RygelMediaContainer* base, GAsyncResult* res, GError** error) {
-	RygelNullContainer * self;
-	RygelMediaObject* result;
-	self = (RygelNullContainer*) base;
-	g_return_val_if_fail (res != NULL, NULL);
-	result = NULL;
-	return result;
-}
-
-
-static void rygel_null_container_class_init (RygelNullContainerClass * klass) {
-	rygel_null_container_parent_class = g_type_class_peek_parent (klass);
-	RYGEL_MEDIA_CONTAINER_CLASS (klass)->get_children = rygel_null_container_real_get_children;
-	RYGEL_MEDIA_CONTAINER_CLASS (klass)->get_children_finish = rygel_null_container_real_get_children_finish;
-	RYGEL_MEDIA_CONTAINER_CLASS (klass)->find_object = rygel_null_container_real_find_object;
-	RYGEL_MEDIA_CONTAINER_CLASS (klass)->find_object_finish = rygel_null_container_real_find_object_finish;
-}
-
-
-static void rygel_null_container_instance_init (RygelNullContainer * self) {
-}
-
-
-GType rygel_null_container_get_type (void) {
-	static GType rygel_null_container_type_id = 0;
-	if (rygel_null_container_type_id == 0) {
-		static const GTypeInfo g_define_type_info = { sizeof (RygelNullContainerClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) rygel_null_container_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (RygelNullContainer), 0, (GInstanceInitFunc) rygel_null_container_instance_init, NULL };
-		rygel_null_container_type_id = g_type_register_static (RYGEL_TYPE_MEDIA_CONTAINER, "RygelNullContainer", &g_define_type_info, 0);
-	}
-	return rygel_null_container_type_id;
-}
-
-
-
-
--- a/src/plugins/media-export/rygel-media-export-plugin.c
+++ /dev/null
@@ -1,121 +0,0 @@
-/* rygel-media-export-plugin.c generated by valac, the Vala compiler
- * generated from rygel-media-export-plugin.vala, do not modify */
-
-/*
- * Copyright (C) 2008-2009 Jens Georg <mail@jensge.org>.
- *
- * This file is part of Rygel.
- *
- * Rygel is free software; you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * Rygel is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this program; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
- */
-
-#include <glib.h>
-#include <glib-object.h>
-#include <rygel.h>
-
-
-#define RYGEL_TYPE_MEDIA_EXPORT_CONTENT_DIR (rygel_media_export_content_dir_get_type ())
-#define RYGEL_MEDIA_EXPORT_CONTENT_DIR(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_MEDIA_EXPORT_CONTENT_DIR, RygelMediaExportContentDir))
-#define RYGEL_MEDIA_EXPORT_CONTENT_DIR_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_MEDIA_EXPORT_CONTENT_DIR, RygelMediaExportContentDirClass))
-#define RYGEL_IS_MEDIA_EXPORT_CONTENT_DIR(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_MEDIA_EXPORT_CONTENT_DIR))
-#define RYGEL_IS_MEDIA_EXPORT_CONTENT_DIR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_MEDIA_EXPORT_CONTENT_DIR))
-#define RYGEL_MEDIA_EXPORT_CONTENT_DIR_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_MEDIA_EXPORT_CONTENT_DIR, RygelMediaExportContentDirClass))
-
-typedef struct _RygelMediaExportContentDir RygelMediaExportContentDir;
-typedef struct _RygelMediaExportContentDirClass RygelMediaExportContentDirClass;
-#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
-#define _rygel_resource_info_unref0(var) ((var == NULL) ? NULL : (var = (rygel_resource_info_unref (var), NULL)))
-typedef struct _RygelMediaExportContentDirPrivate RygelMediaExportContentDirPrivate;
-
-struct _RygelMediaExportContentDir {
-	RygelContentDirectory parent_instance;
-	RygelMediaExportContentDirPrivate * priv;
-};
-
-struct _RygelMediaExportContentDirClass {
-	RygelContentDirectoryClass parent_class;
-};
-
-
-static gpointer rygel_media_export_content_dir_parent_class = NULL;
-
-GType rygel_media_export_content_dir_get_type (void);
-void module_init (RygelPluginLoader* loader);
-enum  {
-	RYGEL_MEDIA_EXPORT_CONTENT_DIR_DUMMY_PROPERTY
-};
-RygelMediaContainer* rygel_media_export_root_container_get_instance (void);
-static RygelMediaContainer* rygel_media_export_content_dir_real_create_root_container (RygelContentDirectory* base);
-RygelMediaExportContentDir* rygel_media_export_content_dir_new (void);
-RygelMediaExportContentDir* rygel_media_export_content_dir_construct (GType object_type);
-
-
-
-void module_init (RygelPluginLoader* loader) {
-	RygelPlugin* plugin;
-	RygelResourceInfo* resource_info;
-	g_return_if_fail (loader != NULL);
-	plugin = rygel_plugin_new_MediaServer ("MediaExport", "@REALNAME@'s media");
-	resource_info = rygel_resource_info_new (RYGEL_CONTENT_DIRECTORY_UPNP_ID, RYGEL_CONTENT_DIRECTORY_UPNP_TYPE, RYGEL_CONTENT_DIRECTORY_DESCRIPTION_PATH, RYGEL_TYPE_MEDIA_EXPORT_CONTENT_DIR);
-	rygel_plugin_add_resource (plugin, resource_info);
-	rygel_plugin_loader_add_plugin (loader, plugin);
-	_g_object_unref0 (plugin);
-	_rygel_resource_info_unref0 (resource_info);
-}
-
-
-static RygelMediaContainer* rygel_media_export_content_dir_real_create_root_container (RygelContentDirectory* base) {
-	RygelMediaExportContentDir * self;
-	RygelMediaContainer* result;
-	self = (RygelMediaExportContentDir*) base;
-	result = rygel_media_export_root_container_get_instance ();
-	return result;
-}
-
-
-RygelMediaExportContentDir* rygel_media_export_content_dir_construct (GType object_type) {
-	RygelMediaExportContentDir * self;
-	self = (RygelMediaExportContentDir*) rygel_content_directory_construct (object_type);
-	return self;
-}
-
-
-RygelMediaExportContentDir* rygel_media_export_content_dir_new (void) {
-	return rygel_media_export_content_dir_construct (RYGEL_TYPE_MEDIA_EXPORT_CONTENT_DIR);
-}
-
-
-static void rygel_media_export_content_dir_class_init (RygelMediaExportContentDirClass * klass) {
-	rygel_media_export_content_dir_parent_class = g_type_class_peek_parent (klass);
-	RYGEL_CONTENT_DIRECTORY_CLASS (klass)->create_root_container = rygel_media_export_content_dir_real_create_root_container;
-}
-
-
-static void rygel_media_export_content_dir_instance_init (RygelMediaExportContentDir * self) {
-}
-
-
-GType rygel_media_export_content_dir_get_type (void) {
-	static GType rygel_media_export_content_dir_type_id = 0;
-	if (rygel_media_export_content_dir_type_id == 0) {
-		static const GTypeInfo g_define_type_info = { sizeof (RygelMediaExportContentDirClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) rygel_media_export_content_dir_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (RygelMediaExportContentDir), 0, (GInstanceInitFunc) rygel_media_export_content_dir_instance_init, NULL };
-		rygel_media_export_content_dir_type_id = g_type_register_static (RYGEL_TYPE_CONTENT_DIRECTORY, "RygelMediaExportContentDir", &g_define_type_info, 0);
-	}
-	return rygel_media_export_content_dir_type_id;
-}
-
-
-
-
--- a/src/plugins/media-export/rygel-media-export-recursive-file-monitor.c
+++ /dev/null
@@ -1,280 +0,0 @@
-/* rygel-media-export-recursive-file-monitor.c generated by valac, the Vala compiler
- * generated from rygel-media-export-recursive-file-monitor.vala, do not modify */
-
-/*
- * Copyright (C) 2009 Jens Georg <mail@jensge.org>.
- *
- * This file is part of Rygel.
- *
- * Rygel is free software; you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * Rygel is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this program; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
- */
-
-#include <glib.h>
-#include <glib-object.h>
-#include <gio/gio.h>
-#include <gee.h>
-
-
-#define RYGEL_TYPE_MEDIA_EXPORT_RECURSIVE_FILE_MONITOR (rygel_media_export_recursive_file_monitor_get_type ())
-#define RYGEL_MEDIA_EXPORT_RECURSIVE_FILE_MONITOR(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_MEDIA_EXPORT_RECURSIVE_FILE_MONITOR, RygelMediaExportRecursiveFileMonitor))
-#define RYGEL_MEDIA_EXPORT_RECURSIVE_FILE_MONITOR_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_MEDIA_EXPORT_RECURSIVE_FILE_MONITOR, RygelMediaExportRecursiveFileMonitorClass))
-#define RYGEL_IS_MEDIA_EXPORT_RECURSIVE_FILE_MONITOR(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_MEDIA_EXPORT_RECURSIVE_FILE_MONITOR))
-#define RYGEL_IS_MEDIA_EXPORT_RECURSIVE_FILE_MONITOR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_MEDIA_EXPORT_RECURSIVE_FILE_MONITOR))
-#define RYGEL_MEDIA_EXPORT_RECURSIVE_FILE_MONITOR_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_MEDIA_EXPORT_RECURSIVE_FILE_MONITOR, RygelMediaExportRecursiveFileMonitorClass))
-
-typedef struct _RygelMediaExportRecursiveFileMonitor RygelMediaExportRecursiveFileMonitor;
-typedef struct _RygelMediaExportRecursiveFileMonitorClass RygelMediaExportRecursiveFileMonitorClass;
-typedef struct _RygelMediaExportRecursiveFileMonitorPrivate RygelMediaExportRecursiveFileMonitorPrivate;
-#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
-#define _g_free0(var) (var = (g_free (var), NULL))
-#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
-
-struct _RygelMediaExportRecursiveFileMonitor {
-	GObject parent_instance;
-	RygelMediaExportRecursiveFileMonitorPrivate * priv;
-};
-
-struct _RygelMediaExportRecursiveFileMonitorClass {
-	GObjectClass parent_class;
-};
-
-struct _RygelMediaExportRecursiveFileMonitorPrivate {
-	GCancellable* cancellable;
-	GeeHashMap* monitors;
-};
-
-
-static gpointer rygel_media_export_recursive_file_monitor_parent_class = NULL;
-
-GType rygel_media_export_recursive_file_monitor_get_type (void);
-#define RYGEL_MEDIA_EXPORT_RECURSIVE_FILE_MONITOR_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), RYGEL_TYPE_MEDIA_EXPORT_RECURSIVE_FILE_MONITOR, RygelMediaExportRecursiveFileMonitorPrivate))
-enum  {
-	RYGEL_MEDIA_EXPORT_RECURSIVE_FILE_MONITOR_DUMMY_PROPERTY
-};
-RygelMediaExportRecursiveFileMonitor* rygel_media_export_recursive_file_monitor_new (GCancellable* cancellable);
-RygelMediaExportRecursiveFileMonitor* rygel_media_export_recursive_file_monitor_construct (GType object_type, GCancellable* cancellable);
-void rygel_media_export_recursive_file_monitor_monitor (RygelMediaExportRecursiveFileMonitor* self, GFile* file);
-void rygel_media_export_recursive_file_monitor_on_monitor_changed (RygelMediaExportRecursiveFileMonitor* self, GFile* file, GFile* other_file, GFileMonitorEvent event_type);
-static void _rygel_media_export_recursive_file_monitor_on_monitor_changed_g_file_monitor_changed (GFileMonitor* _sender, GFile* file, GFile* other_file, GFileMonitorEvent event_type, gpointer self);
-static void rygel_media_export_recursive_file_monitor_on_info_ready (RygelMediaExportRecursiveFileMonitor* self, GObject* source, GAsyncResult* res);
-static void _rygel_media_export_recursive_file_monitor_on_info_ready_gasync_ready_callback (GObject* source_object, GAsyncResult* res, gpointer self);
-void rygel_media_export_recursive_file_monitor_cancel (RygelMediaExportRecursiveFileMonitor* self);
-static void rygel_media_export_recursive_file_monitor_finalize (GObject* obj);
-
-
-static void g_cclosure_user_marshal_VOID__OBJECT_OBJECT_ENUM (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data);
-
-static gpointer _g_object_ref0 (gpointer self) {
-	return self ? g_object_ref (self) : NULL;
-}
-
-
-RygelMediaExportRecursiveFileMonitor* rygel_media_export_recursive_file_monitor_construct (GType object_type, GCancellable* cancellable) {
-	RygelMediaExportRecursiveFileMonitor * self;
-	GCancellable* _tmp0_;
-	GeeHashMap* _tmp1_;
-	self = (RygelMediaExportRecursiveFileMonitor*) g_object_new (object_type, NULL);
-	self->priv->cancellable = (_tmp0_ = _g_object_ref0 (cancellable), _g_object_unref0 (self->priv->cancellable), _tmp0_);
-	self->priv->monitors = (_tmp1_ = gee_hash_map_new (G_TYPE_FILE, (GBoxedCopyFunc) g_object_ref, g_object_unref, G_TYPE_FILE_MONITOR, (GBoxedCopyFunc) g_object_ref, g_object_unref, g_file_hash, g_file_equal, g_direct_equal), _g_object_unref0 (self->priv->monitors), _tmp1_);
-	return self;
-}
-
-
-RygelMediaExportRecursiveFileMonitor* rygel_media_export_recursive_file_monitor_new (GCancellable* cancellable) {
-	return rygel_media_export_recursive_file_monitor_construct (RYGEL_TYPE_MEDIA_EXPORT_RECURSIVE_FILE_MONITOR, cancellable);
-}
-
-
-static void _rygel_media_export_recursive_file_monitor_on_monitor_changed_g_file_monitor_changed (GFileMonitor* _sender, GFile* file, GFile* other_file, GFileMonitorEvent event_type, gpointer self) {
-	rygel_media_export_recursive_file_monitor_on_monitor_changed (self, file, other_file, event_type);
-}
-
-
-void rygel_media_export_recursive_file_monitor_on_monitor_changed (RygelMediaExportRecursiveFileMonitor* self, GFile* file, GFile* other_file, GFileMonitorEvent event_type) {
-	g_return_if_fail (self != NULL);
-	g_return_if_fail (file != NULL);
-	g_signal_emit_by_name (self, "changed", file, other_file, event_type);
-	switch (event_type) {
-		case G_FILE_MONITOR_EVENT_CREATED:
-		{
-			rygel_media_export_recursive_file_monitor_monitor (self, file);
-			break;
-		}
-		case G_FILE_MONITOR_EVENT_DELETED:
-		{
-			GFileMonitor* file_monitor;
-			file_monitor = (GFileMonitor*) gee_abstract_map_get ((GeeAbstractMap*) self->priv->monitors, file);
-			if (file_monitor != NULL) {
-				char* _tmp0_;
-				guint _tmp1_;
-				g_debug ("rygel-media-export-recursive-file-monitor.vala:47: Directory %s gone, removing watch", _tmp0_ = g_file_get_uri (file));
-				_g_free0 (_tmp0_);
-				gee_abstract_map_remove ((GeeAbstractMap*) self->priv->monitors, file, NULL);
-				g_file_monitor_cancel (file_monitor);
-				g_signal_handlers_disconnect_matched (file_monitor, G_SIGNAL_MATCH_ID | G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA, (g_signal_parse_name ("changed", G_TYPE_FILE_MONITOR, &_tmp1_, NULL, FALSE), _tmp1_), 0, NULL, (GCallback) _rygel_media_export_recursive_file_monitor_on_monitor_changed_g_file_monitor_changed, self);
-			}
-			_g_object_unref0 (file_monitor);
-			break;
-		}
-		default:
-		{
-			break;
-		}
-	}
-}
-
-
-static void rygel_media_export_recursive_file_monitor_on_info_ready (RygelMediaExportRecursiveFileMonitor* self, GObject* source, GAsyncResult* res) {
-	GError * _inner_error_;
-	GFile* file;
-	g_return_if_fail (self != NULL);
-	g_return_if_fail (res != NULL);
-	_inner_error_ = NULL;
-	file = _g_object_ref0 (G_FILE (source));
-	{
-		GFileInfo* info;
-		info = g_file_query_info_finish (file, res, &_inner_error_);
-		if (_inner_error_ != NULL) {
-			goto __catch8_g_error;
-			goto __finally8;
-		}
-		if (g_file_info_get_file_type (info) == G_FILE_TYPE_DIRECTORY) {
-			GFileMonitor* file_monitor;
-			file_monitor = g_file_monitor_directory (file, G_FILE_MONITOR_NONE, self->priv->cancellable, &_inner_error_);
-			if (_inner_error_ != NULL) {
-				_g_object_unref0 (info);
-				goto __catch8_g_error;
-				goto __finally8;
-			}
-			gee_abstract_map_set ((GeeAbstractMap*) self->priv->monitors, file, file_monitor);
-			g_signal_connect_object (file_monitor, "changed", (GCallback) _rygel_media_export_recursive_file_monitor_on_monitor_changed_g_file_monitor_changed, self, 0);
-			_g_object_unref0 (file_monitor);
-		}
-		_g_object_unref0 (info);
-	}
-	goto __finally8;
-	__catch8_g_error:
-	{
-		GError * _error_;
-		_error_ = _inner_error_;
-		_inner_error_ = NULL;
-		{
-			char* _tmp0_;
-			g_warning ("rygel-media-export-recursive-file-monitor.vala:73: Failed to get file info for %s", _tmp0_ = g_file_get_uri (file));
-			_g_free0 (_tmp0_);
-			_g_error_free0 (_error_);
-		}
-	}
-	__finally8:
-	if (_inner_error_ != NULL) {
-		_g_object_unref0 (file);
-		g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
-		g_clear_error (&_inner_error_);
-		return;
-	}
-	_g_object_unref0 (file);
-}
-
-
-static void _rygel_media_export_recursive_file_monitor_on_info_ready_gasync_ready_callback (GObject* source_object, GAsyncResult* res, gpointer self) {
-	rygel_media_export_recursive_file_monitor_on_info_ready (self, source_object, res);
-}
-
-
-void rygel_media_export_recursive_file_monitor_monitor (RygelMediaExportRecursiveFileMonitor* self, GFile* file) {
-	g_return_if_fail (self != NULL);
-	g_return_if_fail (file != NULL);
-	g_file_query_info_async (file, G_FILE_ATTRIBUTE_STANDARD_TYPE, G_FILE_QUERY_INFO_NONE, G_PRIORITY_DEFAULT, NULL, _rygel_media_export_recursive_file_monitor_on_info_ready_gasync_ready_callback, self);
-}
-
-
-void rygel_media_export_recursive_file_monitor_cancel (RygelMediaExportRecursiveFileMonitor* self) {
-	g_return_if_fail (self != NULL);
-	if (self->priv->cancellable != NULL) {
-		g_cancellable_cancel (self->priv->cancellable);
-	} else {
-		{
-			GeeCollection* _tmp0_;
-			GeeIterator* _tmp1_;
-			GeeIterator* _monitor_it;
-			_monitor_it = (_tmp1_ = gee_iterable_iterator ((GeeIterable*) (_tmp0_ = gee_abstract_map_get_values ((GeeAbstractMap*) self->priv->monitors))), _g_object_unref0 (_tmp0_), _tmp1_);
-			while (TRUE) {
-				GFileMonitor* monitor;
-				if (!gee_iterator_next (_monitor_it)) {
-					break;
-				}
-				monitor = (GFileMonitor*) gee_iterator_get (_monitor_it);
-				g_file_monitor_cancel (monitor);
-				_g_object_unref0 (monitor);
-			}
-			_g_object_unref0 (_monitor_it);
-		}
-	}
-}
-
-
-static void rygel_media_export_recursive_file_monitor_class_init (RygelMediaExportRecursiveFileMonitorClass * klass) {
-	rygel_media_export_recursive_file_monitor_parent_class = g_type_class_peek_parent (klass);
-	g_type_class_add_private (klass, sizeof (RygelMediaExportRecursiveFileMonitorPrivate));
-	G_OBJECT_CLASS (klass)->finalize = rygel_media_export_recursive_file_monitor_finalize;
-	g_signal_new ("changed", RYGEL_TYPE_MEDIA_EXPORT_RECURSIVE_FILE_MONITOR, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_user_marshal_VOID__OBJECT_OBJECT_ENUM, G_TYPE_NONE, 3, G_TYPE_FILE, G_TYPE_FILE, G_TYPE_FILE_MONITOR_EVENT);
-}
-
-
-static void rygel_media_export_recursive_file_monitor_instance_init (RygelMediaExportRecursiveFileMonitor * self) {
-	self->priv = RYGEL_MEDIA_EXPORT_RECURSIVE_FILE_MONITOR_GET_PRIVATE (self);
-}
-
-
-static void rygel_media_export_recursive_file_monitor_finalize (GObject* obj) {
-	RygelMediaExportRecursiveFileMonitor * self;
-	self = RYGEL_MEDIA_EXPORT_RECURSIVE_FILE_MONITOR (obj);
-	_g_object_unref0 (self->priv->cancellable);
-	_g_object_unref0 (self->priv->monitors);
-	G_OBJECT_CLASS (rygel_media_export_recursive_file_monitor_parent_class)->finalize (obj);
-}
-
-
-GType rygel_media_export_recursive_file_monitor_get_type (void) {
-	static GType rygel_media_export_recursive_file_monitor_type_id = 0;
-	if (rygel_media_export_recursive_file_monitor_type_id == 0) {
-		static const GTypeInfo g_define_type_info = { sizeof (RygelMediaExportRecursiveFileMonitorClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) rygel_media_export_recursive_file_monitor_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (RygelMediaExportRecursiveFileMonitor), 0, (GInstanceInitFunc) rygel_media_export_recursive_file_monitor_instance_init, NULL };
-		rygel_media_export_recursive_file_monitor_type_id = g_type_register_static (G_TYPE_OBJECT, "RygelMediaExportRecursiveFileMonitor", &g_define_type_info, 0);
-	}
-	return rygel_media_export_recursive_file_monitor_type_id;
-}
-
-
-
-static void g_cclosure_user_marshal_VOID__OBJECT_OBJECT_ENUM (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data) {
-	typedef void (*GMarshalFunc_VOID__OBJECT_OBJECT_ENUM) (gpointer data1, gpointer arg_1, gpointer arg_2, gint arg_3, gpointer data2);
-	register GMarshalFunc_VOID__OBJECT_OBJECT_ENUM callback;
-	register GCClosure * cc;
-	register gpointer data1, data2;
-	cc = (GCClosure *) closure;
-	g_return_if_fail (n_param_values == 4);
-	if (G_CCLOSURE_SWAP_DATA (closure)) {
-		data1 = closure->data;
-		data2 = param_values->data[0].v_pointer;
-	} else {
-		data1 = param_values->data[0].v_pointer;
-		data2 = closure->data;
-	}
-	callback = (GMarshalFunc_VOID__OBJECT_OBJECT_ENUM) (marshal_data ? marshal_data : cc->callback);
-	callback (data1, g_value_get_object (param_values + 1), g_value_get_object (param_values + 2), g_value_get_enum (param_values + 3), data2);
-}
-
-
-
--- a/src/plugins/media-export/rygel-media-export-root-container.c
+++ /dev/null
@@ -1,828 +0,0 @@
-/* rygel-media-export-root-container.c generated by valac, the Vala compiler
- * generated from rygel-media-export-root-container.vala, do not modify */
-
-/*
- * Copyright (C) 2009 Jens Georg <mail@jensge.org>.
- *
- * This file is part of Rygel.
- *
- * Rygel is free software; you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * Rygel is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this program; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
- */
-
-#include <glib.h>
-#include <glib-object.h>
-#include <rygel.h>
-#include <gee.h>
-#include <stdlib.h>
-#include <string.h>
-#include <gio/gio.h>
-
-
-#define RYGEL_TYPE_MEDIA_EXPORT_DYNAMIC_CONTAINER (rygel_media_export_dynamic_container_get_type ())
-#define RYGEL_MEDIA_EXPORT_DYNAMIC_CONTAINER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_MEDIA_EXPORT_DYNAMIC_CONTAINER, RygelMediaExportDynamicContainer))
-#define RYGEL_MEDIA_EXPORT_DYNAMIC_CONTAINER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_MEDIA_EXPORT_DYNAMIC_CONTAINER, RygelMediaExportDynamicContainerClass))
-#define RYGEL_IS_MEDIA_EXPORT_DYNAMIC_CONTAINER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_MEDIA_EXPORT_DYNAMIC_CONTAINER))
-#define RYGEL_IS_MEDIA_EXPORT_DYNAMIC_CONTAINER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_MEDIA_EXPORT_DYNAMIC_CONTAINER))
-#define RYGEL_MEDIA_EXPORT_DYNAMIC_CONTAINER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_MEDIA_EXPORT_DYNAMIC_CONTAINER, RygelMediaExportDynamicContainerClass))
-
-typedef struct _RygelMediaExportDynamicContainer RygelMediaExportDynamicContainer;
-typedef struct _RygelMediaExportDynamicContainerClass RygelMediaExportDynamicContainerClass;
-typedef struct _RygelMediaExportDynamicContainerPrivate RygelMediaExportDynamicContainerPrivate;
-#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
-
-#define RYGEL_TYPE_MEDIA_EXPORT_ROOT_CONTAINER (rygel_media_export_root_container_get_type ())
-#define RYGEL_MEDIA_EXPORT_ROOT_CONTAINER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_MEDIA_EXPORT_ROOT_CONTAINER, RygelMediaExportRootContainer))
-#define RYGEL_MEDIA_EXPORT_ROOT_CONTAINER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_MEDIA_EXPORT_ROOT_CONTAINER, RygelMediaExportRootContainerClass))
-#define RYGEL_IS_MEDIA_EXPORT_ROOT_CONTAINER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_MEDIA_EXPORT_ROOT_CONTAINER))
-#define RYGEL_IS_MEDIA_EXPORT_ROOT_CONTAINER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_MEDIA_EXPORT_ROOT_CONTAINER))
-#define RYGEL_MEDIA_EXPORT_ROOT_CONTAINER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_MEDIA_EXPORT_ROOT_CONTAINER, RygelMediaExportRootContainerClass))
-
-typedef struct _RygelMediaExportRootContainer RygelMediaExportRootContainer;
-typedef struct _RygelMediaExportRootContainerClass RygelMediaExportRootContainerClass;
-typedef struct _RygelMediaExportRootContainerPrivate RygelMediaExportRootContainerPrivate;
-
-#define RYGEL_TYPE_MEDIA_EXPORT_HARVESTER (rygel_media_export_harvester_get_type ())
-#define RYGEL_MEDIA_EXPORT_HARVESTER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_MEDIA_EXPORT_HARVESTER, RygelMediaExportHarvester))
-#define RYGEL_MEDIA_EXPORT_HARVESTER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_MEDIA_EXPORT_HARVESTER, RygelMediaExportHarvesterClass))
-#define RYGEL_IS_MEDIA_EXPORT_HARVESTER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_MEDIA_EXPORT_HARVESTER))
-#define RYGEL_IS_MEDIA_EXPORT_HARVESTER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_MEDIA_EXPORT_HARVESTER))
-#define RYGEL_MEDIA_EXPORT_HARVESTER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_MEDIA_EXPORT_HARVESTER, RygelMediaExportHarvesterClass))
-
-typedef struct _RygelMediaExportHarvester RygelMediaExportHarvester;
-typedef struct _RygelMediaExportHarvesterClass RygelMediaExportHarvesterClass;
-
-#define RYGEL_TYPE_MEDIA_EXPORT_RECURSIVE_FILE_MONITOR (rygel_media_export_recursive_file_monitor_get_type ())
-#define RYGEL_MEDIA_EXPORT_RECURSIVE_FILE_MONITOR(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_MEDIA_EXPORT_RECURSIVE_FILE_MONITOR, RygelMediaExportRecursiveFileMonitor))
-#define RYGEL_MEDIA_EXPORT_RECURSIVE_FILE_MONITOR_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_MEDIA_EXPORT_RECURSIVE_FILE_MONITOR, RygelMediaExportRecursiveFileMonitorClass))
-#define RYGEL_IS_MEDIA_EXPORT_RECURSIVE_FILE_MONITOR(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_MEDIA_EXPORT_RECURSIVE_FILE_MONITOR))
-#define RYGEL_IS_MEDIA_EXPORT_RECURSIVE_FILE_MONITOR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_MEDIA_EXPORT_RECURSIVE_FILE_MONITOR))
-#define RYGEL_MEDIA_EXPORT_RECURSIVE_FILE_MONITOR_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_MEDIA_EXPORT_RECURSIVE_FILE_MONITOR, RygelMediaExportRecursiveFileMonitorClass))
-
-typedef struct _RygelMediaExportRecursiveFileMonitor RygelMediaExportRecursiveFileMonitor;
-typedef struct _RygelMediaExportRecursiveFileMonitorClass RygelMediaExportRecursiveFileMonitorClass;
-
-#define RYGEL_TYPE_MEDIA_EXPORT_DBUS_SERVICE (rygel_media_export_dbus_service_get_type ())
-#define RYGEL_MEDIA_EXPORT_DBUS_SERVICE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_MEDIA_EXPORT_DBUS_SERVICE, RygelMediaExportDBusService))
-#define RYGEL_MEDIA_EXPORT_DBUS_SERVICE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_MEDIA_EXPORT_DBUS_SERVICE, RygelMediaExportDBusServiceClass))
-#define RYGEL_IS_MEDIA_EXPORT_DBUS_SERVICE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_MEDIA_EXPORT_DBUS_SERVICE))
-#define RYGEL_IS_MEDIA_EXPORT_DBUS_SERVICE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_MEDIA_EXPORT_DBUS_SERVICE))
-#define RYGEL_MEDIA_EXPORT_DBUS_SERVICE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_MEDIA_EXPORT_DBUS_SERVICE, RygelMediaExportDBusServiceClass))
-
-typedef struct _RygelMediaExportDBusService RygelMediaExportDBusService;
-typedef struct _RygelMediaExportDBusServiceClass RygelMediaExportDBusServiceClass;
-#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
-#define _g_free0(var) (var = (g_free (var), NULL))
-
-#define RYGEL_TYPE_NULL_CONTAINER (rygel_null_container_get_type ())
-#define RYGEL_NULL_CONTAINER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_NULL_CONTAINER, RygelNullContainer))
-#define RYGEL_NULL_CONTAINER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_NULL_CONTAINER, RygelNullContainerClass))
-#define RYGEL_IS_NULL_CONTAINER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_NULL_CONTAINER))
-#define RYGEL_IS_NULL_CONTAINER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_NULL_CONTAINER))
-#define RYGEL_NULL_CONTAINER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_NULL_CONTAINER, RygelNullContainerClass))
-
-typedef struct _RygelNullContainer RygelNullContainer;
-typedef struct _RygelNullContainerClass RygelNullContainerClass;
-
-struct _RygelMediaExportDynamicContainer {
-	RygelMediaDBContainer parent_instance;
-	RygelMediaExportDynamicContainerPrivate * priv;
-};
-
-struct _RygelMediaExportDynamicContainerClass {
-	RygelMediaDBContainerClass parent_class;
-};
-
-struct _RygelMediaExportRootContainer {
-	RygelMediaDBContainer parent_instance;
-	RygelMediaExportRootContainerPrivate * priv;
-};
-
-struct _RygelMediaExportRootContainerClass {
-	RygelMediaDBContainerClass parent_class;
-};
-
-struct _RygelMediaExportRootContainerPrivate {
-	RygelMetadataExtractor* extractor;
-	GeeHashMap* harvester;
-	RygelMediaExportRecursiveFileMonitor* monitor;
-	RygelMediaExportDBusService* service;
-	RygelMediaExportDynamicContainer* dynamic_elements;
-};
-
-
-static gpointer rygel_media_export_dynamic_container_parent_class = NULL;
-static RygelMediaContainer* rygel_media_export_root_container_instance;
-static RygelMediaContainer* rygel_media_export_root_container_instance = NULL;
-static gpointer rygel_media_export_root_container_parent_class = NULL;
-
-GType rygel_media_export_dynamic_container_get_type (void);
-enum  {
-	RYGEL_MEDIA_EXPORT_DYNAMIC_CONTAINER_DUMMY_PROPERTY
-};
-#define RYGEL_MEDIA_EXPORT_DYNAMIC_CONTAINER_ID "DynamicContainerId"
-RygelMediaExportDynamicContainer* rygel_media_export_dynamic_container_new (RygelMediaDB* media_db, RygelMediaContainer* parent);
-RygelMediaExportDynamicContainer* rygel_media_export_dynamic_container_construct (GType object_type, RygelMediaDB* media_db, RygelMediaContainer* parent);
-GeeList* rygel_media_export_dynamic_container_get_uris (RygelMediaExportDynamicContainer* self);
-GType rygel_media_export_root_container_get_type (void);
-GType rygel_media_export_harvester_get_type (void);
-GType rygel_media_export_recursive_file_monitor_get_type (void);
-GType rygel_media_export_dbus_service_get_type (void);
-#define RYGEL_MEDIA_EXPORT_ROOT_CONTAINER_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), RYGEL_TYPE_MEDIA_EXPORT_ROOT_CONTAINER, RygelMediaExportRootContainerPrivate))
-enum  {
-	RYGEL_MEDIA_EXPORT_ROOT_CONTAINER_DUMMY_PROPERTY
-};
-static GeeArrayList* rygel_media_export_root_container_get_uris (RygelMediaExportRootContainer* self);
-static RygelMediaExportRootContainer* rygel_media_export_root_container_new (RygelMediaDB* db);
-static RygelMediaExportRootContainer* rygel_media_export_root_container_construct (GType object_type, RygelMediaDB* db);
-RygelNullContainer* rygel_null_container_new (void);
-RygelNullContainer* rygel_null_container_construct (GType object_type);
-GType rygel_null_container_get_type (void);
-RygelMediaContainer* rygel_media_export_root_container_get_instance (void);
-static void rygel_media_export_root_container_harvest (RygelMediaExportRootContainer* self, GFile* file, RygelMediaContainer* parent);
-void rygel_media_export_root_container_add_uri (RygelMediaExportRootContainer* self, const char* uri);
-void rygel_media_export_root_container_remove_uri (RygelMediaExportRootContainer* self, const char* uri);
-static void _vala_array_add1 (char*** array, int* length, int* size, char* value);
-char** rygel_media_export_root_container_get_dynamic_uris (RygelMediaExportRootContainer* self, int* result_length1);
-RygelMediaExportRecursiveFileMonitor* rygel_media_export_recursive_file_monitor_new (GCancellable* cancellable);
-RygelMediaExportRecursiveFileMonitor* rygel_media_export_recursive_file_monitor_construct (GType object_type, GCancellable* cancellable);
-static void rygel_media_export_root_container_on_file_changed (RygelMediaExportRootContainer* self, GFile* file, GFile* other, GFileMonitorEvent event);
-static void _rygel_media_export_root_container_on_file_changed_rygel_media_export_recursive_file_monitor_changed (RygelMediaExportRecursiveFileMonitor* _sender, GFile* file, GFile* other_file, GFileMonitorEvent event_type, gpointer self);
-RygelMediaExportDBusService* rygel_media_export_dbus_service_new (RygelMediaExportRootContainer* root_container, GError** error);
-RygelMediaExportDBusService* rygel_media_export_dbus_service_construct (GType object_type, RygelMediaExportRootContainer* root_container, GError** error);
-static void rygel_media_export_root_container_on_file_harvested (RygelMediaExportRootContainer* self, GFile* file);
-RygelMediaExportHarvester* rygel_media_export_harvester_new (RygelMediaContainer* parent, RygelMediaDB* media_db, RygelMetadataExtractor* extractor, RygelMediaExportRecursiveFileMonitor* monitor);
-RygelMediaExportHarvester* rygel_media_export_harvester_construct (GType object_type, RygelMediaContainer* parent, RygelMediaDB* media_db, RygelMetadataExtractor* extractor, RygelMediaExportRecursiveFileMonitor* monitor);
-static void _rygel_media_export_root_container_on_file_harvested_rygel_media_export_harvester_harvested (RygelMediaExportHarvester* _sender, GFile* file, gpointer self);
-void rygel_media_export_harvester_harvest (RygelMediaExportHarvester* self, GFile* file);
-static void rygel_media_export_root_container_finalize (GObject* obj);
-static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
-static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);
-static int _vala_strcmp0 (const char * str1, const char * str2);
-
-
-
-RygelMediaExportDynamicContainer* rygel_media_export_dynamic_container_construct (GType object_type, RygelMediaDB* media_db, RygelMediaContainer* parent) {
-	RygelMediaExportDynamicContainer * self;
-	g_return_val_if_fail (media_db != NULL, NULL);
-	g_return_val_if_fail (parent != NULL, NULL);
-	self = (RygelMediaExportDynamicContainer*) rygel_media_db_container_construct (object_type, media_db, RYGEL_MEDIA_EXPORT_DYNAMIC_CONTAINER_ID, "Dynamic");
-	((RygelMediaObject*) self)->parent = parent;
-	return self;
-}
-
-
-RygelMediaExportDynamicContainer* rygel_media_export_dynamic_container_new (RygelMediaDB* media_db, RygelMediaContainer* parent) {
-	return rygel_media_export_dynamic_container_construct (RYGEL_TYPE_MEDIA_EXPORT_DYNAMIC_CONTAINER, media_db, parent);
-}
-
-
-GeeList* rygel_media_export_dynamic_container_get_uris (RygelMediaExportDynamicContainer* self) {
-	GeeList* result;
-	GeeArrayList* _result_;
-	GeeArrayList* children;
-	g_return_val_if_fail (self != NULL, NULL);
-	_result_ = gee_array_list_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, g_direct_equal);
-	children = rygel_media_db_get_children (((RygelMediaDBContainer*) self)->media_db, ((RygelMediaObject*) self)->id, (glong) (-1), (glong) (-1));
-	if (children != NULL) {
-		{
-			GeeIterator* _child_it;
-			_child_it = gee_abstract_collection_iterator ((GeeAbstractCollection*) children);
-			while (TRUE) {
-				RygelMediaObject* child;
-				if (!gee_iterator_next (_child_it)) {
-					break;
-				}
-				child = (RygelMediaObject*) gee_iterator_get (_child_it);
-				gee_abstract_collection_add_all ((GeeAbstractCollection*) _result_, (GeeCollection*) child->uris);
-				_g_object_unref0 (child);
-			}
-			_g_object_unref0 (_child_it);
-		}
-	}
-	result = (GeeList*) _result_;
-	_g_object_unref0 (children);
-	return result;
-}
-
-
-static void rygel_media_export_dynamic_container_class_init (RygelMediaExportDynamicContainerClass * klass) {
-	rygel_media_export_dynamic_container_parent_class = g_type_class_peek_parent (klass);
-}
-
-
-static void rygel_media_export_dynamic_container_instance_init (RygelMediaExportDynamicContainer * self) {
-}
-
-
-GType rygel_media_export_dynamic_container_get_type (void) {
-	static GType rygel_media_export_dynamic_container_type_id = 0;
-	if (rygel_media_export_dynamic_container_type_id == 0) {
-		static const GTypeInfo g_define_type_info = { sizeof (RygelMediaExportDynamicContainerClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) rygel_media_export_dynamic_container_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (RygelMediaExportDynamicContainer), 0, (GInstanceInitFunc) rygel_media_export_dynamic_container_instance_init, NULL };
-		rygel_media_export_dynamic_container_type_id = g_type_register_static (RYGEL_TYPE_MEDIA_DB_CONTAINER, "RygelMediaExportDynamicContainer", &g_define_type_info, 0);
-	}
-	return rygel_media_export_dynamic_container_type_id;
-}
-
-
-static GeeArrayList* rygel_media_export_root_container_get_uris (RygelMediaExportRootContainer* self) {
-	GeeArrayList* result;
-	GError * _inner_error_;
-	GeeArrayList* uris;
-	RygelMetaConfig* config;
-	GeeList* dbus_uris;
-	g_return_val_if_fail (self != NULL, NULL);
-	_inner_error_ = NULL;
-	uris = NULL;
-	config = rygel_meta_config_get_default ();
-	{
-		GeeArrayList* _tmp0_;
-		GeeArrayList* _tmp1_;
-		_tmp0_ = rygel_configuration_get_string_list ((RygelConfiguration*) config, "MediaExport", "uris", &_inner_error_);
-		if (_inner_error_ != NULL) {
-			goto __catch0_g_error;
-			goto __finally0;
-		}
-		uris = (_tmp1_ = _tmp0_, _g_object_unref0 (uris), _tmp1_);
-	}
-	goto __finally0;
-	__catch0_g_error:
-	{
-		GError * _error_;
-		_error_ = _inner_error_;
-		_inner_error_ = NULL;
-		{
-			GeeArrayList* _tmp2_;
-			uris = (_tmp2_ = gee_array_list_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, g_direct_equal), _g_object_unref0 (uris), _tmp2_);
-			_g_error_free0 (_error_);
-		}
-	}
-	__finally0:
-	if (_inner_error_ != NULL) {
-		_g_object_unref0 (uris);
-		_g_object_unref0 (config);
-		g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
-		g_clear_error (&_inner_error_);
-		return NULL;
-	}
-	if (gee_collection_get_size ((GeeCollection*) uris) == 0) {
-		char* uri;
-		char* _tmp3_;
-		char* _tmp4_;
-		g_debug ("rygel-media-export-root-container.vala:71: Nothing configured, using XDG special directories");
-		uri = g_strdup (g_get_user_special_dir (G_USER_DIRECTORY_MUSIC));
-		if (uri != NULL) {
-			gee_abstract_collection_add ((GeeAbstractCollection*) uris, uri);
-		}
-		uri = (_tmp3_ = g_strdup (g_get_user_special_dir (G_USER_DIRECTORY_PICTURES)), _g_free0 (uri), _tmp3_);
-		if (uri != NULL) {
-			gee_abstract_collection_add ((GeeAbstractCollection*) uris, uri);
-		}
-		uri = (_tmp4_ = g_strdup (g_get_user_special_dir (G_USER_DIRECTORY_VIDEOS)), _g_free0 (uri), _tmp4_);
-		if (uri != NULL) {
-			gee_abstract_collection_add ((GeeAbstractCollection*) uris, uri);
-		}
-		_g_free0 (uri);
-	}
-	dbus_uris = rygel_media_export_dynamic_container_get_uris (self->priv->dynamic_elements);
-	if (dbus_uris != NULL) {
-		gee_abstract_collection_add_all ((GeeAbstractCollection*) uris, (GeeCollection*) dbus_uris);
-	}
-	result = uris;
-	_g_object_unref0 (config);
-	_g_object_unref0 (dbus_uris);
-	return result;
-}
-
-
-static gpointer _g_object_ref0 (gpointer self) {
-	return self ? g_object_ref (self) : NULL;
-}
-
-
-RygelMediaContainer* rygel_media_export_root_container_get_instance (void) {
-	RygelMediaContainer* result;
-	GError * _inner_error_;
-	_inner_error_ = NULL;
-	if (rygel_media_export_root_container_instance == NULL) {
-		{
-			RygelMediaDB* db;
-			RygelMediaContainer* _tmp0_;
-			db = rygel_media_db_create ("media-export", &_inner_error_);
-			if (_inner_error_ != NULL) {
-				if (_inner_error_->domain == RYGEL_MEDIA_DB_ERROR) {
-					goto __catch1_rygel_media_db_error;
-				}
-				goto __finally1;
-			}
-			rygel_media_export_root_container_instance = (_tmp0_ = (RygelMediaContainer*) rygel_media_export_root_container_new (db), _g_object_unref0 (rygel_media_export_root_container_instance), _tmp0_);
-			_g_object_unref0 (db);
-		}
-		goto __finally1;
-		__catch1_rygel_media_db_error:
-		{
-			GError * err;
-			err = _inner_error_;
-			_inner_error_ = NULL;
-			{
-				RygelMediaContainer* _tmp1_;
-				g_warning ("rygel-media-export-root-container.vala:100: Failed to create instance of database");
-				rygel_media_export_root_container_instance = (_tmp1_ = (RygelMediaContainer*) rygel_null_container_new (), _g_object_unref0 (rygel_media_export_root_container_instance), _tmp1_);
-				_g_error_free0 (err);
-			}
-		}
-		__finally1:
-		if (_inner_error_ != NULL) {
-			g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
-			g_clear_error (&_inner_error_);
-			return NULL;
-		}
-	}
-	result = _g_object_ref0 (rygel_media_export_root_container_instance);
-	return result;
-}
-
-
-void rygel_media_export_root_container_add_uri (RygelMediaExportRootContainer* self, const char* uri) {
-	GFile* file;
-	g_return_if_fail (self != NULL);
-	g_return_if_fail (uri != NULL);
-	file = g_file_new_for_commandline_arg (uri);
-	rygel_media_export_root_container_harvest (self, file, (RygelMediaContainer*) self->priv->dynamic_elements);
-	_g_object_unref0 (file);
-}
-
-
-void rygel_media_export_root_container_remove_uri (RygelMediaExportRootContainer* self, const char* uri) {
-	GError * _inner_error_;
-	GFile* file;
-	char* _tmp0_;
-	char* _tmp1_;
-	char* id;
-	g_return_if_fail (self != NULL);
-	g_return_if_fail (uri != NULL);
-	_inner_error_ = NULL;
-	file = g_file_new_for_commandline_arg (uri);
-	id = (_tmp1_ = g_compute_checksum_for_string (G_CHECKSUM_MD5, _tmp0_ = g_file_get_uri (file), -1), _g_free0 (_tmp0_), _tmp1_);
-	{
-		rygel_media_db_remove_by_id (((RygelMediaDBContainer*) self)->media_db, id, &_inner_error_);
-		if (_inner_error_ != NULL) {
-			goto __catch2_g_error;
-			goto __finally2;
-		}
-	}
-	goto __finally2;
-	__catch2_g_error:
-	{
-		GError * e;
-		e = _inner_error_;
-		_inner_error_ = NULL;
-		{
-			g_warning ("rygel-media-export-root-container.vala:121: Failed to remove uri: %s", e->message);
-			_g_error_free0 (e);
-		}
-	}
-	__finally2:
-	if (_inner_error_ != NULL) {
-		_g_object_unref0 (file);
-		_g_free0 (id);
-		g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
-		g_clear_error (&_inner_error_);
-		return;
-	}
-	_g_object_unref0 (file);
-	_g_free0 (id);
-}
-
-
-static void _vala_array_add1 (char*** array, int* length, int* size, char* value) {
-	if ((*length) == (*size)) {
-		*size = (*size) ? (2 * (*size)) : 4;
-		*array = g_renew (char*, *array, (*size) + 1);
-	}
-	(*array)[(*length)++] = value;
-	(*array)[*length] = NULL;
-}
-
-
-char** rygel_media_export_root_container_get_dynamic_uris (RygelMediaExportRootContainer* self, int* result_length1) {
-	char** result;
-	char** _tmp0_;
-	gint _result__size;
-	gint _result__length1;
-	char** _result_;
-	GeeList* dynamic_uris;
-	char** _tmp1_;
-	g_return_val_if_fail (self != NULL, NULL);
-	_result_ = (_tmp0_ = g_new0 (char*, 0 + 1), _result__length1 = 0, _result__size = _result__length1, _tmp0_);
-	dynamic_uris = rygel_media_export_dynamic_container_get_uris (self->priv->dynamic_elements);
-	{
-		GeeIterator* _uri_it;
-		_uri_it = gee_iterable_iterator ((GeeIterable*) dynamic_uris);
-		while (TRUE) {
-			char* uri;
-			if (!gee_iterator_next (_uri_it)) {
-				break;
-			}
-			uri = (char*) gee_iterator_get (_uri_it);
-			_vala_array_add1 (&_result_, &_result__length1, &_result__size, g_strdup (uri));
-			_g_free0 (uri);
-		}
-		_g_object_unref0 (_uri_it);
-	}
-	result = (_tmp1_ = _result_, *result_length1 = _result__length1, _tmp1_);
-	_g_object_unref0 (dynamic_uris);
-	return result;
-	_result_ = (_vala_array_free (_result_, _result__length1, (GDestroyNotify) g_free), NULL);
-	_g_object_unref0 (dynamic_uris);
-}
-
-
-static void _rygel_media_export_root_container_on_file_changed_rygel_media_export_recursive_file_monitor_changed (RygelMediaExportRecursiveFileMonitor* _sender, GFile* file, GFile* other_file, GFileMonitorEvent event_type, gpointer self) {
-	rygel_media_export_root_container_on_file_changed (self, file, other_file, event_type);
-}
-
-
-static RygelMediaExportRootContainer* rygel_media_export_root_container_construct (GType object_type, RygelMediaDB* db) {
-	GError * _inner_error_;
-	RygelMediaExportRootContainer * self;
-	RygelMetadataExtractor* _tmp0_;
-	GeeHashMap* _tmp1_;
-	RygelMediaExportRecursiveFileMonitor* _tmp2_;
-	RygelMediaExportDBusService* _tmp3_;
-	RygelMediaExportDBusService* _tmp4_;
-	RygelMediaExportDynamicContainer* _tmp5_;
-	gint64 timestamp = 0LL;
-	gboolean _tmp6_;
-	gboolean _tmp7_;
-	GeeArrayList* ids;
-	GeeArrayList* uris;
-	g_return_val_if_fail (db != NULL, NULL);
-	_inner_error_ = NULL;
-	self = (RygelMediaExportRootContainer*) rygel_media_db_container_construct (object_type, db, "0", "MediaExportRoot");
-	self->priv->extractor = (_tmp0_ = rygel_metadata_extractor_new (), _g_object_unref0 (self->priv->extractor), _tmp0_);
-	self->priv->harvester = (_tmp1_ = gee_hash_map_new (G_TYPE_FILE, (GBoxedCopyFunc) g_object_ref, g_object_unref, RYGEL_TYPE_MEDIA_EXPORT_HARVESTER, (GBoxedCopyFunc) g_object_ref, g_object_unref, g_file_hash, g_file_equal, g_direct_equal), _g_object_unref0 (self->priv->harvester), _tmp1_);
-	self->priv->monitor = (_tmp2_ = rygel_media_export_recursive_file_monitor_new (NULL), _g_object_unref0 (self->priv->monitor), _tmp2_);
-	g_signal_connect_object (self->priv->monitor, "changed", (GCallback) _rygel_media_export_root_container_on_file_changed_rygel_media_export_recursive_file_monitor_changed, self, 0);
-	_tmp3_ = rygel_media_export_dbus_service_new (self, &_inner_error_);
-	if (_inner_error_ != NULL) {
-		g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
-		g_clear_error (&_inner_error_);
-		return NULL;
-	}
-	self->priv->service = (_tmp4_ = _tmp3_, _g_object_unref0 (self->priv->service), _tmp4_);
-	self->priv->dynamic_elements = (_tmp5_ = rygel_media_export_dynamic_container_new (db, (RygelMediaContainer*) self), _g_object_unref0 (self->priv->dynamic_elements), _tmp5_);
-	_tmp6_ = rygel_media_db_exists (((RygelMediaDBContainer*) self)->media_db, "0", &timestamp, &_inner_error_);
-	if (_inner_error_ != NULL) {
-		g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
-		g_clear_error (&_inner_error_);
-		return NULL;
-	}
-	if (!_tmp6_) {
-		{
-			rygel_media_db_save_object (((RygelMediaDBContainer*) self)->media_db, (RygelMediaObject*) self, &_inner_error_);
-			if (_inner_error_ != NULL) {
-				goto __catch3_g_error;
-				goto __finally3;
-			}
-		}
-		goto __finally3;
-		__catch3_g_error:
-		{
-			GError * _error_;
-			_error_ = _inner_error_;
-			_inner_error_ = NULL;
-			{
-				_g_error_free0 (_error_);
-			}
-		}
-		__finally3:
-		if (_inner_error_ != NULL) {
-			g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
-			g_clear_error (&_inner_error_);
-			return NULL;
-		}
-	}
-	_tmp7_ = rygel_media_db_exists (((RygelMediaDBContainer*) self)->media_db, "DynamicContainerId", &timestamp, &_inner_error_);
-	if (_inner_error_ != NULL) {
-		g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
-		g_clear_error (&_inner_error_);
-		return NULL;
-	}
-	if (!_tmp7_) {
-		{
-			rygel_media_db_save_object (((RygelMediaDBContainer*) self)->media_db, (RygelMediaObject*) self->priv->dynamic_elements, &_inner_error_);
-			if (_inner_error_ != NULL) {
-				goto __catch4_g_error;
-				goto __finally4;
-			}
-		}
-		goto __finally4;
-		__catch4_g_error:
-		{
-			GError * _error_;
-			_error_ = _inner_error_;
-			_inner_error_ = NULL;
-			{
-				_g_error_free0 (_error_);
-			}
-		}
-		__finally4:
-		if (_inner_error_ != NULL) {
-			g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
-			g_clear_error (&_inner_error_);
-			return NULL;
-		}
-	}
-	ids = NULL;
-	{
-		GeeArrayList* _tmp8_;
-		GeeArrayList* _tmp9_;
-		_tmp8_ = rygel_media_db_get_child_ids (((RygelMediaDBContainer*) self)->media_db, "0", &_inner_error_);
-		if (_inner_error_ != NULL) {
-			if (_inner_error_->domain == RYGEL_MEDIA_DB_ERROR) {
-				goto __catch5_rygel_media_db_error;
-			}
-			goto __finally5;
-		}
-		ids = (_tmp9_ = _tmp8_, _g_object_unref0 (ids), _tmp9_);
-	}
-	goto __finally5;
-	__catch5_rygel_media_db_error:
-	{
-		GError * e;
-		e = _inner_error_;
-		_inner_error_ = NULL;
-		{
-			GeeArrayList* _tmp10_;
-			ids = (_tmp10_ = gee_array_list_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, g_direct_equal), _g_object_unref0 (ids), _tmp10_);
-			_g_error_free0 (e);
-		}
-	}
-	__finally5:
-	if (_inner_error_ != NULL) {
-		_g_object_unref0 (ids);
-		g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
-		g_clear_error (&_inner_error_);
-		return NULL;
-	}
-	uris = rygel_media_export_root_container_get_uris (self);
-	{
-		GeeIterator* _uri_it;
-		_uri_it = gee_abstract_collection_iterator ((GeeAbstractCollection*) uris);
-		while (TRUE) {
-			char* uri;
-			GFile* file;
-			if (!gee_iterator_next (_uri_it)) {
-				break;
-			}
-			uri = (char*) gee_iterator_get (_uri_it);
-			file = g_file_new_for_commandline_arg (uri);
-			if (g_file_query_exists (file, NULL)) {
-				char* _tmp11_;
-				char* _tmp12_;
-				char* id;
-				id = (_tmp12_ = g_compute_checksum_for_string (G_CHECKSUM_MD5, _tmp11_ = g_file_get_uri (file), -1), _g_free0 (_tmp11_), _tmp12_);
-				gee_abstract_collection_remove ((GeeAbstractCollection*) ids, id);
-				rygel_media_export_root_container_harvest (self, file, self);
-				_g_free0 (id);
-			}
-			_g_free0 (uri);
-			_g_object_unref0 (file);
-		}
-		_g_object_unref0 (_uri_it);
-	}
-	{
-		GeeIterator* _id_it;
-		_id_it = gee_abstract_collection_iterator ((GeeAbstractCollection*) ids);
-		while (TRUE) {
-			char* id;
-			if (!gee_iterator_next (_id_it)) {
-				break;
-			}
-			id = (char*) gee_iterator_get (_id_it);
-			if (_vala_strcmp0 (id, RYGEL_MEDIA_EXPORT_DYNAMIC_CONTAINER_ID) == 0) {
-				_g_free0 (id);
-				continue;
-			}
-			g_debug ("rygel-media-export-root-container.vala:194: Id %s no longer in config, deleting...", id);
-			{
-				rygel_media_db_remove_by_id (((RygelMediaDBContainer*) self)->media_db, id, &_inner_error_);
-				if (_inner_error_ != NULL) {
-					if (_inner_error_->domain == RYGEL_MEDIA_DB_ERROR) {
-						goto __catch6_rygel_media_db_error;
-					}
-					goto __finally6;
-				}
-			}
-			goto __finally6;
-			__catch6_rygel_media_db_error:
-			{
-				GError * e;
-				e = _inner_error_;
-				_inner_error_ = NULL;
-				{
-					g_warning ("rygel-media-export-root-container.vala:199: Failed to remove entry: %s", e->message);
-					_g_error_free0 (e);
-				}
-			}
-			__finally6:
-			if (_inner_error_ != NULL) {
-				_g_free0 (id);
-				_g_object_unref0 (_id_it);
-				_g_object_unref0 (ids);
-				_g_object_unref0 (uris);
-				g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
-				g_clear_error (&_inner_error_);
-				return NULL;
-			}
-			_g_free0 (id);
-		}
-		_g_object_unref0 (_id_it);
-	}
-	rygel_media_container_updated ((RygelMediaContainer*) self);
-	_g_object_unref0 (ids);
-	_g_object_unref0 (uris);
-	return self;
-}
-
-
-static RygelMediaExportRootContainer* rygel_media_export_root_container_new (RygelMediaDB* db) {
-	return rygel_media_export_root_container_construct (RYGEL_TYPE_MEDIA_EXPORT_ROOT_CONTAINER, db);
-}
-
-
-static void rygel_media_export_root_container_on_file_harvested (RygelMediaExportRootContainer* self, GFile* file) {
-	g_return_if_fail (self != NULL);
-	g_return_if_fail (file != NULL);
-	gee_abstract_map_remove ((GeeAbstractMap*) self->priv->harvester, file, NULL);
-}
-
-
-static void _rygel_media_export_root_container_on_file_harvested_rygel_media_export_harvester_harvested (RygelMediaExportHarvester* _sender, GFile* file, gpointer self) {
-	rygel_media_export_root_container_on_file_harvested (self, file);
-}
-
-
-static void rygel_media_export_root_container_harvest (RygelMediaExportRootContainer* self, GFile* file, RygelMediaContainer* parent) {
-	RygelMediaExportHarvester* harvester;
-	g_return_if_fail (self != NULL);
-	g_return_if_fail (file != NULL);
-	g_return_if_fail (parent != NULL);
-	harvester = rygel_media_export_harvester_new (parent, ((RygelMediaDBContainer*) self)->media_db, self->priv->extractor, self->priv->monitor);
-	g_signal_connect_object (harvester, "harvested", (GCallback) _rygel_media_export_root_container_on_file_harvested_rygel_media_export_harvester_harvested, self, 0);
-	gee_abstract_map_set ((GeeAbstractMap*) self->priv->harvester, file, harvester);
-	rygel_media_export_harvester_harvest (harvester, file);
-	_g_object_unref0 (harvester);
-}
-
-
-static void rygel_media_export_root_container_on_file_changed (RygelMediaExportRootContainer* self, GFile* file, GFile* other, GFileMonitorEvent event) {
-	GError * _inner_error_;
-	g_return_if_fail (self != NULL);
-	g_return_if_fail (file != NULL);
-	_inner_error_ = NULL;
-	switch (event) {
-		case G_FILE_MONITOR_EVENT_CREATED:
-		case G_FILE_MONITOR_EVENT_CHANGES_DONE_HINT:
-		{
-			GFile* parent;
-			char* _tmp0_;
-			char* _tmp1_;
-			char* id;
-			RygelMediaObject* parent_container;
-			parent = g_file_get_parent (file);
-			id = (_tmp1_ = g_compute_checksum_for_string (G_CHECKSUM_MD5, _tmp0_ = g_file_get_uri (parent), -1), _g_free0 (_tmp0_), _tmp1_);
-			parent_container = rygel_media_db_get_object (((RygelMediaDBContainer*) self)->media_db, id, &_inner_error_);
-			if (_inner_error_ != NULL) {
-				_g_object_unref0 (parent);
-				_g_free0 (id);
-				g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
-				g_clear_error (&_inner_error_);
-				return;
-			}
-			if (parent_container != NULL) {
-				rygel_media_export_root_container_harvest (self, file, RYGEL_MEDIA_CONTAINER (parent_container));
-			} else {
-				g_assert_not_reached ();
-			}
-			_g_object_unref0 (parent);
-			_g_free0 (id);
-			_g_object_unref0 (parent_container);
-			break;
-		}
-		case G_FILE_MONITOR_EVENT_DELETED:
-		{
-			char* _tmp2_;
-			char* _tmp3_;
-			char* id;
-			RygelMediaObject* obj;
-			id = (_tmp3_ = g_compute_checksum_for_string (G_CHECKSUM_MD5, _tmp2_ = g_file_get_uri (file), -1), _g_free0 (_tmp2_), _tmp3_);
-			obj = rygel_media_db_get_object (((RygelMediaDBContainer*) self)->media_db, id, &_inner_error_);
-			if (_inner_error_ != NULL) {
-				_g_free0 (id);
-				g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
-				g_clear_error (&_inner_error_);
-				return;
-			}
-			if (obj != NULL) {
-				rygel_media_db_remove_object (((RygelMediaDBContainer*) self)->media_db, obj, &_inner_error_);
-				if (_inner_error_ != NULL) {
-					_g_free0 (id);
-					_g_object_unref0 (obj);
-					g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
-					g_clear_error (&_inner_error_);
-					return;
-				}
-				if (obj->parent != NULL) {
-					rygel_media_container_updated (obj->parent);
-				}
-			}
-			_g_free0 (id);
-			_g_object_unref0 (obj);
-			break;
-		}
-		default:
-		{
-			break;
-		}
-	}
-}
-
-
-static void rygel_media_export_root_container_class_init (RygelMediaExportRootContainerClass * klass) {
-	rygel_media_export_root_container_parent_class = g_type_class_peek_parent (klass);
-	g_type_class_add_private (klass, sizeof (RygelMediaExportRootContainerPrivate));
-	G_OBJECT_CLASS (klass)->finalize = rygel_media_export_root_container_finalize;
-}
-
-
-static void rygel_media_export_root_container_instance_init (RygelMediaExportRootContainer * self) {
-	self->priv = RYGEL_MEDIA_EXPORT_ROOT_CONTAINER_GET_PRIVATE (self);
-}
-
-
-static void rygel_media_export_root_container_finalize (GObject* obj) {
-	RygelMediaExportRootContainer * self;
-	self = RYGEL_MEDIA_EXPORT_ROOT_CONTAINER (obj);
-	_g_object_unref0 (self->priv->extractor);
-	_g_object_unref0 (self->priv->harvester);
-	_g_object_unref0 (self->priv->monitor);
-	_g_object_unref0 (self->priv->service);
-	_g_object_unref0 (self->priv->dynamic_elements);
-	G_OBJECT_CLASS (rygel_media_export_root_container_parent_class)->finalize (obj);
-}
-
-
-GType rygel_media_export_root_container_get_type (void) {
-	static GType rygel_media_export_root_container_type_id = 0;
-	if (rygel_media_export_root_container_type_id == 0) {
-		static const GTypeInfo g_define_type_info = { sizeof (RygelMediaExportRootContainerClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) rygel_media_export_root_container_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (RygelMediaExportRootContainer), 0, (GInstanceInitFunc) rygel_media_export_root_container_instance_init, NULL };
-		rygel_media_export_root_container_type_id = g_type_register_static (RYGEL_TYPE_MEDIA_DB_CONTAINER, "RygelMediaExportRootContainer", &g_define_type_info, 0);
-	}
-	return rygel_media_export_root_container_type_id;
-}
-
-
-static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
-	if ((array != NULL) && (destroy_func != NULL)) {
-		int i;
-		for (i = 0; i < array_length; i = i + 1) {
-			if (((gpointer*) array)[i] != NULL) {
-				destroy_func (((gpointer*) array)[i]);
-			}
-		}
-	}
-}
-
-
-static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
-	_vala_array_destroy (array, array_length, destroy_func);
-	g_free (array);
-}
-
-
-static int _vala_strcmp0 (const char * str1, const char * str2) {
-	if (str1 == NULL) {
-		return -(str1 != str2);
-	}
-	if (str2 == NULL) {
-		return str1 != str2;
-	}
-	return strcmp (str1, str2);
-}
-
-
-
-
--- a/src/plugins/mediathek/Makefile.in
+++ b/src/plugins/mediathek/Makefile.in
@@ -41,7 +41,8 @@ DIST_COMMON = $(srcdir)/Makefile.am $(sr
 	rygel-mediathek-root-container.c \
 	rygel-mediathek-rss-container.c rygel-mediathek-video-item.c
 ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
-am__aclocal_m4_deps = $(top_srcdir)/m4/libtool.m4 \
+am__aclocal_m4_deps = $(top_srcdir)/m4/glib-gettext.m4 \
+	$(top_srcdir)/m4/isc-posix.m4 $(top_srcdir)/m4/libtool.m4 \
 	$(top_srcdir)/m4/ltoptions.m4 $(top_srcdir)/m4/ltsugar.m4 \
 	$(top_srcdir)/m4/ltversion.m4 $(top_srcdir)/m4/lt~obsolete.m4 \
 	$(top_srcdir)/configure.ac
@@ -77,7 +78,7 @@ LTLIBRARIES = $(plugin_LTLIBRARIES)
 am__DEPENDENCIES_1 =
 librygel_mediathek_la_DEPENDENCIES = $(am__DEPENDENCIES_1) \
 	$(am__DEPENDENCIES_1) $(am__DEPENDENCIES_1) \
-	$(am__DEPENDENCIES_1) $(am__DEPENDENCIES_1)
+	$(am__DEPENDENCIES_1)
 am_librygel_mediathek_la_OBJECTS = rygel-mediathek-asx-playlist.lo \
 	rygel-mediathek-plugin.lo rygel-mediathek-video-item.lo \
 	rygel-mediathek-root-container.lo \
@@ -164,8 +165,6 @@ GMSGFMT = @GMSGFMT@
 GREP = @GREP@
 GTK_CFLAGS = @GTK_CFLAGS@
 GTK_LIBS = @GTK_LIBS@
-GUPNP_VALA_CFLAGS = @GUPNP_VALA_CFLAGS@
-GUPNP_VALA_LIBS = @GUPNP_VALA_LIBS@
 HAVE_GTK = @HAVE_GTK@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
@@ -180,8 +179,8 @@ LIBDBUS_GLIB_CFLAGS = @LIBDBUS_GLIB_CFLA
 LIBDBUS_GLIB_LIBS = @LIBDBUS_GLIB_LIBS@
 LIBGIO_CFLAGS = @LIBGIO_CFLAGS@
 LIBGIO_LIBS = @LIBGIO_LIBS@
-LIBGSTREAMER_CFLAGS = @LIBGSTREAMER_CFLAGS@
-LIBGSTREAMER_LIBS = @LIBGSTREAMER_LIBS@
+LIBGLIB_CFLAGS = @LIBGLIB_CFLAGS@
+LIBGLIB_LIBS = @LIBGLIB_LIBS@
 LIBGUPNP_AV_CFLAGS = @LIBGUPNP_AV_CFLAGS@
 LIBGUPNP_AV_LIBS = @LIBGUPNP_AV_LIBS@
 LIBGUPNP_CFLAGS = @LIBGUPNP_CFLAGS@
@@ -193,6 +192,8 @@ LIBSOUP_LIBS = @LIBSOUP_LIBS@
 LIBSQLITE3_CFLAGS = @LIBSQLITE3_CFLAGS@
 LIBSQLITE3_LIBS = @LIBSQLITE3_LIBS@
 LIBTOOL = @LIBTOOL@
+LIBVLC_CFLAGS = @LIBVLC_CFLAGS@
+LIBVLC_LIBS = @LIBVLC_LIBS@
 LIPO = @LIPO@
 LN_S = @LN_S@
 LTLIBOBJS = @LTLIBOBJS@
@@ -213,6 +214,7 @@ PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
 PACKAGE_NAME = @PACKAGE_NAME@
 PACKAGE_STRING = @PACKAGE_STRING@
 PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_URL = @PACKAGE_URL@
 PACKAGE_VERSION = @PACKAGE_VERSION@
 PATH_SEPARATOR = @PATH_SEPARATOR@
 PKG_CONFIG = @PKG_CONFIG@
@@ -226,8 +228,6 @@ SET_MAKE = @SET_MAKE@
 SHELL = @SHELL@
 STRIP = @STRIP@
 USE_NLS = @USE_NLS@
-UUID_CFLAGS = @UUID_CFLAGS@
-UUID_LIBS = @UUID_LIBS@
 VALAC = @VALAC@
 VAPIDIR = @VAPIDIR@
 VERSION = @VERSION@
--- a/src/plugins/mediathek/rygel-mediathek-asx-playlist.c
+++ /dev/null
@@ -1,274 +0,0 @@
-/* rygel-mediathek-asx-playlist.c generated by valac, the Vala compiler
- * generated from rygel-mediathek-asx-playlist.vala, do not modify */
-
-/*
- * Copyright (C) 2009 Jens Georg
- *
- * Author: Jens Georg <mail@jensge.org>
- *
- * This file is part of Rygel.
- *
- * Rygel is free software; you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * Rygel is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this program; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
- */
-
-#include <glib.h>
-#include <glib-object.h>
-#include <gee.h>
-#include <stdlib.h>
-#include <string.h>
-#include <libsoup/soup.h>
-#include <libxml/parser.h>
-#include <libxml/tree.h>
-#include <libxml/xpath.h>
-
-
-#define RYGEL_TYPE_MEDIATHEK_ASX_PLAYLIST (rygel_mediathek_asx_playlist_get_type ())
-#define RYGEL_MEDIATHEK_ASX_PLAYLIST(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_MEDIATHEK_ASX_PLAYLIST, RygelMediathekAsxPlaylist))
-#define RYGEL_MEDIATHEK_ASX_PLAYLIST_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_MEDIATHEK_ASX_PLAYLIST, RygelMediathekAsxPlaylistClass))
-#define RYGEL_IS_MEDIATHEK_ASX_PLAYLIST(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_MEDIATHEK_ASX_PLAYLIST))
-#define RYGEL_IS_MEDIATHEK_ASX_PLAYLIST_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_MEDIATHEK_ASX_PLAYLIST))
-#define RYGEL_MEDIATHEK_ASX_PLAYLIST_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_MEDIATHEK_ASX_PLAYLIST, RygelMediathekAsxPlaylistClass))
-
-typedef struct _RygelMediathekAsxPlaylist RygelMediathekAsxPlaylist;
-typedef struct _RygelMediathekAsxPlaylistClass RygelMediathekAsxPlaylistClass;
-typedef struct _RygelMediathekAsxPlaylistPrivate RygelMediathekAsxPlaylistPrivate;
-#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
-#define _g_free0(var) (var = (g_free (var), NULL))
-#define _g_regex_unref0(var) ((var == NULL) ? NULL : (var = (g_regex_unref (var), NULL)))
-#define _xmlXPathFreeContext0(var) ((var == NULL) ? NULL : (var = (xmlXPathFreeContext (var), NULL)))
-#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
-
-typedef enum  {
-	RYGEL_MEDIATHEK_ASX_PLAYLIST_ERROR_XML_ERROR,
-	RYGEL_MEDIATHEK_ASX_PLAYLIST_ERROR_NETWORK_ERROR
-} RygelMediathekAsxPlaylistError;
-#define RYGEL_MEDIATHEK_ASX_PLAYLIST_ERROR rygel_mediathek_asx_playlist_error_quark ()
-struct _RygelMediathekAsxPlaylist {
-	GObject parent_instance;
-	RygelMediathekAsxPlaylistPrivate * priv;
-	GeeArrayList* uris;
-};
-
-struct _RygelMediathekAsxPlaylistClass {
-	GObjectClass parent_class;
-};
-
-struct _RygelMediathekAsxPlaylistPrivate {
-	char* uri;
-};
-
-
-static gpointer rygel_mediathek_asx_playlist_parent_class = NULL;
-
-GQuark rygel_mediathek_asx_playlist_error_quark (void);
-GType rygel_mediathek_asx_playlist_get_type (void);
-#define RYGEL_MEDIATHEK_ASX_PLAYLIST_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), RYGEL_TYPE_MEDIATHEK_ASX_PLAYLIST, RygelMediathekAsxPlaylistPrivate))
-enum  {
-	RYGEL_MEDIATHEK_ASX_PLAYLIST_DUMMY_PROPERTY
-};
-RygelMediathekAsxPlaylist* rygel_mediathek_asx_playlist_new (const char* uri);
-RygelMediathekAsxPlaylist* rygel_mediathek_asx_playlist_construct (GType object_type, const char* uri);
-void rygel_mediathek_asx_playlist_parse (RygelMediathekAsxPlaylist* self, GError** error);
-static void rygel_mediathek_asx_playlist_finalize (GObject* obj);
-
-
-
-GQuark rygel_mediathek_asx_playlist_error_quark (void) {
-	return g_quark_from_static_string ("rygel_mediathek_asx_playlist_error-quark");
-}
-
-
-RygelMediathekAsxPlaylist* rygel_mediathek_asx_playlist_construct (GType object_type, const char* uri) {
-	RygelMediathekAsxPlaylist * self;
-	GeeArrayList* _tmp0_;
-	char* _tmp1_;
-	g_return_val_if_fail (uri != NULL, NULL);
-	self = (RygelMediathekAsxPlaylist*) g_object_new (object_type, NULL);
-	self->uris = (_tmp0_ = gee_array_list_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, g_direct_equal), _g_object_unref0 (self->uris), _tmp0_);
-	self->priv->uri = (_tmp1_ = g_strdup (uri), _g_free0 (self->priv->uri), _tmp1_);
-	return self;
-}
-
-
-RygelMediathekAsxPlaylist* rygel_mediathek_asx_playlist_new (const char* uri) {
-	return rygel_mediathek_asx_playlist_construct (RYGEL_TYPE_MEDIATHEK_ASX_PLAYLIST, uri);
-}
-
-
-static glong string_get_length (const char* self) {
-	glong result;
-	g_return_val_if_fail (self != NULL, 0L);
-	result = g_utf8_strlen (self, -1);
-	return result;
-}
-
-
-void rygel_mediathek_asx_playlist_parse (RygelMediathekAsxPlaylist* self, GError** error) {
-	GError * _inner_error_;
-	SoupSessionSync* session;
-	SoupMessage* message;
-	guint _tmp0_;
-	g_return_if_fail (self != NULL);
-	_inner_error_ = NULL;
-	session = (SoupSessionSync*) soup_session_sync_new ();
-	message = soup_message_new ("GET", self->priv->uri);
-	soup_session_send_message ((SoupSession*) session, message);
-	if ((g_object_get (message, "status-code", &_tmp0_, NULL), _tmp0_) == 200) {
-		{
-			GRegex* normalizer;
-			char* normalized_content;
-			xmlDoc* doc;
-			normalizer = g_regex_new ("(<[/]?)([a-zA-Z:]+)", 0, 0, &_inner_error_);
-			if (_inner_error_ != NULL) {
-				if (_inner_error_->domain == G_REGEX_ERROR) {
-					goto __catch0_g_regex_error;
-				}
-				goto __finally0;
-			}
-			normalized_content = g_regex_replace (normalizer, message->response_body->data, (glong) message->response_body->length, 0, "\\1\\L\\2\\E", 0, &_inner_error_);
-			if (_inner_error_ != NULL) {
-				_g_regex_unref0 (normalizer);
-				if (_inner_error_->domain == G_REGEX_ERROR) {
-					goto __catch0_g_regex_error;
-				}
-				goto __finally0;
-			}
-			doc = xmlParseMemory (normalized_content, (gint) string_get_length (normalized_content));
-			if (doc != NULL) {
-				xmlXPathContext* ctx;
-				xmlXPathObject* xpo;
-				ctx = xmlXPathNewContext (doc);
-				xpo = xmlXPathEval ("/asx/entry/ref/@href", ctx);
-				if (xpo->type == XPATH_NODESET) {
-					{
-						gint i;
-						i = 0;
-						{
-							gboolean _tmp1_;
-							_tmp1_ = TRUE;
-							while (TRUE) {
-								xmlNode* item;
-								if (!_tmp1_) {
-									i++;
-								}
-								_tmp1_ = FALSE;
-								if (!(i < xmlXPathNodeSetGetLength (xpo->nodesetval))) {
-									break;
-								}
-								item = xmlXPathNodeSetItem (xpo->nodesetval, i);
-								gee_abstract_collection_add ((GeeAbstractCollection*) self->uris, item->children->content);
-							}
-						}
-					}
-				}
-				_xmlXPathFreeContext0 (ctx);
-			} else {
-				_inner_error_ = g_error_new_literal (RYGEL_MEDIATHEK_ASX_PLAYLIST_ERROR, RYGEL_MEDIATHEK_ASX_PLAYLIST_ERROR_XML_ERROR, "Could not received XML");
-				if (_inner_error_ != NULL) {
-					_g_regex_unref0 (normalizer);
-					_g_free0 (normalized_content);
-					if (_inner_error_->domain == G_REGEX_ERROR) {
-						goto __catch0_g_regex_error;
-					}
-					goto __finally0;
-				}
-			}
-			_g_regex_unref0 (normalizer);
-			_g_free0 (normalized_content);
-		}
-		goto __finally0;
-		__catch0_g_regex_error:
-		{
-			GError * _error_;
-			_error_ = _inner_error_;
-			_inner_error_ = NULL;
-			{
-				_g_error_free0 (_error_);
-			}
-		}
-		__finally0:
-		if (_inner_error_ != NULL) {
-			if (_inner_error_->domain == RYGEL_MEDIATHEK_ASX_PLAYLIST_ERROR) {
-				g_propagate_error (error, _inner_error_);
-				_g_object_unref0 (session);
-				_g_object_unref0 (message);
-				return;
-			} else {
-				_g_object_unref0 (session);
-				_g_object_unref0 (message);
-				g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
-				g_clear_error (&_inner_error_);
-				return;
-			}
-		}
-	} else {
-		char* _tmp4_;
-		guint _tmp2_;
-		guint _tmp3_;
-		GError* _tmp5_;
-		_inner_error_ = (_tmp5_ = g_error_new_literal (RYGEL_MEDIATHEK_ASX_PLAYLIST_ERROR, RYGEL_MEDIATHEK_ASX_PLAYLIST_ERROR_NETWORK_ERROR, _tmp4_ = g_strdup_printf ("Could not download playlist, error code was %u (%s)", (g_object_get (message, "status-code", &_tmp2_, NULL), _tmp2_), soup_status_get_phrase ((g_object_get (message, "status-code", &_tmp3_, NULL), _tmp3_)))), _g_free0 (_tmp4_), _tmp5_);
-		if (_inner_error_ != NULL) {
-			if (_inner_error_->domain == RYGEL_MEDIATHEK_ASX_PLAYLIST_ERROR) {
-				g_propagate_error (error, _inner_error_);
-				_g_object_unref0 (session);
-				_g_object_unref0 (message);
-				return;
-			} else {
-				_g_object_unref0 (session);
-				_g_object_unref0 (message);
-				g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
-				g_clear_error (&_inner_error_);
-				return;
-			}
-		}
-	}
-	_g_object_unref0 (session);
-	_g_object_unref0 (message);
-}
-
-
-static void rygel_mediathek_asx_playlist_class_init (RygelMediathekAsxPlaylistClass * klass) {
-	rygel_mediathek_asx_playlist_parent_class = g_type_class_peek_parent (klass);
-	g_type_class_add_private (klass, sizeof (RygelMediathekAsxPlaylistPrivate));
-	G_OBJECT_CLASS (klass)->finalize = rygel_mediathek_asx_playlist_finalize;
-}
-
-
-static void rygel_mediathek_asx_playlist_instance_init (RygelMediathekAsxPlaylist * self) {
-	self->priv = RYGEL_MEDIATHEK_ASX_PLAYLIST_GET_PRIVATE (self);
-}
-
-
-static void rygel_mediathek_asx_playlist_finalize (GObject* obj) {
-	RygelMediathekAsxPlaylist * self;
-	self = RYGEL_MEDIATHEK_ASX_PLAYLIST (obj);
-	_g_object_unref0 (self->uris);
-	_g_free0 (self->priv->uri);
-	G_OBJECT_CLASS (rygel_mediathek_asx_playlist_parent_class)->finalize (obj);
-}
-
-
-GType rygel_mediathek_asx_playlist_get_type (void) {
-	static GType rygel_mediathek_asx_playlist_type_id = 0;
-	if (rygel_mediathek_asx_playlist_type_id == 0) {
-		static const GTypeInfo g_define_type_info = { sizeof (RygelMediathekAsxPlaylistClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) rygel_mediathek_asx_playlist_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (RygelMediathekAsxPlaylist), 0, (GInstanceInitFunc) rygel_mediathek_asx_playlist_instance_init, NULL };
-		rygel_mediathek_asx_playlist_type_id = g_type_register_static (G_TYPE_OBJECT, "RygelMediathekAsxPlaylist", &g_define_type_info, 0);
-	}
-	return rygel_mediathek_asx_playlist_type_id;
-}
-
-
-
-
--- a/src/plugins/mediathek/rygel-mediathek-plugin.c
+++ /dev/null
@@ -1,134 +0,0 @@
-/* rygel-mediathek-plugin.c generated by valac, the Vala compiler
- * generated from rygel-mediathek-plugin.vala, do not modify */
-
-/*
- * Copyright (C) 2009 Jens Georg
- *
- * Author: Jens Georg <mail@jensge.org>
- *
- * This file is part of Rygel.
- *
- * Rygel is free software; you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * Rygel is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this program; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
- */
-
-#include <glib.h>
-#include <glib-object.h>
-#include <rygel.h>
-
-
-#define RYGEL_TYPE_MEDIATHEK_CONTENT_DIR (rygel_mediathek_content_dir_get_type ())
-#define RYGEL_MEDIATHEK_CONTENT_DIR(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_MEDIATHEK_CONTENT_DIR, RygelMediathekContentDir))
-#define RYGEL_MEDIATHEK_CONTENT_DIR_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_MEDIATHEK_CONTENT_DIR, RygelMediathekContentDirClass))
-#define RYGEL_IS_MEDIATHEK_CONTENT_DIR(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_MEDIATHEK_CONTENT_DIR))
-#define RYGEL_IS_MEDIATHEK_CONTENT_DIR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_MEDIATHEK_CONTENT_DIR))
-#define RYGEL_MEDIATHEK_CONTENT_DIR_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_MEDIATHEK_CONTENT_DIR, RygelMediathekContentDirClass))
-
-typedef struct _RygelMediathekContentDir RygelMediathekContentDir;
-typedef struct _RygelMediathekContentDirClass RygelMediathekContentDirClass;
-#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
-#define _rygel_resource_info_unref0(var) ((var == NULL) ? NULL : (var = (rygel_resource_info_unref (var), NULL)))
-typedef struct _RygelMediathekContentDirPrivate RygelMediathekContentDirPrivate;
-
-#define RYGEL_TYPE_MEDIATHEK_ROOT_CONTAINER (rygel_mediathek_root_container_get_type ())
-#define RYGEL_MEDIATHEK_ROOT_CONTAINER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_MEDIATHEK_ROOT_CONTAINER, RygelMediathekRootContainer))
-#define RYGEL_MEDIATHEK_ROOT_CONTAINER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_MEDIATHEK_ROOT_CONTAINER, RygelMediathekRootContainerClass))
-#define RYGEL_IS_MEDIATHEK_ROOT_CONTAINER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_MEDIATHEK_ROOT_CONTAINER))
-#define RYGEL_IS_MEDIATHEK_ROOT_CONTAINER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_MEDIATHEK_ROOT_CONTAINER))
-#define RYGEL_MEDIATHEK_ROOT_CONTAINER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_MEDIATHEK_ROOT_CONTAINER, RygelMediathekRootContainerClass))
-
-typedef struct _RygelMediathekRootContainer RygelMediathekRootContainer;
-typedef struct _RygelMediathekRootContainerClass RygelMediathekRootContainerClass;
-
-struct _RygelMediathekContentDir {
-	RygelContentDirectory parent_instance;
-	RygelMediathekContentDirPrivate * priv;
-};
-
-struct _RygelMediathekContentDirClass {
-	RygelContentDirectoryClass parent_class;
-};
-
-
-static gpointer rygel_mediathek_content_dir_parent_class = NULL;
-
-GType rygel_mediathek_content_dir_get_type (void);
-void module_init (RygelPluginLoader* loader);
-enum  {
-	RYGEL_MEDIATHEK_CONTENT_DIR_DUMMY_PROPERTY
-};
-GType rygel_mediathek_root_container_get_type (void);
-RygelMediathekRootContainer* rygel_mediathek_root_container_get_instance (void);
-static RygelMediaContainer* rygel_mediathek_content_dir_real_create_root_container (RygelContentDirectory* base);
-RygelMediathekContentDir* rygel_mediathek_content_dir_new (void);
-RygelMediathekContentDir* rygel_mediathek_content_dir_construct (GType object_type);
-
-
-
-void module_init (RygelPluginLoader* loader) {
-	RygelPlugin* plugin;
-	RygelResourceInfo* resource_info;
-	g_return_if_fail (loader != NULL);
-	plugin = rygel_plugin_new_MediaServer ("ZDFMediathek", "ZDF Mediathek");
-	resource_info = rygel_resource_info_new (RYGEL_CONTENT_DIRECTORY_UPNP_ID, RYGEL_CONTENT_DIRECTORY_UPNP_TYPE, RYGEL_CONTENT_DIRECTORY_DESCRIPTION_PATH, RYGEL_TYPE_MEDIATHEK_CONTENT_DIR);
-	rygel_plugin_add_resource (plugin, resource_info);
-	rygel_plugin_loader_add_plugin (loader, plugin);
-	_g_object_unref0 (plugin);
-	_rygel_resource_info_unref0 (resource_info);
-}
-
-
-static RygelMediaContainer* rygel_mediathek_content_dir_real_create_root_container (RygelContentDirectory* base) {
-	RygelMediathekContentDir * self;
-	RygelMediaContainer* result;
-	self = (RygelMediathekContentDir*) base;
-	result = (RygelMediaContainer*) rygel_mediathek_root_container_get_instance ();
-	return result;
-}
-
-
-RygelMediathekContentDir* rygel_mediathek_content_dir_construct (GType object_type) {
-	RygelMediathekContentDir * self;
-	self = (RygelMediathekContentDir*) rygel_content_directory_construct (object_type);
-	return self;
-}
-
-
-RygelMediathekContentDir* rygel_mediathek_content_dir_new (void) {
-	return rygel_mediathek_content_dir_construct (RYGEL_TYPE_MEDIATHEK_CONTENT_DIR);
-}
-
-
-static void rygel_mediathek_content_dir_class_init (RygelMediathekContentDirClass * klass) {
-	rygel_mediathek_content_dir_parent_class = g_type_class_peek_parent (klass);
-	RYGEL_CONTENT_DIRECTORY_CLASS (klass)->create_root_container = rygel_mediathek_content_dir_real_create_root_container;
-}
-
-
-static void rygel_mediathek_content_dir_instance_init (RygelMediathekContentDir * self) {
-}
-
-
-GType rygel_mediathek_content_dir_get_type (void) {
-	static GType rygel_mediathek_content_dir_type_id = 0;
-	if (rygel_mediathek_content_dir_type_id == 0) {
-		static const GTypeInfo g_define_type_info = { sizeof (RygelMediathekContentDirClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) rygel_mediathek_content_dir_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (RygelMediathekContentDir), 0, (GInstanceInitFunc) rygel_mediathek_content_dir_instance_init, NULL };
-		rygel_mediathek_content_dir_type_id = g_type_register_static (RYGEL_TYPE_CONTENT_DIRECTORY, "RygelMediathekContentDir", &g_define_type_info, 0);
-	}
-	return rygel_mediathek_content_dir_type_id;
-}
-
-
-
-
--- a/src/plugins/mediathek/rygel-mediathek-root-container.c
+++ /dev/null
@@ -1,233 +0,0 @@
-/* rygel-mediathek-root-container.c generated by valac, the Vala compiler
- * generated from rygel-mediathek-root-container.vala, do not modify */
-
-/*
- * Copyright (C) 2009 Jens Georg
- *
- * Author: Jens Georg <mail@jensge.org>
- *
- * This file is part of Rygel.
- *
- * Rygel is free software; you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * Rygel is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this program; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
- */
-
-#include <glib.h>
-#include <glib-object.h>
-#include <rygel.h>
-#include <libsoup/soup.h>
-#include <gee.h>
-
-
-#define RYGEL_TYPE_MEDIATHEK_ROOT_CONTAINER (rygel_mediathek_root_container_get_type ())
-#define RYGEL_MEDIATHEK_ROOT_CONTAINER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_MEDIATHEK_ROOT_CONTAINER, RygelMediathekRootContainer))
-#define RYGEL_MEDIATHEK_ROOT_CONTAINER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_MEDIATHEK_ROOT_CONTAINER, RygelMediathekRootContainerClass))
-#define RYGEL_IS_MEDIATHEK_ROOT_CONTAINER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_MEDIATHEK_ROOT_CONTAINER))
-#define RYGEL_IS_MEDIATHEK_ROOT_CONTAINER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_MEDIATHEK_ROOT_CONTAINER))
-#define RYGEL_MEDIATHEK_ROOT_CONTAINER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_MEDIATHEK_ROOT_CONTAINER, RygelMediathekRootContainerClass))
-
-typedef struct _RygelMediathekRootContainer RygelMediathekRootContainer;
-typedef struct _RygelMediathekRootContainerClass RygelMediathekRootContainerClass;
-typedef struct _RygelMediathekRootContainerPrivate RygelMediathekRootContainerPrivate;
-#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
-
-#define RYGEL_TYPE_MEDIATHEK_RSS_CONTAINER (rygel_mediathek_rss_container_get_type ())
-#define RYGEL_MEDIATHEK_RSS_CONTAINER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_MEDIATHEK_RSS_CONTAINER, RygelMediathekRssContainer))
-#define RYGEL_MEDIATHEK_RSS_CONTAINER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_MEDIATHEK_RSS_CONTAINER, RygelMediathekRssContainerClass))
-#define RYGEL_IS_MEDIATHEK_RSS_CONTAINER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_MEDIATHEK_RSS_CONTAINER))
-#define RYGEL_IS_MEDIATHEK_RSS_CONTAINER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_MEDIATHEK_RSS_CONTAINER))
-#define RYGEL_MEDIATHEK_RSS_CONTAINER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_MEDIATHEK_RSS_CONTAINER, RygelMediathekRssContainerClass))
-
-typedef struct _RygelMediathekRssContainer RygelMediathekRssContainer;
-typedef struct _RygelMediathekRssContainerClass RygelMediathekRssContainerClass;
-#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
-
-struct _RygelMediathekRootContainer {
-	RygelSimpleContainer parent_instance;
-	RygelMediathekRootContainerPrivate * priv;
-	SoupSessionAsync* session;
-};
-
-struct _RygelMediathekRootContainerClass {
-	RygelSimpleContainerClass parent_class;
-};
-
-
-static RygelMediathekRootContainer* rygel_mediathek_root_container_instance;
-static RygelMediathekRootContainer* rygel_mediathek_root_container_instance = NULL;
-static gpointer rygel_mediathek_root_container_parent_class = NULL;
-
-GType rygel_mediathek_root_container_get_type (void);
-enum  {
-	RYGEL_MEDIATHEK_ROOT_CONTAINER_DUMMY_PROPERTY
-};
-GType rygel_mediathek_rss_container_get_type (void);
-void rygel_mediathek_rss_container_update (RygelMediathekRssContainer* self);
-static gboolean rygel_mediathek_root_container_on_schedule_update (RygelMediathekRootContainer* self);
-static RygelMediathekRootContainer* rygel_mediathek_root_container_new (void);
-static RygelMediathekRootContainer* rygel_mediathek_root_container_construct (GType object_type);
-RygelMediathekRootContainer* rygel_mediathek_root_container_get_instance (void);
-RygelMediathekRssContainer* rygel_mediathek_rss_container_new (RygelMediaContainer* parent, guint id);
-RygelMediathekRssContainer* rygel_mediathek_rss_container_construct (GType object_type, RygelMediaContainer* parent, guint id);
-static gboolean _rygel_mediathek_root_container_on_schedule_update_gsource_func (gpointer self);
-static void rygel_mediathek_root_container_finalize (GObject* obj);
-
-
-
-static gboolean rygel_mediathek_root_container_on_schedule_update (RygelMediathekRootContainer* self) {
-	gboolean result;
-	g_return_val_if_fail (self != NULL, FALSE);
-	g_message ("rygel-mediathek-root-container.vala:31: Scheduling update for all feeds....");
-	{
-		GeeIterator* _container_it;
-		_container_it = gee_abstract_collection_iterator ((GeeAbstractCollection*) ((RygelSimpleContainer*) self)->children);
-		while (TRUE) {
-			RygelMediaObject* container;
-			if (!gee_iterator_next (_container_it)) {
-				break;
-			}
-			container = (RygelMediaObject*) gee_iterator_get (_container_it);
-			rygel_mediathek_rss_container_update (RYGEL_MEDIATHEK_RSS_CONTAINER (container));
-			_g_object_unref0 (container);
-		}
-		_g_object_unref0 (_container_it);
-	}
-	result = TRUE;
-	return result;
-}
-
-
-static gpointer _g_object_ref0 (gpointer self) {
-	return self ? g_object_ref (self) : NULL;
-}
-
-
-RygelMediathekRootContainer* rygel_mediathek_root_container_get_instance (void) {
-	RygelMediathekRootContainer* result;
-	if (rygel_mediathek_root_container_instance == NULL) {
-		RygelMediathekRootContainer* _tmp0_;
-		rygel_mediathek_root_container_instance = (_tmp0_ = rygel_mediathek_root_container_new (), _g_object_unref0 (rygel_mediathek_root_container_instance), _tmp0_);
-	}
-	result = _g_object_ref0 (rygel_mediathek_root_container_instance);
-	return result;
-}
-
-
-static gboolean _rygel_mediathek_root_container_on_schedule_update_gsource_func (gpointer self) {
-	return rygel_mediathek_root_container_on_schedule_update (self);
-}
-
-
-static RygelMediathekRootContainer* rygel_mediathek_root_container_construct (GType object_type) {
-	GError * _inner_error_;
-	RygelMediathekRootContainer * self;
-	SoupSessionAsync* _tmp0_;
-	GeeArrayList* feeds;
-	RygelMetaConfig* config;
-	_inner_error_ = NULL;
-	self = (RygelMediathekRootContainer*) rygel_simple_container_construct_root (object_type, "ZDF Mediathek");
-	self->session = (_tmp0_ = (SoupSessionAsync*) soup_session_async_new (), _g_object_unref0 (self->session), _tmp0_);
-	feeds = NULL;
-	config = rygel_meta_config_get_default ();
-	{
-		GeeArrayList* _tmp1_;
-		GeeArrayList* _tmp2_;
-		_tmp1_ = rygel_configuration_get_int_list ((RygelConfiguration*) config, "ZDFMediathek", "rss", &_inner_error_);
-		if (_inner_error_ != NULL) {
-			goto __catch2_g_error;
-			goto __finally2;
-		}
-		feeds = (_tmp2_ = _tmp1_, _g_object_unref0 (feeds), _tmp2_);
-	}
-	goto __finally2;
-	__catch2_g_error:
-	{
-		GError * _error_;
-		_error_ = _inner_error_;
-		_inner_error_ = NULL;
-		{
-			GeeArrayList* _tmp3_;
-			feeds = (_tmp3_ = gee_array_list_new (G_TYPE_INT, NULL, NULL, g_direct_equal), _g_object_unref0 (feeds), _tmp3_);
-			_g_error_free0 (_error_);
-		}
-	}
-	__finally2:
-	if (_inner_error_ != NULL) {
-		_g_object_unref0 (feeds);
-		_g_object_unref0 (config);
-		g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
-		g_clear_error (&_inner_error_);
-		return NULL;
-	}
-	if (gee_collection_get_size ((GeeCollection*) feeds) == 0) {
-		g_message ("rygel-mediathek-root-container.vala:60: Could not get RSS items from GConf, using defaults");
-		gee_abstract_collection_add ((GeeAbstractCollection*) feeds, GINT_TO_POINTER (508));
-	}
-	{
-		GeeIterator* _id_it;
-		_id_it = gee_abstract_collection_iterator ((GeeAbstractCollection*) feeds);
-		while (TRUE) {
-			gint id;
-			RygelMediathekRssContainer* _tmp4_;
-			if (!gee_iterator_next (_id_it)) {
-				break;
-			}
-			id = GPOINTER_TO_INT (gee_iterator_get (_id_it));
-			rygel_simple_container_add_child ((RygelSimpleContainer*) self, (RygelMediaObject*) (_tmp4_ = rygel_mediathek_rss_container_new ((RygelMediaContainer*) self, (guint) id)));
-			_g_object_unref0 (_tmp4_);
-		}
-		_g_object_unref0 (_id_it);
-	}
-	g_timeout_add_seconds_full (G_PRIORITY_DEFAULT, (guint) 1800, _rygel_mediathek_root_container_on_schedule_update_gsource_func, g_object_ref (self), g_object_unref);
-	_g_object_unref0 (feeds);
-	_g_object_unref0 (config);
-	return self;
-}
-
-
-static RygelMediathekRootContainer* rygel_mediathek_root_container_new (void) {
-	return rygel_mediathek_root_container_construct (RYGEL_TYPE_MEDIATHEK_ROOT_CONTAINER);
-}
-
-
-static void rygel_mediathek_root_container_class_init (RygelMediathekRootContainerClass * klass) {
-	rygel_mediathek_root_container_parent_class = g_type_class_peek_parent (klass);
-	G_OBJECT_CLASS (klass)->finalize = rygel_mediathek_root_container_finalize;
-}
-
-
-static void rygel_mediathek_root_container_instance_init (RygelMediathekRootContainer * self) {
-}
-
-
-static void rygel_mediathek_root_container_finalize (GObject* obj) {
-	RygelMediathekRootContainer * self;
-	self = RYGEL_MEDIATHEK_ROOT_CONTAINER (obj);
-	_g_object_unref0 (self->session);
-	G_OBJECT_CLASS (rygel_mediathek_root_container_parent_class)->finalize (obj);
-}
-
-
-GType rygel_mediathek_root_container_get_type (void) {
-	static GType rygel_mediathek_root_container_type_id = 0;
-	if (rygel_mediathek_root_container_type_id == 0) {
-		static const GTypeInfo g_define_type_info = { sizeof (RygelMediathekRootContainerClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) rygel_mediathek_root_container_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (RygelMediathekRootContainer), 0, (GInstanceInitFunc) rygel_mediathek_root_container_instance_init, NULL };
-		rygel_mediathek_root_container_type_id = g_type_register_static (RYGEL_TYPE_SIMPLE_CONTAINER, "RygelMediathekRootContainer", &g_define_type_info, 0);
-	}
-	return rygel_mediathek_root_container_type_id;
-}
-
-
-
-
--- a/src/plugins/mediathek/rygel-mediathek-rss-container.c
+++ /dev/null
@@ -1,324 +0,0 @@
-/* rygel-mediathek-rss-container.c generated by valac, the Vala compiler
- * generated from rygel-mediathek-rss-container.vala, do not modify */
-
-/*
- * Copyright (C) 2009 Jens Georg
- *
- * Author: Jens Georg <mail@jensge.org>
- *
- * This file is part of Rygel.
- *
- * Rygel is free software; you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * Rygel is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this program; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
- */
-
-#include <glib.h>
-#include <glib-object.h>
-#include <rygel.h>
-#include <libsoup/soup.h>
-#include <stdlib.h>
-#include <string.h>
-#include <libxml/parser.h>
-#include <libxml/tree.h>
-#include <gee.h>
-#include <libxml/xpath.h>
-
-
-#define RYGEL_TYPE_MEDIATHEK_RSS_CONTAINER (rygel_mediathek_rss_container_get_type ())
-#define RYGEL_MEDIATHEK_RSS_CONTAINER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_MEDIATHEK_RSS_CONTAINER, RygelMediathekRssContainer))
-#define RYGEL_MEDIATHEK_RSS_CONTAINER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_MEDIATHEK_RSS_CONTAINER, RygelMediathekRssContainerClass))
-#define RYGEL_IS_MEDIATHEK_RSS_CONTAINER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_MEDIATHEK_RSS_CONTAINER))
-#define RYGEL_IS_MEDIATHEK_RSS_CONTAINER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_MEDIATHEK_RSS_CONTAINER))
-#define RYGEL_MEDIATHEK_RSS_CONTAINER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_MEDIATHEK_RSS_CONTAINER, RygelMediathekRssContainerClass))
-
-typedef struct _RygelMediathekRssContainer RygelMediathekRssContainer;
-typedef struct _RygelMediathekRssContainerClass RygelMediathekRssContainerClass;
-typedef struct _RygelMediathekRssContainerPrivate RygelMediathekRssContainerPrivate;
-#define _soup_date_free0(var) ((var == NULL) ? NULL : (var = (soup_date_free (var), NULL)))
-#define _g_free0(var) (var = (g_free (var), NULL))
-
-#define RYGEL_TYPE_MEDIATHEK_VIDEO_ITEM (rygel_mediathek_video_item_get_type ())
-#define RYGEL_MEDIATHEK_VIDEO_ITEM(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_MEDIATHEK_VIDEO_ITEM, RygelMediathekVideoItem))
-#define RYGEL_MEDIATHEK_VIDEO_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_MEDIATHEK_VIDEO_ITEM, RygelMediathekVideoItemClass))
-#define RYGEL_IS_MEDIATHEK_VIDEO_ITEM(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_MEDIATHEK_VIDEO_ITEM))
-#define RYGEL_IS_MEDIATHEK_VIDEO_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_MEDIATHEK_VIDEO_ITEM))
-#define RYGEL_MEDIATHEK_VIDEO_ITEM_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_MEDIATHEK_VIDEO_ITEM, RygelMediathekVideoItemClass))
-
-typedef struct _RygelMediathekVideoItem RygelMediathekVideoItem;
-typedef struct _RygelMediathekVideoItemClass RygelMediathekVideoItemClass;
-#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
-#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
-#define _xmlXPathFreeContext0(var) ((var == NULL) ? NULL : (var = (xmlXPathFreeContext (var), NULL)))
-
-#define RYGEL_TYPE_MEDIATHEK_ROOT_CONTAINER (rygel_mediathek_root_container_get_type ())
-#define RYGEL_MEDIATHEK_ROOT_CONTAINER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_MEDIATHEK_ROOT_CONTAINER, RygelMediathekRootContainer))
-#define RYGEL_MEDIATHEK_ROOT_CONTAINER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_MEDIATHEK_ROOT_CONTAINER, RygelMediathekRootContainerClass))
-#define RYGEL_IS_MEDIATHEK_ROOT_CONTAINER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_MEDIATHEK_ROOT_CONTAINER))
-#define RYGEL_IS_MEDIATHEK_ROOT_CONTAINER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_MEDIATHEK_ROOT_CONTAINER))
-#define RYGEL_MEDIATHEK_ROOT_CONTAINER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_MEDIATHEK_ROOT_CONTAINER, RygelMediathekRootContainerClass))
-
-typedef struct _RygelMediathekRootContainer RygelMediathekRootContainer;
-typedef struct _RygelMediathekRootContainerClass RygelMediathekRootContainerClass;
-typedef struct _RygelMediathekRootContainerPrivate RygelMediathekRootContainerPrivate;
-
-struct _RygelMediathekRssContainer {
-	RygelSimpleContainer parent_instance;
-	RygelMediathekRssContainerPrivate * priv;
-};
-
-struct _RygelMediathekRssContainerClass {
-	RygelSimpleContainerClass parent_class;
-};
-
-struct _RygelMediathekRssContainerPrivate {
-	guint zdf_content_id;
-	SoupDate* last_modified;
-};
-
-typedef enum  {
-	RYGEL_MEDIATHEK_VIDEO_ITEM_ERROR_XML_PARSE_ERROR
-} RygelMediathekVideoItemError;
-#define RYGEL_MEDIATHEK_VIDEO_ITEM_ERROR rygel_mediathek_video_item_error_quark ()
-struct _RygelMediathekRootContainer {
-	RygelSimpleContainer parent_instance;
-	RygelMediathekRootContainerPrivate * priv;
-	SoupSessionAsync* session;
-};
-
-struct _RygelMediathekRootContainerClass {
-	RygelSimpleContainerClass parent_class;
-};
-
-
-static gpointer rygel_mediathek_rss_container_parent_class = NULL;
-
-GType rygel_mediathek_rss_container_get_type (void);
-#define RYGEL_MEDIATHEK_RSS_CONTAINER_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), RYGEL_TYPE_MEDIATHEK_RSS_CONTAINER, RygelMediathekRssContainerPrivate))
-enum  {
-	RYGEL_MEDIATHEK_RSS_CONTAINER_DUMMY_PROPERTY
-};
-static gboolean rygel_mediathek_rss_container_parse_response (RygelMediathekRssContainer* self, const char* data, gsize length);
-static void rygel_mediathek_rss_container_on_feed_got (RygelMediathekRssContainer* self, SoupSession* session, SoupMessage* msg);
-GType rygel_mediathek_video_item_get_type (void);
-GQuark rygel_mediathek_video_item_error_quark (void);
-RygelMediathekVideoItem* rygel_mediathek_video_item_create_from_xml (RygelMediaContainer* parent, xmlNode* item, GError** error);
-GType rygel_mediathek_root_container_get_type (void);
-static void _rygel_mediathek_rss_container_on_feed_got_soup_session_callback (SoupSession* session, SoupMessage* msg, gpointer self);
-void rygel_mediathek_rss_container_update (RygelMediathekRssContainer* self);
-RygelMediathekRssContainer* rygel_mediathek_rss_container_new (RygelMediaContainer* parent, guint id);
-RygelMediathekRssContainer* rygel_mediathek_rss_container_construct (GType object_type, RygelMediaContainer* parent, guint id);
-static void rygel_mediathek_rss_container_finalize (GObject* obj);
-
-
-
-static void rygel_mediathek_rss_container_on_feed_got (RygelMediathekRssContainer* self, SoupSession* session, SoupMessage* msg) {
-	guint _tmp0_;
-	g_return_if_fail (self != NULL);
-	g_return_if_fail (session != NULL);
-	g_return_if_fail (msg != NULL);
-	switch ((g_object_get (msg, "status-code", &_tmp0_, NULL), _tmp0_)) {
-		case 304:
-		{
-			g_message ("rygel-mediathek-rss-container.vala:34: Feed has not changed, nothing to do");
-			break;
-		}
-		case 200:
-		{
-			if (rygel_mediathek_rss_container_parse_response (self, msg->response_body->data, (gsize) msg->response_body->length)) {
-				SoupDate* _tmp1_;
-				self->priv->last_modified = (_tmp1_ = soup_date_new_from_string (soup_message_headers_get (msg->response_headers, "Date")), _soup_date_free0 (self->priv->last_modified), _tmp1_);
-			}
-			break;
-		}
-		default:
-		{
-			guint _tmp2_;
-			guint _tmp3_;
-			g_warning ("rygel-mediathek-rss-container.vala:45: Got unexpected response %u (%s)", (g_object_get (msg, "status-code", &_tmp2_, NULL), _tmp2_), soup_status_get_phrase ((g_object_get (msg, "status-code", &_tmp3_, NULL), _tmp3_)));
-			break;
-		}
-	}
-}
-
-
-static gboolean rygel_mediathek_rss_container_parse_response (RygelMediathekRssContainer* self, const char* data, gsize length) {
-	gboolean result;
-	GError * _inner_error_;
-	gboolean ret;
-	xmlDoc* doc;
-	g_return_val_if_fail (self != NULL, FALSE);
-	g_return_val_if_fail (data != NULL, FALSE);
-	_inner_error_ = NULL;
-	ret = FALSE;
-	doc = xmlParseMemory (data, (gint) length);
-	if (doc != NULL) {
-		xmlXPathContext* ctx;
-		xmlXPathObject* xpo;
-		gboolean _tmp0_ = FALSE;
-		gee_abstract_collection_clear ((GeeAbstractCollection*) ((RygelSimpleContainer*) self)->children);
-		((RygelMediaContainer*) self)->child_count = (guint) 0;
-		ctx = xmlXPathNewContext (doc);
-		xpo = xmlXPathEval ("/rss/channel/title", ctx);
-		if (xpo->type == XPATH_NODESET) {
-			_tmp0_ = xmlXPathNodeSetGetLength (xpo->nodesetval) > 0;
-		} else {
-			_tmp0_ = FALSE;
-		}
-		if (_tmp0_) {
-			char* _tmp1_;
-			((RygelMediaObject*) self)->title = (_tmp1_ = xmlNodeGetContent (xmlXPathNodeSetItem (xpo->nodesetval, 0)), _g_free0 (((RygelMediaObject*) self)->title), _tmp1_);
-		}
-		xpo = xmlXPathEval ("/rss/channel/item", ctx);
-		if (xpo->type == XPATH_NODESET) {
-			{
-				gint i;
-				i = 0;
-				{
-					gboolean _tmp2_;
-					_tmp2_ = TRUE;
-					while (TRUE) {
-						xmlNode* node;
-						if (!_tmp2_) {
-							i++;
-						}
-						_tmp2_ = FALSE;
-						if (!(i < xmlXPathNodeSetGetLength (xpo->nodesetval))) {
-							break;
-						}
-						node = xmlXPathNodeSetItem (xpo->nodesetval, i);
-						{
-							RygelMediathekVideoItem* item;
-							item = rygel_mediathek_video_item_create_from_xml ((RygelMediaContainer*) self, node, &_inner_error_);
-							if (_inner_error_ != NULL) {
-								if (_inner_error_->domain == RYGEL_MEDIATHEK_VIDEO_ITEM_ERROR) {
-									goto __catch3_rygel_mediathek_video_item_error;
-								}
-								goto __finally3;
-							}
-							rygel_simple_container_add_child ((RygelSimpleContainer*) self, (RygelMediaObject*) item);
-							ret = TRUE;
-							_g_object_unref0 (item);
-						}
-						goto __finally3;
-						__catch3_rygel_mediathek_video_item_error:
-						{
-							GError * _error_;
-							_error_ = _inner_error_;
-							_inner_error_ = NULL;
-							{
-								g_warning ("rygel-mediathek-rss-container.vala:79: Error creating video item: %s", _error_->message);
-								_g_error_free0 (_error_);
-							}
-						}
-						__finally3:
-						if (_inner_error_ != NULL) {
-							_xmlXPathFreeContext0 (ctx);
-							g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
-							g_clear_error (&_inner_error_);
-							return FALSE;
-						}
-					}
-				}
-			}
-		} else {
-			g_warning ("rygel-mediathek-rss-container.vala:85: XPath query failed");
-		}
-		xmlFreeDoc (doc);
-		rygel_media_container_updated ((RygelMediaContainer*) self);
-		_xmlXPathFreeContext0 (ctx);
-	} else {
-		g_warning ("rygel-mediathek-rss-container.vala:92: Failed to parse doc");
-	}
-	result = ret;
-	return result;
-}
-
-
-static gpointer _g_object_ref0 (gpointer self) {
-	return self ? g_object_ref (self) : NULL;
-}
-
-
-static void _rygel_mediathek_rss_container_on_feed_got_soup_session_callback (SoupSession* session, SoupMessage* msg, gpointer self) {
-	rygel_mediathek_rss_container_on_feed_got (self, session, msg);
-}
-
-
-void rygel_mediathek_rss_container_update (RygelMediathekRssContainer* self) {
-	char* _tmp0_;
-	SoupMessage* _tmp1_;
-	SoupMessage* message;
-	g_return_if_fail (self != NULL);
-	message = (_tmp1_ = soup_message_new ("GET", _tmp0_ = g_strdup_printf ("http://www.zdf.de/ZDFmediathek/content/%u?view=rss", self->priv->zdf_content_id)), _g_free0 (_tmp0_), _tmp1_);
-	if (self->priv->last_modified != NULL) {
-		g_debug ("rygel-mediathek-rss-container.vala:103: Requesting change since %s", soup_date_to_string (self->priv->last_modified, SOUP_DATE_HTTP));
-		soup_message_headers_append (message->request_headers, "If-Modified-Since", soup_date_to_string (self->priv->last_modified, SOUP_DATE_HTTP));
-	}
-	soup_session_queue_message ((SoupSession*) RYGEL_MEDIATHEK_ROOT_CONTAINER (((RygelMediaObject*) self)->parent)->session, _g_object_ref0 (message), _rygel_mediathek_rss_container_on_feed_got_soup_session_callback, self);
-	_g_object_unref0 (message);
-}
-
-
-RygelMediathekRssContainer* rygel_mediathek_rss_container_construct (GType object_type, RygelMediaContainer* parent, guint id) {
-	RygelMediathekRssContainer * self;
-	char* _tmp1_;
-	char* _tmp0_;
-	g_return_val_if_fail (parent != NULL, NULL);
-	self = (RygelMediathekRssContainer*) rygel_simple_container_construct (object_type, _tmp0_ = g_strdup_printf ("GroupId:%u", id), parent, _tmp1_ = g_strdup_printf ("ZDF Mediathek RSS feed %u", id));
-	_g_free0 (_tmp1_);
-	_g_free0 (_tmp0_);
-	self->priv->zdf_content_id = id;
-	rygel_mediathek_rss_container_update (self);
-	return self;
-}
-
-
-RygelMediathekRssContainer* rygel_mediathek_rss_container_new (RygelMediaContainer* parent, guint id) {
-	return rygel_mediathek_rss_container_construct (RYGEL_TYPE_MEDIATHEK_RSS_CONTAINER, parent, id);
-}
-
-
-static void rygel_mediathek_rss_container_class_init (RygelMediathekRssContainerClass * klass) {
-	rygel_mediathek_rss_container_parent_class = g_type_class_peek_parent (klass);
-	g_type_class_add_private (klass, sizeof (RygelMediathekRssContainerPrivate));
-	G_OBJECT_CLASS (klass)->finalize = rygel_mediathek_rss_container_finalize;
-}
-
-
-static void rygel_mediathek_rss_container_instance_init (RygelMediathekRssContainer * self) {
-	self->priv = RYGEL_MEDIATHEK_RSS_CONTAINER_GET_PRIVATE (self);
-	self->priv->last_modified = NULL;
-}
-
-
-static void rygel_mediathek_rss_container_finalize (GObject* obj) {
-	RygelMediathekRssContainer * self;
-	self = RYGEL_MEDIATHEK_RSS_CONTAINER (obj);
-	_soup_date_free0 (self->priv->last_modified);
-	G_OBJECT_CLASS (rygel_mediathek_rss_container_parent_class)->finalize (obj);
-}
-
-
-GType rygel_mediathek_rss_container_get_type (void) {
-	static GType rygel_mediathek_rss_container_type_id = 0;
-	if (rygel_mediathek_rss_container_type_id == 0) {
-		static const GTypeInfo g_define_type_info = { sizeof (RygelMediathekRssContainerClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) rygel_mediathek_rss_container_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (RygelMediathekRssContainer), 0, (GInstanceInitFunc) rygel_mediathek_rss_container_instance_init, NULL };
-		rygel_mediathek_rss_container_type_id = g_type_register_static (RYGEL_TYPE_SIMPLE_CONTAINER, "RygelMediathekRssContainer", &g_define_type_info, 0);
-	}
-	return rygel_mediathek_rss_container_type_id;
-}
-
-
-
-
--- a/src/plugins/mediathek/rygel-mediathek-video-item.c
+++ /dev/null
@@ -1,433 +0,0 @@
-/* rygel-mediathek-video-item.c generated by valac, the Vala compiler
- * generated from rygel-mediathek-video-item.vala, do not modify */
-
-/*
- * Copyright (C) 2009 Jens Georg
- *
- * Author: Jens Georg <mail@jensge.org>
- *
- * This file is part of Rygel.
- *
- * Rygel is free software; you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * Rygel is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this program; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
- */
-
-#include <glib.h>
-#include <glib-object.h>
-#include <rygel.h>
-#include <stdlib.h>
-#include <string.h>
-#include <libxml/tree.h>
-#include <gee.h>
-
-
-#define RYGEL_TYPE_MEDIATHEK_VIDEO_ITEM (rygel_mediathek_video_item_get_type ())
-#define RYGEL_MEDIATHEK_VIDEO_ITEM(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_MEDIATHEK_VIDEO_ITEM, RygelMediathekVideoItem))
-#define RYGEL_MEDIATHEK_VIDEO_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_MEDIATHEK_VIDEO_ITEM, RygelMediathekVideoItemClass))
-#define RYGEL_IS_MEDIATHEK_VIDEO_ITEM(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_MEDIATHEK_VIDEO_ITEM))
-#define RYGEL_IS_MEDIATHEK_VIDEO_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_MEDIATHEK_VIDEO_ITEM))
-#define RYGEL_MEDIATHEK_VIDEO_ITEM_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_MEDIATHEK_VIDEO_ITEM, RygelMediathekVideoItemClass))
-
-typedef struct _RygelMediathekVideoItem RygelMediathekVideoItem;
-typedef struct _RygelMediathekVideoItemClass RygelMediathekVideoItemClass;
-typedef struct _RygelMediathekVideoItemPrivate RygelMediathekVideoItemPrivate;
-#define _g_free0(var) (var = (g_free (var), NULL))
-
-#define RYGEL_TYPE_MEDIATHEK_ASX_PLAYLIST (rygel_mediathek_asx_playlist_get_type ())
-#define RYGEL_MEDIATHEK_ASX_PLAYLIST(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_MEDIATHEK_ASX_PLAYLIST, RygelMediathekAsxPlaylist))
-#define RYGEL_MEDIATHEK_ASX_PLAYLIST_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_MEDIATHEK_ASX_PLAYLIST, RygelMediathekAsxPlaylistClass))
-#define RYGEL_IS_MEDIATHEK_ASX_PLAYLIST(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_MEDIATHEK_ASX_PLAYLIST))
-#define RYGEL_IS_MEDIATHEK_ASX_PLAYLIST_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_MEDIATHEK_ASX_PLAYLIST))
-#define RYGEL_MEDIATHEK_ASX_PLAYLIST_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_MEDIATHEK_ASX_PLAYLIST, RygelMediathekAsxPlaylistClass))
-
-typedef struct _RygelMediathekAsxPlaylist RygelMediathekAsxPlaylist;
-typedef struct _RygelMediathekAsxPlaylistClass RygelMediathekAsxPlaylistClass;
-#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
-#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
-typedef struct _RygelMediathekAsxPlaylistPrivate RygelMediathekAsxPlaylistPrivate;
-
-typedef enum  {
-	RYGEL_MEDIATHEK_VIDEO_ITEM_ERROR_XML_PARSE_ERROR
-} RygelMediathekVideoItemError;
-#define RYGEL_MEDIATHEK_VIDEO_ITEM_ERROR rygel_mediathek_video_item_error_quark ()
-struct _RygelMediathekVideoItem {
-	RygelMediaItem parent_instance;
-	RygelMediathekVideoItemPrivate * priv;
-};
-
-struct _RygelMediathekVideoItemClass {
-	RygelMediaItemClass parent_class;
-};
-
-typedef enum  {
-	RYGEL_MEDIATHEK_ASX_PLAYLIST_ERROR_XML_ERROR,
-	RYGEL_MEDIATHEK_ASX_PLAYLIST_ERROR_NETWORK_ERROR
-} RygelMediathekAsxPlaylistError;
-#define RYGEL_MEDIATHEK_ASX_PLAYLIST_ERROR rygel_mediathek_asx_playlist_error_quark ()
-struct _RygelMediathekAsxPlaylist {
-	GObject parent_instance;
-	RygelMediathekAsxPlaylistPrivate * priv;
-	GeeArrayList* uris;
-};
-
-struct _RygelMediathekAsxPlaylistClass {
-	GObjectClass parent_class;
-};
-
-
-static gpointer rygel_mediathek_video_item_parent_class = NULL;
-
-GQuark rygel_mediathek_video_item_error_quark (void);
-GType rygel_mediathek_video_item_get_type (void);
-enum  {
-	RYGEL_MEDIATHEK_VIDEO_ITEM_DUMMY_PROPERTY
-};
-static RygelMediathekVideoItem* rygel_mediathek_video_item_new (RygelMediaContainer* parent, const char* title);
-static RygelMediathekVideoItem* rygel_mediathek_video_item_construct (GType object_type, RygelMediaContainer* parent, const char* title);
-static gboolean rygel_mediathek_video_item_namespace_ok (xmlNode* node);
-GType rygel_mediathek_asx_playlist_get_type (void);
-RygelMediathekAsxPlaylist* rygel_mediathek_asx_playlist_new (const char* uri);
-RygelMediathekAsxPlaylist* rygel_mediathek_asx_playlist_construct (GType object_type, const char* uri);
-GQuark rygel_mediathek_asx_playlist_error_quark (void);
-void rygel_mediathek_asx_playlist_parse (RygelMediathekAsxPlaylist* self, GError** error);
-RygelMediathekAsxPlaylist* rygel_mediathek_video_item_handle_content (xmlNode* group, GError** error);
-RygelMediathekVideoItem* rygel_mediathek_video_item_create_from_xml (RygelMediaContainer* parent, xmlNode* item, GError** error);
-static int _vala_strcmp0 (const char * str1, const char * str2);
-
-
-
-GQuark rygel_mediathek_video_item_error_quark (void) {
-	return g_quark_from_static_string ("rygel_mediathek_video_item_error-quark");
-}
-
-
-static RygelMediathekVideoItem* rygel_mediathek_video_item_construct (GType object_type, RygelMediaContainer* parent, const char* title) {
-	RygelMediathekVideoItem * self;
-	char* _tmp0_;
-	char* _tmp1_;
-	char* _tmp2_;
-	g_return_val_if_fail (parent != NULL, NULL);
-	g_return_val_if_fail (title != NULL, NULL);
-	self = (RygelMediathekVideoItem*) rygel_media_item_construct (object_type, _tmp0_ = g_compute_checksum_for_string (G_CHECKSUM_MD5, title, -1), parent, title, RYGEL_MEDIA_ITEM_VIDEO_CLASS);
-	_g_free0 (_tmp0_);
-	((RygelMediaItem*) self)->mime_type = (_tmp1_ = g_strdup ("video/x-ms-asf"), _g_free0 (((RygelMediaItem*) self)->mime_type), _tmp1_);
-	((RygelMediaItem*) self)->author = (_tmp2_ = g_strdup ("ZDF - Zweites Deutsches Fernsehen"), _g_free0 (((RygelMediaItem*) self)->author), _tmp2_);
-	return self;
-}
-
-
-static RygelMediathekVideoItem* rygel_mediathek_video_item_new (RygelMediaContainer* parent, const char* title) {
-	return rygel_mediathek_video_item_construct (RYGEL_TYPE_MEDIATHEK_VIDEO_ITEM, parent, title);
-}
-
-
-static gboolean rygel_mediathek_video_item_namespace_ok (xmlNode* node) {
-	gboolean result;
-	gboolean _tmp0_ = FALSE;
-	if (node->ns != NULL) {
-		_tmp0_ = _vala_strcmp0 (node->ns->prefix, "media") == 0;
-	} else {
-		_tmp0_ = FALSE;
-	}
-	result = _tmp0_;
-	return result;
-}
-
-
-RygelMediathekAsxPlaylist* rygel_mediathek_video_item_handle_content (xmlNode* group, GError** error) {
-	RygelMediathekAsxPlaylist* result;
-	GError * _inner_error_;
-	RygelMediathekAsxPlaylist* asx;
-	_inner_error_ = NULL;
-	asx = NULL;
-	if (rygel_mediathek_video_item_namespace_ok (group)) {
-		xmlAttr* attr;
-		attr = xmlHasProp (group, "url");
-		if (attr != NULL) {
-			char* url;
-			url = g_strdup (attr->children->content);
-			if (g_str_has_suffix (url, ".asx")) {
-				{
-					RygelMediathekAsxPlaylist* _tmp0_;
-					asx = (_tmp0_ = rygel_mediathek_asx_playlist_new (url), _g_object_unref0 (asx), _tmp0_);
-					rygel_mediathek_asx_playlist_parse (asx, &_inner_error_);
-					if (_inner_error_ != NULL) {
-						if (_inner_error_->domain == RYGEL_MEDIATHEK_ASX_PLAYLIST_ERROR) {
-							goto __catch1_rygel_mediathek_asx_playlist_error;
-						}
-						goto __finally1;
-					}
-				}
-				goto __finally1;
-				__catch1_rygel_mediathek_asx_playlist_error:
-				{
-					GError * _error_;
-					_error_ = _inner_error_;
-					_inner_error_ = NULL;
-					{
-						RygelMediathekAsxPlaylist* _tmp1_;
-						asx = (_tmp1_ = NULL, _g_object_unref0 (asx), _tmp1_);
-						_g_error_free0 (_error_);
-					}
-				}
-				__finally1:
-				if (_inner_error_ != NULL) {
-					if (_inner_error_->domain == RYGEL_MEDIATHEK_VIDEO_ITEM_ERROR) {
-						g_propagate_error (error, _inner_error_);
-						_g_free0 (url);
-						_g_object_unref0 (asx);
-						return NULL;
-					} else {
-						_g_free0 (url);
-						_g_object_unref0 (asx);
-						g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
-						g_clear_error (&_inner_error_);
-						return NULL;
-					}
-				}
-			}
-			_g_free0 (url);
-		} else {
-			_inner_error_ = g_error_new_literal (RYGEL_MEDIATHEK_VIDEO_ITEM_ERROR, RYGEL_MEDIATHEK_VIDEO_ITEM_ERROR_XML_PARSE_ERROR, "group node has url property");
-			if (_inner_error_ != NULL) {
-				if (_inner_error_->domain == RYGEL_MEDIATHEK_VIDEO_ITEM_ERROR) {
-					g_propagate_error (error, _inner_error_);
-					_g_object_unref0 (asx);
-					return NULL;
-				} else {
-					_g_object_unref0 (asx);
-					g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
-					g_clear_error (&_inner_error_);
-					return NULL;
-				}
-			}
-		}
-	} else {
-		_inner_error_ = g_error_new_literal (RYGEL_MEDIATHEK_VIDEO_ITEM_ERROR, RYGEL_MEDIATHEK_VIDEO_ITEM_ERROR_XML_PARSE_ERROR, "invalid or no namespace");
-		if (_inner_error_ != NULL) {
-			if (_inner_error_->domain == RYGEL_MEDIATHEK_VIDEO_ITEM_ERROR) {
-				g_propagate_error (error, _inner_error_);
-				_g_object_unref0 (asx);
-				return NULL;
-			} else {
-				_g_object_unref0 (asx);
-				g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
-				g_clear_error (&_inner_error_);
-				return NULL;
-			}
-		}
-	}
-	result = asx;
-	return result;
-}
-
-
-RygelMediathekVideoItem* rygel_mediathek_video_item_create_from_xml (RygelMediaContainer* parent, xmlNode* item, GError** error) {
-	RygelMediathekVideoItem* result;
-	GError * _inner_error_;
-	char* title;
-	RygelMediathekVideoItem* video_item;
-	RygelMediathekAsxPlaylist* asx;
-	RygelMediathekVideoItem* _tmp7_;
-	g_return_val_if_fail (parent != NULL, NULL);
-	_inner_error_ = NULL;
-	title = NULL;
-	video_item = NULL;
-	asx = NULL;
-	{
-		xmlNode* item_child;
-		item_child = item->children;
-		{
-			gboolean _tmp0_;
-			_tmp0_ = TRUE;
-			while (TRUE) {
-				GQuark _tmp6_;
-				const char* _tmp5_;
-				static GQuark _tmp6__label0 = 0;
-				static GQuark _tmp6__label1 = 0;
-				if (!_tmp0_) {
-					item_child = item_child->next;
-				}
-				_tmp0_ = FALSE;
-				if (!(item_child != NULL)) {
-					break;
-				}
-				_tmp5_ = item_child->name;
-				_tmp6_ = (NULL == _tmp5_) ? 0 : g_quark_from_string (_tmp5_);
-				if (_tmp6_ == ((0 != _tmp6__label0) ? _tmp6__label0 : (_tmp6__label0 = g_quark_from_static_string ("title"))))
-				do {
-					char* _tmp1_;
-					title = (_tmp1_ = xmlNodeGetContent (item_child), _g_free0 (title), _tmp1_);
-					break;
-				} while (0); else if (_tmp6_ == ((0 != _tmp6__label1) ? _tmp6__label1 : (_tmp6__label1 = g_quark_from_static_string ("group"))))
-				do {
-					if (rygel_mediathek_video_item_namespace_ok (item_child)) {
-						{
-							xmlNode* group;
-							group = item_child->children;
-							{
-								gboolean _tmp2_;
-								_tmp2_ = TRUE;
-								while (TRUE) {
-									if (!_tmp2_) {
-										group = group->next;
-									}
-									_tmp2_ = FALSE;
-									if (!(group != NULL)) {
-										break;
-									}
-									if (_vala_strcmp0 (group->name, "content") == 0) {
-										RygelMediathekAsxPlaylist* _tmp3_;
-										RygelMediathekAsxPlaylist* _tmp4_;
-										_tmp3_ = rygel_mediathek_video_item_handle_content (group, &_inner_error_);
-										if (_inner_error_ != NULL) {
-											if (_inner_error_->domain == RYGEL_MEDIATHEK_VIDEO_ITEM_ERROR) {
-												g_propagate_error (error, _inner_error_);
-												_g_free0 (title);
-												_g_object_unref0 (video_item);
-												_g_object_unref0 (asx);
-												return NULL;
-											} else {
-												_g_free0 (title);
-												_g_object_unref0 (video_item);
-												_g_object_unref0 (asx);
-												g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
-												g_clear_error (&_inner_error_);
-												return NULL;
-											}
-										}
-										asx = (_tmp4_ = _tmp3_, _g_object_unref0 (asx), _tmp4_);
-									}
-								}
-							}
-						}
-					} else {
-						_inner_error_ = g_error_new_literal (RYGEL_MEDIATHEK_VIDEO_ITEM_ERROR, RYGEL_MEDIATHEK_VIDEO_ITEM_ERROR_XML_PARSE_ERROR, "invalid or no namespace on group node");
-						if (_inner_error_ != NULL) {
-							if (_inner_error_->domain == RYGEL_MEDIATHEK_VIDEO_ITEM_ERROR) {
-								g_propagate_error (error, _inner_error_);
-								_g_free0 (title);
-								_g_object_unref0 (video_item);
-								_g_object_unref0 (asx);
-								return NULL;
-							} else {
-								_g_free0 (title);
-								_g_object_unref0 (video_item);
-								_g_object_unref0 (asx);
-								g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
-								g_clear_error (&_inner_error_);
-								return NULL;
-							}
-						}
-					}
-					break;
-				} while (0); else
-				do {
-					break;
-				} while (0);
-			}
-		}
-	}
-	if (title == NULL) {
-		_inner_error_ = g_error_new_literal (RYGEL_MEDIATHEK_VIDEO_ITEM_ERROR, RYGEL_MEDIATHEK_VIDEO_ITEM_ERROR_XML_PARSE_ERROR, "Could not find title");
-		if (_inner_error_ != NULL) {
-			if (_inner_error_->domain == RYGEL_MEDIATHEK_VIDEO_ITEM_ERROR) {
-				g_propagate_error (error, _inner_error_);
-				_g_free0 (title);
-				_g_object_unref0 (video_item);
-				_g_object_unref0 (asx);
-				return NULL;
-			} else {
-				_g_free0 (title);
-				_g_object_unref0 (video_item);
-				_g_object_unref0 (asx);
-				g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
-				g_clear_error (&_inner_error_);
-				return NULL;
-			}
-		}
-	}
-	if (asx == NULL) {
-		_inner_error_ = g_error_new_literal (RYGEL_MEDIATHEK_VIDEO_ITEM_ERROR, RYGEL_MEDIATHEK_VIDEO_ITEM_ERROR_XML_PARSE_ERROR, "Could not find uris");
-		if (_inner_error_ != NULL) {
-			if (_inner_error_->domain == RYGEL_MEDIATHEK_VIDEO_ITEM_ERROR) {
-				g_propagate_error (error, _inner_error_);
-				_g_free0 (title);
-				_g_object_unref0 (video_item);
-				_g_object_unref0 (asx);
-				return NULL;
-			} else {
-				_g_free0 (title);
-				_g_object_unref0 (video_item);
-				_g_object_unref0 (asx);
-				g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
-				g_clear_error (&_inner_error_);
-				return NULL;
-			}
-		}
-	}
-	video_item = (_tmp7_ = rygel_mediathek_video_item_new (parent, title), _g_object_unref0 (video_item), _tmp7_);
-	{
-		GeeIterator* _uri_it;
-		_uri_it = gee_abstract_collection_iterator ((GeeAbstractCollection*) asx->uris);
-		while (TRUE) {
-			char* uri;
-			if (!gee_iterator_next (_uri_it)) {
-				break;
-			}
-			uri = (char*) gee_iterator_get (_uri_it);
-			rygel_media_item_add_uri ((RygelMediaItem*) video_item, uri, NULL);
-			_g_free0 (uri);
-		}
-		_g_object_unref0 (_uri_it);
-	}
-	result = video_item;
-	_g_free0 (title);
-	_g_object_unref0 (asx);
-	return result;
-}
-
-
-static void rygel_mediathek_video_item_class_init (RygelMediathekVideoItemClass * klass) {
-	rygel_mediathek_video_item_parent_class = g_type_class_peek_parent (klass);
-}
-
-
-static void rygel_mediathek_video_item_instance_init (RygelMediathekVideoItem * self) {
-}
-
-
-GType rygel_mediathek_video_item_get_type (void) {
-	static GType rygel_mediathek_video_item_type_id = 0;
-	if (rygel_mediathek_video_item_type_id == 0) {
-		static const GTypeInfo g_define_type_info = { sizeof (RygelMediathekVideoItemClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) rygel_mediathek_video_item_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (RygelMediathekVideoItem), 0, (GInstanceInitFunc) rygel_mediathek_video_item_instance_init, NULL };
-		rygel_mediathek_video_item_type_id = g_type_register_static (RYGEL_TYPE_MEDIA_ITEM, "RygelMediathekVideoItem", &g_define_type_info, 0);
-	}
-	return rygel_mediathek_video_item_type_id;
-}
-
-
-static int _vala_strcmp0 (const char * str1, const char * str2) {
-	if (str1 == NULL) {
-		return -(str1 != str2);
-	}
-	if (str2 == NULL) {
-		return str1 != str2;
-	}
-	return strcmp (str1, str2);
-}
-
-
-
-
--- a/src/plugins/test/Makefile.in
+++ b/src/plugins/test/Makefile.in
@@ -40,7 +40,8 @@ DIST_COMMON = $(srcdir)/Makefile.am $(sr
 	rygel-test-content-dir.c rygel-test-item.c rygel-test-plugin.c \
 	rygel-test-root-container.c rygel-test-video-item.c
 ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
-am__aclocal_m4_deps = $(top_srcdir)/m4/libtool.m4 \
+am__aclocal_m4_deps = $(top_srcdir)/m4/glib-gettext.m4 \
+	$(top_srcdir)/m4/isc-posix.m4 $(top_srcdir)/m4/libtool.m4 \
 	$(top_srcdir)/m4/ltoptions.m4 $(top_srcdir)/m4/ltsugar.m4 \
 	$(top_srcdir)/m4/ltversion.m4 $(top_srcdir)/m4/lt~obsolete.m4 \
 	$(top_srcdir)/configure.ac
@@ -76,7 +77,7 @@ LTLIBRARIES = $(plugin_LTLIBRARIES)
 am__DEPENDENCIES_1 =
 librygel_test_la_DEPENDENCIES = $(am__DEPENDENCIES_1) \
 	$(am__DEPENDENCIES_1) $(am__DEPENDENCIES_1) \
-	$(am__DEPENDENCIES_1) $(am__DEPENDENCIES_1)
+	$(am__DEPENDENCIES_1)
 am_librygel_test_la_OBJECTS = rygel-test-content-dir.lo \
 	rygel-test-root-container.lo rygel-test-item.lo \
 	rygel-test-audio-item.lo rygel-test-video-item.lo \
@@ -163,8 +164,6 @@ GMSGFMT = @GMSGFMT@
 GREP = @GREP@
 GTK_CFLAGS = @GTK_CFLAGS@
 GTK_LIBS = @GTK_LIBS@
-GUPNP_VALA_CFLAGS = @GUPNP_VALA_CFLAGS@
-GUPNP_VALA_LIBS = @GUPNP_VALA_LIBS@
 HAVE_GTK = @HAVE_GTK@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
@@ -179,8 +178,8 @@ LIBDBUS_GLIB_CFLAGS = @LIBDBUS_GLIB_CFLA
 LIBDBUS_GLIB_LIBS = @LIBDBUS_GLIB_LIBS@
 LIBGIO_CFLAGS = @LIBGIO_CFLAGS@
 LIBGIO_LIBS = @LIBGIO_LIBS@
-LIBGSTREAMER_CFLAGS = @LIBGSTREAMER_CFLAGS@
-LIBGSTREAMER_LIBS = @LIBGSTREAMER_LIBS@
+LIBGLIB_CFLAGS = @LIBGLIB_CFLAGS@
+LIBGLIB_LIBS = @LIBGLIB_LIBS@
 LIBGUPNP_AV_CFLAGS = @LIBGUPNP_AV_CFLAGS@
 LIBGUPNP_AV_LIBS = @LIBGUPNP_AV_LIBS@
 LIBGUPNP_CFLAGS = @LIBGUPNP_CFLAGS@
@@ -192,6 +191,8 @@ LIBSOUP_LIBS = @LIBSOUP_LIBS@
 LIBSQLITE3_CFLAGS = @LIBSQLITE3_CFLAGS@
 LIBSQLITE3_LIBS = @LIBSQLITE3_LIBS@
 LIBTOOL = @LIBTOOL@
+LIBVLC_CFLAGS = @LIBVLC_CFLAGS@
+LIBVLC_LIBS = @LIBVLC_LIBS@
 LIPO = @LIPO@
 LN_S = @LN_S@
 LTLIBOBJS = @LTLIBOBJS@
@@ -212,6 +213,7 @@ PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
 PACKAGE_NAME = @PACKAGE_NAME@
 PACKAGE_STRING = @PACKAGE_STRING@
 PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_URL = @PACKAGE_URL@
 PACKAGE_VERSION = @PACKAGE_VERSION@
 PATH_SEPARATOR = @PATH_SEPARATOR@
 PKG_CONFIG = @PKG_CONFIG@
@@ -225,8 +227,6 @@ SET_MAKE = @SET_MAKE@
 SHELL = @SHELL@
 STRIP = @STRIP@
 USE_NLS = @USE_NLS@
-UUID_CFLAGS = @UUID_CFLAGS@
-UUID_LIBS = @UUID_LIBS@
 VALAC = @VALAC@
 VAPIDIR = @VAPIDIR@
 VERSION = @VERSION@
--- a/src/plugins/test/rygel-test-audio-item.c
+++ /dev/null
@@ -1,167 +0,0 @@
-/* rygel-test-audio-item.c generated by valac, the Vala compiler
- * generated from rygel-test-audio-item.vala, do not modify */
-
-/*
- * Copyright (C) 2008 Zeeshan Ali (Khattak) <zeeshanak@gnome.org>.
- * Copyright (C) 2008 Nokia Corporation.
- *
- * Author: Zeeshan Ali (Khattak) <zeeshanak@gnome.org>
- *                               <zeeshan.ali@nokia.com>
- *
- * This file is part of Rygel.
- *
- * Rygel is free software; you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * Rygel is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this program; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
- */
-
-#include <glib.h>
-#include <glib-object.h>
-#include <rygel.h>
-#include <stdlib.h>
-#include <string.h>
-#include <gst/gst.h>
-
-
-#define RYGEL_TYPE_TEST_ITEM (rygel_test_item_get_type ())
-#define RYGEL_TEST_ITEM(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_TEST_ITEM, RygelTestItem))
-#define RYGEL_TEST_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_TEST_ITEM, RygelTestItemClass))
-#define RYGEL_IS_TEST_ITEM(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_TEST_ITEM))
-#define RYGEL_IS_TEST_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_TEST_ITEM))
-#define RYGEL_TEST_ITEM_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_TEST_ITEM, RygelTestItemClass))
-
-typedef struct _RygelTestItem RygelTestItem;
-typedef struct _RygelTestItemClass RygelTestItemClass;
-typedef struct _RygelTestItemPrivate RygelTestItemPrivate;
-
-#define RYGEL_TYPE_TEST_AUDIO_ITEM (rygel_test_audio_item_get_type ())
-#define RYGEL_TEST_AUDIO_ITEM(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_TEST_AUDIO_ITEM, RygelTestAudioItem))
-#define RYGEL_TEST_AUDIO_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_TEST_AUDIO_ITEM, RygelTestAudioItemClass))
-#define RYGEL_IS_TEST_AUDIO_ITEM(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_TEST_AUDIO_ITEM))
-#define RYGEL_IS_TEST_AUDIO_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_TEST_AUDIO_ITEM))
-#define RYGEL_TEST_AUDIO_ITEM_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_TEST_AUDIO_ITEM, RygelTestAudioItemClass))
-
-typedef struct _RygelTestAudioItem RygelTestAudioItem;
-typedef struct _RygelTestAudioItemClass RygelTestAudioItemClass;
-typedef struct _RygelTestAudioItemPrivate RygelTestAudioItemPrivate;
-#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
-
-struct _RygelTestItem {
-	RygelMediaItem parent_instance;
-	RygelTestItemPrivate * priv;
-};
-
-struct _RygelTestItemClass {
-	RygelMediaItemClass parent_class;
-};
-
-struct _RygelTestAudioItem {
-	RygelTestItem parent_instance;
-	RygelTestAudioItemPrivate * priv;
-};
-
-struct _RygelTestAudioItemClass {
-	RygelTestItemClass parent_class;
-};
-
-
-static gpointer rygel_test_audio_item_parent_class = NULL;
-
-GType rygel_test_item_get_type (void);
-GType rygel_test_audio_item_get_type (void);
-enum  {
-	RYGEL_TEST_AUDIO_ITEM_DUMMY_PROPERTY
-};
-#define RYGEL_TEST_AUDIO_ITEM_TEST_MIMETYPE "audio/x-wav"
-RygelTestItem* rygel_test_item_construct (GType object_type, const char* id, RygelMediaContainer* parent, const char* title, const char* mime, const char* upnp_class);
-RygelTestAudioItem* rygel_test_audio_item_new (const char* id, RygelMediaContainer* parent, const char* title);
-RygelTestAudioItem* rygel_test_audio_item_construct (GType object_type, const char* id, RygelMediaContainer* parent, const char* title);
-static GstElement* rygel_test_audio_item_real_create_stream_source (RygelMediaItem* base);
-
-
-
-RygelTestAudioItem* rygel_test_audio_item_construct (GType object_type, const char* id, RygelMediaContainer* parent, const char* title) {
-	RygelTestAudioItem * self;
-	g_return_val_if_fail (id != NULL, NULL);
-	g_return_val_if_fail (parent != NULL, NULL);
-	g_return_val_if_fail (title != NULL, NULL);
-	self = (RygelTestAudioItem*) rygel_test_item_construct (object_type, id, parent, title, RYGEL_TEST_AUDIO_ITEM_TEST_MIMETYPE, RYGEL_MEDIA_ITEM_AUDIO_CLASS);
-	return self;
-}
-
-
-RygelTestAudioItem* rygel_test_audio_item_new (const char* id, RygelMediaContainer* parent, const char* title) {
-	return rygel_test_audio_item_construct (RYGEL_TYPE_TEST_AUDIO_ITEM, id, parent, title);
-}
-
-
-static GstElement* rygel_test_audio_item_real_create_stream_source (RygelMediaItem* base) {
-	RygelTestAudioItem * self;
-	GstElement* result;
-	GError * _inner_error_;
-	self = (RygelTestAudioItem*) base;
-	_inner_error_ = NULL;
-	{
-		GstElement* _tmp0_;
-		_tmp0_ = gst_parse_bin_from_description ("audiotestsrc is-live=1 ! wavenc", TRUE, &_inner_error_);
-		if (_inner_error_ != NULL) {
-			goto __catch0_g_error;
-			goto __finally0;
-		}
-		result = _tmp0_;
-		return result;
-	}
-	goto __finally0;
-	__catch0_g_error:
-	{
-		GError * err;
-		err = _inner_error_;
-		_inner_error_ = NULL;
-		{
-			g_warning ("rygel-test-audio-item.vala:49: Required plugin missing (%s)", err->message);
-			result = NULL;
-			_g_error_free0 (err);
-			return result;
-		}
-	}
-	__finally0:
-	if (_inner_error_ != NULL) {
-		g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
-		g_clear_error (&_inner_error_);
-		return NULL;
-	}
-}
-
-
-static void rygel_test_audio_item_class_init (RygelTestAudioItemClass * klass) {
-	rygel_test_audio_item_parent_class = g_type_class_peek_parent (klass);
-	RYGEL_MEDIA_ITEM_CLASS (klass)->create_stream_source = rygel_test_audio_item_real_create_stream_source;
-}
-
-
-static void rygel_test_audio_item_instance_init (RygelTestAudioItem * self) {
-}
-
-
-GType rygel_test_audio_item_get_type (void) {
-	static GType rygel_test_audio_item_type_id = 0;
-	if (rygel_test_audio_item_type_id == 0) {
-		static const GTypeInfo g_define_type_info = { sizeof (RygelTestAudioItemClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) rygel_test_audio_item_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (RygelTestAudioItem), 0, (GInstanceInitFunc) rygel_test_audio_item_instance_init, NULL };
-		rygel_test_audio_item_type_id = g_type_register_static (RYGEL_TYPE_TEST_ITEM, "RygelTestAudioItem", &g_define_type_info, 0);
-	}
-	return rygel_test_audio_item_type_id;
-}
-
-
-
-
--- a/src/plugins/test/rygel-test-content-dir.c
+++ /dev/null
@@ -1,132 +0,0 @@
-/* rygel-test-content-dir.c generated by valac, the Vala compiler
- * generated from rygel-test-content-dir.vala, do not modify */
-
-/*
- * Copyright (C) 2008 Zeeshan Ali (Khattak) <zeeshanak@gnome.org>.
- * Copyright (C) 2008 Nokia Corporation.
- *
- * Author: Zeeshan Ali (Khattak) <zeeshanak@gnome.org>
- *                               <zeeshan.ali@nokia.com>
- *
- * This file is part of Rygel.
- *
- * Rygel is free software; you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * Rygel is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this program; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
- */
-
-#include <glib.h>
-#include <glib-object.h>
-#include <rygel.h>
-#include <libgupnp/gupnp.h>
-#include <stdlib.h>
-#include <string.h>
-
-
-#define RYGEL_TYPE_TEST_CONTENT_DIR (rygel_test_content_dir_get_type ())
-#define RYGEL_TEST_CONTENT_DIR(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_TEST_CONTENT_DIR, RygelTestContentDir))
-#define RYGEL_TEST_CONTENT_DIR_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_TEST_CONTENT_DIR, RygelTestContentDirClass))
-#define RYGEL_IS_TEST_CONTENT_DIR(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_TEST_CONTENT_DIR))
-#define RYGEL_IS_TEST_CONTENT_DIR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_TEST_CONTENT_DIR))
-#define RYGEL_TEST_CONTENT_DIR_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_TEST_CONTENT_DIR, RygelTestContentDirClass))
-
-typedef struct _RygelTestContentDir RygelTestContentDir;
-typedef struct _RygelTestContentDirClass RygelTestContentDirClass;
-typedef struct _RygelTestContentDirPrivate RygelTestContentDirPrivate;
-#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
-
-#define RYGEL_TYPE_TEST_ROOT_CONTAINER (rygel_test_root_container_get_type ())
-#define RYGEL_TEST_ROOT_CONTAINER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_TEST_ROOT_CONTAINER, RygelTestRootContainer))
-#define RYGEL_TEST_ROOT_CONTAINER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_TEST_ROOT_CONTAINER, RygelTestRootContainerClass))
-#define RYGEL_IS_TEST_ROOT_CONTAINER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_TEST_ROOT_CONTAINER))
-#define RYGEL_IS_TEST_ROOT_CONTAINER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_TEST_ROOT_CONTAINER))
-#define RYGEL_TEST_ROOT_CONTAINER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_TEST_ROOT_CONTAINER, RygelTestRootContainerClass))
-
-typedef struct _RygelTestRootContainer RygelTestRootContainer;
-typedef struct _RygelTestRootContainerClass RygelTestRootContainerClass;
-#define _g_free0(var) (var = (g_free (var), NULL))
-
-struct _RygelTestContentDir {
-	RygelContentDirectory parent_instance;
-	RygelTestContentDirPrivate * priv;
-};
-
-struct _RygelTestContentDirClass {
-	RygelContentDirectoryClass parent_class;
-};
-
-
-static gpointer rygel_test_content_dir_parent_class = NULL;
-
-GType rygel_test_content_dir_get_type (void);
-enum  {
-	RYGEL_TEST_CONTENT_DIR_DUMMY_PROPERTY
-};
-RygelTestRootContainer* rygel_test_root_container_new (const char* title);
-RygelTestRootContainer* rygel_test_root_container_construct (GType object_type, const char* title);
-GType rygel_test_root_container_get_type (void);
-static RygelMediaContainer* rygel_test_content_dir_real_create_root_container (RygelContentDirectory* base);
-RygelTestContentDir* rygel_test_content_dir_new (void);
-RygelTestContentDir* rygel_test_content_dir_construct (GType object_type);
-
-
-
-static RygelMediaContainer* rygel_test_content_dir_real_create_root_container (RygelContentDirectory* base) {
-	RygelTestContentDir * self;
-	RygelMediaContainer* result;
-	GUPnPRootDevice* _tmp1_;
-	GUPnPRootDevice* _tmp0_ = NULL;
-	char* _tmp2_;
-	char* friendly_name;
-	self = (RygelTestContentDir*) base;
-	friendly_name = (_tmp2_ = gupnp_device_info_get_friendly_name ((GUPnPDeviceInfo*) (_tmp1_ = (g_object_get ((GUPnPService*) self, "root-device", &_tmp0_, NULL), _tmp0_))), _g_object_unref0 (_tmp1_), _tmp2_);
-	result = (RygelMediaContainer*) rygel_test_root_container_new (friendly_name);
-	_g_free0 (friendly_name);
-	return result;
-}
-
-
-RygelTestContentDir* rygel_test_content_dir_construct (GType object_type) {
-	RygelTestContentDir * self;
-	self = (RygelTestContentDir*) rygel_content_directory_construct (object_type);
-	return self;
-}
-
-
-RygelTestContentDir* rygel_test_content_dir_new (void) {
-	return rygel_test_content_dir_construct (RYGEL_TYPE_TEST_CONTENT_DIR);
-}
-
-
-static void rygel_test_content_dir_class_init (RygelTestContentDirClass * klass) {
-	rygel_test_content_dir_parent_class = g_type_class_peek_parent (klass);
-	RYGEL_CONTENT_DIRECTORY_CLASS (klass)->create_root_container = rygel_test_content_dir_real_create_root_container;
-}
-
-
-static void rygel_test_content_dir_instance_init (RygelTestContentDir * self) {
-}
-
-
-GType rygel_test_content_dir_get_type (void) {
-	static GType rygel_test_content_dir_type_id = 0;
-	if (rygel_test_content_dir_type_id == 0) {
-		static const GTypeInfo g_define_type_info = { sizeof (RygelTestContentDirClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) rygel_test_content_dir_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (RygelTestContentDir), 0, (GInstanceInitFunc) rygel_test_content_dir_instance_init, NULL };
-		rygel_test_content_dir_type_id = g_type_register_static (RYGEL_TYPE_CONTENT_DIRECTORY, "RygelTestContentDir", &g_define_type_info, 0);
-	}
-	return rygel_test_content_dir_type_id;
-}
-
-
-
-
--- a/src/plugins/test/rygel-test-item.c
+++ /dev/null
@@ -1,104 +0,0 @@
-/* rygel-test-item.c generated by valac, the Vala compiler
- * generated from rygel-test-item.vala, do not modify */
-
-/*
- * Copyright (C) 2008 Zeeshan Ali (Khattak) <zeeshanak@gnome.org>.
- * Copyright (C) 2008 Nokia Corporation.
- *
- * Author: Zeeshan Ali (Khattak) <zeeshanak@gnome.org>
- *                               <zeeshan.ali@nokia.com>
- *
- * This file is part of Rygel.
- *
- * Rygel is free software; you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * Rygel is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this program; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
- */
-
-#include <glib.h>
-#include <glib-object.h>
-#include <rygel.h>
-#include <stdlib.h>
-#include <string.h>
-
-
-#define RYGEL_TYPE_TEST_ITEM (rygel_test_item_get_type ())
-#define RYGEL_TEST_ITEM(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_TEST_ITEM, RygelTestItem))
-#define RYGEL_TEST_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_TEST_ITEM, RygelTestItemClass))
-#define RYGEL_IS_TEST_ITEM(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_TEST_ITEM))
-#define RYGEL_IS_TEST_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_TEST_ITEM))
-#define RYGEL_TEST_ITEM_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_TEST_ITEM, RygelTestItemClass))
-
-typedef struct _RygelTestItem RygelTestItem;
-typedef struct _RygelTestItemClass RygelTestItemClass;
-typedef struct _RygelTestItemPrivate RygelTestItemPrivate;
-#define _g_free0(var) (var = (g_free (var), NULL))
-
-struct _RygelTestItem {
-	RygelMediaItem parent_instance;
-	RygelTestItemPrivate * priv;
-};
-
-struct _RygelTestItemClass {
-	RygelMediaItemClass parent_class;
-};
-
-
-static gpointer rygel_test_item_parent_class = NULL;
-
-GType rygel_test_item_get_type (void);
-enum  {
-	RYGEL_TEST_ITEM_DUMMY_PROPERTY
-};
-#define RYGEL_TEST_ITEM_TEST_AUTHOR "Zeeshan Ali (Khattak)"
-RygelTestItem* rygel_test_item_construct (GType object_type, const char* id, RygelMediaContainer* parent, const char* title, const char* mime, const char* upnp_class);
-
-
-
-RygelTestItem* rygel_test_item_construct (GType object_type, const char* id, RygelMediaContainer* parent, const char* title, const char* mime, const char* upnp_class) {
-	RygelTestItem * self;
-	char* _tmp0_;
-	char* _tmp1_;
-	g_return_val_if_fail (id != NULL, NULL);
-	g_return_val_if_fail (parent != NULL, NULL);
-	g_return_val_if_fail (title != NULL, NULL);
-	g_return_val_if_fail (mime != NULL, NULL);
-	g_return_val_if_fail (upnp_class != NULL, NULL);
-	self = (RygelTestItem*) rygel_media_item_construct (object_type, id, parent, title, upnp_class);
-	((RygelMediaItem*) self)->mime_type = (_tmp0_ = g_strdup (mime), _g_free0 (((RygelMediaItem*) self)->mime_type), _tmp0_);
-	((RygelMediaItem*) self)->author = (_tmp1_ = g_strdup (RYGEL_TEST_ITEM_TEST_AUTHOR), _g_free0 (((RygelMediaItem*) self)->author), _tmp1_);
-	return self;
-}
-
-
-static void rygel_test_item_class_init (RygelTestItemClass * klass) {
-	rygel_test_item_parent_class = g_type_class_peek_parent (klass);
-}
-
-
-static void rygel_test_item_instance_init (RygelTestItem * self) {
-}
-
-
-GType rygel_test_item_get_type (void) {
-	static GType rygel_test_item_type_id = 0;
-	if (rygel_test_item_type_id == 0) {
-		static const GTypeInfo g_define_type_info = { sizeof (RygelTestItemClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) rygel_test_item_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (RygelTestItem), 0, (GInstanceInitFunc) rygel_test_item_instance_init, NULL };
-		rygel_test_item_type_id = g_type_register_static (RYGEL_TYPE_MEDIA_ITEM, "RygelTestItem", &g_define_type_info, G_TYPE_FLAG_ABSTRACT);
-	}
-	return rygel_test_item_type_id;
-}
-
-
-
-
--- a/src/plugins/test/rygel-test-plugin.c
+++ /dev/null
@@ -1,66 +0,0 @@
-/* rygel-test-plugin.c generated by valac, the Vala compiler
- * generated from rygel-test-plugin.vala, do not modify */
-
-/*
- * Copyright (C) 2008 Zeeshan Ali (Khattak) <zeeshanak@gnome.org>.
- * Copyright (C) 2008 Nokia Corporation.
- *
- * Author: Zeeshan Ali (Khattak) <zeeshanak@gnome.org>
- *                               <zeeshan.ali@nokia.com>
- *
- * This file is part of Rygel.
- *
- * Rygel is free software; you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * Rygel is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this program; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
- */
-
-#include <glib.h>
-#include <glib-object.h>
-#include <rygel.h>
-
-
-#define RYGEL_TYPE_TEST_CONTENT_DIR (rygel_test_content_dir_get_type ())
-#define RYGEL_TEST_CONTENT_DIR(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_TEST_CONTENT_DIR, RygelTestContentDir))
-#define RYGEL_TEST_CONTENT_DIR_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_TEST_CONTENT_DIR, RygelTestContentDirClass))
-#define RYGEL_IS_TEST_CONTENT_DIR(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_TEST_CONTENT_DIR))
-#define RYGEL_IS_TEST_CONTENT_DIR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_TEST_CONTENT_DIR))
-#define RYGEL_TEST_CONTENT_DIR_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_TEST_CONTENT_DIR, RygelTestContentDirClass))
-
-typedef struct _RygelTestContentDir RygelTestContentDir;
-typedef struct _RygelTestContentDirClass RygelTestContentDirClass;
-#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
-#define _rygel_resource_info_unref0(var) ((var == NULL) ? NULL : (var = (rygel_resource_info_unref (var), NULL)))
-
-
-
-GType rygel_test_content_dir_get_type (void);
-void module_init (RygelPluginLoader* loader);
-
-
-
-void module_init (RygelPluginLoader* loader) {
-	RygelPlugin* plugin;
-	RygelResourceInfo* resource_info;
-	g_return_if_fail (loader != NULL);
-	plugin = rygel_plugin_new_MediaServer ("Test", "Test Streams");
-	resource_info = rygel_resource_info_new (RYGEL_CONTENT_DIRECTORY_UPNP_ID, RYGEL_CONTENT_DIRECTORY_UPNP_TYPE, RYGEL_CONTENT_DIRECTORY_DESCRIPTION_PATH, RYGEL_TYPE_TEST_CONTENT_DIR);
-	rygel_plugin_add_resource (plugin, resource_info);
-	rygel_plugin_loader_add_plugin (loader, plugin);
-	_g_object_unref0 (plugin);
-	_rygel_resource_info_unref0 (resource_info);
-}
-
-
-
-
--- a/src/plugins/test/rygel-test-root-container.c
+++ /dev/null
@@ -1,144 +0,0 @@
-/* rygel-test-root-container.c generated by valac, the Vala compiler
- * generated from rygel-test-root-container.vala, do not modify */
-
-/*
- * Copyright (C) 2008 Zeeshan Ali (Khattak) <zeeshanak@gnome.org>.
- * Copyright (C) 2008 Nokia Corporation.
- *
- * Author: Zeeshan Ali (Khattak) <zeeshanak@gnome.org>
- *                               <zeeshan.ali@nokia.com>
- *
- * This file is part of Rygel.
- *
- * Rygel is free software; you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * Rygel is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this program; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
- */
-
-#include <glib.h>
-#include <glib-object.h>
-#include <rygel.h>
-#include <stdlib.h>
-#include <string.h>
-
-
-#define RYGEL_TYPE_TEST_ROOT_CONTAINER (rygel_test_root_container_get_type ())
-#define RYGEL_TEST_ROOT_CONTAINER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_TEST_ROOT_CONTAINER, RygelTestRootContainer))
-#define RYGEL_TEST_ROOT_CONTAINER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_TEST_ROOT_CONTAINER, RygelTestRootContainerClass))
-#define RYGEL_IS_TEST_ROOT_CONTAINER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_TEST_ROOT_CONTAINER))
-#define RYGEL_IS_TEST_ROOT_CONTAINER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_TEST_ROOT_CONTAINER))
-#define RYGEL_TEST_ROOT_CONTAINER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_TEST_ROOT_CONTAINER, RygelTestRootContainerClass))
-
-typedef struct _RygelTestRootContainer RygelTestRootContainer;
-typedef struct _RygelTestRootContainerClass RygelTestRootContainerClass;
-typedef struct _RygelTestRootContainerPrivate RygelTestRootContainerPrivate;
-
-#define RYGEL_TYPE_TEST_ITEM (rygel_test_item_get_type ())
-#define RYGEL_TEST_ITEM(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_TEST_ITEM, RygelTestItem))
-#define RYGEL_TEST_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_TEST_ITEM, RygelTestItemClass))
-#define RYGEL_IS_TEST_ITEM(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_TEST_ITEM))
-#define RYGEL_IS_TEST_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_TEST_ITEM))
-#define RYGEL_TEST_ITEM_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_TEST_ITEM, RygelTestItemClass))
-
-typedef struct _RygelTestItem RygelTestItem;
-typedef struct _RygelTestItemClass RygelTestItemClass;
-
-#define RYGEL_TYPE_TEST_AUDIO_ITEM (rygel_test_audio_item_get_type ())
-#define RYGEL_TEST_AUDIO_ITEM(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_TEST_AUDIO_ITEM, RygelTestAudioItem))
-#define RYGEL_TEST_AUDIO_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_TEST_AUDIO_ITEM, RygelTestAudioItemClass))
-#define RYGEL_IS_TEST_AUDIO_ITEM(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_TEST_AUDIO_ITEM))
-#define RYGEL_IS_TEST_AUDIO_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_TEST_AUDIO_ITEM))
-#define RYGEL_TEST_AUDIO_ITEM_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_TEST_AUDIO_ITEM, RygelTestAudioItemClass))
-
-typedef struct _RygelTestAudioItem RygelTestAudioItem;
-typedef struct _RygelTestAudioItemClass RygelTestAudioItemClass;
-#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
-
-#define RYGEL_TYPE_TEST_VIDEO_ITEM (rygel_test_video_item_get_type ())
-#define RYGEL_TEST_VIDEO_ITEM(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_TEST_VIDEO_ITEM, RygelTestVideoItem))
-#define RYGEL_TEST_VIDEO_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_TEST_VIDEO_ITEM, RygelTestVideoItemClass))
-#define RYGEL_IS_TEST_VIDEO_ITEM(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_TEST_VIDEO_ITEM))
-#define RYGEL_IS_TEST_VIDEO_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_TEST_VIDEO_ITEM))
-#define RYGEL_TEST_VIDEO_ITEM_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_TEST_VIDEO_ITEM, RygelTestVideoItemClass))
-
-typedef struct _RygelTestVideoItem RygelTestVideoItem;
-typedef struct _RygelTestVideoItemClass RygelTestVideoItemClass;
-
-struct _RygelTestRootContainer {
-	RygelSimpleContainer parent_instance;
-	RygelTestRootContainerPrivate * priv;
-};
-
-struct _RygelTestRootContainerClass {
-	RygelSimpleContainerClass parent_class;
-};
-
-
-static gpointer rygel_test_root_container_parent_class = NULL;
-
-GType rygel_test_root_container_get_type (void);
-enum  {
-	RYGEL_TEST_ROOT_CONTAINER_DUMMY_PROPERTY
-};
-RygelTestAudioItem* rygel_test_audio_item_new (const char* id, RygelMediaContainer* parent, const char* title);
-RygelTestAudioItem* rygel_test_audio_item_construct (GType object_type, const char* id, RygelMediaContainer* parent, const char* title);
-GType rygel_test_item_get_type (void);
-GType rygel_test_audio_item_get_type (void);
-RygelTestVideoItem* rygel_test_video_item_new (const char* id, RygelMediaContainer* parent, const char* title);
-RygelTestVideoItem* rygel_test_video_item_construct (GType object_type, const char* id, RygelMediaContainer* parent, const char* title);
-GType rygel_test_video_item_get_type (void);
-RygelTestRootContainer* rygel_test_root_container_new (const char* title);
-RygelTestRootContainer* rygel_test_root_container_construct (GType object_type, const char* title);
-
-
-
-RygelTestRootContainer* rygel_test_root_container_construct (GType object_type, const char* title) {
-	RygelTestRootContainer * self;
-	RygelTestAudioItem* _tmp0_;
-	RygelTestVideoItem* _tmp1_;
-	g_return_val_if_fail (title != NULL, NULL);
-	self = (RygelTestRootContainer*) rygel_simple_container_construct_root (object_type, title);
-	rygel_simple_container_add_child ((RygelSimpleContainer*) self, (RygelMediaObject*) (_tmp0_ = rygel_test_audio_item_new ("sinewave", (RygelMediaContainer*) self, "Sine Wave")));
-	_g_object_unref0 (_tmp0_);
-	rygel_simple_container_add_child ((RygelSimpleContainer*) self, (RygelMediaObject*) (_tmp1_ = rygel_test_video_item_new ("smtpe", (RygelMediaContainer*) self, "SMTPE")));
-	_g_object_unref0 (_tmp1_);
-	return self;
-}
-
-
-RygelTestRootContainer* rygel_test_root_container_new (const char* title) {
-	return rygel_test_root_container_construct (RYGEL_TYPE_TEST_ROOT_CONTAINER, title);
-}
-
-
-static void rygel_test_root_container_class_init (RygelTestRootContainerClass * klass) {
-	rygel_test_root_container_parent_class = g_type_class_peek_parent (klass);
-}
-
-
-static void rygel_test_root_container_instance_init (RygelTestRootContainer * self) {
-}
-
-
-GType rygel_test_root_container_get_type (void) {
-	static GType rygel_test_root_container_type_id = 0;
-	if (rygel_test_root_container_type_id == 0) {
-		static const GTypeInfo g_define_type_info = { sizeof (RygelTestRootContainerClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) rygel_test_root_container_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (RygelTestRootContainer), 0, (GInstanceInitFunc) rygel_test_root_container_instance_init, NULL };
-		rygel_test_root_container_type_id = g_type_register_static (RYGEL_TYPE_SIMPLE_CONTAINER, "RygelTestRootContainer", &g_define_type_info, 0);
-	}
-	return rygel_test_root_container_type_id;
-}
-
-
-
-
--- a/src/plugins/test/rygel-test-video-item.c
+++ /dev/null
@@ -1,167 +0,0 @@
-/* rygel-test-video-item.c generated by valac, the Vala compiler
- * generated from rygel-test-video-item.vala, do not modify */
-
-/*
- * Copyright (C) 2008 Zeeshan Ali (Khattak) <zeeshanak@gnome.org>.
- * Copyright (C) 2008 Nokia Corporation.
- *
- * Author: Zeeshan Ali (Khattak) <zeeshanak@gnome.org>
- *                               <zeeshan.ali@nokia.com>
- *
- * This file is part of Rygel.
- *
- * Rygel is free software; you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * Rygel is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this program; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
- */
-
-#include <glib.h>
-#include <glib-object.h>
-#include <rygel.h>
-#include <stdlib.h>
-#include <string.h>
-#include <gst/gst.h>
-
-
-#define RYGEL_TYPE_TEST_ITEM (rygel_test_item_get_type ())
-#define RYGEL_TEST_ITEM(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_TEST_ITEM, RygelTestItem))
-#define RYGEL_TEST_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_TEST_ITEM, RygelTestItemClass))
-#define RYGEL_IS_TEST_ITEM(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_TEST_ITEM))
-#define RYGEL_IS_TEST_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_TEST_ITEM))
-#define RYGEL_TEST_ITEM_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_TEST_ITEM, RygelTestItemClass))
-
-typedef struct _RygelTestItem RygelTestItem;
-typedef struct _RygelTestItemClass RygelTestItemClass;
-typedef struct _RygelTestItemPrivate RygelTestItemPrivate;
-
-#define RYGEL_TYPE_TEST_VIDEO_ITEM (rygel_test_video_item_get_type ())
-#define RYGEL_TEST_VIDEO_ITEM(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_TEST_VIDEO_ITEM, RygelTestVideoItem))
-#define RYGEL_TEST_VIDEO_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_TEST_VIDEO_ITEM, RygelTestVideoItemClass))
-#define RYGEL_IS_TEST_VIDEO_ITEM(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_TEST_VIDEO_ITEM))
-#define RYGEL_IS_TEST_VIDEO_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_TEST_VIDEO_ITEM))
-#define RYGEL_TEST_VIDEO_ITEM_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_TEST_VIDEO_ITEM, RygelTestVideoItemClass))
-
-typedef struct _RygelTestVideoItem RygelTestVideoItem;
-typedef struct _RygelTestVideoItemClass RygelTestVideoItemClass;
-typedef struct _RygelTestVideoItemPrivate RygelTestVideoItemPrivate;
-#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
-
-struct _RygelTestItem {
-	RygelMediaItem parent_instance;
-	RygelTestItemPrivate * priv;
-};
-
-struct _RygelTestItemClass {
-	RygelMediaItemClass parent_class;
-};
-
-struct _RygelTestVideoItem {
-	RygelTestItem parent_instance;
-	RygelTestVideoItemPrivate * priv;
-};
-
-struct _RygelTestVideoItemClass {
-	RygelTestItemClass parent_class;
-};
-
-
-static gpointer rygel_test_video_item_parent_class = NULL;
-
-GType rygel_test_item_get_type (void);
-GType rygel_test_video_item_get_type (void);
-enum  {
-	RYGEL_TEST_VIDEO_ITEM_DUMMY_PROPERTY
-};
-#define RYGEL_TEST_VIDEO_ITEM_TEST_MIMETYPE "video/mpeg"
-RygelTestItem* rygel_test_item_construct (GType object_type, const char* id, RygelMediaContainer* parent, const char* title, const char* mime, const char* upnp_class);
-RygelTestVideoItem* rygel_test_video_item_new (const char* id, RygelMediaContainer* parent, const char* title);
-RygelTestVideoItem* rygel_test_video_item_construct (GType object_type, const char* id, RygelMediaContainer* parent, const char* title);
-static GstElement* rygel_test_video_item_real_create_stream_source (RygelMediaItem* base);
-
-
-
-RygelTestVideoItem* rygel_test_video_item_construct (GType object_type, const char* id, RygelMediaContainer* parent, const char* title) {
-	RygelTestVideoItem * self;
-	g_return_val_if_fail (id != NULL, NULL);
-	g_return_val_if_fail (parent != NULL, NULL);
-	g_return_val_if_fail (title != NULL, NULL);
-	self = (RygelTestVideoItem*) rygel_test_item_construct (object_type, id, parent, title, RYGEL_TEST_VIDEO_ITEM_TEST_MIMETYPE, RYGEL_MEDIA_ITEM_VIDEO_CLASS);
-	return self;
-}
-
-
-RygelTestVideoItem* rygel_test_video_item_new (const char* id, RygelMediaContainer* parent, const char* title) {
-	return rygel_test_video_item_construct (RYGEL_TYPE_TEST_VIDEO_ITEM, id, parent, title);
-}
-
-
-static GstElement* rygel_test_video_item_real_create_stream_source (RygelMediaItem* base) {
-	RygelTestVideoItem * self;
-	GstElement* result;
-	GError * _inner_error_;
-	self = (RygelTestVideoItem*) base;
-	_inner_error_ = NULL;
-	{
-		GstElement* _tmp0_;
-		_tmp0_ = gst_parse_bin_from_description ("videotestsrc is-live=1 ! ffenc_mpeg2video ! mpegtsmux", TRUE, &_inner_error_);
-		if (_inner_error_ != NULL) {
-			goto __catch1_g_error;
-			goto __finally1;
-		}
-		result = _tmp0_;
-		return result;
-	}
-	goto __finally1;
-	__catch1_g_error:
-	{
-		GError * err;
-		err = _inner_error_;
-		_inner_error_ = NULL;
-		{
-			g_warning ("rygel-test-video-item.vala:49: Required plugin missing (%s)", err->message);
-			result = NULL;
-			_g_error_free0 (err);
-			return result;
-		}
-	}
-	__finally1:
-	if (_inner_error_ != NULL) {
-		g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
-		g_clear_error (&_inner_error_);
-		return NULL;
-	}
-}
-
-
-static void rygel_test_video_item_class_init (RygelTestVideoItemClass * klass) {
-	rygel_test_video_item_parent_class = g_type_class_peek_parent (klass);
-	RYGEL_MEDIA_ITEM_CLASS (klass)->create_stream_source = rygel_test_video_item_real_create_stream_source;
-}
-
-
-static void rygel_test_video_item_instance_init (RygelTestVideoItem * self) {
-}
-
-
-GType rygel_test_video_item_get_type (void) {
-	static GType rygel_test_video_item_type_id = 0;
-	if (rygel_test_video_item_type_id == 0) {
-		static const GTypeInfo g_define_type_info = { sizeof (RygelTestVideoItemClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) rygel_test_video_item_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (RygelTestVideoItem), 0, (GInstanceInitFunc) rygel_test_video_item_instance_init, NULL };
-		rygel_test_video_item_type_id = g_type_register_static (RYGEL_TYPE_TEST_ITEM, "RygelTestVideoItem", &g_define_type_info, 0);
-	}
-	return rygel_test_video_item_type_id;
-}
-
-
-
-
--- a/src/plugins/tracker/Makefile.in
+++ b/src/plugins/tracker/Makefile.in
@@ -45,7 +45,8 @@ DIST_COMMON = $(srcdir)/Makefile.am $(sr
 	rygel-tracker-search-container.c rygel-tracker-search-result.c \
 	rygel-tracker-video-item.c
 ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
-am__aclocal_m4_deps = $(top_srcdir)/m4/libtool.m4 \
+am__aclocal_m4_deps = $(top_srcdir)/m4/glib-gettext.m4 \
+	$(top_srcdir)/m4/isc-posix.m4 $(top_srcdir)/m4/libtool.m4 \
 	$(top_srcdir)/m4/ltoptions.m4 $(top_srcdir)/m4/ltsugar.m4 \
 	$(top_srcdir)/m4/ltversion.m4 $(top_srcdir)/m4/lt~obsolete.m4 \
 	$(top_srcdir)/configure.ac
@@ -81,7 +82,7 @@ LTLIBRARIES = $(plugin_LTLIBRARIES)
 am__DEPENDENCIES_1 =
 librygel_media_tracker_la_DEPENDENCIES = $(am__DEPENDENCIES_1) \
 	$(am__DEPENDENCIES_1) $(am__DEPENDENCIES_1) \
-	$(am__DEPENDENCIES_1) $(am__DEPENDENCIES_1)
+	$(am__DEPENDENCIES_1)
 am_librygel_media_tracker_la_OBJECTS = rygel-media-tracker.lo \
 	rygel-tracker-root-container.lo \
 	rygel-tracker-metadata-values.lo rygel-tracker-keywords.lo \
@@ -174,8 +175,6 @@ GMSGFMT = @GMSGFMT@
 GREP = @GREP@
 GTK_CFLAGS = @GTK_CFLAGS@
 GTK_LIBS = @GTK_LIBS@
-GUPNP_VALA_CFLAGS = @GUPNP_VALA_CFLAGS@
-GUPNP_VALA_LIBS = @GUPNP_VALA_LIBS@
 HAVE_GTK = @HAVE_GTK@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
@@ -190,8 +189,8 @@ LIBDBUS_GLIB_CFLAGS = @LIBDBUS_GLIB_CFLA
 LIBDBUS_GLIB_LIBS = @LIBDBUS_GLIB_LIBS@
 LIBGIO_CFLAGS = @LIBGIO_CFLAGS@
 LIBGIO_LIBS = @LIBGIO_LIBS@
-LIBGSTREAMER_CFLAGS = @LIBGSTREAMER_CFLAGS@
-LIBGSTREAMER_LIBS = @LIBGSTREAMER_LIBS@
+LIBGLIB_CFLAGS = @LIBGLIB_CFLAGS@
+LIBGLIB_LIBS = @LIBGLIB_LIBS@
 LIBGUPNP_AV_CFLAGS = @LIBGUPNP_AV_CFLAGS@
 LIBGUPNP_AV_LIBS = @LIBGUPNP_AV_LIBS@
 LIBGUPNP_CFLAGS = @LIBGUPNP_CFLAGS@
@@ -203,6 +202,8 @@ LIBSOUP_LIBS = @LIBSOUP_LIBS@
 LIBSQLITE3_CFLAGS = @LIBSQLITE3_CFLAGS@
 LIBSQLITE3_LIBS = @LIBSQLITE3_LIBS@
 LIBTOOL = @LIBTOOL@
+LIBVLC_CFLAGS = @LIBVLC_CFLAGS@
+LIBVLC_LIBS = @LIBVLC_LIBS@
 LIPO = @LIPO@
 LN_S = @LN_S@
 LTLIBOBJS = @LTLIBOBJS@
@@ -223,6 +224,7 @@ PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
 PACKAGE_NAME = @PACKAGE_NAME@
 PACKAGE_STRING = @PACKAGE_STRING@
 PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_URL = @PACKAGE_URL@
 PACKAGE_VERSION = @PACKAGE_VERSION@
 PATH_SEPARATOR = @PATH_SEPARATOR@
 PKG_CONFIG = @PKG_CONFIG@
@@ -236,8 +238,6 @@ SET_MAKE = @SET_MAKE@
 SHELL = @SHELL@
 STRIP = @STRIP@
 USE_NLS = @USE_NLS@
-UUID_CFLAGS = @UUID_CFLAGS@
-UUID_LIBS = @UUID_LIBS@
 VALAC = @VALAC@
 VAPIDIR = @VAPIDIR@
 VERSION = @VERSION@
--- a/src/plugins/tracker/rygel-media-tracker.c
+++ /dev/null
@@ -1,131 +0,0 @@
-/* rygel-media-tracker.c generated by valac, the Vala compiler
- * generated from rygel-media-tracker.vala, do not modify */
-
-/*
- * Copyright (C) 2008 Zeeshan Ali <zeenix@gmail.com>.
- * Copyright (C) 2008 Nokia Corporation.
- *
- * Author: Zeeshan Ali <zeenix@gmail.com>
- *
- * This file is part of Rygel.
- *
- * Rygel is free software; you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * Rygel is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this program; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
- */
-
-#include <glib.h>
-#include <glib-object.h>
-#include <rygel.h>
-#include <libgupnp/gupnp.h>
-#include <stdlib.h>
-#include <string.h>
-
-
-#define RYGEL_TYPE_MEDIA_TRACKER (rygel_media_tracker_get_type ())
-#define RYGEL_MEDIA_TRACKER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_MEDIA_TRACKER, RygelMediaTracker))
-#define RYGEL_MEDIA_TRACKER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_MEDIA_TRACKER, RygelMediaTrackerClass))
-#define RYGEL_IS_MEDIA_TRACKER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_MEDIA_TRACKER))
-#define RYGEL_IS_MEDIA_TRACKER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_MEDIA_TRACKER))
-#define RYGEL_MEDIA_TRACKER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_MEDIA_TRACKER, RygelMediaTrackerClass))
-
-typedef struct _RygelMediaTracker RygelMediaTracker;
-typedef struct _RygelMediaTrackerClass RygelMediaTrackerClass;
-typedef struct _RygelMediaTrackerPrivate RygelMediaTrackerPrivate;
-#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
-
-#define RYGEL_TYPE_TRACKER_ROOT_CONTAINER (rygel_tracker_root_container_get_type ())
-#define RYGEL_TRACKER_ROOT_CONTAINER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_TRACKER_ROOT_CONTAINER, RygelTrackerRootContainer))
-#define RYGEL_TRACKER_ROOT_CONTAINER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_TRACKER_ROOT_CONTAINER, RygelTrackerRootContainerClass))
-#define RYGEL_IS_TRACKER_ROOT_CONTAINER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_TRACKER_ROOT_CONTAINER))
-#define RYGEL_IS_TRACKER_ROOT_CONTAINER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_TRACKER_ROOT_CONTAINER))
-#define RYGEL_TRACKER_ROOT_CONTAINER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_TRACKER_ROOT_CONTAINER, RygelTrackerRootContainerClass))
-
-typedef struct _RygelTrackerRootContainer RygelTrackerRootContainer;
-typedef struct _RygelTrackerRootContainerClass RygelTrackerRootContainerClass;
-#define _g_free0(var) (var = (g_free (var), NULL))
-
-struct _RygelMediaTracker {
-	RygelContentDirectory parent_instance;
-	RygelMediaTrackerPrivate * priv;
-};
-
-struct _RygelMediaTrackerClass {
-	RygelContentDirectoryClass parent_class;
-};
-
-
-static gpointer rygel_media_tracker_parent_class = NULL;
-
-GType rygel_media_tracker_get_type (void);
-enum  {
-	RYGEL_MEDIA_TRACKER_DUMMY_PROPERTY
-};
-RygelTrackerRootContainer* rygel_tracker_root_container_new (const char* title);
-RygelTrackerRootContainer* rygel_tracker_root_container_construct (GType object_type, const char* title);
-GType rygel_tracker_root_container_get_type (void);
-static RygelMediaContainer* rygel_media_tracker_real_create_root_container (RygelContentDirectory* base);
-RygelMediaTracker* rygel_media_tracker_new (void);
-RygelMediaTracker* rygel_media_tracker_construct (GType object_type);
-
-
-
-static RygelMediaContainer* rygel_media_tracker_real_create_root_container (RygelContentDirectory* base) {
-	RygelMediaTracker * self;
-	RygelMediaContainer* result;
-	GUPnPRootDevice* _tmp1_;
-	GUPnPRootDevice* _tmp0_ = NULL;
-	char* _tmp2_;
-	char* friendly_name;
-	self = (RygelMediaTracker*) base;
-	friendly_name = (_tmp2_ = gupnp_device_info_get_friendly_name ((GUPnPDeviceInfo*) (_tmp1_ = (g_object_get ((GUPnPService*) self, "root-device", &_tmp0_, NULL), _tmp0_))), _g_object_unref0 (_tmp1_), _tmp2_);
-	result = (RygelMediaContainer*) rygel_tracker_root_container_new (friendly_name);
-	_g_free0 (friendly_name);
-	return result;
-}
-
-
-RygelMediaTracker* rygel_media_tracker_construct (GType object_type) {
-	RygelMediaTracker * self;
-	self = (RygelMediaTracker*) rygel_content_directory_construct (object_type);
-	return self;
-}
-
-
-RygelMediaTracker* rygel_media_tracker_new (void) {
-	return rygel_media_tracker_construct (RYGEL_TYPE_MEDIA_TRACKER);
-}
-
-
-static void rygel_media_tracker_class_init (RygelMediaTrackerClass * klass) {
-	rygel_media_tracker_parent_class = g_type_class_peek_parent (klass);
-	RYGEL_CONTENT_DIRECTORY_CLASS (klass)->create_root_container = rygel_media_tracker_real_create_root_container;
-}
-
-
-static void rygel_media_tracker_instance_init (RygelMediaTracker * self) {
-}
-
-
-GType rygel_media_tracker_get_type (void) {
-	static GType rygel_media_tracker_type_id = 0;
-	if (rygel_media_tracker_type_id == 0) {
-		static const GTypeInfo g_define_type_info = { sizeof (RygelMediaTrackerClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) rygel_media_tracker_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (RygelMediaTracker), 0, (GInstanceInitFunc) rygel_media_tracker_instance_init, NULL };
-		rygel_media_tracker_type_id = g_type_register_static (RYGEL_TYPE_CONTENT_DIRECTORY, "RygelMediaTracker", &g_define_type_info, 0);
-	}
-	return rygel_media_tracker_type_id;
-}
-
-
-
-
--- a/src/plugins/tracker/rygel-tracker-get-metadata-result.c
+++ /dev/null
@@ -1,160 +0,0 @@
-/* rygel-tracker-get-metadata-result.c generated by valac, the Vala compiler
- * generated from rygel-tracker-get-metadata-result.vala, do not modify */
-
-/*
- * Copyright (C) 2009 Nokia Corporation.
- *
- * Author: Zeeshan Ali (Khattak) <zeeshanak@gnome.org>
- *
- * This file is part of Rygel.
- *
- * Rygel is free software; you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * Rygel is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this program; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
- */
-
-#include <glib.h>
-#include <glib-object.h>
-#include <rygel.h>
-#include <stdlib.h>
-#include <string.h>
-#include <gio/gio.h>
-
-
-#define RYGEL_TYPE_TRACKER_GET_METADATA_RESULT (rygel_tracker_get_metadata_result_get_type ())
-#define RYGEL_TRACKER_GET_METADATA_RESULT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_TRACKER_GET_METADATA_RESULT, RygelTrackerGetMetadataResult))
-#define RYGEL_TRACKER_GET_METADATA_RESULT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_TRACKER_GET_METADATA_RESULT, RygelTrackerGetMetadataResultClass))
-#define RYGEL_IS_TRACKER_GET_METADATA_RESULT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_TRACKER_GET_METADATA_RESULT))
-#define RYGEL_IS_TRACKER_GET_METADATA_RESULT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_TRACKER_GET_METADATA_RESULT))
-#define RYGEL_TRACKER_GET_METADATA_RESULT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_TRACKER_GET_METADATA_RESULT, RygelTrackerGetMetadataResultClass))
-
-typedef struct _RygelTrackerGetMetadataResult RygelTrackerGetMetadataResult;
-typedef struct _RygelTrackerGetMetadataResultClass RygelTrackerGetMetadataResultClass;
-typedef struct _RygelTrackerGetMetadataResultPrivate RygelTrackerGetMetadataResultPrivate;
-#define _g_free0(var) (var = (g_free (var), NULL))
-
-#define RYGEL_TYPE_TRACKER_SEARCH_CONTAINER (rygel_tracker_search_container_get_type ())
-#define RYGEL_TRACKER_SEARCH_CONTAINER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_TRACKER_SEARCH_CONTAINER, RygelTrackerSearchContainer))
-#define RYGEL_TRACKER_SEARCH_CONTAINER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_TRACKER_SEARCH_CONTAINER, RygelTrackerSearchContainerClass))
-#define RYGEL_IS_TRACKER_SEARCH_CONTAINER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_TRACKER_SEARCH_CONTAINER))
-#define RYGEL_IS_TRACKER_SEARCH_CONTAINER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_TRACKER_SEARCH_CONTAINER))
-#define RYGEL_TRACKER_SEARCH_CONTAINER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_TRACKER_SEARCH_CONTAINER, RygelTrackerSearchContainerClass))
-
-typedef struct _RygelTrackerSearchContainer RygelTrackerSearchContainer;
-typedef struct _RygelTrackerSearchContainerClass RygelTrackerSearchContainerClass;
-#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
-#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
-
-struct _RygelTrackerGetMetadataResult {
-	RygelSimpleAsyncResult parent_instance;
-	RygelTrackerGetMetadataResultPrivate * priv;
-	char* item_id;
-	char* item_path;
-	char* item_service;
-};
-
-struct _RygelTrackerGetMetadataResultClass {
-	RygelSimpleAsyncResultClass parent_class;
-};
-
-
-static gpointer rygel_tracker_get_metadata_result_parent_class = NULL;
-
-GType rygel_tracker_get_metadata_result_get_type (void);
-enum  {
-	RYGEL_TRACKER_GET_METADATA_RESULT_DUMMY_PROPERTY
-};
-GType rygel_tracker_search_container_get_type (void);
-RygelTrackerGetMetadataResult* rygel_tracker_get_metadata_result_new (RygelTrackerSearchContainer* search_container, GAsyncReadyCallback callback, void* callback_target, const char* item_id);
-RygelTrackerGetMetadataResult* rygel_tracker_get_metadata_result_construct (GType object_type, RygelTrackerSearchContainer* search_container, GAsyncReadyCallback callback, void* callback_target, const char* item_id);
-RygelMediaItem* rygel_tracker_search_container_create_item (RygelTrackerSearchContainer* self, const char* service, const char* path, char** metadata, int metadata_length1);
-void rygel_tracker_get_metadata_result_ready (RygelTrackerGetMetadataResult* self, char** metadata, int metadata_length1, GError* _error_);
-static void rygel_tracker_get_metadata_result_finalize (GObject* obj);
-
-
-
-RygelTrackerGetMetadataResult* rygel_tracker_get_metadata_result_construct (GType object_type, RygelTrackerSearchContainer* search_container, GAsyncReadyCallback callback, void* callback_target, const char* item_id) {
-	RygelTrackerGetMetadataResult * self;
-	char* _tmp0_;
-	g_return_val_if_fail (search_container != NULL, NULL);
-	g_return_val_if_fail (item_id != NULL, NULL);
-	self = (RygelTrackerGetMetadataResult*) rygel_simple_async_result_construct (object_type, RYGEL_TYPE_MEDIA_OBJECT, (GBoxedCopyFunc) g_object_ref, g_object_unref, (GObject*) search_container, callback, callback_target);
-	self->item_id = (_tmp0_ = g_strdup (item_id), _g_free0 (self->item_id), _tmp0_);
-	return self;
-}
-
-
-RygelTrackerGetMetadataResult* rygel_tracker_get_metadata_result_new (RygelTrackerSearchContainer* search_container, GAsyncReadyCallback callback, void* callback_target, const char* item_id) {
-	return rygel_tracker_get_metadata_result_construct (RYGEL_TYPE_TRACKER_GET_METADATA_RESULT, search_container, callback, callback_target, item_id);
-}
-
-
-static gpointer _g_error_copy0 (gpointer self) {
-	return self ? g_error_copy (self) : NULL;
-}
-
-
-static gpointer _g_object_ref0 (gpointer self) {
-	return self ? g_object_ref (self) : NULL;
-}
-
-
-void rygel_tracker_get_metadata_result_ready (RygelTrackerGetMetadataResult* self, char** metadata, int metadata_length1, GError* _error_) {
-	RygelTrackerSearchContainer* search_container;
-	RygelMediaObject* _tmp1_;
-	g_return_if_fail (self != NULL);
-	if (_error_ != NULL) {
-		GError* _tmp0_;
-		((RygelSimpleAsyncResult*) self)->error = (_tmp0_ = _g_error_copy0 (_error_), _g_error_free0 (((RygelSimpleAsyncResult*) self)->error), _tmp0_);
-		rygel_simple_async_result_complete ((RygelSimpleAsyncResult*) self);
-		return;
-	}
-	search_container = _g_object_ref0 (RYGEL_TRACKER_SEARCH_CONTAINER (((RygelSimpleAsyncResult*) self)->source_object));
-	((RygelSimpleAsyncResult*) self)->data = (_tmp1_ = (RygelMediaObject*) rygel_tracker_search_container_create_item (search_container, self->item_service, self->item_path, metadata, metadata_length1), _g_object_unref0 (((RygelSimpleAsyncResult*) self)->data), _tmp1_);
-	rygel_simple_async_result_complete ((RygelSimpleAsyncResult*) self);
-	_g_object_unref0 (search_container);
-}
-
-
-static void rygel_tracker_get_metadata_result_class_init (RygelTrackerGetMetadataResultClass * klass) {
-	rygel_tracker_get_metadata_result_parent_class = g_type_class_peek_parent (klass);
-	G_OBJECT_CLASS (klass)->finalize = rygel_tracker_get_metadata_result_finalize;
-}
-
-
-static void rygel_tracker_get_metadata_result_instance_init (RygelTrackerGetMetadataResult * self) {
-}
-
-
-static void rygel_tracker_get_metadata_result_finalize (GObject* obj) {
-	RygelTrackerGetMetadataResult * self;
-	self = RYGEL_TRACKER_GET_METADATA_RESULT (obj);
-	_g_free0 (self->item_id);
-	_g_free0 (self->item_path);
-	_g_free0 (self->item_service);
-	G_OBJECT_CLASS (rygel_tracker_get_metadata_result_parent_class)->finalize (obj);
-}
-
-
-GType rygel_tracker_get_metadata_result_get_type (void) {
-	static GType rygel_tracker_get_metadata_result_type_id = 0;
-	if (rygel_tracker_get_metadata_result_type_id == 0) {
-		static const GTypeInfo g_define_type_info = { sizeof (RygelTrackerGetMetadataResultClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) rygel_tracker_get_metadata_result_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (RygelTrackerGetMetadataResult), 0, (GInstanceInitFunc) rygel_tracker_get_metadata_result_instance_init, NULL };
-		rygel_tracker_get_metadata_result_type_id = g_type_register_static (RYGEL_TYPE_SIMPLE_ASYNC_RESULT, "RygelTrackerGetMetadataResult", &g_define_type_info, 0);
-	}
-	return rygel_tracker_get_metadata_result_type_id;
-}
-
-
-
-
--- a/src/plugins/tracker/rygel-tracker-image-item.c
+++ /dev/null
@@ -1,200 +0,0 @@
-/* rygel-tracker-image-item.c generated by valac, the Vala compiler
- * generated from rygel-tracker-image-item.vala, do not modify */
-
-/*
- * Copyright (C) 2008 Zeeshan Ali <zeenix@gmail.com>.
- * Copyright (C) 2008 Nokia Corporation.
- *
- * Author: Zeeshan Ali <zeenix@gmail.com>
- *
- * This file is part of Rygel.
- *
- * Rygel is free software; you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * Rygel is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this program; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
- */
-
-#include <glib.h>
-#include <glib-object.h>
-#include <rygel.h>
-#include <stdlib.h>
-#include <string.h>
-
-
-#define RYGEL_TYPE_TRACKER_ITEM (rygel_tracker_item_get_type ())
-#define RYGEL_TRACKER_ITEM(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_TRACKER_ITEM, RygelTrackerItem))
-#define RYGEL_TRACKER_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_TRACKER_ITEM, RygelTrackerItemClass))
-#define RYGEL_IS_TRACKER_ITEM(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_TRACKER_ITEM))
-#define RYGEL_IS_TRACKER_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_TRACKER_ITEM))
-#define RYGEL_TRACKER_ITEM_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_TRACKER_ITEM, RygelTrackerItemClass))
-
-typedef struct _RygelTrackerItem RygelTrackerItem;
-typedef struct _RygelTrackerItemClass RygelTrackerItemClass;
-typedef struct _RygelTrackerItemPrivate RygelTrackerItemPrivate;
-
-#define RYGEL_TYPE_TRACKER_IMAGE_ITEM (rygel_tracker_image_item_get_type ())
-#define RYGEL_TRACKER_IMAGE_ITEM(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_TRACKER_IMAGE_ITEM, RygelTrackerImageItem))
-#define RYGEL_TRACKER_IMAGE_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_TRACKER_IMAGE_ITEM, RygelTrackerImageItemClass))
-#define RYGEL_IS_TRACKER_IMAGE_ITEM(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_TRACKER_IMAGE_ITEM))
-#define RYGEL_IS_TRACKER_IMAGE_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_TRACKER_IMAGE_ITEM))
-#define RYGEL_TRACKER_IMAGE_ITEM_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_TRACKER_IMAGE_ITEM, RygelTrackerImageItemClass))
-
-typedef struct _RygelTrackerImageItem RygelTrackerImageItem;
-typedef struct _RygelTrackerImageItemClass RygelTrackerImageItemClass;
-typedef struct _RygelTrackerImageItemPrivate RygelTrackerImageItemPrivate;
-
-#define RYGEL_TYPE_TRACKER_SEARCH_CONTAINER (rygel_tracker_search_container_get_type ())
-#define RYGEL_TRACKER_SEARCH_CONTAINER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_TRACKER_SEARCH_CONTAINER, RygelTrackerSearchContainer))
-#define RYGEL_TRACKER_SEARCH_CONTAINER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_TRACKER_SEARCH_CONTAINER, RygelTrackerSearchContainerClass))
-#define RYGEL_IS_TRACKER_SEARCH_CONTAINER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_TRACKER_SEARCH_CONTAINER))
-#define RYGEL_IS_TRACKER_SEARCH_CONTAINER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_TRACKER_SEARCH_CONTAINER))
-#define RYGEL_TRACKER_SEARCH_CONTAINER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_TRACKER_SEARCH_CONTAINER, RygelTrackerSearchContainerClass))
-
-typedef struct _RygelTrackerSearchContainer RygelTrackerSearchContainer;
-typedef struct _RygelTrackerSearchContainerClass RygelTrackerSearchContainerClass;
-
-#define RYGEL_TRACKER_ITEM_TYPE_METADATA (rygel_tracker_item_metadata_get_type ())
-#define _g_free0(var) (var = (g_free (var), NULL))
-
-struct _RygelTrackerItem {
-	RygelMediaItem parent_instance;
-	RygelTrackerItemPrivate * priv;
-	char* path;
-};
-
-struct _RygelTrackerItemClass {
-	RygelMediaItemClass parent_class;
-};
-
-struct _RygelTrackerImageItem {
-	RygelTrackerItem parent_instance;
-	RygelTrackerImageItemPrivate * priv;
-};
-
-struct _RygelTrackerImageItemClass {
-	RygelTrackerItemClass parent_class;
-};
-
-typedef enum  {
-	RYGEL_TRACKER_ITEM_METADATA_FILE_NAME,
-	RYGEL_TRACKER_ITEM_METADATA_MIME,
-	RYGEL_TRACKER_ITEM_METADATA_SIZE,
-	RYGEL_TRACKER_ITEM_METADATA_DATE,
-	RYGEL_TRACKER_ITEM_METADATA_IMAGE_TITLE,
-	RYGEL_TRACKER_ITEM_METADATA_IMAGE_WIDTH,
-	RYGEL_TRACKER_ITEM_METADATA_IMAGE_HEIGHT,
-	RYGEL_TRACKER_ITEM_METADATA_IMAGE_ALBUM,
-	RYGEL_TRACKER_ITEM_METADATA_IMAGE_DATE,
-	RYGEL_TRACKER_ITEM_METADATA_CREATOR,
-	RYGEL_TRACKER_ITEM_METADATA_AUDIO_TITLE,
-	RYGEL_TRACKER_ITEM_METADATA_AUDIO_DURATION,
-	RYGEL_TRACKER_ITEM_METADATA_AUDIO_ALBUM,
-	RYGEL_TRACKER_ITEM_METADATA_ARTIST,
-	RYGEL_TRACKER_ITEM_METADATA_TRACK_NUM,
-	RYGEL_TRACKER_ITEM_METADATA_RELEASE,
-	RYGEL_TRACKER_ITEM_METADATA_DATE_ADDED,
-	RYGEL_TRACKER_ITEM_METADATA_VIDEO_TITLE,
-	RYGEL_TRACKER_ITEM_METADATA_VIDEO_WIDTH,
-	RYGEL_TRACKER_ITEM_METADATA_VIDEO_HEIGHT,
-	RYGEL_TRACKER_ITEM_METADATA_VIDEO_DURATION,
-	RYGEL_TRACKER_ITEM_METADATA_AUTHOR,
-	RYGEL_TRACKER_ITEM_METADATA_LAST_KEY
-} RygelTrackerItemMetadata;
-
-
-static gpointer rygel_tracker_image_item_parent_class = NULL;
-
-GType rygel_tracker_item_get_type (void);
-GType rygel_tracker_image_item_get_type (void);
-enum  {
-	RYGEL_TRACKER_IMAGE_ITEM_DUMMY_PROPERTY
-};
-#define RYGEL_TRACKER_IMAGE_ITEM_SERVICE "Images"
-GType rygel_tracker_search_container_get_type (void);
-RygelTrackerItem* rygel_tracker_item_construct (GType object_type, const char* id, const char* path, RygelTrackerSearchContainer* parent, const char* upnp_class, char** metadata, int metadata_length1);
-GType rygel_tracker_item_metadata_get_type (void);
-char* rygel_tracker_item_seconds_to_iso8601 (RygelTrackerItem* self, const char* seconds);
-RygelTrackerImageItem* rygel_tracker_image_item_new (const char* id, const char* path, RygelTrackerSearchContainer* parent, char** metadata, int metadata_length1);
-RygelTrackerImageItem* rygel_tracker_image_item_construct (GType object_type, const char* id, const char* path, RygelTrackerSearchContainer* parent, char** metadata, int metadata_length1);
-static int _vala_strcmp0 (const char * str1, const char * str2);
-
-
-
-RygelTrackerImageItem* rygel_tracker_image_item_construct (GType object_type, const char* id, const char* path, RygelTrackerSearchContainer* parent, char** metadata, int metadata_length1) {
-	RygelTrackerImageItem * self;
-	char* _tmp3_;
-	char* _tmp4_;
-	g_return_val_if_fail (id != NULL, NULL);
-	g_return_val_if_fail (path != NULL, NULL);
-	g_return_val_if_fail (parent != NULL, NULL);
-	self = (RygelTrackerImageItem*) rygel_tracker_item_construct (object_type, id, path, parent, RYGEL_MEDIA_ITEM_IMAGE_CLASS, metadata, metadata_length1);
-	if (_vala_strcmp0 (metadata[RYGEL_TRACKER_ITEM_METADATA_IMAGE_TITLE], "") != 0) {
-		char* _tmp0_;
-		((RygelMediaObject*) self)->title = (_tmp0_ = g_strdup (metadata[RYGEL_TRACKER_ITEM_METADATA_IMAGE_TITLE]), _g_free0 (((RygelMediaObject*) self)->title), _tmp0_);
-	} else {
-		char* _tmp1_;
-		((RygelMediaObject*) self)->title = (_tmp1_ = g_strdup (metadata[RYGEL_TRACKER_ITEM_METADATA_FILE_NAME]), _g_free0 (((RygelMediaObject*) self)->title), _tmp1_);
-	}
-	if (_vala_strcmp0 (metadata[RYGEL_TRACKER_ITEM_METADATA_IMAGE_WIDTH], "") != 0) {
-		((RygelMediaItem*) self)->width = atoi (metadata[RYGEL_TRACKER_ITEM_METADATA_IMAGE_WIDTH]);
-	}
-	if (_vala_strcmp0 (metadata[RYGEL_TRACKER_ITEM_METADATA_IMAGE_HEIGHT], "") != 0) {
-		((RygelMediaItem*) self)->height = atoi (metadata[RYGEL_TRACKER_ITEM_METADATA_IMAGE_HEIGHT]);
-	}
-	if (_vala_strcmp0 (metadata[RYGEL_TRACKER_ITEM_METADATA_IMAGE_DATE], "") != 0) {
-		char* _tmp2_;
-		((RygelMediaItem*) self)->date = (_tmp2_ = rygel_tracker_item_seconds_to_iso8601 ((RygelTrackerItem*) self, metadata[RYGEL_TRACKER_ITEM_METADATA_IMAGE_DATE]), _g_free0 (((RygelMediaItem*) self)->date), _tmp2_);
-	}
-	((RygelMediaItem*) self)->author = (_tmp3_ = g_strdup (metadata[RYGEL_TRACKER_ITEM_METADATA_CREATOR]), _g_free0 (((RygelMediaItem*) self)->author), _tmp3_);
-	((RygelMediaItem*) self)->album = (_tmp4_ = g_strdup (metadata[RYGEL_TRACKER_ITEM_METADATA_IMAGE_ALBUM]), _g_free0 (((RygelMediaItem*) self)->album), _tmp4_);
-	return self;
-}
-
-
-RygelTrackerImageItem* rygel_tracker_image_item_new (const char* id, const char* path, RygelTrackerSearchContainer* parent, char** metadata, int metadata_length1) {
-	return rygel_tracker_image_item_construct (RYGEL_TYPE_TRACKER_IMAGE_ITEM, id, path, parent, metadata, metadata_length1);
-}
-
-
-static void rygel_tracker_image_item_class_init (RygelTrackerImageItemClass * klass) {
-	rygel_tracker_image_item_parent_class = g_type_class_peek_parent (klass);
-}
-
-
-static void rygel_tracker_image_item_instance_init (RygelTrackerImageItem * self) {
-}
-
-
-GType rygel_tracker_image_item_get_type (void) {
-	static GType rygel_tracker_image_item_type_id = 0;
-	if (rygel_tracker_image_item_type_id == 0) {
-		static const GTypeInfo g_define_type_info = { sizeof (RygelTrackerImageItemClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) rygel_tracker_image_item_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (RygelTrackerImageItem), 0, (GInstanceInitFunc) rygel_tracker_image_item_instance_init, NULL };
-		rygel_tracker_image_item_type_id = g_type_register_static (RYGEL_TYPE_TRACKER_ITEM, "RygelTrackerImageItem", &g_define_type_info, 0);
-	}
-	return rygel_tracker_image_item_type_id;
-}
-
-
-static int _vala_strcmp0 (const char * str1, const char * str2) {
-	if (str1 == NULL) {
-		return -(str1 != str2);
-	}
-	if (str2 == NULL) {
-		return str1 != str2;
-	}
-	return strcmp (str1, str2);
-}
-
-
-
-
--- a/src/plugins/tracker/rygel-tracker-item.c
+++ /dev/null
@@ -1,297 +0,0 @@
-/* rygel-tracker-item.c generated by valac, the Vala compiler
- * generated from rygel-tracker-item.vala, do not modify */
-
-/*
- * Copyright (C) 2008 Zeeshan Ali <zeenix@gmail.com>.
- * Copyright (C) 2008 Nokia Corporation.
- *
- * Author: Zeeshan Ali <zeenix@gmail.com>
- *
- * This file is part of Rygel.
- *
- * Rygel is free software; you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * Rygel is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this program; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
- */
-
-#include <glib.h>
-#include <glib-object.h>
-#include <rygel.h>
-#include <stdlib.h>
-#include <string.h>
-
-
-#define RYGEL_TYPE_TRACKER_ITEM (rygel_tracker_item_get_type ())
-#define RYGEL_TRACKER_ITEM(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_TRACKER_ITEM, RygelTrackerItem))
-#define RYGEL_TRACKER_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_TRACKER_ITEM, RygelTrackerItemClass))
-#define RYGEL_IS_TRACKER_ITEM(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_TRACKER_ITEM))
-#define RYGEL_IS_TRACKER_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_TRACKER_ITEM))
-#define RYGEL_TRACKER_ITEM_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_TRACKER_ITEM, RygelTrackerItemClass))
-
-typedef struct _RygelTrackerItem RygelTrackerItem;
-typedef struct _RygelTrackerItemClass RygelTrackerItemClass;
-typedef struct _RygelTrackerItemPrivate RygelTrackerItemPrivate;
-
-#define RYGEL_TRACKER_ITEM_TYPE_METADATA (rygel_tracker_item_metadata_get_type ())
-#define _g_free0(var) (var = (g_free (var), NULL))
-
-#define RYGEL_TYPE_TRACKER_SEARCH_CONTAINER (rygel_tracker_search_container_get_type ())
-#define RYGEL_TRACKER_SEARCH_CONTAINER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_TRACKER_SEARCH_CONTAINER, RygelTrackerSearchContainer))
-#define RYGEL_TRACKER_SEARCH_CONTAINER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_TRACKER_SEARCH_CONTAINER, RygelTrackerSearchContainerClass))
-#define RYGEL_IS_TRACKER_SEARCH_CONTAINER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_TRACKER_SEARCH_CONTAINER))
-#define RYGEL_IS_TRACKER_SEARCH_CONTAINER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_TRACKER_SEARCH_CONTAINER))
-#define RYGEL_TRACKER_SEARCH_CONTAINER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_TRACKER_SEARCH_CONTAINER, RygelTrackerSearchContainerClass))
-
-typedef struct _RygelTrackerSearchContainer RygelTrackerSearchContainer;
-typedef struct _RygelTrackerSearchContainerClass RygelTrackerSearchContainerClass;
-
-struct _RygelTrackerItem {
-	RygelMediaItem parent_instance;
-	RygelTrackerItemPrivate * priv;
-	char* path;
-};
-
-struct _RygelTrackerItemClass {
-	RygelMediaItemClass parent_class;
-};
-
-typedef enum  {
-	RYGEL_TRACKER_ITEM_METADATA_FILE_NAME,
-	RYGEL_TRACKER_ITEM_METADATA_MIME,
-	RYGEL_TRACKER_ITEM_METADATA_SIZE,
-	RYGEL_TRACKER_ITEM_METADATA_DATE,
-	RYGEL_TRACKER_ITEM_METADATA_IMAGE_TITLE,
-	RYGEL_TRACKER_ITEM_METADATA_IMAGE_WIDTH,
-	RYGEL_TRACKER_ITEM_METADATA_IMAGE_HEIGHT,
-	RYGEL_TRACKER_ITEM_METADATA_IMAGE_ALBUM,
-	RYGEL_TRACKER_ITEM_METADATA_IMAGE_DATE,
-	RYGEL_TRACKER_ITEM_METADATA_CREATOR,
-	RYGEL_TRACKER_ITEM_METADATA_AUDIO_TITLE,
-	RYGEL_TRACKER_ITEM_METADATA_AUDIO_DURATION,
-	RYGEL_TRACKER_ITEM_METADATA_AUDIO_ALBUM,
-	RYGEL_TRACKER_ITEM_METADATA_ARTIST,
-	RYGEL_TRACKER_ITEM_METADATA_TRACK_NUM,
-	RYGEL_TRACKER_ITEM_METADATA_RELEASE,
-	RYGEL_TRACKER_ITEM_METADATA_DATE_ADDED,
-	RYGEL_TRACKER_ITEM_METADATA_VIDEO_TITLE,
-	RYGEL_TRACKER_ITEM_METADATA_VIDEO_WIDTH,
-	RYGEL_TRACKER_ITEM_METADATA_VIDEO_HEIGHT,
-	RYGEL_TRACKER_ITEM_METADATA_VIDEO_DURATION,
-	RYGEL_TRACKER_ITEM_METADATA_AUTHOR,
-	RYGEL_TRACKER_ITEM_METADATA_LAST_KEY
-} RygelTrackerItemMetadata;
-
-
-static gpointer rygel_tracker_item_parent_class = NULL;
-
-GType rygel_tracker_item_get_type (void);
-enum  {
-	RYGEL_TRACKER_ITEM_DUMMY_PROPERTY
-};
-GType rygel_tracker_item_metadata_get_type (void);
-char* rygel_tracker_item_seconds_to_iso8601 (RygelTrackerItem* self, const char* seconds);
-GType rygel_tracker_search_container_get_type (void);
-RygelTrackerItem* rygel_tracker_item_construct (GType object_type, const char* id, const char* path, RygelTrackerSearchContainer* parent, const char* upnp_class, char** metadata, int metadata_length1);
-char** rygel_tracker_item_get_metadata_keys (int* result_length1);
-static void rygel_tracker_item_finalize (GObject* obj);
-static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
-static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);
-static int _vala_strcmp0 (const char * str1, const char * str2);
-
-
-
-
-GType rygel_tracker_item_metadata_get_type (void) {
-	static GType rygel_tracker_item_metadata_type_id = 0;
-	if (G_UNLIKELY (rygel_tracker_item_metadata_type_id == 0)) {
-		static const GEnumValue values[] = {{RYGEL_TRACKER_ITEM_METADATA_FILE_NAME, "RYGEL_TRACKER_ITEM_METADATA_FILE_NAME", "file-name"}, {RYGEL_TRACKER_ITEM_METADATA_MIME, "RYGEL_TRACKER_ITEM_METADATA_MIME", "mime"}, {RYGEL_TRACKER_ITEM_METADATA_SIZE, "RYGEL_TRACKER_ITEM_METADATA_SIZE", "size"}, {RYGEL_TRACKER_ITEM_METADATA_DATE, "RYGEL_TRACKER_ITEM_METADATA_DATE", "date"}, {RYGEL_TRACKER_ITEM_METADATA_IMAGE_TITLE, "RYGEL_TRACKER_ITEM_METADATA_IMAGE_TITLE", "image-title"}, {RYGEL_TRACKER_ITEM_METADATA_IMAGE_WIDTH, "RYGEL_TRACKER_ITEM_METADATA_IMAGE_WIDTH", "image-width"}, {RYGEL_TRACKER_ITEM_METADATA_IMAGE_HEIGHT, "RYGEL_TRACKER_ITEM_METADATA_IMAGE_HEIGHT", "image-height"}, {RYGEL_TRACKER_ITEM_METADATA_IMAGE_ALBUM, "RYGEL_TRACKER_ITEM_METADATA_IMAGE_ALBUM", "image-album"}, {RYGEL_TRACKER_ITEM_METADATA_IMAGE_DATE, "RYGEL_TRACKER_ITEM_METADATA_IMAGE_DATE", "image-date"}, {RYGEL_TRACKER_ITEM_METADATA_CREATOR, "RYGEL_TRACKER_ITEM_METADATA_CREATOR", "creator"}, {RYGEL_TRACKER_ITEM_METADATA_AUDIO_TITLE, "RYGEL_TRACKER_ITEM_METADATA_AUDIO_TITLE", "audio-title"}, {RYGEL_TRACKER_ITEM_METADATA_AUDIO_DURATION, "RYGEL_TRACKER_ITEM_METADATA_AUDIO_DURATION", "audio-duration"}, {RYGEL_TRACKER_ITEM_METADATA_AUDIO_ALBUM, "RYGEL_TRACKER_ITEM_METADATA_AUDIO_ALBUM", "audio-album"}, {RYGEL_TRACKER_ITEM_METADATA_ARTIST, "RYGEL_TRACKER_ITEM_METADATA_ARTIST", "artist"}, {RYGEL_TRACKER_ITEM_METADATA_TRACK_NUM, "RYGEL_TRACKER_ITEM_METADATA_TRACK_NUM", "track-num"}, {RYGEL_TRACKER_ITEM_METADATA_RELEASE, "RYGEL_TRACKER_ITEM_METADATA_RELEASE", "release"}, {RYGEL_TRACKER_ITEM_METADATA_DATE_ADDED, "RYGEL_TRACKER_ITEM_METADATA_DATE_ADDED", "date-added"}, {RYGEL_TRACKER_ITEM_METADATA_VIDEO_TITLE, "RYGEL_TRACKER_ITEM_METADATA_VIDEO_TITLE", "video-title"}, {RYGEL_TRACKER_ITEM_METADATA_VIDEO_WIDTH, "RYGEL_TRACKER_ITEM_METADATA_VIDEO_WIDTH", "video-width"}, {RYGEL_TRACKER_ITEM_METADATA_VIDEO_HEIGHT, "RYGEL_TRACKER_ITEM_METADATA_VIDEO_HEIGHT", "video-height"}, {RYGEL_TRACKER_ITEM_METADATA_VIDEO_DURATION, "RYGEL_TRACKER_ITEM_METADATA_VIDEO_DURATION", "video-duration"}, {RYGEL_TRACKER_ITEM_METADATA_AUTHOR, "RYGEL_TRACKER_ITEM_METADATA_AUTHOR", "author"}, {RYGEL_TRACKER_ITEM_METADATA_LAST_KEY, "RYGEL_TRACKER_ITEM_METADATA_LAST_KEY", "last-key"}, {0, NULL, NULL}};
-		rygel_tracker_item_metadata_type_id = g_enum_register_static ("RygelTrackerItemMetadata", values);
-	}
-	return rygel_tracker_item_metadata_type_id;
-}
-
-
-RygelTrackerItem* rygel_tracker_item_construct (GType object_type, const char* id, const char* path, RygelTrackerSearchContainer* parent, const char* upnp_class, char** metadata, int metadata_length1) {
-	GError * _inner_error_;
-	RygelTrackerItem * self;
-	char* _tmp0_;
-	char* _tmp2_;
-	char* _tmp3_;
-	char* _tmp4_;
-	g_return_val_if_fail (id != NULL, NULL);
-	g_return_val_if_fail (path != NULL, NULL);
-	g_return_val_if_fail (parent != NULL, NULL);
-	g_return_val_if_fail (upnp_class != NULL, NULL);
-	_inner_error_ = NULL;
-	self = (RygelTrackerItem*) rygel_media_item_construct (object_type, id, (RygelMediaContainer*) parent, "", upnp_class);
-	self->path = (_tmp0_ = g_strdup (path), _g_free0 (self->path), _tmp0_);
-	if (_vala_strcmp0 (metadata[RYGEL_TRACKER_ITEM_METADATA_SIZE], "") != 0) {
-		((RygelMediaItem*) self)->size = (glong) atoi (metadata[RYGEL_TRACKER_ITEM_METADATA_SIZE]);
-	}
-	if (_vala_strcmp0 (metadata[RYGEL_TRACKER_ITEM_METADATA_DATE], "") != 0) {
-		char* _tmp1_;
-		((RygelMediaItem*) self)->date = (_tmp1_ = rygel_tracker_item_seconds_to_iso8601 (self, metadata[RYGEL_TRACKER_ITEM_METADATA_DATE]), _g_free0 (((RygelMediaItem*) self)->date), _tmp1_);
-	}
-	((RygelMediaItem*) self)->mime_type = (_tmp2_ = g_strdup (metadata[RYGEL_TRACKER_ITEM_METADATA_MIME]), _g_free0 (((RygelMediaItem*) self)->mime_type), _tmp2_);
-	_tmp3_ = g_filename_to_uri (path, NULL, &_inner_error_);
-	if (_inner_error_ != NULL) {
-		g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
-		g_clear_error (&_inner_error_);
-		return NULL;
-	}
-	rygel_media_item_add_uri ((RygelMediaItem*) self, _tmp4_ = _tmp3_, NULL);
-	_g_free0 (_tmp4_);
-	return self;
-}
-
-
-char** rygel_tracker_item_get_metadata_keys (int* result_length1) {
-	char** result;
-	char** _tmp0_;
-	gint keys_size;
-	gint keys_length1;
-	char** keys;
-	char* _tmp1_;
-	char* _tmp2_;
-	char* _tmp3_;
-	char* _tmp4_;
-	char* _tmp5_;
-	char* _tmp6_;
-	char* _tmp7_;
-	char* _tmp8_;
-	char* _tmp9_;
-	char* _tmp10_;
-	char* _tmp11_;
-	char* _tmp12_;
-	char* _tmp13_;
-	char* _tmp14_;
-	char* _tmp15_;
-	char* _tmp16_;
-	char* _tmp17_;
-	char* _tmp18_;
-	char* _tmp19_;
-	char* _tmp20_;
-	char* _tmp21_;
-	char* _tmp22_;
-	char** _tmp23_;
-	keys = (_tmp0_ = g_new0 (char*, RYGEL_TRACKER_ITEM_METADATA_LAST_KEY + 1), keys_length1 = RYGEL_TRACKER_ITEM_METADATA_LAST_KEY, keys_size = keys_length1, _tmp0_);
-	keys[RYGEL_TRACKER_ITEM_METADATA_FILE_NAME] = (_tmp1_ = g_strdup ("File:Name"), _g_free0 (keys[RYGEL_TRACKER_ITEM_METADATA_FILE_NAME]), _tmp1_);
-	keys[RYGEL_TRACKER_ITEM_METADATA_MIME] = (_tmp2_ = g_strdup ("File:Mime"), _g_free0 (keys[RYGEL_TRACKER_ITEM_METADATA_MIME]), _tmp2_);
-	keys[RYGEL_TRACKER_ITEM_METADATA_SIZE] = (_tmp3_ = g_strdup ("File:Size"), _g_free0 (keys[RYGEL_TRACKER_ITEM_METADATA_SIZE]), _tmp3_);
-	keys[RYGEL_TRACKER_ITEM_METADATA_DATE] = (_tmp4_ = g_strdup ("DC:Date"), _g_free0 (keys[RYGEL_TRACKER_ITEM_METADATA_DATE]), _tmp4_);
-	keys[RYGEL_TRACKER_ITEM_METADATA_IMAGE_TITLE] = (_tmp5_ = g_strdup ("Image:Title"), _g_free0 (keys[RYGEL_TRACKER_ITEM_METADATA_IMAGE_TITLE]), _tmp5_);
-	keys[RYGEL_TRACKER_ITEM_METADATA_CREATOR] = (_tmp6_ = g_strdup ("Image:Creator"), _g_free0 (keys[RYGEL_TRACKER_ITEM_METADATA_CREATOR]), _tmp6_);
-	keys[RYGEL_TRACKER_ITEM_METADATA_IMAGE_WIDTH] = (_tmp7_ = g_strdup ("Image:Width"), _g_free0 (keys[RYGEL_TRACKER_ITEM_METADATA_IMAGE_WIDTH]), _tmp7_);
-	keys[RYGEL_TRACKER_ITEM_METADATA_IMAGE_HEIGHT] = (_tmp8_ = g_strdup ("Image:Height"), _g_free0 (keys[RYGEL_TRACKER_ITEM_METADATA_IMAGE_HEIGHT]), _tmp8_);
-	keys[RYGEL_TRACKER_ITEM_METADATA_IMAGE_ALBUM] = (_tmp9_ = g_strdup ("Image:Album"), _g_free0 (keys[RYGEL_TRACKER_ITEM_METADATA_IMAGE_ALBUM]), _tmp9_);
-	keys[RYGEL_TRACKER_ITEM_METADATA_IMAGE_DATE] = (_tmp10_ = g_strdup ("Image:Date"), _g_free0 (keys[RYGEL_TRACKER_ITEM_METADATA_IMAGE_DATE]), _tmp10_);
-	keys[RYGEL_TRACKER_ITEM_METADATA_AUDIO_TITLE] = (_tmp11_ = g_strdup ("Audio:Title"), _g_free0 (keys[RYGEL_TRACKER_ITEM_METADATA_AUDIO_TITLE]), _tmp11_);
-	keys[RYGEL_TRACKER_ITEM_METADATA_AUDIO_DURATION] = (_tmp12_ = g_strdup ("Audio:Duration"), _g_free0 (keys[RYGEL_TRACKER_ITEM_METADATA_AUDIO_DURATION]), _tmp12_);
-	keys[RYGEL_TRACKER_ITEM_METADATA_ARTIST] = (_tmp13_ = g_strdup ("Audio:Artist"), _g_free0 (keys[RYGEL_TRACKER_ITEM_METADATA_ARTIST]), _tmp13_);
-	keys[RYGEL_TRACKER_ITEM_METADATA_AUDIO_ALBUM] = (_tmp14_ = g_strdup ("Audio:Album"), _g_free0 (keys[RYGEL_TRACKER_ITEM_METADATA_AUDIO_ALBUM]), _tmp14_);
-	keys[RYGEL_TRACKER_ITEM_METADATA_TRACK_NUM] = (_tmp15_ = g_strdup ("Audio:TrackNo"), _g_free0 (keys[RYGEL_TRACKER_ITEM_METADATA_TRACK_NUM]), _tmp15_);
-	keys[RYGEL_TRACKER_ITEM_METADATA_RELEASE] = (_tmp16_ = g_strdup ("Audio:ReleaseDate"), _g_free0 (keys[RYGEL_TRACKER_ITEM_METADATA_RELEASE]), _tmp16_);
-	keys[RYGEL_TRACKER_ITEM_METADATA_DATE_ADDED] = (_tmp17_ = g_strdup ("Audio:DateAdded"), _g_free0 (keys[RYGEL_TRACKER_ITEM_METADATA_DATE_ADDED]), _tmp17_);
-	keys[RYGEL_TRACKER_ITEM_METADATA_VIDEO_DURATION] = (_tmp18_ = g_strdup ("Video:Duration"), _g_free0 (keys[RYGEL_TRACKER_ITEM_METADATA_VIDEO_DURATION]), _tmp18_);
-	keys[RYGEL_TRACKER_ITEM_METADATA_VIDEO_TITLE] = (_tmp19_ = g_strdup ("Video:Title"), _g_free0 (keys[RYGEL_TRACKER_ITEM_METADATA_VIDEO_TITLE]), _tmp19_);
-	keys[RYGEL_TRACKER_ITEM_METADATA_AUTHOR] = (_tmp20_ = g_strdup ("Video:Author"), _g_free0 (keys[RYGEL_TRACKER_ITEM_METADATA_AUTHOR]), _tmp20_);
-	keys[RYGEL_TRACKER_ITEM_METADATA_VIDEO_WIDTH] = (_tmp21_ = g_strdup ("Video:Width"), _g_free0 (keys[RYGEL_TRACKER_ITEM_METADATA_VIDEO_WIDTH]), _tmp21_);
-	keys[RYGEL_TRACKER_ITEM_METADATA_VIDEO_HEIGHT] = (_tmp22_ = g_strdup ("Video:Height"), _g_free0 (keys[RYGEL_TRACKER_ITEM_METADATA_VIDEO_HEIGHT]), _tmp22_);
-	result = (_tmp23_ = keys, *result_length1 = keys_length1, _tmp23_);
-	return result;
-	keys = (_vala_array_free (keys, keys_length1, (GDestroyNotify) g_free), NULL);
-}
-
-
-char* rygel_tracker_item_seconds_to_iso8601 (RygelTrackerItem* self, const char* seconds) {
-	char* result;
-	char* date;
-	g_return_val_if_fail (self != NULL, NULL);
-	g_return_val_if_fail (seconds != NULL, NULL);
-	date = NULL;
-	if (_vala_strcmp0 (seconds, "") != 0) {
-		GTimeVal _tmp0_ = {0};
-		GTimeVal tv;
-		char* _tmp1_;
-		tv = (g_get_current_time (&_tmp0_), _tmp0_);
-		tv.tv_sec = (glong) atoi (seconds);
-		tv.tv_usec = (glong) 0;
-		date = (_tmp1_ = g_time_val_to_iso8601 (&tv), _g_free0 (date), _tmp1_);
-	} else {
-		char* _tmp2_;
-		date = (_tmp2_ = g_strdup (""), _g_free0 (date), _tmp2_);
-	}
-	result = date;
-	return result;
-}
-
-
-static void rygel_tracker_item_class_init (RygelTrackerItemClass * klass) {
-	rygel_tracker_item_parent_class = g_type_class_peek_parent (klass);
-	G_OBJECT_CLASS (klass)->finalize = rygel_tracker_item_finalize;
-}
-
-
-static void rygel_tracker_item_instance_init (RygelTrackerItem * self) {
-}
-
-
-static void rygel_tracker_item_finalize (GObject* obj) {
-	RygelTrackerItem * self;
-	self = RYGEL_TRACKER_ITEM (obj);
-	_g_free0 (self->path);
-	G_OBJECT_CLASS (rygel_tracker_item_parent_class)->finalize (obj);
-}
-
-
-GType rygel_tracker_item_get_type (void) {
-	static GType rygel_tracker_item_type_id = 0;
-	if (rygel_tracker_item_type_id == 0) {
-		static const GTypeInfo g_define_type_info = { sizeof (RygelTrackerItemClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) rygel_tracker_item_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (RygelTrackerItem), 0, (GInstanceInitFunc) rygel_tracker_item_instance_init, NULL };
-		rygel_tracker_item_type_id = g_type_register_static (RYGEL_TYPE_MEDIA_ITEM, "RygelTrackerItem", &g_define_type_info, G_TYPE_FLAG_ABSTRACT);
-	}
-	return rygel_tracker_item_type_id;
-}
-
-
-static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
-	if ((array != NULL) && (destroy_func != NULL)) {
-		int i;
-		for (i = 0; i < array_length; i = i + 1) {
-			if (((gpointer*) array)[i] != NULL) {
-				destroy_func (((gpointer*) array)[i]);
-			}
-		}
-	}
-}
-
-
-static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
-	_vala_array_destroy (array, array_length, destroy_func);
-	g_free (array);
-}
-
-
-static int _vala_strcmp0 (const char * str1, const char * str2) {
-	if (str1 == NULL) {
-		return -(str1 != str2);
-	}
-	if (str2 == NULL) {
-		return str1 != str2;
-	}
-	return strcmp (str1, str2);
-}
-
-
-
-
--- a/src/plugins/tracker/rygel-tracker-keywords.c
+++ /dev/null
@@ -1,269 +0,0 @@
-/* rygel-tracker-keywords.c generated by valac, the Vala compiler
- * generated from rygel-tracker-keywords.vala, do not modify */
-
-/*
- * Copyright (C) 2008 Zeeshan Ali <zeenix@gmail.com>.
- * Copyright (C) 2008 Nokia Corporation.
- *
- * Author: Zeeshan Ali <zeenix@gmail.com>
- *
- * This file is part of Rygel.
- *
- * Rygel is free software; you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * Rygel is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this program; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
- */
-
-#include <glib.h>
-#include <glib-object.h>
-#include <rygel.h>
-#include <dbus/dbus-glib-lowlevel.h>
-#include <dbus/dbus-glib.h>
-#include <stdlib.h>
-#include <string.h>
-
-
-#define RYGEL_TYPE_TRACKER_KEYWORDS (rygel_tracker_keywords_get_type ())
-#define RYGEL_TRACKER_KEYWORDS(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_TRACKER_KEYWORDS, RygelTrackerKeywords))
-#define RYGEL_TRACKER_KEYWORDS_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_TRACKER_KEYWORDS, RygelTrackerKeywordsClass))
-#define RYGEL_IS_TRACKER_KEYWORDS(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_TRACKER_KEYWORDS))
-#define RYGEL_IS_TRACKER_KEYWORDS_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_TRACKER_KEYWORDS))
-#define RYGEL_TRACKER_KEYWORDS_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_TRACKER_KEYWORDS, RygelTrackerKeywordsClass))
-
-typedef struct _RygelTrackerKeywords RygelTrackerKeywords;
-typedef struct _RygelTrackerKeywordsClass RygelTrackerKeywordsClass;
-typedef struct _RygelTrackerKeywordsPrivate RygelTrackerKeywordsPrivate;
-#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
-#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
-
-#define RYGEL_TYPE_TRACKER_SEARCH_CONTAINER (rygel_tracker_search_container_get_type ())
-#define RYGEL_TRACKER_SEARCH_CONTAINER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_TRACKER_SEARCH_CONTAINER, RygelTrackerSearchContainer))
-#define RYGEL_TRACKER_SEARCH_CONTAINER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_TRACKER_SEARCH_CONTAINER, RygelTrackerSearchContainerClass))
-#define RYGEL_IS_TRACKER_SEARCH_CONTAINER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_TRACKER_SEARCH_CONTAINER))
-#define RYGEL_IS_TRACKER_SEARCH_CONTAINER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_TRACKER_SEARCH_CONTAINER))
-#define RYGEL_TRACKER_SEARCH_CONTAINER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_TRACKER_SEARCH_CONTAINER, RygelTrackerSearchContainerClass))
-
-typedef struct _RygelTrackerSearchContainer RygelTrackerSearchContainer;
-typedef struct _RygelTrackerSearchContainerClass RygelTrackerSearchContainerClass;
-#define _g_free0(var) (var = (g_free (var), NULL))
-#define _dbus_g_connection_unref0(var) ((var == NULL) ? NULL : (var = (dbus_g_connection_unref (var), NULL)))
-
-struct _RygelTrackerKeywords {
-	RygelSimpleContainer parent_instance;
-	RygelTrackerKeywordsPrivate * priv;
-	DBusGProxy* keywords;
-};
-
-struct _RygelTrackerKeywordsClass {
-	RygelSimpleContainerClass parent_class;
-};
-
-
-static gpointer rygel_tracker_keywords_parent_class = NULL;
-
-GType rygel_tracker_keywords_get_type (void);
-enum  {
-	RYGEL_TRACKER_KEYWORDS_DUMMY_PROPERTY
-};
-#define RYGEL_TRACKER_KEYWORDS_TRACKER_SERVICE "org.freedesktop.Tracker"
-#define RYGEL_TRACKER_KEYWORDS_KEYWORDS_PATH "/org/freedesktop/Tracker/Keywords"
-#define RYGEL_TRACKER_KEYWORDS_KEYWORDS_IFACE "org.freedesktop.Tracker.Keywords"
-#define RYGEL_TRACKER_KEYWORDS_SERVICE "Files"
-#define RYGEL_TRACKER_KEYWORDS_TITLE "Tags"
-static void rygel_tracker_keywords_create_proxies (RygelTrackerKeywords* self, GError** error);
-static void rygel_tracker_keywords_on_get_keywords_cb (RygelTrackerKeywords* self, char*** keywords_list, int keywords_list_length1, GError* _error_);
-void _dynamic_GetList1 (DBusGProxy* self, const char* param1, gpointer param2, void* param2_target, GError** error);
-RygelTrackerKeywords* rygel_tracker_keywords_new (const char* id, RygelMediaContainer* parent);
-RygelTrackerKeywords* rygel_tracker_keywords_construct (GType object_type, const char* id, RygelMediaContainer* parent);
-RygelTrackerSearchContainer* rygel_tracker_search_container_new (const char* id, RygelMediaContainer* parent, const char* title, const char* service, const char* query_condition, char** keywords, int keywords_length1);
-RygelTrackerSearchContainer* rygel_tracker_search_container_construct (GType object_type, const char* id, RygelMediaContainer* parent, const char* title, const char* service, const char* query_condition, char** keywords, int keywords_length1);
-GType rygel_tracker_search_container_get_type (void);
-static void rygel_tracker_keywords_finalize (GObject* obj);
-static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
-static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);
-
-
-
-static void _rygel_tracker_keywords_on_get_keywords_cb_cb (DBusGProxy* proxy, DBusGProxyCall* call, void* user_data) {
-	GError* error;
-	GPtrArray* keywords_list;
-	error = NULL;
-	dbus_g_proxy_end_call (proxy, call, &error, dbus_g_type_get_collection ("GPtrArray", G_TYPE_STRV), &keywords_list, G_TYPE_INVALID);
-	rygel_tracker_keywords_on_get_keywords_cb (user_data, keywords_list->pdata, keywords_list->len, error);
-}
-
-
-void _dynamic_GetList1 (DBusGProxy* self, const char* param1, gpointer param2, void* param2_target, GError** error) {
-	dbus_g_proxy_begin_call (self, "GetList", _rygel_tracker_keywords_on_get_keywords_cb_cb, param2_target, NULL, G_TYPE_STRING, param1, G_TYPE_INVALID, G_TYPE_INVALID);
-	if (*error) {
-		return;
-	}
-}
-
-
-RygelTrackerKeywords* rygel_tracker_keywords_construct (GType object_type, const char* id, RygelMediaContainer* parent) {
-	GError * _inner_error_;
-	RygelTrackerKeywords * self;
-	g_return_val_if_fail (id != NULL, NULL);
-	g_return_val_if_fail (parent != NULL, NULL);
-	_inner_error_ = NULL;
-	self = (RygelTrackerKeywords*) rygel_simple_container_construct (object_type, id, parent, RYGEL_TRACKER_KEYWORDS_TITLE);
-	{
-		rygel_tracker_keywords_create_proxies (self, &_inner_error_);
-		if (_inner_error_ != NULL) {
-			goto __catch1_g_error;
-			goto __finally1;
-		}
-		_dynamic_GetList1 (self->keywords, RYGEL_TRACKER_KEYWORDS_SERVICE, rygel_tracker_keywords_on_get_keywords_cb, self, &_inner_error_);
-		if (_inner_error_ != NULL) {
-			goto __catch1_g_error;
-			goto __finally1;
-		}
-	}
-	goto __finally1;
-	__catch1_g_error:
-	{
-		GError * _error_;
-		_error_ = _inner_error_;
-		_inner_error_ = NULL;
-		{
-			g_critical ("rygel-tracker-keywords.vala:54: Failed to create to Session bus: %s\n", _error_->message);
-			_g_error_free0 (_error_);
-		}
-	}
-	__finally1:
-	if (_inner_error_ != NULL) {
-		g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
-		g_clear_error (&_inner_error_);
-		return NULL;
-	}
-	return self;
-}
-
-
-RygelTrackerKeywords* rygel_tracker_keywords_new (const char* id, RygelMediaContainer* parent) {
-	return rygel_tracker_keywords_construct (RYGEL_TYPE_TRACKER_KEYWORDS, id, parent);
-}
-
-
-static void rygel_tracker_keywords_on_get_keywords_cb (RygelTrackerKeywords* self, char*** keywords_list, int keywords_list_length1, GError* _error_) {
-	g_return_if_fail (self != NULL);
-	if (_error_ != NULL) {
-		g_critical ("rygel-tracker-keywords.vala:62: error getting all keywords: %s", _error_->message);
-		return;
-	}
-	{
-		guint i;
-		i = (guint) 0;
-		{
-			gboolean _tmp0_;
-			_tmp0_ = TRUE;
-			while (TRUE) {
-				char* keyword;
-				char** _tmp2_;
-				gint keywords_size;
-				gint keywords_length1;
-				char** _tmp1_ = NULL;
-				char** keywords;
-				RygelTrackerSearchContainer* container;
-				if (!_tmp0_) {
-					i++;
-				}
-				_tmp0_ = FALSE;
-				if (!(i < keywords_list_length1)) {
-					break;
-				}
-				keyword = g_strdup (keywords_list[i][0]);
-				keywords = (_tmp2_ = (_tmp1_ = g_new0 (char*, 1 + 1), _tmp1_[0] = g_strdup (keyword), _tmp1_), keywords_length1 = 1, keywords_size = keywords_length1, _tmp2_);
-				container = rygel_tracker_search_container_new (keyword, (RygelMediaContainer*) self, keyword, RYGEL_TRACKER_KEYWORDS_SERVICE, "", keywords, keywords_length1);
-				rygel_simple_container_add_child ((RygelSimpleContainer*) self, (RygelMediaObject*) container);
-				_g_free0 (keyword);
-				keywords = (_vala_array_free (keywords, keywords_length1, (GDestroyNotify) g_free), NULL);
-				_g_object_unref0 (container);
-			}
-		}
-	}
-	rygel_media_container_updated ((RygelMediaContainer*) self);
-}
-
-
-static void rygel_tracker_keywords_create_proxies (RygelTrackerKeywords* self, GError** error) {
-	GError * _inner_error_;
-	DBusGConnection* connection;
-	DBusGProxy* _tmp0_;
-	g_return_if_fail (self != NULL);
-	_inner_error_ = NULL;
-	connection = dbus_g_bus_get (DBUS_BUS_SESSION, &_inner_error_);
-	if (_inner_error_ != NULL) {
-		if (_inner_error_->domain == DBUS_GERROR) {
-			g_propagate_error (error, _inner_error_);
-			return;
-		} else {
-			g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
-			g_clear_error (&_inner_error_);
-			return;
-		}
-	}
-	self->keywords = (_tmp0_ = dbus_g_proxy_new_for_name (connection, RYGEL_TRACKER_KEYWORDS_TRACKER_SERVICE, RYGEL_TRACKER_KEYWORDS_KEYWORDS_PATH, RYGEL_TRACKER_KEYWORDS_KEYWORDS_IFACE), _g_object_unref0 (self->keywords), _tmp0_);
-	_dbus_g_connection_unref0 (connection);
-}
-
-
-static void rygel_tracker_keywords_class_init (RygelTrackerKeywordsClass * klass) {
-	rygel_tracker_keywords_parent_class = g_type_class_peek_parent (klass);
-	G_OBJECT_CLASS (klass)->finalize = rygel_tracker_keywords_finalize;
-}
-
-
-static void rygel_tracker_keywords_instance_init (RygelTrackerKeywords * self) {
-}
-
-
-static void rygel_tracker_keywords_finalize (GObject* obj) {
-	RygelTrackerKeywords * self;
-	self = RYGEL_TRACKER_KEYWORDS (obj);
-	_g_object_unref0 (self->keywords);
-	G_OBJECT_CLASS (rygel_tracker_keywords_parent_class)->finalize (obj);
-}
-
-
-GType rygel_tracker_keywords_get_type (void) {
-	static GType rygel_tracker_keywords_type_id = 0;
-	if (rygel_tracker_keywords_type_id == 0) {
-		static const GTypeInfo g_define_type_info = { sizeof (RygelTrackerKeywordsClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) rygel_tracker_keywords_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (RygelTrackerKeywords), 0, (GInstanceInitFunc) rygel_tracker_keywords_instance_init, NULL };
-		rygel_tracker_keywords_type_id = g_type_register_static (RYGEL_TYPE_SIMPLE_CONTAINER, "RygelTrackerKeywords", &g_define_type_info, 0);
-	}
-	return rygel_tracker_keywords_type_id;
-}
-
-
-static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
-	if ((array != NULL) && (destroy_func != NULL)) {
-		int i;
-		for (i = 0; i < array_length; i = i + 1) {
-			if (((gpointer*) array)[i] != NULL) {
-				destroy_func (((gpointer*) array)[i]);
-			}
-		}
-	}
-}
-
-
-static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
-	_vala_array_destroy (array, array_length, destroy_func);
-	g_free (array);
-}
-
-
-
-
--- a/src/plugins/tracker/rygel-tracker-metadata-values.c
+++ /dev/null
@@ -1,300 +0,0 @@
-/* rygel-tracker-metadata-values.c generated by valac, the Vala compiler
- * generated from rygel-tracker-metadata-values.vala, do not modify */
-
-/*
- * Copyright (C) 2008 Zeeshan Ali <zeenix@gmail.com>.
- * Copyright (C) 2008 Nokia Corporation.
- *
- * Author: Zeeshan Ali <zeenix@gmail.com>
- *
- * This file is part of Rygel.
- *
- * Rygel is free software; you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * Rygel is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this program; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
- */
-
-#include <glib.h>
-#include <glib-object.h>
-#include <rygel.h>
-#include <dbus/dbus-glib-lowlevel.h>
-#include <dbus/dbus-glib.h>
-#include <stdlib.h>
-#include <string.h>
-
-
-#define RYGEL_TYPE_TRACKER_METADATA_VALUES (rygel_tracker_metadata_values_get_type ())
-#define RYGEL_TRACKER_METADATA_VALUES(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_TRACKER_METADATA_VALUES, RygelTrackerMetadataValues))
-#define RYGEL_TRACKER_METADATA_VALUES_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_TRACKER_METADATA_VALUES, RygelTrackerMetadataValuesClass))
-#define RYGEL_IS_TRACKER_METADATA_VALUES(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_TRACKER_METADATA_VALUES))
-#define RYGEL_IS_TRACKER_METADATA_VALUES_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_TRACKER_METADATA_VALUES))
-#define RYGEL_TRACKER_METADATA_VALUES_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_TRACKER_METADATA_VALUES, RygelTrackerMetadataValuesClass))
-
-typedef struct _RygelTrackerMetadataValues RygelTrackerMetadataValues;
-typedef struct _RygelTrackerMetadataValuesClass RygelTrackerMetadataValuesClass;
-typedef struct _RygelTrackerMetadataValuesPrivate RygelTrackerMetadataValuesPrivate;
-#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
-#define _g_free0(var) (var = (g_free (var), NULL))
-#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
-
-#define RYGEL_TYPE_TRACKER_SEARCH_CONTAINER (rygel_tracker_search_container_get_type ())
-#define RYGEL_TRACKER_SEARCH_CONTAINER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_TRACKER_SEARCH_CONTAINER, RygelTrackerSearchContainer))
-#define RYGEL_TRACKER_SEARCH_CONTAINER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_TRACKER_SEARCH_CONTAINER, RygelTrackerSearchContainerClass))
-#define RYGEL_IS_TRACKER_SEARCH_CONTAINER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_TRACKER_SEARCH_CONTAINER))
-#define RYGEL_IS_TRACKER_SEARCH_CONTAINER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_TRACKER_SEARCH_CONTAINER))
-#define RYGEL_TRACKER_SEARCH_CONTAINER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_TRACKER_SEARCH_CONTAINER, RygelTrackerSearchContainerClass))
-
-typedef struct _RygelTrackerSearchContainer RygelTrackerSearchContainer;
-typedef struct _RygelTrackerSearchContainerClass RygelTrackerSearchContainerClass;
-#define _dbus_g_connection_unref0(var) ((var == NULL) ? NULL : (var = (dbus_g_connection_unref (var), NULL)))
-
-struct _RygelTrackerMetadataValues {
-	RygelSimpleContainer parent_instance;
-	RygelTrackerMetadataValuesPrivate * priv;
-	DBusGProxy* metadata;
-	char* key;
-};
-
-struct _RygelTrackerMetadataValuesClass {
-	RygelSimpleContainerClass parent_class;
-};
-
-
-static gpointer rygel_tracker_metadata_values_parent_class = NULL;
-
-GType rygel_tracker_metadata_values_get_type (void);
-enum  {
-	RYGEL_TRACKER_METADATA_VALUES_DUMMY_PROPERTY
-};
-#define RYGEL_TRACKER_METADATA_VALUES_TRACKER_SERVICE "org.freedesktop.Tracker"
-#define RYGEL_TRACKER_METADATA_VALUES_METADATA_PATH "/org/freedesktop/Tracker/Metadata"
-#define RYGEL_TRACKER_METADATA_VALUES_METADATA_IFACE "org.freedesktop.Tracker.Metadata"
-#define RYGEL_TRACKER_METADATA_VALUES_SERVICE "Files"
-#define RYGEL_TRACKER_METADATA_VALUES_QUERY_CONDITION "<rdfq:Condition>\n" "<rdfq:equals>\n" "<rdfq:Property name=\"%s\" />\n" "<rdf:String>%s</rdf:String>\n" "</rdfq:equals>\n" "</rdfq:Condition>"
-static void rygel_tracker_metadata_values_create_proxies (RygelTrackerMetadataValues* self, GError** error);
-static void rygel_tracker_metadata_values_on_get_unique_values_cb (RygelTrackerMetadataValues* self, char*** search_result, int search_result_length1, GError* _error_);
-void _dynamic_GetUniqueValues0 (DBusGProxy* self, const char* param1, char** param2, int param2_length1, const char* param3, gboolean param4, gint param5, gint param6, gpointer param7, void* param7_target, GError** error);
-RygelTrackerMetadataValues* rygel_tracker_metadata_values_new (const char* key, const char* id, RygelMediaContainer* parent, const char* title);
-RygelTrackerMetadataValues* rygel_tracker_metadata_values_construct (GType object_type, const char* key, const char* id, RygelMediaContainer* parent, const char* title);
-RygelTrackerSearchContainer* rygel_tracker_search_container_new (const char* id, RygelMediaContainer* parent, const char* title, const char* service, const char* query_condition, char** keywords, int keywords_length1);
-RygelTrackerSearchContainer* rygel_tracker_search_container_construct (GType object_type, const char* id, RygelMediaContainer* parent, const char* title, const char* service, const char* query_condition, char** keywords, int keywords_length1);
-GType rygel_tracker_search_container_get_type (void);
-static void rygel_tracker_metadata_values_finalize (GObject* obj);
-static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
-static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);
-static int _vala_strcmp0 (const char * str1, const char * str2);
-
-
-
-static void _rygel_tracker_metadata_values_on_get_unique_values_cb_cb (DBusGProxy* proxy, DBusGProxyCall* call, void* user_data) {
-	GError* error;
-	GPtrArray* search_result;
-	error = NULL;
-	dbus_g_proxy_end_call (proxy, call, &error, dbus_g_type_get_collection ("GPtrArray", G_TYPE_STRV), &search_result, G_TYPE_INVALID);
-	rygel_tracker_metadata_values_on_get_unique_values_cb (user_data, search_result->pdata, search_result->len, error);
-}
-
-
-void _dynamic_GetUniqueValues0 (DBusGProxy* self, const char* param1, char** param2, int param2_length1, const char* param3, gboolean param4, gint param5, gint param6, gpointer param7, void* param7_target, GError** error) {
-	dbus_g_proxy_begin_call (self, "GetUniqueValues", _rygel_tracker_metadata_values_on_get_unique_values_cb_cb, param7_target, NULL, G_TYPE_STRING, param1, G_TYPE_STRV, param2, G_TYPE_STRING, param3, G_TYPE_BOOLEAN, param4, G_TYPE_INT, param5, G_TYPE_INT, param6, G_TYPE_INVALID, G_TYPE_INVALID);
-	if (*error) {
-		return;
-	}
-}
-
-
-RygelTrackerMetadataValues* rygel_tracker_metadata_values_construct (GType object_type, const char* key, const char* id, RygelMediaContainer* parent, const char* title) {
-	GError * _inner_error_;
-	RygelTrackerMetadataValues * self;
-	char* _tmp0_;
-	g_return_val_if_fail (key != NULL, NULL);
-	g_return_val_if_fail (id != NULL, NULL);
-	g_return_val_if_fail (parent != NULL, NULL);
-	g_return_val_if_fail (title != NULL, NULL);
-	_inner_error_ = NULL;
-	self = (RygelTrackerMetadataValues*) rygel_simple_container_construct (object_type, id, parent, title);
-	self->key = (_tmp0_ = g_strdup (key), _g_free0 (self->key), _tmp0_);
-	{
-		char** _tmp2_;
-		gint keys_size;
-		gint keys_length1;
-		char** _tmp1_ = NULL;
-		char** keys;
-		rygel_tracker_metadata_values_create_proxies (self, &_inner_error_);
-		if (_inner_error_ != NULL) {
-			goto __catch0_g_error;
-			goto __finally0;
-		}
-		keys = (_tmp2_ = (_tmp1_ = g_new0 (char*, 1 + 1), _tmp1_[0] = g_strdup (self->key), _tmp1_), keys_length1 = 1, keys_size = keys_length1, _tmp2_);
-		_dynamic_GetUniqueValues0 (self->metadata, RYGEL_TRACKER_METADATA_VALUES_SERVICE, keys, keys_length1, "", FALSE, 0, -1, rygel_tracker_metadata_values_on_get_unique_values_cb, self, &_inner_error_);
-		if (_inner_error_ != NULL) {
-			keys = (_vala_array_free (keys, keys_length1, (GDestroyNotify) g_free), NULL);
-			goto __catch0_g_error;
-			goto __finally0;
-		}
-		keys = (_vala_array_free (keys, keys_length1, (GDestroyNotify) g_free), NULL);
-	}
-	goto __finally0;
-	__catch0_g_error:
-	{
-		GError * _error_;
-		_error_ = _inner_error_;
-		_inner_error_ = NULL;
-		{
-			g_critical ("rygel-tracker-metadata-values.vala:74: Failed to create to Session bus: %s\n", _error_->message);
-			_g_error_free0 (_error_);
-		}
-	}
-	__finally0:
-	if (_inner_error_ != NULL) {
-		g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
-		g_clear_error (&_inner_error_);
-		return NULL;
-	}
-	return self;
-}
-
-
-RygelTrackerMetadataValues* rygel_tracker_metadata_values_new (const char* key, const char* id, RygelMediaContainer* parent, const char* title) {
-	return rygel_tracker_metadata_values_construct (RYGEL_TYPE_TRACKER_METADATA_VALUES, key, id, parent, title);
-}
-
-
-static void rygel_tracker_metadata_values_on_get_unique_values_cb (RygelTrackerMetadataValues* self, char*** search_result, int search_result_length1, GError* _error_) {
-	g_return_if_fail (self != NULL);
-	if (_error_ != NULL) {
-		g_critical ("rygel-tracker-metadata-values.vala:82: error getting all values for '%s': %s", self->key, _error_->message);
-		return;
-	}
-	{
-		guint i;
-		i = (guint) 0;
-		{
-			gboolean _tmp0_;
-			_tmp0_ = TRUE;
-			while (TRUE) {
-				char* value;
-				char* _tmp1_;
-				char* _tmp2_;
-				char* query_condition;
-				gint _tmp3__length1;
-				char** _tmp3_;
-				RygelTrackerSearchContainer* _tmp4_;
-				RygelTrackerSearchContainer* container;
-				if (!_tmp0_) {
-					i++;
-				}
-				_tmp0_ = FALSE;
-				if (!(i < search_result_length1)) {
-					break;
-				}
-				value = g_strdup (search_result[i][0]);
-				if (_vala_strcmp0 (value, "") == 0) {
-					_g_free0 (value);
-					continue;
-				}
-				query_condition = (_tmp2_ = g_strdup_printf (RYGEL_TRACKER_METADATA_VALUES_QUERY_CONDITION, self->key, _tmp1_ = g_markup_escape_text (value, -1)), _g_free0 (_tmp1_), _tmp2_);
-				container = (_tmp4_ = rygel_tracker_search_container_new (value, (RygelMediaContainer*) self, value, RYGEL_TRACKER_METADATA_VALUES_SERVICE, query_condition, (_tmp3_ = g_new0 (char*, 0 + 1), _tmp3__length1 = 0, _tmp3_), 0), _tmp3_ = (_vala_array_free (_tmp3_, _tmp3__length1, (GDestroyNotify) g_free), NULL), _tmp4_);
-				rygel_simple_container_add_child ((RygelSimpleContainer*) self, (RygelMediaObject*) container);
-				_g_free0 (value);
-				_g_free0 (query_condition);
-				_g_object_unref0 (container);
-			}
-		}
-	}
-	rygel_media_container_updated ((RygelMediaContainer*) self);
-}
-
-
-static void rygel_tracker_metadata_values_create_proxies (RygelTrackerMetadataValues* self, GError** error) {
-	GError * _inner_error_;
-	DBusGConnection* connection;
-	DBusGProxy* _tmp0_;
-	g_return_if_fail (self != NULL);
-	_inner_error_ = NULL;
-	connection = dbus_g_bus_get (DBUS_BUS_SESSION, &_inner_error_);
-	if (_inner_error_ != NULL) {
-		if (_inner_error_->domain == DBUS_GERROR) {
-			g_propagate_error (error, _inner_error_);
-			return;
-		} else {
-			g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
-			g_clear_error (&_inner_error_);
-			return;
-		}
-	}
-	self->metadata = (_tmp0_ = dbus_g_proxy_new_for_name (connection, RYGEL_TRACKER_METADATA_VALUES_TRACKER_SERVICE, RYGEL_TRACKER_METADATA_VALUES_METADATA_PATH, RYGEL_TRACKER_METADATA_VALUES_METADATA_IFACE), _g_object_unref0 (self->metadata), _tmp0_);
-	_dbus_g_connection_unref0 (connection);
-}
-
-
-static void rygel_tracker_metadata_values_class_init (RygelTrackerMetadataValuesClass * klass) {
-	rygel_tracker_metadata_values_parent_class = g_type_class_peek_parent (klass);
-	G_OBJECT_CLASS (klass)->finalize = rygel_tracker_metadata_values_finalize;
-}
-
-
-static void rygel_tracker_metadata_values_instance_init (RygelTrackerMetadataValues * self) {
-}
-
-
-static void rygel_tracker_metadata_values_finalize (GObject* obj) {
-	RygelTrackerMetadataValues * self;
-	self = RYGEL_TRACKER_METADATA_VALUES (obj);
-	_g_object_unref0 (self->metadata);
-	_g_free0 (self->key);
-	G_OBJECT_CLASS (rygel_tracker_metadata_values_parent_class)->finalize (obj);
-}
-
-
-GType rygel_tracker_metadata_values_get_type (void) {
-	static GType rygel_tracker_metadata_values_type_id = 0;
-	if (rygel_tracker_metadata_values_type_id == 0) {
-		static const GTypeInfo g_define_type_info = { sizeof (RygelTrackerMetadataValuesClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) rygel_tracker_metadata_values_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (RygelTrackerMetadataValues), 0, (GInstanceInitFunc) rygel_tracker_metadata_values_instance_init, NULL };
-		rygel_tracker_metadata_values_type_id = g_type_register_static (RYGEL_TYPE_SIMPLE_CONTAINER, "RygelTrackerMetadataValues", &g_define_type_info, 0);
-	}
-	return rygel_tracker_metadata_values_type_id;
-}
-
-
-static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
-	if ((array != NULL) && (destroy_func != NULL)) {
-		int i;
-		for (i = 0; i < array_length; i = i + 1) {
-			if (((gpointer*) array)[i] != NULL) {
-				destroy_func (((gpointer*) array)[i]);
-			}
-		}
-	}
-}
-
-
-static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
-	_vala_array_destroy (array, array_length, destroy_func);
-	g_free (array);
-}
-
-
-static int _vala_strcmp0 (const char * str1, const char * str2) {
-	if (str1 == NULL) {
-		return -(str1 != str2);
-	}
-	if (str2 == NULL) {
-		return str1 != str2;
-	}
-	return strcmp (str1, str2);
-}
-
-
-
-
--- a/src/plugins/tracker/rygel-tracker-music-item.c
+++ /dev/null
@@ -1,203 +0,0 @@
-/* rygel-tracker-music-item.c generated by valac, the Vala compiler
- * generated from rygel-tracker-music-item.vala, do not modify */
-
-/*
- * Copyright (C) 2008 Zeeshan Ali <zeenix@gmail.com>.
- * Copyright (C) 2008 Nokia Corporation.
- *
- * Author: Zeeshan Ali <zeenix@gmail.com>
- *
- * This file is part of Rygel.
- *
- * Rygel is free software; you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * Rygel is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this program; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
- */
-
-#include <glib.h>
-#include <glib-object.h>
-#include <rygel.h>
-#include <stdlib.h>
-#include <string.h>
-
-
-#define RYGEL_TYPE_TRACKER_ITEM (rygel_tracker_item_get_type ())
-#define RYGEL_TRACKER_ITEM(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_TRACKER_ITEM, RygelTrackerItem))
-#define RYGEL_TRACKER_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_TRACKER_ITEM, RygelTrackerItemClass))
-#define RYGEL_IS_TRACKER_ITEM(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_TRACKER_ITEM))
-#define RYGEL_IS_TRACKER_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_TRACKER_ITEM))
-#define RYGEL_TRACKER_ITEM_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_TRACKER_ITEM, RygelTrackerItemClass))
-
-typedef struct _RygelTrackerItem RygelTrackerItem;
-typedef struct _RygelTrackerItemClass RygelTrackerItemClass;
-typedef struct _RygelTrackerItemPrivate RygelTrackerItemPrivate;
-
-#define RYGEL_TYPE_TRACKER_MUSIC_ITEM (rygel_tracker_music_item_get_type ())
-#define RYGEL_TRACKER_MUSIC_ITEM(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_TRACKER_MUSIC_ITEM, RygelTrackerMusicItem))
-#define RYGEL_TRACKER_MUSIC_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_TRACKER_MUSIC_ITEM, RygelTrackerMusicItemClass))
-#define RYGEL_IS_TRACKER_MUSIC_ITEM(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_TRACKER_MUSIC_ITEM))
-#define RYGEL_IS_TRACKER_MUSIC_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_TRACKER_MUSIC_ITEM))
-#define RYGEL_TRACKER_MUSIC_ITEM_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_TRACKER_MUSIC_ITEM, RygelTrackerMusicItemClass))
-
-typedef struct _RygelTrackerMusicItem RygelTrackerMusicItem;
-typedef struct _RygelTrackerMusicItemClass RygelTrackerMusicItemClass;
-typedef struct _RygelTrackerMusicItemPrivate RygelTrackerMusicItemPrivate;
-
-#define RYGEL_TYPE_TRACKER_SEARCH_CONTAINER (rygel_tracker_search_container_get_type ())
-#define RYGEL_TRACKER_SEARCH_CONTAINER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_TRACKER_SEARCH_CONTAINER, RygelTrackerSearchContainer))
-#define RYGEL_TRACKER_SEARCH_CONTAINER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_TRACKER_SEARCH_CONTAINER, RygelTrackerSearchContainerClass))
-#define RYGEL_IS_TRACKER_SEARCH_CONTAINER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_TRACKER_SEARCH_CONTAINER))
-#define RYGEL_IS_TRACKER_SEARCH_CONTAINER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_TRACKER_SEARCH_CONTAINER))
-#define RYGEL_TRACKER_SEARCH_CONTAINER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_TRACKER_SEARCH_CONTAINER, RygelTrackerSearchContainerClass))
-
-typedef struct _RygelTrackerSearchContainer RygelTrackerSearchContainer;
-typedef struct _RygelTrackerSearchContainerClass RygelTrackerSearchContainerClass;
-
-#define RYGEL_TRACKER_ITEM_TYPE_METADATA (rygel_tracker_item_metadata_get_type ())
-#define _g_free0(var) (var = (g_free (var), NULL))
-
-struct _RygelTrackerItem {
-	RygelMediaItem parent_instance;
-	RygelTrackerItemPrivate * priv;
-	char* path;
-};
-
-struct _RygelTrackerItemClass {
-	RygelMediaItemClass parent_class;
-};
-
-struct _RygelTrackerMusicItem {
-	RygelTrackerItem parent_instance;
-	RygelTrackerMusicItemPrivate * priv;
-};
-
-struct _RygelTrackerMusicItemClass {
-	RygelTrackerItemClass parent_class;
-};
-
-typedef enum  {
-	RYGEL_TRACKER_ITEM_METADATA_FILE_NAME,
-	RYGEL_TRACKER_ITEM_METADATA_MIME,
-	RYGEL_TRACKER_ITEM_METADATA_SIZE,
-	RYGEL_TRACKER_ITEM_METADATA_DATE,
-	RYGEL_TRACKER_ITEM_METADATA_IMAGE_TITLE,
-	RYGEL_TRACKER_ITEM_METADATA_IMAGE_WIDTH,
-	RYGEL_TRACKER_ITEM_METADATA_IMAGE_HEIGHT,
-	RYGEL_TRACKER_ITEM_METADATA_IMAGE_ALBUM,
-	RYGEL_TRACKER_ITEM_METADATA_IMAGE_DATE,
-	RYGEL_TRACKER_ITEM_METADATA_CREATOR,
-	RYGEL_TRACKER_ITEM_METADATA_AUDIO_TITLE,
-	RYGEL_TRACKER_ITEM_METADATA_AUDIO_DURATION,
-	RYGEL_TRACKER_ITEM_METADATA_AUDIO_ALBUM,
-	RYGEL_TRACKER_ITEM_METADATA_ARTIST,
-	RYGEL_TRACKER_ITEM_METADATA_TRACK_NUM,
-	RYGEL_TRACKER_ITEM_METADATA_RELEASE,
-	RYGEL_TRACKER_ITEM_METADATA_DATE_ADDED,
-	RYGEL_TRACKER_ITEM_METADATA_VIDEO_TITLE,
-	RYGEL_TRACKER_ITEM_METADATA_VIDEO_WIDTH,
-	RYGEL_TRACKER_ITEM_METADATA_VIDEO_HEIGHT,
-	RYGEL_TRACKER_ITEM_METADATA_VIDEO_DURATION,
-	RYGEL_TRACKER_ITEM_METADATA_AUTHOR,
-	RYGEL_TRACKER_ITEM_METADATA_LAST_KEY
-} RygelTrackerItemMetadata;
-
-
-static gpointer rygel_tracker_music_item_parent_class = NULL;
-
-GType rygel_tracker_item_get_type (void);
-GType rygel_tracker_music_item_get_type (void);
-enum  {
-	RYGEL_TRACKER_MUSIC_ITEM_DUMMY_PROPERTY
-};
-#define RYGEL_TRACKER_MUSIC_ITEM_SERVICE "Music"
-GType rygel_tracker_search_container_get_type (void);
-RygelTrackerItem* rygel_tracker_item_construct (GType object_type, const char* id, const char* path, RygelTrackerSearchContainer* parent, const char* upnp_class, char** metadata, int metadata_length1);
-GType rygel_tracker_item_metadata_get_type (void);
-char* rygel_tracker_item_seconds_to_iso8601 (RygelTrackerItem* self, const char* seconds);
-RygelTrackerMusicItem* rygel_tracker_music_item_new (const char* id, const char* path, RygelTrackerSearchContainer* parent, char** metadata, int metadata_length1);
-RygelTrackerMusicItem* rygel_tracker_music_item_construct (GType object_type, const char* id, const char* path, RygelTrackerSearchContainer* parent, char** metadata, int metadata_length1);
-static int _vala_strcmp0 (const char * str1, const char * str2);
-
-
-
-RygelTrackerMusicItem* rygel_tracker_music_item_construct (GType object_type, const char* id, const char* path, RygelTrackerSearchContainer* parent, char** metadata, int metadata_length1) {
-	RygelTrackerMusicItem * self;
-	char* _tmp4_;
-	char* _tmp5_;
-	g_return_val_if_fail (id != NULL, NULL);
-	g_return_val_if_fail (path != NULL, NULL);
-	g_return_val_if_fail (parent != NULL, NULL);
-	self = (RygelTrackerMusicItem*) rygel_tracker_item_construct (object_type, id, path, parent, RYGEL_MEDIA_ITEM_MUSIC_CLASS, metadata, metadata_length1);
-	if (_vala_strcmp0 (metadata[RYGEL_TRACKER_ITEM_METADATA_AUDIO_TITLE], "") != 0) {
-		char* _tmp0_;
-		((RygelMediaObject*) self)->title = (_tmp0_ = g_strdup (metadata[RYGEL_TRACKER_ITEM_METADATA_AUDIO_TITLE]), _g_free0 (((RygelMediaObject*) self)->title), _tmp0_);
-	} else {
-		char* _tmp1_;
-		((RygelMediaObject*) self)->title = (_tmp1_ = g_strdup (metadata[RYGEL_TRACKER_ITEM_METADATA_FILE_NAME]), _g_free0 (((RygelMediaObject*) self)->title), _tmp1_);
-	}
-	if (_vala_strcmp0 (metadata[RYGEL_TRACKER_ITEM_METADATA_AUDIO_DURATION], "") != 0) {
-		((RygelMediaItem*) self)->duration = (glong) atoi (metadata[RYGEL_TRACKER_ITEM_METADATA_AUDIO_DURATION]);
-	}
-	if (_vala_strcmp0 (metadata[RYGEL_TRACKER_ITEM_METADATA_TRACK_NUM], "") != 0) {
-		((RygelMediaItem*) self)->track_number = atoi (metadata[RYGEL_TRACKER_ITEM_METADATA_TRACK_NUM]);
-	}
-	if (_vala_strcmp0 (metadata[RYGEL_TRACKER_ITEM_METADATA_RELEASE], "") != 0) {
-		char* _tmp2_;
-		((RygelMediaItem*) self)->date = (_tmp2_ = rygel_tracker_item_seconds_to_iso8601 ((RygelTrackerItem*) self, metadata[RYGEL_TRACKER_ITEM_METADATA_RELEASE]), _g_free0 (((RygelMediaItem*) self)->date), _tmp2_);
-	} else {
-		char* _tmp3_;
-		((RygelMediaItem*) self)->date = (_tmp3_ = rygel_tracker_item_seconds_to_iso8601 ((RygelTrackerItem*) self, metadata[RYGEL_TRACKER_ITEM_METADATA_DATE_ADDED]), _g_free0 (((RygelMediaItem*) self)->date), _tmp3_);
-	}
-	((RygelMediaItem*) self)->author = (_tmp4_ = g_strdup (metadata[RYGEL_TRACKER_ITEM_METADATA_ARTIST]), _g_free0 (((RygelMediaItem*) self)->author), _tmp4_);
-	((RygelMediaItem*) self)->album = (_tmp5_ = g_strdup (metadata[RYGEL_TRACKER_ITEM_METADATA_AUDIO_ALBUM]), _g_free0 (((RygelMediaItem*) self)->album), _tmp5_);
-	return self;
-}
-
-
-RygelTrackerMusicItem* rygel_tracker_music_item_new (const char* id, const char* path, RygelTrackerSearchContainer* parent, char** metadata, int metadata_length1) {
-	return rygel_tracker_music_item_construct (RYGEL_TYPE_TRACKER_MUSIC_ITEM, id, path, parent, metadata, metadata_length1);
-}
-
-
-static void rygel_tracker_music_item_class_init (RygelTrackerMusicItemClass * klass) {
-	rygel_tracker_music_item_parent_class = g_type_class_peek_parent (klass);
-}
-
-
-static void rygel_tracker_music_item_instance_init (RygelTrackerMusicItem * self) {
-}
-
-
-GType rygel_tracker_music_item_get_type (void) {
-	static GType rygel_tracker_music_item_type_id = 0;
-	if (rygel_tracker_music_item_type_id == 0) {
-		static const GTypeInfo g_define_type_info = { sizeof (RygelTrackerMusicItemClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) rygel_tracker_music_item_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (RygelTrackerMusicItem), 0, (GInstanceInitFunc) rygel_tracker_music_item_instance_init, NULL };
-		rygel_tracker_music_item_type_id = g_type_register_static (RYGEL_TYPE_TRACKER_ITEM, "RygelTrackerMusicItem", &g_define_type_info, 0);
-	}
-	return rygel_tracker_music_item_type_id;
-}
-
-
-static int _vala_strcmp0 (const char * str1, const char * str2) {
-	if (str1 == NULL) {
-		return -(str1 != str2);
-	}
-	if (str2 == NULL) {
-		return str1 != str2;
-	}
-	return strcmp (str1, str2);
-}
-
-
-
-
--- a/src/plugins/tracker/rygel-tracker-plugin-factory.c
+++ /dev/null
@@ -1,373 +0,0 @@
-/* rygel-tracker-plugin-factory.c generated by valac, the Vala compiler
- * generated from rygel-tracker-plugin-factory.vala, do not modify */
-
-/*
- * Copyright (C) 2009 Zeeshan Ali (Khattak) <zeeshanak@gnome.org>.
- * Copyright (C) 2009 Nokia Corporation.
- *
- * Author: Zeeshan Ali (Khattak) <zeeshanak@gnome.org>
- *                               <zeeshan.ali@nokia.com>
- *
- * This file is part of Rygel.
- *
- * Rygel is free software; you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * Rygel is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this program; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
- */
-
-#include <glib.h>
-#include <glib-object.h>
-#include <rygel.h>
-#include <dbus/dbus-glib-lowlevel.h>
-#include <dbus/dbus-glib.h>
-#include <gobject/gvaluecollector.h>
-
-
-#define TYPE_TRACKER_PLUGIN_FACTORY (tracker_plugin_factory_get_type ())
-#define TRACKER_PLUGIN_FACTORY(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_TRACKER_PLUGIN_FACTORY, TrackerPluginFactory))
-#define TRACKER_PLUGIN_FACTORY_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_TRACKER_PLUGIN_FACTORY, TrackerPluginFactoryClass))
-#define IS_TRACKER_PLUGIN_FACTORY(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_TRACKER_PLUGIN_FACTORY))
-#define IS_TRACKER_PLUGIN_FACTORY_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_TRACKER_PLUGIN_FACTORY))
-#define TRACKER_PLUGIN_FACTORY_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_TRACKER_PLUGIN_FACTORY, TrackerPluginFactoryClass))
-
-typedef struct _TrackerPluginFactory TrackerPluginFactory;
-typedef struct _TrackerPluginFactoryClass TrackerPluginFactoryClass;
-#define _tracker_plugin_factory_unref0(var) ((var == NULL) ? NULL : (var = (tracker_plugin_factory_unref (var), NULL)))
-#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
-typedef struct _TrackerPluginFactoryPrivate TrackerPluginFactoryPrivate;
-#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
-#define _dbus_g_connection_unref0(var) ((var == NULL) ? NULL : (var = (dbus_g_connection_unref (var), NULL)))
-
-#define RYGEL_TYPE_TRACKER_PLUGIN (rygel_tracker_plugin_get_type ())
-#define RYGEL_TRACKER_PLUGIN(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_TRACKER_PLUGIN, RygelTrackerPlugin))
-#define RYGEL_TRACKER_PLUGIN_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_TRACKER_PLUGIN, RygelTrackerPluginClass))
-#define RYGEL_IS_TRACKER_PLUGIN(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_TRACKER_PLUGIN))
-#define RYGEL_IS_TRACKER_PLUGIN_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_TRACKER_PLUGIN))
-#define RYGEL_TRACKER_PLUGIN_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_TRACKER_PLUGIN, RygelTrackerPluginClass))
-
-typedef struct _RygelTrackerPlugin RygelTrackerPlugin;
-typedef struct _RygelTrackerPluginClass RygelTrackerPluginClass;
-typedef struct _ParamSpecTrackerPluginFactory ParamSpecTrackerPluginFactory;
-
-struct _TrackerPluginFactory {
-	GTypeInstance parent_instance;
-	volatile int ref_count;
-	TrackerPluginFactoryPrivate * priv;
-};
-
-struct _TrackerPluginFactoryClass {
-	GTypeClass parent_class;
-	void (*finalize) (TrackerPluginFactory *self);
-};
-
-struct _TrackerPluginFactoryPrivate {
-	DBusGProxy* tracker;
-	RygelPluginLoader* loader;
-};
-
-struct _ParamSpecTrackerPluginFactory {
-	GParamSpec parent_instance;
-};
-
-
-extern TrackerPluginFactory* plugin_factory;
-TrackerPluginFactory* plugin_factory = NULL;
-static gpointer tracker_plugin_factory_parent_class = NULL;
-
-gpointer tracker_plugin_factory_ref (gpointer instance);
-void tracker_plugin_factory_unref (gpointer instance);
-GParamSpec* param_spec_tracker_plugin_factory (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
-void value_set_tracker_plugin_factory (GValue* value, gpointer v_object);
-gpointer value_get_tracker_plugin_factory (const GValue* value);
-GType tracker_plugin_factory_get_type (void);
-TrackerPluginFactory* tracker_plugin_factory_new (RygelPluginLoader* loader, GError** error);
-TrackerPluginFactory* tracker_plugin_factory_construct (GType object_type, RygelPluginLoader* loader, GError** error);
-void module_init (RygelPluginLoader* loader);
-#define TRACKER_PLUGIN_FACTORY_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_TRACKER_PLUGIN_FACTORY, TrackerPluginFactoryPrivate))
-enum  {
-	TRACKER_PLUGIN_FACTORY_DUMMY_PROPERTY
-};
-#define TRACKER_PLUGIN_FACTORY_TRACKER_SERVICE "org.freedesktop.Tracker"
-#define TRACKER_PLUGIN_FACTORY_TRACKER_OBJECT "/org/freedesktop/Tracker"
-#define TRACKER_PLUGIN_FACTORY_TRACKER_IFACE "org.freedesktop.Tracker"
-static void tracker_plugin_factory_get_version_cb (TrackerPluginFactory* self, gint32 version, GError* err);
-void _dynamic_GetVersion5 (DBusGProxy* self, gpointer param1, void* param1_target, GError** error);
-RygelTrackerPlugin* rygel_tracker_plugin_new (void);
-RygelTrackerPlugin* rygel_tracker_plugin_construct (GType object_type);
-GType rygel_tracker_plugin_get_type (void);
-static void tracker_plugin_factory_finalize (TrackerPluginFactory* obj);
-
-
-
-void module_init (RygelPluginLoader* loader) {
-	GError * _inner_error_;
-	g_return_if_fail (loader != NULL);
-	_inner_error_ = NULL;
-	{
-		TrackerPluginFactory* _tmp0_;
-		TrackerPluginFactory* _tmp1_;
-		_tmp0_ = tracker_plugin_factory_new (loader, &_inner_error_);
-		if (_inner_error_ != NULL) {
-			if (_inner_error_->domain == DBUS_GERROR) {
-				goto __catch6_dbus_gerror;
-			}
-			goto __finally6;
-		}
-		plugin_factory = (_tmp1_ = _tmp0_, _tracker_plugin_factory_unref0 (plugin_factory), _tmp1_);
-	}
-	goto __finally6;
-	__catch6_dbus_gerror:
-	{
-		GError * _error_;
-		_error_ = _inner_error_;
-		_inner_error_ = NULL;
-		{
-			g_critical ("rygel-tracker-plugin-factory.vala:36: Failed to fetch list of external services: %s\n", _error_->message);
-			_g_error_free0 (_error_);
-		}
-	}
-	__finally6:
-	if (_inner_error_ != NULL) {
-		g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
-		g_clear_error (&_inner_error_);
-		return;
-	}
-}
-
-
-static gpointer _g_object_ref0 (gpointer self) {
-	return self ? g_object_ref (self) : NULL;
-}
-
-
-static void _tracker_plugin_factory_get_version_cb_cb (DBusGProxy* proxy, DBusGProxyCall* call, void* user_data) {
-	GError* error;
-	gint32 version;
-	error = NULL;
-	dbus_g_proxy_end_call (proxy, call, &error, G_TYPE_INT, &version, G_TYPE_INVALID);
-	tracker_plugin_factory_get_version_cb (user_data, version, error);
-}
-
-
-void _dynamic_GetVersion5 (DBusGProxy* self, gpointer param1, void* param1_target, GError** error) {
-	dbus_g_proxy_begin_call (self, "GetVersion", _tracker_plugin_factory_get_version_cb_cb, param1_target, NULL, G_TYPE_INVALID, G_TYPE_INVALID);
-	if (*error) {
-		return;
-	}
-}
-
-
-TrackerPluginFactory* tracker_plugin_factory_construct (GType object_type, RygelPluginLoader* loader, GError** error) {
-	GError * _inner_error_;
-	TrackerPluginFactory* self;
-	DBusGConnection* connection;
-	DBusGProxy* _tmp0_;
-	RygelPluginLoader* _tmp1_;
-	g_return_val_if_fail (loader != NULL, NULL);
-	_inner_error_ = NULL;
-	self = (TrackerPluginFactory*) g_type_create_instance (object_type);
-	connection = dbus_g_bus_get (DBUS_BUS_SESSION, &_inner_error_);
-	if (_inner_error_ != NULL) {
-		if (_inner_error_->domain == DBUS_GERROR) {
-			g_propagate_error (error, _inner_error_);
-			return;
-		} else {
-			g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
-			g_clear_error (&_inner_error_);
-			return NULL;
-		}
-	}
-	self->priv->tracker = (_tmp0_ = dbus_g_proxy_new_for_name (connection, TRACKER_PLUGIN_FACTORY_TRACKER_SERVICE, TRACKER_PLUGIN_FACTORY_TRACKER_OBJECT, TRACKER_PLUGIN_FACTORY_TRACKER_IFACE), _g_object_unref0 (self->priv->tracker), _tmp0_);
-	self->priv->loader = (_tmp1_ = _g_object_ref0 (loader), _g_object_unref0 (self->priv->loader), _tmp1_);
-	_dynamic_GetVersion5 (self->priv->tracker, tracker_plugin_factory_get_version_cb, self, &_inner_error_);
-	if (_inner_error_ != NULL) {
-		if (_inner_error_->domain == DBUS_GERROR) {
-			g_propagate_error (error, _inner_error_);
-			_dbus_g_connection_unref0 (connection);
-			return;
-		} else {
-			_dbus_g_connection_unref0 (connection);
-			g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
-			g_clear_error (&_inner_error_);
-			return NULL;
-		}
-	}
-	_dbus_g_connection_unref0 (connection);
-	return self;
-}
-
-
-TrackerPluginFactory* tracker_plugin_factory_new (RygelPluginLoader* loader, GError** error) {
-	return tracker_plugin_factory_construct (TYPE_TRACKER_PLUGIN_FACTORY, loader, error);
-}
-
-
-static void tracker_plugin_factory_get_version_cb (TrackerPluginFactory* self, gint32 version, GError* err) {
-	RygelTrackerPlugin* _tmp0_;
-	g_return_if_fail (self != NULL);
-	if (err != NULL) {
-		g_warning ("rygel-tracker-plugin-factory.vala:62: Failed to start Tracker service: %s\n", err->message);
-		g_warning ("rygel-tracker-plugin-factory.vala:64: Tracker plugin disabled.\n");
-		return;
-	}
-	rygel_plugin_loader_add_plugin (self->priv->loader, (RygelPlugin*) (_tmp0_ = rygel_tracker_plugin_new ()));
-	_g_object_unref0 (_tmp0_);
-}
-
-
-static void value_tracker_plugin_factory_init (GValue* value) {
-	value->data[0].v_pointer = NULL;
-}
-
-
-static void value_tracker_plugin_factory_free_value (GValue* value) {
-	if (value->data[0].v_pointer) {
-		tracker_plugin_factory_unref (value->data[0].v_pointer);
-	}
-}
-
-
-static void value_tracker_plugin_factory_copy_value (const GValue* src_value, GValue* dest_value) {
-	if (src_value->data[0].v_pointer) {
-		dest_value->data[0].v_pointer = tracker_plugin_factory_ref (src_value->data[0].v_pointer);
-	} else {
-		dest_value->data[0].v_pointer = NULL;
-	}
-}
-
-
-static gpointer value_tracker_plugin_factory_peek_pointer (const GValue* value) {
-	return value->data[0].v_pointer;
-}
-
-
-static gchar* value_tracker_plugin_factory_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
-	if (collect_values[0].v_pointer) {
-		TrackerPluginFactory* object;
-		object = collect_values[0].v_pointer;
-		if (object->parent_instance.g_class == NULL) {
-			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
-		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
-			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
-		}
-		value->data[0].v_pointer = tracker_plugin_factory_ref (object);
-	} else {
-		value->data[0].v_pointer = NULL;
-	}
-	return NULL;
-}
-
-
-static gchar* value_tracker_plugin_factory_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
-	TrackerPluginFactory** object_p;
-	object_p = collect_values[0].v_pointer;
-	if (!object_p) {
-		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
-	}
-	if (!value->data[0].v_pointer) {
-		*object_p = NULL;
-	} else if (collect_flags && G_VALUE_NOCOPY_CONTENTS) {
-		*object_p = value->data[0].v_pointer;
-	} else {
-		*object_p = tracker_plugin_factory_ref (value->data[0].v_pointer);
-	}
-	return NULL;
-}
-
-
-GParamSpec* param_spec_tracker_plugin_factory (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
-	ParamSpecTrackerPluginFactory* spec;
-	g_return_val_if_fail (g_type_is_a (object_type, TYPE_TRACKER_PLUGIN_FACTORY), NULL);
-	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
-	G_PARAM_SPEC (spec)->value_type = object_type;
-	return G_PARAM_SPEC (spec);
-}
-
-
-gpointer value_get_tracker_plugin_factory (const GValue* value) {
-	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_TRACKER_PLUGIN_FACTORY), NULL);
-	return value->data[0].v_pointer;
-}
-
-
-void value_set_tracker_plugin_factory (GValue* value, gpointer v_object) {
-	TrackerPluginFactory* old;
-	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_TRACKER_PLUGIN_FACTORY));
-	old = value->data[0].v_pointer;
-	if (v_object) {
-		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_TRACKER_PLUGIN_FACTORY));
-		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
-		value->data[0].v_pointer = v_object;
-		tracker_plugin_factory_ref (value->data[0].v_pointer);
-	} else {
-		value->data[0].v_pointer = NULL;
-	}
-	if (old) {
-		tracker_plugin_factory_unref (old);
-	}
-}
-
-
-static void tracker_plugin_factory_class_init (TrackerPluginFactoryClass * klass) {
-	tracker_plugin_factory_parent_class = g_type_class_peek_parent (klass);
-	TRACKER_PLUGIN_FACTORY_CLASS (klass)->finalize = tracker_plugin_factory_finalize;
-	g_type_class_add_private (klass, sizeof (TrackerPluginFactoryPrivate));
-}
-
-
-static void tracker_plugin_factory_instance_init (TrackerPluginFactory * self) {
-	self->priv = TRACKER_PLUGIN_FACTORY_GET_PRIVATE (self);
-	self->ref_count = 1;
-}
-
-
-static void tracker_plugin_factory_finalize (TrackerPluginFactory* obj) {
-	TrackerPluginFactory * self;
-	self = TRACKER_PLUGIN_FACTORY (obj);
-	_g_object_unref0 (self->priv->tracker);
-	_g_object_unref0 (self->priv->loader);
-}
-
-
-GType tracker_plugin_factory_get_type (void) {
-	static GType tracker_plugin_factory_type_id = 0;
-	if (tracker_plugin_factory_type_id == 0) {
-		static const GTypeValueTable g_define_type_value_table = { value_tracker_plugin_factory_init, value_tracker_plugin_factory_free_value, value_tracker_plugin_factory_copy_value, value_tracker_plugin_factory_peek_pointer, "p", value_tracker_plugin_factory_collect_value, "p", value_tracker_plugin_factory_lcopy_value };
-		static const GTypeInfo g_define_type_info = { sizeof (TrackerPluginFactoryClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) tracker_plugin_factory_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (TrackerPluginFactory), 0, (GInstanceInitFunc) tracker_plugin_factory_instance_init, &g_define_type_value_table };
-		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
-		tracker_plugin_factory_type_id = g_type_register_fundamental (g_type_fundamental_next (), "TrackerPluginFactory", &g_define_type_info, &g_define_type_fundamental_info, 0);
-	}
-	return tracker_plugin_factory_type_id;
-}
-
-
-gpointer tracker_plugin_factory_ref (gpointer instance) {
-	TrackerPluginFactory* self;
-	self = instance;
-	g_atomic_int_inc (&self->ref_count);
-	return instance;
-}
-
-
-void tracker_plugin_factory_unref (gpointer instance) {
-	TrackerPluginFactory* self;
-	self = instance;
-	if (g_atomic_int_dec_and_test (&self->ref_count)) {
-		TRACKER_PLUGIN_FACTORY_GET_CLASS (self)->finalize (self);
-		g_type_free_instance ((GTypeInstance *) self);
-	}
-}
-
-
-
-
--- a/src/plugins/tracker/rygel-tracker-plugin.c
+++ /dev/null
@@ -1,123 +0,0 @@
-/* rygel-tracker-plugin.c generated by valac, the Vala compiler
- * generated from rygel-tracker-plugin.vala, do not modify */
-
-/*
- * Copyright (C) 2008 Zeeshan Ali <zeenix@gmail.com>.
- *
- * Author: Zeeshan Ali <zeenix@gmail.com>
- *
- * This file is part of Rygel.
- *
- * Rygel is free software; you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * Rygel is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this program; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
- */
-
-#include <glib.h>
-#include <glib-object.h>
-#include <rygel.h>
-
-
-#define RYGEL_TYPE_TRACKER_PLUGIN (rygel_tracker_plugin_get_type ())
-#define RYGEL_TRACKER_PLUGIN(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_TRACKER_PLUGIN, RygelTrackerPlugin))
-#define RYGEL_TRACKER_PLUGIN_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_TRACKER_PLUGIN, RygelTrackerPluginClass))
-#define RYGEL_IS_TRACKER_PLUGIN(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_TRACKER_PLUGIN))
-#define RYGEL_IS_TRACKER_PLUGIN_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_TRACKER_PLUGIN))
-#define RYGEL_TRACKER_PLUGIN_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_TRACKER_PLUGIN, RygelTrackerPluginClass))
-
-typedef struct _RygelTrackerPlugin RygelTrackerPlugin;
-typedef struct _RygelTrackerPluginClass RygelTrackerPluginClass;
-typedef struct _RygelTrackerPluginPrivate RygelTrackerPluginPrivate;
-
-#define RYGEL_TYPE_MEDIA_TRACKER (rygel_media_tracker_get_type ())
-#define RYGEL_MEDIA_TRACKER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_MEDIA_TRACKER, RygelMediaTracker))
-#define RYGEL_MEDIA_TRACKER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_MEDIA_TRACKER, RygelMediaTrackerClass))
-#define RYGEL_IS_MEDIA_TRACKER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_MEDIA_TRACKER))
-#define RYGEL_IS_MEDIA_TRACKER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_MEDIA_TRACKER))
-#define RYGEL_MEDIA_TRACKER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_MEDIA_TRACKER, RygelMediaTrackerClass))
-
-typedef struct _RygelMediaTracker RygelMediaTracker;
-typedef struct _RygelMediaTrackerClass RygelMediaTrackerClass;
-#define _g_free0(var) (var = (g_free (var), NULL))
-#define _rygel_resource_info_unref0(var) ((var == NULL) ? NULL : (var = (rygel_resource_info_unref (var), NULL)))
-#define _rygel_icon_info_unref0(var) ((var == NULL) ? NULL : (var = (rygel_icon_info_unref (var), NULL)))
-
-struct _RygelTrackerPlugin {
-	RygelPlugin parent_instance;
-	RygelTrackerPluginPrivate * priv;
-};
-
-struct _RygelTrackerPluginClass {
-	RygelPluginClass parent_class;
-};
-
-
-static gpointer rygel_tracker_plugin_parent_class = NULL;
-
-GType rygel_tracker_plugin_get_type (void);
-enum  {
-	RYGEL_TRACKER_PLUGIN_DUMMY_PROPERTY
-};
-#define RYGEL_TRACKER_PLUGIN_ICON DATA_DIR "/icons/hicolor/48x48/apps/tracker.png"
-GType rygel_media_tracker_get_type (void);
-RygelTrackerPlugin* rygel_tracker_plugin_new (void);
-RygelTrackerPlugin* rygel_tracker_plugin_construct (GType object_type);
-
-
-
-RygelTrackerPlugin* rygel_tracker_plugin_construct (GType object_type) {
-	RygelTrackerPlugin * self;
-	RygelResourceInfo* resource_info;
-	RygelIconInfo* icon_info;
-	char* _tmp0_;
-	self = (RygelTrackerPlugin*) rygel_plugin_construct_MediaServer (object_type, "Tracker", "@REALNAME@'s media");
-	resource_info = rygel_resource_info_new (RYGEL_CONTENT_DIRECTORY_UPNP_ID, RYGEL_CONTENT_DIRECTORY_UPNP_TYPE, RYGEL_CONTENT_DIRECTORY_DESCRIPTION_PATH, RYGEL_TYPE_MEDIA_TRACKER);
-	rygel_plugin_add_resource ((RygelPlugin*) self, resource_info);
-	icon_info = rygel_icon_info_new ("image/png");
-	icon_info->path = (_tmp0_ = g_strdup (RYGEL_TRACKER_PLUGIN_ICON), _g_free0 (icon_info->path), _tmp0_);
-	icon_info->width = 48;
-	icon_info->height = 48;
-	icon_info->depth = 24;
-	rygel_plugin_add_icon ((RygelPlugin*) self, icon_info);
-	_rygel_resource_info_unref0 (resource_info);
-	_rygel_icon_info_unref0 (icon_info);
-	return self;
-}
-
-
-RygelTrackerPlugin* rygel_tracker_plugin_new (void) {
-	return rygel_tracker_plugin_construct (RYGEL_TYPE_TRACKER_PLUGIN);
-}
-
-
-static void rygel_tracker_plugin_class_init (RygelTrackerPluginClass * klass) {
-	rygel_tracker_plugin_parent_class = g_type_class_peek_parent (klass);
-}
-
-
-static void rygel_tracker_plugin_instance_init (RygelTrackerPlugin * self) {
-}
-
-
-GType rygel_tracker_plugin_get_type (void) {
-	static GType rygel_tracker_plugin_type_id = 0;
-	if (rygel_tracker_plugin_type_id == 0) {
-		static const GTypeInfo g_define_type_info = { sizeof (RygelTrackerPluginClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) rygel_tracker_plugin_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (RygelTrackerPlugin), 0, (GInstanceInitFunc) rygel_tracker_plugin_instance_init, NULL };
-		rygel_tracker_plugin_type_id = g_type_register_static (RYGEL_TYPE_PLUGIN, "RygelTrackerPlugin", &g_define_type_info, 0);
-	}
-	return rygel_tracker_plugin_type_id;
-}
-
-
-
-
--- a/src/plugins/tracker/rygel-tracker-root-container.c
+++ /dev/null
@@ -1,190 +0,0 @@
-/* rygel-tracker-root-container.c generated by valac, the Vala compiler
- * generated from rygel-tracker-root-container.vala, do not modify */
-
-/*
- * Copyright (C) 2008 Zeeshan Ali (Khattak) <zeeshanak@gnome.org>.
- * Copyright (C) 2008 Nokia Corporation.
- *
- * Author: Zeeshan Ali (Khattak) <zeeshanak@gnome.org>
- *                               <zeeshan.ali@nokia.com>
- *
- * This file is part of Rygel.
- *
- * Rygel is free software; you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * Rygel is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this program; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
- */
-
-#include <glib.h>
-#include <glib-object.h>
-#include <rygel.h>
-#include <stdlib.h>
-#include <string.h>
-
-
-#define RYGEL_TYPE_TRACKER_ROOT_CONTAINER (rygel_tracker_root_container_get_type ())
-#define RYGEL_TRACKER_ROOT_CONTAINER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_TRACKER_ROOT_CONTAINER, RygelTrackerRootContainer))
-#define RYGEL_TRACKER_ROOT_CONTAINER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_TRACKER_ROOT_CONTAINER, RygelTrackerRootContainerClass))
-#define RYGEL_IS_TRACKER_ROOT_CONTAINER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_TRACKER_ROOT_CONTAINER))
-#define RYGEL_IS_TRACKER_ROOT_CONTAINER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_TRACKER_ROOT_CONTAINER))
-#define RYGEL_TRACKER_ROOT_CONTAINER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_TRACKER_ROOT_CONTAINER, RygelTrackerRootContainerClass))
-
-typedef struct _RygelTrackerRootContainer RygelTrackerRootContainer;
-typedef struct _RygelTrackerRootContainerClass RygelTrackerRootContainerClass;
-typedef struct _RygelTrackerRootContainerPrivate RygelTrackerRootContainerPrivate;
-
-#define RYGEL_TYPE_TRACKER_SEARCH_CONTAINER (rygel_tracker_search_container_get_type ())
-#define RYGEL_TRACKER_SEARCH_CONTAINER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_TRACKER_SEARCH_CONTAINER, RygelTrackerSearchContainer))
-#define RYGEL_TRACKER_SEARCH_CONTAINER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_TRACKER_SEARCH_CONTAINER, RygelTrackerSearchContainerClass))
-#define RYGEL_IS_TRACKER_SEARCH_CONTAINER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_TRACKER_SEARCH_CONTAINER))
-#define RYGEL_IS_TRACKER_SEARCH_CONTAINER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_TRACKER_SEARCH_CONTAINER))
-#define RYGEL_TRACKER_SEARCH_CONTAINER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_TRACKER_SEARCH_CONTAINER, RygelTrackerSearchContainerClass))
-
-typedef struct _RygelTrackerSearchContainer RygelTrackerSearchContainer;
-typedef struct _RygelTrackerSearchContainerClass RygelTrackerSearchContainerClass;
-#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
-
-#define RYGEL_TYPE_TRACKER_METADATA_VALUES (rygel_tracker_metadata_values_get_type ())
-#define RYGEL_TRACKER_METADATA_VALUES(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_TRACKER_METADATA_VALUES, RygelTrackerMetadataValues))
-#define RYGEL_TRACKER_METADATA_VALUES_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_TRACKER_METADATA_VALUES, RygelTrackerMetadataValuesClass))
-#define RYGEL_IS_TRACKER_METADATA_VALUES(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_TRACKER_METADATA_VALUES))
-#define RYGEL_IS_TRACKER_METADATA_VALUES_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_TRACKER_METADATA_VALUES))
-#define RYGEL_TRACKER_METADATA_VALUES_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_TRACKER_METADATA_VALUES, RygelTrackerMetadataValuesClass))
-
-typedef struct _RygelTrackerMetadataValues RygelTrackerMetadataValues;
-typedef struct _RygelTrackerMetadataValuesClass RygelTrackerMetadataValuesClass;
-
-#define RYGEL_TYPE_TRACKER_KEYWORDS (rygel_tracker_keywords_get_type ())
-#define RYGEL_TRACKER_KEYWORDS(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_TRACKER_KEYWORDS, RygelTrackerKeywords))
-#define RYGEL_TRACKER_KEYWORDS_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_TRACKER_KEYWORDS, RygelTrackerKeywordsClass))
-#define RYGEL_IS_TRACKER_KEYWORDS(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_TRACKER_KEYWORDS))
-#define RYGEL_IS_TRACKER_KEYWORDS_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_TRACKER_KEYWORDS))
-#define RYGEL_TRACKER_KEYWORDS_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_TRACKER_KEYWORDS, RygelTrackerKeywordsClass))
-
-typedef struct _RygelTrackerKeywords RygelTrackerKeywords;
-typedef struct _RygelTrackerKeywordsClass RygelTrackerKeywordsClass;
-
-struct _RygelTrackerRootContainer {
-	RygelSimpleContainer parent_instance;
-	RygelTrackerRootContainerPrivate * priv;
-};
-
-struct _RygelTrackerRootContainerClass {
-	RygelSimpleContainerClass parent_class;
-};
-
-
-static gpointer rygel_tracker_root_container_parent_class = NULL;
-
-GType rygel_tracker_root_container_get_type (void);
-enum  {
-	RYGEL_TRACKER_ROOT_CONTAINER_DUMMY_PROPERTY
-};
-#define RYGEL_TRACKER_IMAGE_ITEM_SERVICE "Images"
-RygelTrackerSearchContainer* rygel_tracker_search_container_new (const char* id, RygelMediaContainer* parent, const char* title, const char* service, const char* query_condition, char** keywords, int keywords_length1);
-RygelTrackerSearchContainer* rygel_tracker_search_container_construct (GType object_type, const char* id, RygelMediaContainer* parent, const char* title, const char* service, const char* query_condition, char** keywords, int keywords_length1);
-GType rygel_tracker_search_container_get_type (void);
-#define RYGEL_TRACKER_MUSIC_ITEM_SERVICE "Music"
-#define RYGEL_TRACKER_VIDEO_ITEM_SERVICE "Videos"
-RygelTrackerMetadataValues* rygel_tracker_metadata_values_new (const char* key, const char* id, RygelMediaContainer* parent, const char* title);
-RygelTrackerMetadataValues* rygel_tracker_metadata_values_construct (GType object_type, const char* key, const char* id, RygelMediaContainer* parent, const char* title);
-GType rygel_tracker_metadata_values_get_type (void);
-RygelTrackerKeywords* rygel_tracker_keywords_new (const char* id, RygelMediaContainer* parent);
-RygelTrackerKeywords* rygel_tracker_keywords_construct (GType object_type, const char* id, RygelMediaContainer* parent);
-GType rygel_tracker_keywords_get_type (void);
-RygelTrackerRootContainer* rygel_tracker_root_container_new (const char* title);
-RygelTrackerRootContainer* rygel_tracker_root_container_construct (GType object_type, const char* title);
-static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
-static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);
-
-
-
-RygelTrackerRootContainer* rygel_tracker_root_container_construct (GType object_type, const char* title) {
-	RygelTrackerRootContainer * self;
-	RygelTrackerSearchContainer* _tmp1_;
-	gint _tmp0__length1;
-	char** _tmp0_;
-	RygelTrackerSearchContainer* _tmp3_;
-	gint _tmp2__length1;
-	char** _tmp2_;
-	RygelTrackerSearchContainer* _tmp5_;
-	gint _tmp4__length1;
-	char** _tmp4_;
-	RygelTrackerMetadataValues* _tmp6_;
-	RygelTrackerMetadataValues* _tmp7_;
-	RygelTrackerKeywords* _tmp8_;
-	g_return_val_if_fail (title != NULL, NULL);
-	self = (RygelTrackerRootContainer*) rygel_simple_container_construct_root (object_type, title);
-	rygel_simple_container_add_child ((RygelSimpleContainer*) self, (RygelMediaObject*) (_tmp1_ = rygel_tracker_search_container_new ("16", (RygelMediaContainer*) self, "Pictures", RYGEL_TRACKER_IMAGE_ITEM_SERVICE, "", (_tmp0_ = g_new0 (char*, 0 + 1), _tmp0__length1 = 0, _tmp0_), 0)));
-	_g_object_unref0 (_tmp1_);
-	_tmp0_ = (_vala_array_free (_tmp0_, _tmp0__length1, (GDestroyNotify) g_free), NULL);
-	rygel_simple_container_add_child ((RygelSimpleContainer*) self, (RygelMediaObject*) (_tmp3_ = rygel_tracker_search_container_new ("14", (RygelMediaContainer*) self, "Music", RYGEL_TRACKER_MUSIC_ITEM_SERVICE, "", (_tmp2_ = g_new0 (char*, 0 + 1), _tmp2__length1 = 0, _tmp2_), 0)));
-	_g_object_unref0 (_tmp3_);
-	_tmp2_ = (_vala_array_free (_tmp2_, _tmp2__length1, (GDestroyNotify) g_free), NULL);
-	rygel_simple_container_add_child ((RygelSimpleContainer*) self, (RygelMediaObject*) (_tmp5_ = rygel_tracker_search_container_new ("15", (RygelMediaContainer*) self, "Videos", RYGEL_TRACKER_VIDEO_ITEM_SERVICE, "", (_tmp4_ = g_new0 (char*, 0 + 1), _tmp4__length1 = 0, _tmp4_), 0)));
-	_g_object_unref0 (_tmp5_);
-	_tmp4_ = (_vala_array_free (_tmp4_, _tmp4__length1, (GDestroyNotify) g_free), NULL);
-	rygel_simple_container_add_child ((RygelSimpleContainer*) self, (RygelMediaObject*) (_tmp6_ = rygel_tracker_metadata_values_new ("Audio:Artist", "17", (RygelMediaContainer*) self, "Artists")));
-	_g_object_unref0 (_tmp6_);
-	rygel_simple_container_add_child ((RygelSimpleContainer*) self, (RygelMediaObject*) (_tmp7_ = rygel_tracker_metadata_values_new ("Audio:Album", "18", (RygelMediaContainer*) self, "Albums")));
-	_g_object_unref0 (_tmp7_);
-	rygel_simple_container_add_child ((RygelSimpleContainer*) self, (RygelMediaObject*) (_tmp8_ = rygel_tracker_keywords_new ("19", (RygelMediaContainer*) self)));
-	_g_object_unref0 (_tmp8_);
-	return self;
-}
-
-
-RygelTrackerRootContainer* rygel_tracker_root_container_new (const char* title) {
-	return rygel_tracker_root_container_construct (RYGEL_TYPE_TRACKER_ROOT_CONTAINER, title);
-}
-
-
-static void rygel_tracker_root_container_class_init (RygelTrackerRootContainerClass * klass) {
-	rygel_tracker_root_container_parent_class = g_type_class_peek_parent (klass);
-}
-
-
-static void rygel_tracker_root_container_instance_init (RygelTrackerRootContainer * self) {
-}
-
-
-GType rygel_tracker_root_container_get_type (void) {
-	static GType rygel_tracker_root_container_type_id = 0;
-	if (rygel_tracker_root_container_type_id == 0) {
-		static const GTypeInfo g_define_type_info = { sizeof (RygelTrackerRootContainerClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) rygel_tracker_root_container_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (RygelTrackerRootContainer), 0, (GInstanceInitFunc) rygel_tracker_root_container_instance_init, NULL };
-		rygel_tracker_root_container_type_id = g_type_register_static (RYGEL_TYPE_SIMPLE_CONTAINER, "RygelTrackerRootContainer", &g_define_type_info, 0);
-	}
-	return rygel_tracker_root_container_type_id;
-}
-
-
-static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
-	if ((array != NULL) && (destroy_func != NULL)) {
-		int i;
-		for (i = 0; i < array_length; i = i + 1) {
-			if (((gpointer*) array)[i] != NULL) {
-				destroy_func (((gpointer*) array)[i]);
-			}
-		}
-	}
-}
-
-
-static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
-	_vala_array_destroy (array, array_length, destroy_func);
-	g_free (array);
-}
-
-
-
-
--- a/src/plugins/tracker/rygel-tracker-search-container.c
+++ /dev/null
@@ -1,774 +0,0 @@
-/* rygel-tracker-search-container.c generated by valac, the Vala compiler
- * generated from rygel-tracker-search-container.vala, do not modify */
-
-/*
- * Copyright (C) 2008 Zeeshan Ali <zeenix@gmail.com>.
- * Copyright (C) 2008 Nokia Corporation.
- *
- * Author: Zeeshan Ali <zeenix@gmail.com>
- *
- * This file is part of Rygel.
- *
- * Rygel is free software; you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * Rygel is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this program; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
- */
-
-#include <glib.h>
-#include <glib-object.h>
-#include <rygel.h>
-#include <dbus/dbus-glib-lowlevel.h>
-#include <dbus/dbus-glib.h>
-#include <stdlib.h>
-#include <string.h>
-#include <gee.h>
-#include <gio/gio.h>
-
-
-#define RYGEL_TYPE_TRACKER_SEARCH_CONTAINER (rygel_tracker_search_container_get_type ())
-#define RYGEL_TRACKER_SEARCH_CONTAINER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_TRACKER_SEARCH_CONTAINER, RygelTrackerSearchContainer))
-#define RYGEL_TRACKER_SEARCH_CONTAINER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_TRACKER_SEARCH_CONTAINER, RygelTrackerSearchContainerClass))
-#define RYGEL_IS_TRACKER_SEARCH_CONTAINER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_TRACKER_SEARCH_CONTAINER))
-#define RYGEL_IS_TRACKER_SEARCH_CONTAINER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_TRACKER_SEARCH_CONTAINER))
-#define RYGEL_TRACKER_SEARCH_CONTAINER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_TRACKER_SEARCH_CONTAINER, RygelTrackerSearchContainerClass))
-
-typedef struct _RygelTrackerSearchContainer RygelTrackerSearchContainer;
-typedef struct _RygelTrackerSearchContainerClass RygelTrackerSearchContainerClass;
-typedef struct _RygelTrackerSearchContainerPrivate RygelTrackerSearchContainerPrivate;
-#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
-#define _g_free0(var) (var = (g_free (var), NULL))
-#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
-
-#define RYGEL_TYPE_TRACKER_SEARCH_RESULT (rygel_tracker_search_result_get_type ())
-#define RYGEL_TRACKER_SEARCH_RESULT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_TRACKER_SEARCH_RESULT, RygelTrackerSearchResult))
-#define RYGEL_TRACKER_SEARCH_RESULT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_TRACKER_SEARCH_RESULT, RygelTrackerSearchResultClass))
-#define RYGEL_IS_TRACKER_SEARCH_RESULT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_TRACKER_SEARCH_RESULT))
-#define RYGEL_IS_TRACKER_SEARCH_RESULT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_TRACKER_SEARCH_RESULT))
-#define RYGEL_TRACKER_SEARCH_RESULT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_TRACKER_SEARCH_RESULT, RygelTrackerSearchResultClass))
-
-typedef struct _RygelTrackerSearchResult RygelTrackerSearchResult;
-typedef struct _RygelTrackerSearchResultClass RygelTrackerSearchResultClass;
-
-#define RYGEL_TYPE_TRACKER_GET_METADATA_RESULT (rygel_tracker_get_metadata_result_get_type ())
-#define RYGEL_TRACKER_GET_METADATA_RESULT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_TRACKER_GET_METADATA_RESULT, RygelTrackerGetMetadataResult))
-#define RYGEL_TRACKER_GET_METADATA_RESULT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_TRACKER_GET_METADATA_RESULT, RygelTrackerGetMetadataResultClass))
-#define RYGEL_IS_TRACKER_GET_METADATA_RESULT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_TRACKER_GET_METADATA_RESULT))
-#define RYGEL_IS_TRACKER_GET_METADATA_RESULT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_TRACKER_GET_METADATA_RESULT))
-#define RYGEL_TRACKER_GET_METADATA_RESULT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_TRACKER_GET_METADATA_RESULT, RygelTrackerGetMetadataResultClass))
-
-typedef struct _RygelTrackerGetMetadataResult RygelTrackerGetMetadataResult;
-typedef struct _RygelTrackerGetMetadataResultClass RygelTrackerGetMetadataResultClass;
-typedef struct _RygelTrackerGetMetadataResultPrivate RygelTrackerGetMetadataResultPrivate;
-
-#define RYGEL_TYPE_TRACKER_ITEM (rygel_tracker_item_get_type ())
-#define RYGEL_TRACKER_ITEM(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_TRACKER_ITEM, RygelTrackerItem))
-#define RYGEL_TRACKER_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_TRACKER_ITEM, RygelTrackerItemClass))
-#define RYGEL_IS_TRACKER_ITEM(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_TRACKER_ITEM))
-#define RYGEL_IS_TRACKER_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_TRACKER_ITEM))
-#define RYGEL_TRACKER_ITEM_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_TRACKER_ITEM, RygelTrackerItemClass))
-
-typedef struct _RygelTrackerItem RygelTrackerItem;
-typedef struct _RygelTrackerItemClass RygelTrackerItemClass;
-
-#define RYGEL_TYPE_TRACKER_VIDEO_ITEM (rygel_tracker_video_item_get_type ())
-#define RYGEL_TRACKER_VIDEO_ITEM(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_TRACKER_VIDEO_ITEM, RygelTrackerVideoItem))
-#define RYGEL_TRACKER_VIDEO_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_TRACKER_VIDEO_ITEM, RygelTrackerVideoItemClass))
-#define RYGEL_IS_TRACKER_VIDEO_ITEM(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_TRACKER_VIDEO_ITEM))
-#define RYGEL_IS_TRACKER_VIDEO_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_TRACKER_VIDEO_ITEM))
-#define RYGEL_TRACKER_VIDEO_ITEM_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_TRACKER_VIDEO_ITEM, RygelTrackerVideoItemClass))
-
-typedef struct _RygelTrackerVideoItem RygelTrackerVideoItem;
-typedef struct _RygelTrackerVideoItemClass RygelTrackerVideoItemClass;
-
-#define RYGEL_TYPE_TRACKER_IMAGE_ITEM (rygel_tracker_image_item_get_type ())
-#define RYGEL_TRACKER_IMAGE_ITEM(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_TRACKER_IMAGE_ITEM, RygelTrackerImageItem))
-#define RYGEL_TRACKER_IMAGE_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_TRACKER_IMAGE_ITEM, RygelTrackerImageItemClass))
-#define RYGEL_IS_TRACKER_IMAGE_ITEM(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_TRACKER_IMAGE_ITEM))
-#define RYGEL_IS_TRACKER_IMAGE_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_TRACKER_IMAGE_ITEM))
-#define RYGEL_TRACKER_IMAGE_ITEM_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_TRACKER_IMAGE_ITEM, RygelTrackerImageItemClass))
-
-typedef struct _RygelTrackerImageItem RygelTrackerImageItem;
-typedef struct _RygelTrackerImageItemClass RygelTrackerImageItemClass;
-
-#define RYGEL_TYPE_TRACKER_MUSIC_ITEM (rygel_tracker_music_item_get_type ())
-#define RYGEL_TRACKER_MUSIC_ITEM(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_TRACKER_MUSIC_ITEM, RygelTrackerMusicItem))
-#define RYGEL_TRACKER_MUSIC_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_TRACKER_MUSIC_ITEM, RygelTrackerMusicItemClass))
-#define RYGEL_IS_TRACKER_MUSIC_ITEM(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_TRACKER_MUSIC_ITEM))
-#define RYGEL_IS_TRACKER_MUSIC_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_TRACKER_MUSIC_ITEM))
-#define RYGEL_TRACKER_MUSIC_ITEM_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_TRACKER_MUSIC_ITEM, RygelTrackerMusicItemClass))
-
-typedef struct _RygelTrackerMusicItem RygelTrackerMusicItem;
-typedef struct _RygelTrackerMusicItemClass RygelTrackerMusicItemClass;
-#define _dbus_g_connection_unref0(var) ((var == NULL) ? NULL : (var = (dbus_g_connection_unref (var), NULL)))
-
-struct _RygelTrackerSearchContainer {
-	RygelMediaContainer parent_instance;
-	RygelTrackerSearchContainerPrivate * priv;
-	DBusGProxy* metadata;
-	DBusGProxy* search;
-	DBusGProxy* tracker;
-	char* service;
-	char* query_condition;
-	char** keywords;
-	gint keywords_length1;
-};
-
-struct _RygelTrackerSearchContainerClass {
-	RygelMediaContainerClass parent_class;
-};
-
-struct _RygelTrackerSearchContainerPrivate {
-	GeeList* results;
-};
-
-struct _RygelTrackerGetMetadataResult {
-	RygelSimpleAsyncResult parent_instance;
-	RygelTrackerGetMetadataResultPrivate * priv;
-	char* item_id;
-	char* item_path;
-	char* item_service;
-};
-
-struct _RygelTrackerGetMetadataResultClass {
-	RygelSimpleAsyncResultClass parent_class;
-};
-
-
-static gpointer rygel_tracker_search_container_parent_class = NULL;
-
-GType rygel_tracker_search_container_get_type (void);
-#define RYGEL_TRACKER_SEARCH_CONTAINER_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), RYGEL_TYPE_TRACKER_SEARCH_CONTAINER, RygelTrackerSearchContainerPrivate))
-enum  {
-	RYGEL_TRACKER_SEARCH_CONTAINER_DUMMY_PROPERTY
-};
-#define RYGEL_TRACKER_SEARCH_CONTAINER_TRACKER_SERVICE "org.freedesktop.Tracker"
-#define RYGEL_TRACKER_SEARCH_CONTAINER_TRACKER_PATH "/org/freedesktop/Tracker"
-#define RYGEL_TRACKER_SEARCH_CONTAINER_TRACKER_IFACE "org.freedesktop.Tracker"
-#define RYGEL_TRACKER_SEARCH_CONTAINER_SEARCH_PATH "/org/freedesktop/Tracker/Search"
-#define RYGEL_TRACKER_SEARCH_CONTAINER_SEARCH_IFACE "org.freedesktop.Tracker.Search"
-#define RYGEL_TRACKER_SEARCH_CONTAINER_METADATA_PATH "/org/freedesktop/Tracker/Metadata"
-#define RYGEL_TRACKER_SEARCH_CONTAINER_METADATA_IFACE "org.freedesktop.Tracker.Metadata"
-static char** _vala_array_dup1 (char** self, int length);
-static void rygel_tracker_search_container_create_proxies (RygelTrackerSearchContainer* self, GError** error);
-static void rygel_tracker_search_container_get_children_count (RygelTrackerSearchContainer* self);
-RygelTrackerSearchContainer* rygel_tracker_search_container_new (const char* id, RygelMediaContainer* parent, const char* title, const char* service, const char* query_condition, char** keywords, int keywords_length1);
-RygelTrackerSearchContainer* rygel_tracker_search_container_construct (GType object_type, const char* id, RygelMediaContainer* parent, const char* title, const char* service, const char* query_condition, char** keywords, int keywords_length1);
-static void rygel_tracker_search_container_on_search_query_cb (RygelTrackerSearchContainer* self, char*** search_result, int search_result_length1, GError* _error_);
-void _dynamic_Query2 (DBusGProxy* self, gint param1, const char* param2, char** param3, int param3_length1, const char* param4, char** param5, int param5_length1, const char* param6, gboolean param7, char** param8, int param8_length1, gboolean param9, gint param10, gint param11, gpointer param12, void* param12_target, GError** error);
-RygelTrackerSearchResult* rygel_tracker_search_result_new (RygelTrackerSearchContainer* search_container, GAsyncReadyCallback callback, void* callback_target);
-RygelTrackerSearchResult* rygel_tracker_search_result_construct (GType object_type, RygelTrackerSearchContainer* search_container, GAsyncReadyCallback callback, void* callback_target);
-GType rygel_tracker_search_result_get_type (void);
-char** rygel_tracker_item_get_metadata_keys (int* result_length1);
-void rygel_tracker_search_result_ready (RygelTrackerSearchResult* self, char*** search_result, int search_result_length1, GError* _error_);
-void _dynamic_Query3 (DBusGProxy* self, gint param1, const char* param2, char** param3, int param3_length1, const char* param4, char** param5, int param5_length1, const char* param6, gboolean param7, char** param8, int param8_length1, gboolean param9, gint param10, gint param11, gpointer param12, void* param12_target, GError** error);
-static void rygel_tracker_search_container_real_get_children (RygelMediaContainer* base, guint offset, guint max_count, GCancellable* cancellable, GAsyncReadyCallback callback, void* callback_target);
-static GeeList* rygel_tracker_search_container_real_get_children_finish (RygelMediaContainer* base, GAsyncResult* res, GError** error);
-RygelTrackerGetMetadataResult* rygel_tracker_get_metadata_result_new (RygelTrackerSearchContainer* search_container, GAsyncReadyCallback callback, void* callback_target, const char* item_id);
-RygelTrackerGetMetadataResult* rygel_tracker_get_metadata_result_construct (GType object_type, RygelTrackerSearchContainer* search_container, GAsyncReadyCallback callback, void* callback_target, const char* item_id);
-GType rygel_tracker_get_metadata_result_get_type (void);
-char* rygel_tracker_search_container_get_item_info (RygelTrackerSearchContainer* self, const char* item_id, char** parent_id, char** service);
-void rygel_tracker_get_metadata_result_ready (RygelTrackerGetMetadataResult* self, char** metadata, int metadata_length1, GError* _error_);
-void _dynamic_Get4 (DBusGProxy* self, const char* param1, const char* param2, char** param3, int param3_length1, gpointer param4, void* param4_target, GError** error);
-static void rygel_tracker_search_container_real_find_object (RygelMediaContainer* base, const char* id, GCancellable* cancellable, GAsyncReadyCallback callback, void* callback_target);
-static RygelMediaObject* rygel_tracker_search_container_real_find_object_finish (RygelMediaContainer* base, GAsyncResult* res, GError** error);
-gboolean rygel_tracker_search_container_is_thy_child (RygelTrackerSearchContainer* self, const char* item_id);
-#define RYGEL_TRACKER_VIDEO_ITEM_SERVICE "Videos"
-RygelTrackerVideoItem* rygel_tracker_video_item_new (const char* id, const char* path, RygelTrackerSearchContainer* parent, char** metadata, int metadata_length1);
-RygelTrackerVideoItem* rygel_tracker_video_item_construct (GType object_type, const char* id, const char* path, RygelTrackerSearchContainer* parent, char** metadata, int metadata_length1);
-GType rygel_tracker_item_get_type (void);
-GType rygel_tracker_video_item_get_type (void);
-#define RYGEL_TRACKER_IMAGE_ITEM_SERVICE "Images"
-RygelTrackerImageItem* rygel_tracker_image_item_new (const char* id, const char* path, RygelTrackerSearchContainer* parent, char** metadata, int metadata_length1);
-RygelTrackerImageItem* rygel_tracker_image_item_construct (GType object_type, const char* id, const char* path, RygelTrackerSearchContainer* parent, char** metadata, int metadata_length1);
-GType rygel_tracker_image_item_get_type (void);
-#define RYGEL_TRACKER_MUSIC_ITEM_SERVICE "Music"
-RygelTrackerMusicItem* rygel_tracker_music_item_new (const char* id, const char* path, RygelTrackerSearchContainer* parent, char** metadata, int metadata_length1);
-RygelTrackerMusicItem* rygel_tracker_music_item_construct (GType object_type, const char* id, const char* path, RygelTrackerSearchContainer* parent, char** metadata, int metadata_length1);
-GType rygel_tracker_music_item_get_type (void);
-RygelMediaItem* rygel_tracker_search_container_create_item (RygelTrackerSearchContainer* self, const char* service, const char* path, char** metadata, int metadata_length1);
-static void rygel_tracker_search_container_finalize (GObject* obj);
-static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
-static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);
-static gint _vala_array_length (gpointer array);
-static int _vala_strcmp0 (const char * str1, const char * str2);
-
-
-
-static char** _vala_array_dup1 (char** self, int length) {
-	char** result;
-	int i;
-	result = g_new0 (char*, length);
-	for (i = 0; i < length; i++) {
-		result[i] = g_strdup (self[i]);
-	}
-	return result;
-}
-
-
-RygelTrackerSearchContainer* rygel_tracker_search_container_construct (GType object_type, const char* id, RygelMediaContainer* parent, const char* title, const char* service, const char* query_condition, char** keywords, int keywords_length1) {
-	GError * _inner_error_;
-	RygelTrackerSearchContainer * self;
-	gint _tmp0__length1;
-	char** _tmp0_;
-	char* _tmp1_;
-	char** _tmp3_;
-	char** _tmp2_;
-	char* _tmp4_;
-	g_return_val_if_fail (id != NULL, NULL);
-	g_return_val_if_fail (parent != NULL, NULL);
-	g_return_val_if_fail (title != NULL, NULL);
-	g_return_val_if_fail (service != NULL, NULL);
-	g_return_val_if_fail (query_condition != NULL, NULL);
-	_inner_error_ = NULL;
-	self = (RygelTrackerSearchContainer*) rygel_media_container_construct (object_type, id, parent, title, (guint) 0);
-	_tmp0_ = (_vala_array_free (_tmp0_, _tmp0__length1, (GDestroyNotify) g_free), NULL);
-	self->service = (_tmp1_ = g_strdup (service), _g_free0 (self->service), _tmp1_);
-	self->keywords = (_tmp3_ = (_tmp2_ = keywords, (_tmp2_ == NULL) ? ((gpointer) _tmp2_) : _vala_array_dup1 (_tmp2_, keywords_length1)), self->keywords = (_vala_array_free (self->keywords, self->keywords_length1, (GDestroyNotify) g_free), NULL), self->keywords_length1 = keywords_length1, _tmp3_);
-	self->query_condition = (_tmp4_ = g_strdup (query_condition), _g_free0 (self->query_condition), _tmp4_);
-	{
-		GeeList* _tmp5_;
-		rygel_tracker_search_container_create_proxies (self, &_inner_error_);
-		if (_inner_error_ != NULL) {
-			if (_inner_error_->domain == DBUS_GERROR) {
-				goto __catch2_dbus_gerror;
-			}
-			goto __finally2;
-		}
-		rygel_tracker_search_container_get_children_count (self);
-		self->priv->results = (_tmp5_ = (GeeList*) gee_array_list_new (G_TYPE_ASYNC_RESULT, (GBoxedCopyFunc) g_object_ref, g_object_unref, g_direct_equal), _g_object_unref0 (self->priv->results), _tmp5_);
-	}
-	goto __finally2;
-	__catch2_dbus_gerror:
-	{
-		GError * _error_;
-		_error_ = _inner_error_;
-		_inner_error_ = NULL;
-		{
-			g_critical ("rygel-tracker-search-container.vala:75: Failed to connect to session bus: %s\n", _error_->message);
-			_g_error_free0 (_error_);
-		}
-	}
-	__finally2:
-	if (_inner_error_ != NULL) {
-		g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
-		g_clear_error (&_inner_error_);
-		return NULL;
-	}
-	return self;
-}
-
-
-RygelTrackerSearchContainer* rygel_tracker_search_container_new (const char* id, RygelMediaContainer* parent, const char* title, const char* service, const char* query_condition, char** keywords, int keywords_length1) {
-	return rygel_tracker_search_container_construct (RYGEL_TYPE_TRACKER_SEARCH_CONTAINER, id, parent, title, service, query_condition, keywords, keywords_length1);
-}
-
-
-static void _rygel_tracker_search_container_on_search_query_cb_cb (DBusGProxy* proxy, DBusGProxyCall* call, void* user_data) {
-	GError* error;
-	GPtrArray* search_result;
-	error = NULL;
-	dbus_g_proxy_end_call (proxy, call, &error, dbus_g_type_get_collection ("GPtrArray", G_TYPE_STRV), &search_result, G_TYPE_INVALID);
-	rygel_tracker_search_container_on_search_query_cb (user_data, search_result->pdata, search_result->len, error);
-}
-
-
-void _dynamic_Query2 (DBusGProxy* self, gint param1, const char* param2, char** param3, int param3_length1, const char* param4, char** param5, int param5_length1, const char* param6, gboolean param7, char** param8, int param8_length1, gboolean param9, gint param10, gint param11, gpointer param12, void* param12_target, GError** error) {
-	dbus_g_proxy_begin_call (self, "Query", _rygel_tracker_search_container_on_search_query_cb_cb, param12_target, NULL, G_TYPE_INT, param1, G_TYPE_STRING, param2, G_TYPE_STRV, param3, G_TYPE_STRING, param4, G_TYPE_STRV, param5, G_TYPE_STRING, param6, G_TYPE_BOOLEAN, param7, G_TYPE_STRV, param8, G_TYPE_BOOLEAN, param9, G_TYPE_INT, param10, G_TYPE_INT, param11, G_TYPE_INVALID, G_TYPE_INVALID);
-	if (*error) {
-		return;
-	}
-}
-
-
-static void rygel_tracker_search_container_get_children_count (RygelTrackerSearchContainer* self) {
-	GError * _inner_error_;
-	g_return_if_fail (self != NULL);
-	_inner_error_ = NULL;
-	{
-		gint _tmp1__length1;
-		char** _tmp1_;
-		gint _tmp0__length1;
-		char** _tmp0_;
-		_dynamic_Query2 (self->search, 0, self->service, (_tmp0_ = g_new0 (char*, 0 + 1), _tmp0__length1 = 0, _tmp0_), 0, "", self->keywords, self->keywords_length1, self->query_condition, FALSE, (_tmp1_ = g_new0 (char*, 0 + 1), _tmp1__length1 = 0, _tmp1_), 0, FALSE, 0, -1, rygel_tracker_search_container_on_search_query_cb, self, &_inner_error_);
-		if (_inner_error_ != NULL) {
-			goto __catch3_g_error;
-			goto __finally3;
-		}
-		_tmp1_ = (_vala_array_free (_tmp1_, _tmp1__length1, (GDestroyNotify) g_free), NULL);
-		_tmp0_ = (_vala_array_free (_tmp0_, _tmp0__length1, (GDestroyNotify) g_free), NULL);
-	}
-	goto __finally3;
-	__catch3_g_error:
-	{
-		GError * _error_;
-		_error_ = _inner_error_;
-		_inner_error_ = NULL;
-		{
-			g_critical ("rygel-tracker-search-container.vala:97: error getting items under service '%s': %s", self->service, _error_->message);
-			_g_error_free0 (_error_);
-			return;
-		}
-	}
-	__finally3:
-	if (_inner_error_ != NULL) {
-		g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
-		g_clear_error (&_inner_error_);
-		return;
-	}
-}
-
-
-static void rygel_tracker_search_container_on_search_query_cb (RygelTrackerSearchContainer* self, char*** search_result, int search_result_length1, GError* _error_) {
-	g_return_if_fail (self != NULL);
-	if (_error_ != NULL) {
-		g_critical ("rygel-tracker-search-container.vala:108: error getting items under service '%s': %s", self->service, _error_->message);
-		return;
-	}
-	((RygelMediaContainer*) self)->child_count = (guint) search_result_length1;
-	rygel_media_container_updated ((RygelMediaContainer*) self);
-}
-
-
-static void _rygel_tracker_search_result_ready_cb (DBusGProxy* proxy, DBusGProxyCall* call, void* user_data) {
-	GError* error;
-	GPtrArray* search_result;
-	error = NULL;
-	dbus_g_proxy_end_call (proxy, call, &error, dbus_g_type_get_collection ("GPtrArray", G_TYPE_STRV), &search_result, G_TYPE_INVALID);
-	rygel_tracker_search_result_ready (user_data, search_result->pdata, search_result->len, error);
-}
-
-
-void _dynamic_Query3 (DBusGProxy* self, gint param1, const char* param2, char** param3, int param3_length1, const char* param4, char** param5, int param5_length1, const char* param6, gboolean param7, char** param8, int param8_length1, gboolean param9, gint param10, gint param11, gpointer param12, void* param12_target, GError** error) {
-	dbus_g_proxy_begin_call (self, "Query", _rygel_tracker_search_result_ready_cb, param12_target, NULL, G_TYPE_INT, param1, G_TYPE_STRING, param2, G_TYPE_STRV, param3, G_TYPE_STRING, param4, G_TYPE_STRV, param5, G_TYPE_STRING, param6, G_TYPE_BOOLEAN, param7, G_TYPE_STRV, param8, G_TYPE_BOOLEAN, param9, G_TYPE_INT, param10, G_TYPE_INT, param11, G_TYPE_INVALID, G_TYPE_INVALID);
-	if (*error) {
-		return;
-	}
-}
-
-
-static gpointer _g_error_copy0 (gpointer self) {
-	return self ? g_error_copy (self) : NULL;
-}
-
-
-static void rygel_tracker_search_container_real_get_children (RygelMediaContainer* base, guint offset, guint max_count, GCancellable* cancellable, GAsyncReadyCallback callback, void* callback_target) {
-	RygelTrackerSearchContainer * self;
-	GError * _inner_error_;
-	RygelTrackerSearchResult* res;
-	self = (RygelTrackerSearchContainer*) base;
-	_inner_error_ = NULL;
-	res = rygel_tracker_search_result_new (self, callback, callback_target);
-	gee_collection_add ((GeeCollection*) self->priv->results, (GAsyncResult*) res);
-	{
-		char** _tmp3_;
-		gint _tmp2__length1;
-		char** _tmp2_;
-		gint _tmp1__length1;
-		char** _tmp1_;
-		gint _tmp0_;
-		_tmp3_ = (_tmp1_ = rygel_tracker_item_get_metadata_keys (&_tmp0_), _tmp1__length1 = _tmp0_, _tmp1_);
-		_dynamic_Query3 (self->search, 0, self->service, _tmp3_, _tmp0_, "", self->keywords, self->keywords_length1, self->query_condition, FALSE, (_tmp2_ = g_new0 (char*, 0 + 1), _tmp2__length1 = 0, _tmp2_), 0, FALSE, (gint) offset, (gint) max_count, rygel_tracker_search_result_ready, res, &_inner_error_);
-		if (_inner_error_ != NULL) {
-			goto __catch4_g_error;
-			goto __finally4;
-		}
-		_tmp2_ = (_vala_array_free (_tmp2_, _tmp2__length1, (GDestroyNotify) g_free), NULL);
-		_tmp1_ = (_vala_array_free (_tmp1_, _tmp1__length1, (GDestroyNotify) g_free), NULL);
-	}
-	goto __finally4;
-	__catch4_g_error:
-	{
-		GError * _error_;
-		_error_ = _inner_error_;
-		_inner_error_ = NULL;
-		{
-			GError* _tmp4_;
-			((RygelSimpleAsyncResult*) res)->error = (_tmp4_ = _g_error_copy0 (_error_), _g_error_free0 (((RygelSimpleAsyncResult*) res)->error), _tmp4_);
-			rygel_simple_async_result_complete_in_idle ((RygelSimpleAsyncResult*) res);
-			_g_error_free0 (_error_);
-		}
-	}
-	__finally4:
-	if (_inner_error_ != NULL) {
-		_g_object_unref0 (res);
-		g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
-		g_clear_error (&_inner_error_);
-		return;
-	}
-	_g_object_unref0 (res);
-}
-
-
-static gpointer _g_object_ref0 (gpointer self) {
-	return self ? g_object_ref (self) : NULL;
-}
-
-
-static GeeList* rygel_tracker_search_container_real_get_children_finish (RygelMediaContainer* base, GAsyncResult* res, GError** error) {
-	RygelTrackerSearchContainer * self;
-	GeeList* result;
-	GError * _inner_error_;
-	RygelTrackerSearchResult* search_res;
-	self = (RygelTrackerSearchContainer*) base;
-	g_return_val_if_fail (res != NULL, NULL);
-	_inner_error_ = NULL;
-	search_res = _g_object_ref0 (RYGEL_TRACKER_SEARCH_RESULT (res));
-	gee_collection_remove ((GeeCollection*) self->priv->results, (GAsyncResult*) search_res);
-	if (((RygelSimpleAsyncResult*) search_res)->error != NULL) {
-		_inner_error_ = _g_error_copy0 (((RygelSimpleAsyncResult*) search_res)->error);
-		if (_inner_error_ != NULL) {
-			g_propagate_error (error, _inner_error_);
-			_g_object_unref0 (search_res);
-			return NULL;
-		}
-	} else {
-		result = _g_object_ref0 ((GeeList*) ((RygelSimpleAsyncResult*) search_res)->data);
-		_g_object_unref0 (search_res);
-		return result;
-	}
-	_g_object_unref0 (search_res);
-}
-
-
-static void _rygel_tracker_get_metadata_result_ready_cb (DBusGProxy* proxy, DBusGProxyCall* call, void* user_data) {
-	GError* error;
-	char** metadata;
-	error = NULL;
-	dbus_g_proxy_end_call (proxy, call, &error, G_TYPE_STRV, &metadata, G_TYPE_INVALID);
-	rygel_tracker_get_metadata_result_ready (user_data, metadata, g_strv_length (metadata), error);
-}
-
-
-void _dynamic_Get4 (DBusGProxy* self, const char* param1, const char* param2, char** param3, int param3_length1, gpointer param4, void* param4_target, GError** error) {
-	dbus_g_proxy_begin_call (self, "Get", _rygel_tracker_get_metadata_result_ready_cb, param4_target, NULL, G_TYPE_STRING, param1, G_TYPE_STRING, param2, G_TYPE_STRV, param3, G_TYPE_INVALID, G_TYPE_INVALID);
-	if (*error) {
-		return;
-	}
-}
-
-
-static void rygel_tracker_search_container_real_find_object (RygelMediaContainer* base, const char* id, GCancellable* cancellable, GAsyncReadyCallback callback, void* callback_target) {
-	RygelTrackerSearchContainer * self;
-	GError * _inner_error_;
-	RygelTrackerGetMetadataResult* res;
-	self = (RygelTrackerSearchContainer*) base;
-	g_return_if_fail (id != NULL);
-	_inner_error_ = NULL;
-	res = rygel_tracker_get_metadata_result_new (self, callback, callback_target, id);
-	gee_collection_add ((GeeCollection*) self->priv->results, (GAsyncResult*) res);
-	{
-		char* parent_id;
-		char* _tmp6_;
-		char* _tmp5_;
-		char* _tmp4_;
-		char* _tmp3_ = NULL;
-		char* _tmp2_;
-		char* _tmp1_;
-		char* _tmp0_ = NULL;
-		char** _tmp8_;
-		gint keys_size;
-		gint keys_length1;
-		gint _tmp7_;
-		char** keys;
-		parent_id = NULL;
-		res->item_path = (_tmp6_ = (_tmp4_ = (_tmp1_ = rygel_tracker_search_container_get_item_info (self, id, &_tmp0_, &_tmp3_), parent_id = (_tmp2_ = _tmp0_, _g_free0 (parent_id), _tmp2_), _tmp1_), res->item_service = (_tmp5_ = _tmp3_, _g_free0 (res->item_service), _tmp5_), _tmp4_), _g_free0 (res->item_path), _tmp6_);
-		if (res->item_path == NULL) {
-			rygel_simple_async_result_complete_in_idle ((RygelSimpleAsyncResult*) res);
-			_g_free0 (parent_id);
-			_g_object_unref0 (res);
-			return;
-		}
-		keys = (_tmp8_ = rygel_tracker_item_get_metadata_keys (&_tmp7_), keys_length1 = _tmp7_, keys_size = keys_length1, _tmp8_);
-		_dynamic_Get4 (self->metadata, res->item_service, res->item_path, keys, keys_length1, rygel_tracker_get_metadata_result_ready, res, &_inner_error_);
-		if (_inner_error_ != NULL) {
-			_g_free0 (parent_id);
-			keys = (_vala_array_free (keys, keys_length1, (GDestroyNotify) g_free), NULL);
-			goto __catch5_g_error;
-			goto __finally5;
-		}
-		_g_free0 (parent_id);
-		keys = (_vala_array_free (keys, keys_length1, (GDestroyNotify) g_free), NULL);
-	}
-	goto __finally5;
-	__catch5_g_error:
-	{
-		GError * _error_;
-		_error_ = _inner_error_;
-		_inner_error_ = NULL;
-		{
-			GError* _tmp9_;
-			((RygelSimpleAsyncResult*) res)->error = (_tmp9_ = _g_error_copy0 (_error_), _g_error_free0 (((RygelSimpleAsyncResult*) res)->error), _tmp9_);
-			rygel_simple_async_result_complete_in_idle ((RygelSimpleAsyncResult*) res);
-			_g_error_free0 (_error_);
-		}
-	}
-	__finally5:
-	if (_inner_error_ != NULL) {
-		_g_object_unref0 (res);
-		g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
-		g_clear_error (&_inner_error_);
-		return;
-	}
-	_g_object_unref0 (res);
-}
-
-
-static RygelMediaObject* rygel_tracker_search_container_real_find_object_finish (RygelMediaContainer* base, GAsyncResult* res, GError** error) {
-	RygelTrackerSearchContainer * self;
-	RygelMediaObject* result;
-	GError * _inner_error_;
-	RygelTrackerGetMetadataResult* metadata_res;
-	self = (RygelTrackerSearchContainer*) base;
-	g_return_val_if_fail (res != NULL, NULL);
-	_inner_error_ = NULL;
-	metadata_res = _g_object_ref0 (RYGEL_TRACKER_GET_METADATA_RESULT (res));
-	if (((RygelSimpleAsyncResult*) metadata_res)->error != NULL) {
-		_inner_error_ = _g_error_copy0 (((RygelSimpleAsyncResult*) metadata_res)->error);
-		if (_inner_error_ != NULL) {
-			g_propagate_error (error, _inner_error_);
-			_g_object_unref0 (metadata_res);
-			return NULL;
-		}
-	} else {
-		result = _g_object_ref0 ((RygelMediaObject*) ((RygelSimpleAsyncResult*) metadata_res)->data);
-		_g_object_unref0 (metadata_res);
-		return result;
-	}
-	_g_object_unref0 (metadata_res);
-}
-
-
-gboolean rygel_tracker_search_container_is_thy_child (RygelTrackerSearchContainer* self, const char* item_id) {
-	gboolean result;
-	char* parent_id;
-	char* _tmp6_;
-	char* _tmp5_;
-	char* _tmp4_;
-	char* _tmp3_ = NULL;
-	char* _tmp2_;
-	char* _tmp1_;
-	char* _tmp0_ = NULL;
-	gboolean _tmp7_ = FALSE;
-	g_return_val_if_fail (self != NULL, FALSE);
-	g_return_val_if_fail (item_id != NULL, FALSE);
-	parent_id = NULL;
-	_tmp6_ = (_tmp4_ = (_tmp1_ = rygel_tracker_search_container_get_item_info (self, ((RygelMediaObject*) self)->id, &_tmp0_, &_tmp3_), parent_id = (_tmp2_ = _tmp0_, _g_free0 (parent_id), _tmp2_), _tmp1_), self->service = (_tmp5_ = _tmp3_, _g_free0 (self->service), _tmp5_), _tmp4_);
-	_g_free0 (_tmp6_);
-	if (parent_id != NULL) {
-		_tmp7_ = _vala_strcmp0 (parent_id, ((RygelMediaObject*) self)->id) == 0;
-	} else {
-		_tmp7_ = FALSE;
-	}
-	if (_tmp7_) {
-		result = TRUE;
-		_g_free0 (parent_id);
-		return result;
-	} else {
-		result = FALSE;
-		_g_free0 (parent_id);
-		return result;
-	}
-	_g_free0 (parent_id);
-}
-
-
-RygelMediaItem* rygel_tracker_search_container_create_item (RygelTrackerSearchContainer* self, const char* service, const char* path, char** metadata, int metadata_length1) {
-	RygelMediaItem* result;
-	char* _tmp2_;
-	char* _tmp1_;
-	char* _tmp0_;
-	char* _tmp3_;
-	char* id;
-	g_return_val_if_fail (self != NULL, NULL);
-	g_return_val_if_fail (service != NULL, NULL);
-	g_return_val_if_fail (path != NULL, NULL);
-	id = (_tmp3_ = g_strconcat (_tmp2_ = g_strconcat (_tmp1_ = g_strconcat (_tmp0_ = g_strconcat (service, ":", NULL), ((RygelMediaObject*) self)->id, NULL), ":", NULL), path, NULL), _g_free0 (_tmp2_), _g_free0 (_tmp1_), _g_free0 (_tmp0_), _tmp3_);
-	if (_vala_strcmp0 (service, RYGEL_TRACKER_VIDEO_ITEM_SERVICE) == 0) {
-		result = (RygelMediaItem*) rygel_tracker_video_item_new (id, path, self, metadata, metadata_length1);
-		_g_free0 (id);
-		return result;
-	} else {
-		if (_vala_strcmp0 (service, RYGEL_TRACKER_IMAGE_ITEM_SERVICE) == 0) {
-			result = (RygelMediaItem*) rygel_tracker_image_item_new (id, path, self, metadata, metadata_length1);
-			_g_free0 (id);
-			return result;
-		} else {
-			if (_vala_strcmp0 (service, RYGEL_TRACKER_MUSIC_ITEM_SERVICE) == 0) {
-				result = (RygelMediaItem*) rygel_tracker_music_item_new (id, path, self, metadata, metadata_length1);
-				_g_free0 (id);
-				return result;
-			} else {
-				result = NULL;
-				_g_free0 (id);
-				return result;
-			}
-		}
-	}
-	_g_free0 (id);
-}
-
-
-char* rygel_tracker_search_container_get_item_info (RygelTrackerSearchContainer* self, const char* item_id, char** parent_id, char** service) {
-	char* result;
-	char** _tmp1_;
-	gint tokens_size;
-	gint tokens_length1;
-	char** _tmp0_;
-	char** tokens;
-	gboolean _tmp2_ = FALSE;
-	gboolean _tmp3_ = FALSE;
-	g_return_val_if_fail (self != NULL, NULL);
-	g_return_val_if_fail (item_id != NULL, NULL);
-	if (parent_id != NULL) {
-		*parent_id = NULL;
-	}
-	if (service != NULL) {
-		*service = NULL;
-	}
-	tokens = (_tmp1_ = _tmp0_ = g_strsplit (item_id, ":", 3), tokens_length1 = _vala_array_length (_tmp0_), tokens_size = tokens_length1, _tmp1_);
-	if (tokens[0] != NULL) {
-		_tmp3_ = tokens[1] != NULL;
-	} else {
-		_tmp3_ = FALSE;
-	}
-	if (_tmp3_) {
-		_tmp2_ = tokens[2] != NULL;
-	} else {
-		_tmp2_ = FALSE;
-	}
-	if (_tmp2_) {
-		char* _tmp4_;
-		char* _tmp5_;
-		*service = (_tmp4_ = g_strdup (tokens[0]), _g_free0 (*service), _tmp4_);
-		*parent_id = (_tmp5_ = g_strdup (tokens[1]), _g_free0 (*parent_id), _tmp5_);
-		result = g_strdup (tokens[2]);
-		tokens = (_vala_array_free (tokens, tokens_length1, (GDestroyNotify) g_free), NULL);
-		return result;
-	} else {
-		result = NULL;
-		tokens = (_vala_array_free (tokens, tokens_length1, (GDestroyNotify) g_free), NULL);
-		return result;
-	}
-	tokens = (_vala_array_free (tokens, tokens_length1, (GDestroyNotify) g_free), NULL);
-}
-
-
-static void rygel_tracker_search_container_create_proxies (RygelTrackerSearchContainer* self, GError** error) {
-	GError * _inner_error_;
-	DBusGConnection* connection;
-	DBusGProxy* _tmp0_;
-	DBusGProxy* _tmp1_;
-	DBusGProxy* _tmp2_;
-	g_return_if_fail (self != NULL);
-	_inner_error_ = NULL;
-	connection = dbus_g_bus_get (DBUS_BUS_SESSION, &_inner_error_);
-	if (_inner_error_ != NULL) {
-		if (_inner_error_->domain == DBUS_GERROR) {
-			g_propagate_error (error, _inner_error_);
-			return;
-		} else {
-			g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
-			g_clear_error (&_inner_error_);
-			return;
-		}
-	}
-	self->metadata = (_tmp0_ = dbus_g_proxy_new_for_name (connection, RYGEL_TRACKER_SEARCH_CONTAINER_TRACKER_SERVICE, RYGEL_TRACKER_SEARCH_CONTAINER_METADATA_PATH, RYGEL_TRACKER_SEARCH_CONTAINER_METADATA_IFACE), _g_object_unref0 (self->metadata), _tmp0_);
-	self->search = (_tmp1_ = dbus_g_proxy_new_for_name (connection, RYGEL_TRACKER_SEARCH_CONTAINER_TRACKER_SERVICE, RYGEL_TRACKER_SEARCH_CONTAINER_SEARCH_PATH, RYGEL_TRACKER_SEARCH_CONTAINER_SEARCH_IFACE), _g_object_unref0 (self->search), _tmp1_);
-	self->tracker = (_tmp2_ = dbus_g_proxy_new_for_name (connection, RYGEL_TRACKER_SEARCH_CONTAINER_TRACKER_SERVICE, RYGEL_TRACKER_SEARCH_CONTAINER_TRACKER_PATH, RYGEL_TRACKER_SEARCH_CONTAINER_TRACKER_IFACE), _g_object_unref0 (self->tracker), _tmp2_);
-	_dbus_g_connection_unref0 (connection);
-}
-
-
-static void rygel_tracker_search_container_class_init (RygelTrackerSearchContainerClass * klass) {
-	rygel_tracker_search_container_parent_class = g_type_class_peek_parent (klass);
-	g_type_class_add_private (klass, sizeof (RygelTrackerSearchContainerPrivate));
-	RYGEL_MEDIA_CONTAINER_CLASS (klass)->get_children = rygel_tracker_search_container_real_get_children;
-	RYGEL_MEDIA_CONTAINER_CLASS (klass)->get_children_finish = rygel_tracker_search_container_real_get_children_finish;
-	RYGEL_MEDIA_CONTAINER_CLASS (klass)->find_object = rygel_tracker_search_container_real_find_object;
-	RYGEL_MEDIA_CONTAINER_CLASS (klass)->find_object_finish = rygel_tracker_search_container_real_find_object_finish;
-	G_OBJECT_CLASS (klass)->finalize = rygel_tracker_search_container_finalize;
-}
-
-
-static void rygel_tracker_search_container_instance_init (RygelTrackerSearchContainer * self) {
-	self->priv = RYGEL_TRACKER_SEARCH_CONTAINER_GET_PRIVATE (self);
-}
-
-
-static void rygel_tracker_search_container_finalize (GObject* obj) {
-	RygelTrackerSearchContainer * self;
-	self = RYGEL_TRACKER_SEARCH_CONTAINER (obj);
-	_g_object_unref0 (self->metadata);
-	_g_object_unref0 (self->search);
-	_g_object_unref0 (self->tracker);
-	_g_free0 (self->service);
-	_g_free0 (self->query_condition);
-	self->keywords = (_vala_array_free (self->keywords, self->keywords_length1, (GDestroyNotify) g_free), NULL);
-	_g_object_unref0 (self->priv->results);
-	G_OBJECT_CLASS (rygel_tracker_search_container_parent_class)->finalize (obj);
-}
-
-
-GType rygel_tracker_search_container_get_type (void) {
-	static GType rygel_tracker_search_container_type_id = 0;
-	if (rygel_tracker_search_container_type_id == 0) {
-		static const GTypeInfo g_define_type_info = { sizeof (RygelTrackerSearchContainerClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) rygel_tracker_search_container_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (RygelTrackerSearchContainer), 0, (GInstanceInitFunc) rygel_tracker_search_container_instance_init, NULL };
-		rygel_tracker_search_container_type_id = g_type_register_static (RYGEL_TYPE_MEDIA_CONTAINER, "RygelTrackerSearchContainer", &g_define_type_info, 0);
-	}
-	return rygel_tracker_search_container_type_id;
-}
-
-
-static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
-	if ((array != NULL) && (destroy_func != NULL)) {
-		int i;
-		for (i = 0; i < array_length; i = i + 1) {
-			if (((gpointer*) array)[i] != NULL) {
-				destroy_func (((gpointer*) array)[i]);
-			}
-		}
-	}
-}
-
-
-static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
-	_vala_array_destroy (array, array_length, destroy_func);
-	g_free (array);
-}
-
-
-static gint _vala_array_length (gpointer array) {
-	int length;
-	length = 0;
-	if (array) {
-		while (((gpointer*) array)[length]) {
-			length++;
-		}
-	}
-	return length;
-}
-
-
-static int _vala_strcmp0 (const char * str1, const char * str2) {
-	if (str1 == NULL) {
-		return -(str1 != str2);
-	}
-	if (str2 == NULL) {
-		return str1 != str2;
-	}
-	return strcmp (str1, str2);
-}
-
-
-
-
--- a/src/plugins/tracker/rygel-tracker-search-result.c
+++ /dev/null
@@ -1,261 +0,0 @@
-/* rygel-tracker-search-result.c generated by valac, the Vala compiler
- * generated from rygel-tracker-search-result.vala, do not modify */
-
-/*
- * Copyright (C) 2009 Nokia Corporation.
- *
- * Author: Zeeshan Ali (Khattak) <zeeshanak@gnome.org>
- *
- * This file is part of Rygel.
- *
- * Rygel is free software; you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * Rygel is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this program; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
- */
-
-#include <glib.h>
-#include <glib-object.h>
-#include <rygel.h>
-#include <gio/gio.h>
-#include <gee.h>
-#include <stdlib.h>
-#include <string.h>
-
-
-#define RYGEL_TYPE_TRACKER_SEARCH_RESULT (rygel_tracker_search_result_get_type ())
-#define RYGEL_TRACKER_SEARCH_RESULT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_TRACKER_SEARCH_RESULT, RygelTrackerSearchResult))
-#define RYGEL_TRACKER_SEARCH_RESULT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_TRACKER_SEARCH_RESULT, RygelTrackerSearchResultClass))
-#define RYGEL_IS_TRACKER_SEARCH_RESULT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_TRACKER_SEARCH_RESULT))
-#define RYGEL_IS_TRACKER_SEARCH_RESULT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_TRACKER_SEARCH_RESULT))
-#define RYGEL_TRACKER_SEARCH_RESULT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_TRACKER_SEARCH_RESULT, RygelTrackerSearchResultClass))
-
-typedef struct _RygelTrackerSearchResult RygelTrackerSearchResult;
-typedef struct _RygelTrackerSearchResultClass RygelTrackerSearchResultClass;
-typedef struct _RygelTrackerSearchResultPrivate RygelTrackerSearchResultPrivate;
-#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
-
-#define RYGEL_TYPE_TRACKER_SEARCH_CONTAINER (rygel_tracker_search_container_get_type ())
-#define RYGEL_TRACKER_SEARCH_CONTAINER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_TRACKER_SEARCH_CONTAINER, RygelTrackerSearchContainer))
-#define RYGEL_TRACKER_SEARCH_CONTAINER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_TRACKER_SEARCH_CONTAINER, RygelTrackerSearchContainerClass))
-#define RYGEL_IS_TRACKER_SEARCH_CONTAINER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_TRACKER_SEARCH_CONTAINER))
-#define RYGEL_IS_TRACKER_SEARCH_CONTAINER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_TRACKER_SEARCH_CONTAINER))
-#define RYGEL_TRACKER_SEARCH_CONTAINER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_TRACKER_SEARCH_CONTAINER, RygelTrackerSearchContainerClass))
-
-typedef struct _RygelTrackerSearchContainer RygelTrackerSearchContainer;
-typedef struct _RygelTrackerSearchContainerClass RygelTrackerSearchContainerClass;
-#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
-#define _g_free0(var) (var = (g_free (var), NULL))
-
-struct _RygelTrackerSearchResult {
-	RygelSimpleAsyncResult parent_instance;
-	RygelTrackerSearchResultPrivate * priv;
-};
-
-struct _RygelTrackerSearchResultClass {
-	RygelSimpleAsyncResultClass parent_class;
-};
-
-
-static gpointer rygel_tracker_search_result_parent_class = NULL;
-
-GType rygel_tracker_search_result_get_type (void);
-enum  {
-	RYGEL_TRACKER_SEARCH_RESULT_DUMMY_PROPERTY
-};
-GType rygel_tracker_search_container_get_type (void);
-RygelTrackerSearchResult* rygel_tracker_search_result_new (RygelTrackerSearchContainer* search_container, GAsyncReadyCallback callback, void* callback_target);
-RygelTrackerSearchResult* rygel_tracker_search_result_construct (GType object_type, RygelTrackerSearchContainer* search_container, GAsyncReadyCallback callback, void* callback_target);
-static char** rygel_tracker_search_result_slice_strv_tail (RygelTrackerSearchResult* self, char** strv, int strv_length1, gint index, int* result_length1);
-RygelMediaItem* rygel_tracker_search_container_create_item (RygelTrackerSearchContainer* self, const char* service, const char* path, char** metadata, int metadata_length1);
-void rygel_tracker_search_result_ready (RygelTrackerSearchResult* self, char*** search_result, int search_result_length1, GError* _error_);
-static gint rygel_tracker_search_result_get_strv_length (RygelTrackerSearchResult* self, char** strv, int strv_length1);
-static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
-static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);
-
-
-
-RygelTrackerSearchResult* rygel_tracker_search_result_construct (GType object_type, RygelTrackerSearchContainer* search_container, GAsyncReadyCallback callback, void* callback_target) {
-	RygelTrackerSearchResult * self;
-	GeeList* _tmp0_;
-	g_return_val_if_fail (search_container != NULL, NULL);
-	self = (RygelTrackerSearchResult*) rygel_simple_async_result_construct (object_type, GEE_TYPE_LIST, (GBoxedCopyFunc) g_object_ref, g_object_unref, (GObject*) search_container, callback, callback_target);
-	((RygelSimpleAsyncResult*) self)->data = (_tmp0_ = (GeeList*) gee_array_list_new (RYGEL_TYPE_MEDIA_OBJECT, (GBoxedCopyFunc) g_object_ref, g_object_unref, g_direct_equal), _g_object_unref0 (((RygelSimpleAsyncResult*) self)->data), _tmp0_);
-	return self;
-}
-
-
-RygelTrackerSearchResult* rygel_tracker_search_result_new (RygelTrackerSearchContainer* search_container, GAsyncReadyCallback callback, void* callback_target) {
-	return rygel_tracker_search_result_construct (RYGEL_TYPE_TRACKER_SEARCH_RESULT, search_container, callback, callback_target);
-}
-
-
-static gpointer _g_error_copy0 (gpointer self) {
-	return self ? g_error_copy (self) : NULL;
-}
-
-
-static gpointer _g_object_ref0 (gpointer self) {
-	return self ? g_object_ref (self) : NULL;
-}
-
-
-void rygel_tracker_search_result_ready (RygelTrackerSearchResult* self, char*** search_result, int search_result_length1, GError* _error_) {
-	RygelTrackerSearchContainer* search_container;
-	g_return_if_fail (self != NULL);
-	if (_error_ != NULL) {
-		GError* _tmp0_;
-		((RygelSimpleAsyncResult*) self)->error = (_tmp0_ = _g_error_copy0 (_error_), _g_error_free0 (((RygelSimpleAsyncResult*) self)->error), _tmp0_);
-		rygel_simple_async_result_complete ((RygelSimpleAsyncResult*) self);
-		return;
-	}
-	search_container = _g_object_ref0 (RYGEL_TRACKER_SEARCH_CONTAINER (((RygelSimpleAsyncResult*) self)->source_object));
-	{
-		guint i;
-		i = (guint) 0;
-		{
-			gboolean _tmp1_;
-			_tmp1_ = TRUE;
-			while (TRUE) {
-				char* child_path;
-				char* service;
-				char** _tmp3_;
-				gint metadata_size;
-				gint metadata_length1;
-				gint _tmp2_;
-				char** metadata;
-				RygelMediaItem* item;
-				if (!_tmp1_) {
-					i++;
-				}
-				_tmp1_ = FALSE;
-				if (!(i < search_result_length1)) {
-					break;
-				}
-				child_path = g_strdup (search_result[i][0]);
-				service = g_strdup (search_result[i][1]);
-				metadata = (_tmp3_ = rygel_tracker_search_result_slice_strv_tail (self, search_result[i], -1, 2, &_tmp2_), metadata_length1 = _tmp2_, metadata_size = metadata_length1, _tmp3_);
-				item = rygel_tracker_search_container_create_item (search_container, service, child_path, metadata, metadata_length1);
-				gee_collection_add ((GeeCollection*) ((GeeList*) ((RygelSimpleAsyncResult*) self)->data), (RygelMediaObject*) item);
-				_g_free0 (child_path);
-				_g_free0 (service);
-				metadata = (_vala_array_free (metadata, metadata_length1, (GDestroyNotify) g_free), NULL);
-				_g_object_unref0 (item);
-			}
-		}
-	}
-	rygel_simple_async_result_complete ((RygelSimpleAsyncResult*) self);
-	_g_object_unref0 (search_container);
-}
-
-
-static char** rygel_tracker_search_result_slice_strv_tail (RygelTrackerSearchResult* self, char** strv, int strv_length1, gint index, int* result_length1) {
-	char** result;
-	gint strv_length;
-	char** _tmp1_;
-	gint slice_size;
-	gint slice_length1;
-	gint _tmp0_;
-	char** slice;
-	char** _tmp4_;
-	g_return_val_if_fail (self != NULL, NULL);
-	strv_length = rygel_tracker_search_result_get_strv_length (self, strv, strv_length1);
-	slice = (_tmp1_ = g_new0 (char*, (_tmp0_ = strv_length - index) + 1), slice_length1 = _tmp0_, slice_size = slice_length1, _tmp1_);
-	{
-		gint i;
-		i = 0;
-		{
-			gboolean _tmp2_;
-			_tmp2_ = TRUE;
-			while (TRUE) {
-				char* _tmp3_;
-				if (!_tmp2_) {
-					i++;
-				}
-				_tmp2_ = FALSE;
-				if (!(i < slice_length1)) {
-					break;
-				}
-				slice[i] = (_tmp3_ = g_strdup (strv[i + index]), _g_free0 (slice[i]), _tmp3_);
-			}
-		}
-	}
-	result = (_tmp4_ = slice, *result_length1 = slice_length1, _tmp4_);
-	return result;
-	slice = (_vala_array_free (slice, slice_length1, (GDestroyNotify) g_free), NULL);
-}
-
-
-static gint rygel_tracker_search_result_get_strv_length (RygelTrackerSearchResult* self, char** strv, int strv_length1) {
-	gint result;
-	gint i;
-	g_return_val_if_fail (self != NULL, 0);
-	i = 0;
-	{
-		gboolean _tmp0_;
-		i = 0;
-		_tmp0_ = TRUE;
-		while (TRUE) {
-			if (!_tmp0_) {
-				i++;
-			}
-			_tmp0_ = FALSE;
-			if (!(strv[i] != NULL)) {
-				break;
-			}
-			;
-		}
-	}
-	result = i + 1;
-	return result;
-}
-
-
-static void rygel_tracker_search_result_class_init (RygelTrackerSearchResultClass * klass) {
-	rygel_tracker_search_result_parent_class = g_type_class_peek_parent (klass);
-}
-
-
-static void rygel_tracker_search_result_instance_init (RygelTrackerSearchResult * self) {
-}
-
-
-GType rygel_tracker_search_result_get_type (void) {
-	static GType rygel_tracker_search_result_type_id = 0;
-	if (rygel_tracker_search_result_type_id == 0) {
-		static const GTypeInfo g_define_type_info = { sizeof (RygelTrackerSearchResultClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) rygel_tracker_search_result_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (RygelTrackerSearchResult), 0, (GInstanceInitFunc) rygel_tracker_search_result_instance_init, NULL };
-		rygel_tracker_search_result_type_id = g_type_register_static (RYGEL_TYPE_SIMPLE_ASYNC_RESULT, "RygelTrackerSearchResult", &g_define_type_info, 0);
-	}
-	return rygel_tracker_search_result_type_id;
-}
-
-
-static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
-	if ((array != NULL) && (destroy_func != NULL)) {
-		int i;
-		for (i = 0; i < array_length; i = i + 1) {
-			if (((gpointer*) array)[i] != NULL) {
-				destroy_func (((gpointer*) array)[i]);
-			}
-		}
-	}
-}
-
-
-static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
-	_vala_array_destroy (array, array_length, destroy_func);
-	g_free (array);
-}
-
-
-
-
--- a/src/plugins/tracker/rygel-tracker-video-item.c
+++ /dev/null
@@ -1,199 +0,0 @@
-/* rygel-tracker-video-item.c generated by valac, the Vala compiler
- * generated from rygel-tracker-video-item.vala, do not modify */
-
-/*
- * Copyright (C) 2008 Zeeshan Ali <zeenix@gmail.com>.
- * Copyright (C) 2008 Nokia Corporation.
- *
- * Author: Zeeshan Ali <zeenix@gmail.com>
- *
- * This file is part of Rygel.
- *
- * Rygel is free software; you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * Rygel is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this program; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
- */
-
-#include <glib.h>
-#include <glib-object.h>
-#include <rygel.h>
-#include <stdlib.h>
-#include <string.h>
-
-
-#define RYGEL_TYPE_TRACKER_ITEM (rygel_tracker_item_get_type ())
-#define RYGEL_TRACKER_ITEM(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_TRACKER_ITEM, RygelTrackerItem))
-#define RYGEL_TRACKER_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_TRACKER_ITEM, RygelTrackerItemClass))
-#define RYGEL_IS_TRACKER_ITEM(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_TRACKER_ITEM))
-#define RYGEL_IS_TRACKER_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_TRACKER_ITEM))
-#define RYGEL_TRACKER_ITEM_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_TRACKER_ITEM, RygelTrackerItemClass))
-
-typedef struct _RygelTrackerItem RygelTrackerItem;
-typedef struct _RygelTrackerItemClass RygelTrackerItemClass;
-typedef struct _RygelTrackerItemPrivate RygelTrackerItemPrivate;
-
-#define RYGEL_TYPE_TRACKER_VIDEO_ITEM (rygel_tracker_video_item_get_type ())
-#define RYGEL_TRACKER_VIDEO_ITEM(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_TRACKER_VIDEO_ITEM, RygelTrackerVideoItem))
-#define RYGEL_TRACKER_VIDEO_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_TRACKER_VIDEO_ITEM, RygelTrackerVideoItemClass))
-#define RYGEL_IS_TRACKER_VIDEO_ITEM(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_TRACKER_VIDEO_ITEM))
-#define RYGEL_IS_TRACKER_VIDEO_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_TRACKER_VIDEO_ITEM))
-#define RYGEL_TRACKER_VIDEO_ITEM_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_TRACKER_VIDEO_ITEM, RygelTrackerVideoItemClass))
-
-typedef struct _RygelTrackerVideoItem RygelTrackerVideoItem;
-typedef struct _RygelTrackerVideoItemClass RygelTrackerVideoItemClass;
-typedef struct _RygelTrackerVideoItemPrivate RygelTrackerVideoItemPrivate;
-
-#define RYGEL_TYPE_TRACKER_SEARCH_CONTAINER (rygel_tracker_search_container_get_type ())
-#define RYGEL_TRACKER_SEARCH_CONTAINER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_TRACKER_SEARCH_CONTAINER, RygelTrackerSearchContainer))
-#define RYGEL_TRACKER_SEARCH_CONTAINER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_TRACKER_SEARCH_CONTAINER, RygelTrackerSearchContainerClass))
-#define RYGEL_IS_TRACKER_SEARCH_CONTAINER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_TRACKER_SEARCH_CONTAINER))
-#define RYGEL_IS_TRACKER_SEARCH_CONTAINER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_TRACKER_SEARCH_CONTAINER))
-#define RYGEL_TRACKER_SEARCH_CONTAINER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_TRACKER_SEARCH_CONTAINER, RygelTrackerSearchContainerClass))
-
-typedef struct _RygelTrackerSearchContainer RygelTrackerSearchContainer;
-typedef struct _RygelTrackerSearchContainerClass RygelTrackerSearchContainerClass;
-
-#define RYGEL_TRACKER_ITEM_TYPE_METADATA (rygel_tracker_item_metadata_get_type ())
-#define _g_free0(var) (var = (g_free (var), NULL))
-
-struct _RygelTrackerItem {
-	RygelMediaItem parent_instance;
-	RygelTrackerItemPrivate * priv;
-	char* path;
-};
-
-struct _RygelTrackerItemClass {
-	RygelMediaItemClass parent_class;
-};
-
-struct _RygelTrackerVideoItem {
-	RygelTrackerItem parent_instance;
-	RygelTrackerVideoItemPrivate * priv;
-};
-
-struct _RygelTrackerVideoItemClass {
-	RygelTrackerItemClass parent_class;
-};
-
-typedef enum  {
-	RYGEL_TRACKER_ITEM_METADATA_FILE_NAME,
-	RYGEL_TRACKER_ITEM_METADATA_MIME,
-	RYGEL_TRACKER_ITEM_METADATA_SIZE,
-	RYGEL_TRACKER_ITEM_METADATA_DATE,
-	RYGEL_TRACKER_ITEM_METADATA_IMAGE_TITLE,
-	RYGEL_TRACKER_ITEM_METADATA_IMAGE_WIDTH,
-	RYGEL_TRACKER_ITEM_METADATA_IMAGE_HEIGHT,
-	RYGEL_TRACKER_ITEM_METADATA_IMAGE_ALBUM,
-	RYGEL_TRACKER_ITEM_METADATA_IMAGE_DATE,
-	RYGEL_TRACKER_ITEM_METADATA_CREATOR,
-	RYGEL_TRACKER_ITEM_METADATA_AUDIO_TITLE,
-	RYGEL_TRACKER_ITEM_METADATA_AUDIO_DURATION,
-	RYGEL_TRACKER_ITEM_METADATA_AUDIO_ALBUM,
-	RYGEL_TRACKER_ITEM_METADATA_ARTIST,
-	RYGEL_TRACKER_ITEM_METADATA_TRACK_NUM,
-	RYGEL_TRACKER_ITEM_METADATA_RELEASE,
-	RYGEL_TRACKER_ITEM_METADATA_DATE_ADDED,
-	RYGEL_TRACKER_ITEM_METADATA_VIDEO_TITLE,
-	RYGEL_TRACKER_ITEM_METADATA_VIDEO_WIDTH,
-	RYGEL_TRACKER_ITEM_METADATA_VIDEO_HEIGHT,
-	RYGEL_TRACKER_ITEM_METADATA_VIDEO_DURATION,
-	RYGEL_TRACKER_ITEM_METADATA_AUTHOR,
-	RYGEL_TRACKER_ITEM_METADATA_LAST_KEY
-} RygelTrackerItemMetadata;
-
-
-static gpointer rygel_tracker_video_item_parent_class = NULL;
-
-GType rygel_tracker_item_get_type (void);
-GType rygel_tracker_video_item_get_type (void);
-enum  {
-	RYGEL_TRACKER_VIDEO_ITEM_DUMMY_PROPERTY
-};
-#define RYGEL_TRACKER_VIDEO_ITEM_SERVICE "Videos"
-GType rygel_tracker_search_container_get_type (void);
-RygelTrackerItem* rygel_tracker_item_construct (GType object_type, const char* id, const char* path, RygelTrackerSearchContainer* parent, const char* upnp_class, char** metadata, int metadata_length1);
-GType rygel_tracker_item_metadata_get_type (void);
-RygelTrackerVideoItem* rygel_tracker_video_item_new (const char* id, const char* path, RygelTrackerSearchContainer* parent, char** metadata, int metadata_length1);
-RygelTrackerVideoItem* rygel_tracker_video_item_construct (GType object_type, const char* id, const char* path, RygelTrackerSearchContainer* parent, char** metadata, int metadata_length1);
-static int _vala_strcmp0 (const char * str1, const char * str2);
-
-
-
-RygelTrackerVideoItem* rygel_tracker_video_item_construct (GType object_type, const char* id, const char* path, RygelTrackerSearchContainer* parent, char** metadata, int metadata_length1) {
-	RygelTrackerVideoItem * self;
-	char* _tmp2_;
-	g_return_val_if_fail (id != NULL, NULL);
-	g_return_val_if_fail (path != NULL, NULL);
-	g_return_val_if_fail (parent != NULL, NULL);
-	self = (RygelTrackerVideoItem*) rygel_tracker_item_construct (object_type, id, path, parent, RYGEL_MEDIA_ITEM_VIDEO_CLASS, metadata, metadata_length1);
-	if (_vala_strcmp0 (metadata[RYGEL_TRACKER_ITEM_METADATA_VIDEO_TITLE], "") != 0) {
-		char* _tmp0_;
-		((RygelMediaObject*) self)->title = (_tmp0_ = g_strdup (metadata[RYGEL_TRACKER_ITEM_METADATA_VIDEO_TITLE]), _g_free0 (((RygelMediaObject*) self)->title), _tmp0_);
-	} else {
-		char* _tmp1_;
-		((RygelMediaObject*) self)->title = (_tmp1_ = g_strdup (metadata[RYGEL_TRACKER_ITEM_METADATA_FILE_NAME]), _g_free0 (((RygelMediaObject*) self)->title), _tmp1_);
-	}
-	if (_vala_strcmp0 (metadata[RYGEL_TRACKER_ITEM_METADATA_VIDEO_WIDTH], "") != 0) {
-		((RygelMediaItem*) self)->width = atoi (metadata[RYGEL_TRACKER_ITEM_METADATA_VIDEO_WIDTH]);
-	}
-	if (_vala_strcmp0 (metadata[RYGEL_TRACKER_ITEM_METADATA_VIDEO_HEIGHT], "") != 0) {
-		((RygelMediaItem*) self)->height = atoi (metadata[RYGEL_TRACKER_ITEM_METADATA_VIDEO_HEIGHT]);
-	}
-	if (_vala_strcmp0 (metadata[RYGEL_TRACKER_ITEM_METADATA_VIDEO_DURATION], "") != 0) {
-		((RygelMediaItem*) self)->duration = (glong) atoi (metadata[RYGEL_TRACKER_ITEM_METADATA_VIDEO_DURATION]);
-	}
-	if (_vala_strcmp0 (metadata[RYGEL_TRACKER_ITEM_METADATA_VIDEO_DURATION], "") != 0) {
-		((RygelMediaItem*) self)->duration = (glong) atoi (metadata[RYGEL_TRACKER_ITEM_METADATA_VIDEO_DURATION]);
-	}
-	((RygelMediaItem*) self)->author = (_tmp2_ = g_strdup (metadata[RYGEL_TRACKER_ITEM_METADATA_AUTHOR]), _g_free0 (((RygelMediaItem*) self)->author), _tmp2_);
-	return self;
-}
-
-
-RygelTrackerVideoItem* rygel_tracker_video_item_new (const char* id, const char* path, RygelTrackerSearchContainer* parent, char** metadata, int metadata_length1) {
-	return rygel_tracker_video_item_construct (RYGEL_TYPE_TRACKER_VIDEO_ITEM, id, path, parent, metadata, metadata_length1);
-}
-
-
-static void rygel_tracker_video_item_class_init (RygelTrackerVideoItemClass * klass) {
-	rygel_tracker_video_item_parent_class = g_type_class_peek_parent (klass);
-}
-
-
-static void rygel_tracker_video_item_instance_init (RygelTrackerVideoItem * self) {
-}
-
-
-GType rygel_tracker_video_item_get_type (void) {
-	static GType rygel_tracker_video_item_type_id = 0;
-	if (rygel_tracker_video_item_type_id == 0) {
-		static const GTypeInfo g_define_type_info = { sizeof (RygelTrackerVideoItemClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) rygel_tracker_video_item_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (RygelTrackerVideoItem), 0, (GInstanceInitFunc) rygel_tracker_video_item_instance_init, NULL };
-		rygel_tracker_video_item_type_id = g_type_register_static (RYGEL_TYPE_TRACKER_ITEM, "RygelTrackerVideoItem", &g_define_type_info, 0);
-	}
-	return rygel_tracker_video_item_type_id;
-}
-
-
-static int _vala_strcmp0 (const char * str1, const char * str2) {
-	if (str1 == NULL) {
-		return -(str1 != str2);
-	}
-	if (str2 == NULL) {
-		return str1 != str2;
-	}
-	return strcmp (str1, str2);
-}
-
-
-
-
--- a/src/rygel/Makefile.in
+++ b/src/rygel/Makefile.in
@@ -44,27 +44,22 @@ DIST_COMMON = $(librygelinc_HEADERS) $(s
 	rygel-browse.c rygel-cmdline-config.c rygel-configuration.c \
 	rygel-connection-manager.c rygel-content-directory.c \
 	rygel-dbus-service.c rygel-didl-lite-writer.c \
-	rygel-gst-utils.c rygel-http-identity-handler.c \
-	rygel-http-request-handler.c rygel-http-request.c \
-	rygel-http-response.c rygel-http-seek.c rygel-http-server.c \
-	rygel-http-transcode-handler.c rygel-icon-info.c \
-	rygel-l16-transcoder-bin.c rygel-l16-transcoder.c \
-	rygel-live-response.c rygel-log-handler.c rygel-main.c \
+	rygel-http-identity-handler.c rygel-http-request-handler.c \
+	rygel-http-request.c rygel-http-response.c rygel-http-server.c \
+	rygel-icon-info.c rygel-log-handler.c rygel-main.c \
 	rygel-media-container.c rygel-media-db-container.c \
 	rygel-media-db-object-factory.c rygel-media-db.c \
 	rygel-media-item.c rygel-media-object-search.c \
 	rygel-media-object.c rygel-meta-config.c \
-	rygel-metadata-extractor.c rygel-mp2ts-transcoder-bin.c \
-	rygel-mp2ts-transcoder.c rygel-mp3-transcoder-bin.c \
-	rygel-mp3-transcoder.c rygel-plugin-loader.c rygel-plugin.c \
+	rygel-network-manager.c rygel-plugin-loader.c rygel-plugin.c \
 	rygel-resource-info.c rygel-root-device-factory.c \
-	rygel-root-device.c rygel-seekable-response.c \
-	rygel-simple-async-result.c rygel-simple-container.c \
-	rygel-state-machine.c rygel-thumbnail.c rygel-thumbnailer.c \
-	rygel-transcode-manager.c rygel-transcoder.c \
-	rygel-user-config.c rygel.h rygel_vala.stamp
+	rygel-root-device.c rygel-simple-async-result.c \
+	rygel-simple-container.c rygel-state-machine.c \
+	rygel-thumbnail.c rygel-thumbnailer.c rygel-user-config.c \
+	rygel.h rygel_vala.stamp
 ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
-am__aclocal_m4_deps = $(top_srcdir)/m4/libtool.m4 \
+am__aclocal_m4_deps = $(top_srcdir)/m4/glib-gettext.m4 \
+	$(top_srcdir)/m4/isc-posix.m4 $(top_srcdir)/m4/libtool.m4 \
 	$(top_srcdir)/m4/ltoptions.m4 $(top_srcdir)/m4/ltsugar.m4 \
 	$(top_srcdir)/m4/ltversion.m4 $(top_srcdir)/m4/lt~obsolete.m4 \
 	$(top_srcdir)/configure.ac
@@ -89,39 +84,29 @@ am_librygel_configuration_a_OBJECTS = ry
 	rygel-cmdline-config.$(OBJEXT) cstuff.$(OBJEXT)
 librygel_configuration_a_OBJECTS =  \
 	$(am_librygel_configuration_a_OBJECTS)
-am__installdirs = "$(DESTDIR)$(bindir)" "$(DESTDIR)$(vapidir)" \
-	"$(DESTDIR)$(librygelincdir)"
+am__installdirs = "$(DESTDIR)$(bindir)" "$(DESTDIR)$(librygelincdir)"
 PROGRAMS = $(bin_PROGRAMS)
 am__objects_1 = rygel-configuration.$(OBJEXT) \
 	rygel-user-config.$(OBJEXT) rygel-meta-config.$(OBJEXT) \
 	rygel-cmdline-config.$(OBJEXT) \
 	rygel-content-directory.$(OBJEXT) \
-	rygel-connection-manager.$(OBJEXT) \
-	rygel-transcode-manager.$(OBJEXT) rygel-http-server.$(OBJEXT) \
+	rygel-connection-manager.$(OBJEXT) rygel-http-server.$(OBJEXT) \
 	rygel-state-machine.$(OBJEXT) rygel-http-request.$(OBJEXT) \
 	rygel-http-request-handler.$(OBJEXT) \
 	rygel-http-identity-handler.$(OBJEXT) \
-	rygel-http-transcode-handler.$(OBJEXT) \
-	rygel-http-seek.$(OBJEXT) rygel-http-response.$(OBJEXT) \
-	rygel-live-response.$(OBJEXT) \
-	rygel-seekable-response.$(OBJEXT) \
-	rygel-resource-info.$(OBJEXT) rygel-icon-info.$(OBJEXT) \
-	rygel-plugin.$(OBJEXT) rygel-plugin-loader.$(OBJEXT) \
-	rygel-media-object.$(OBJEXT) rygel-media-container.$(OBJEXT) \
+	rygel-http-response.$(OBJEXT) rygel-resource-info.$(OBJEXT) \
+	rygel-icon-info.$(OBJEXT) rygel-plugin.$(OBJEXT) \
+	rygel-plugin-loader.$(OBJEXT) rygel-media-object.$(OBJEXT) \
+	rygel-media-container.$(OBJEXT) \
 	rygel-simple-container.$(OBJEXT) \
 	rygel-media-object-search.$(OBJEXT) \
 	rygel-simple-async-result.$(OBJEXT) rygel-media-item.$(OBJEXT) \
 	rygel-thumbnail.$(OBJEXT) rygel-thumbnailer.$(OBJEXT) \
 	rygel-browse.$(OBJEXT) rygel-didl-lite-writer.$(OBJEXT) \
-	rygel-transcoder.$(OBJEXT) rygel-mp2ts-transcoder.$(OBJEXT) \
-	rygel-mp3-transcoder.$(OBJEXT) rygel-l16-transcoder.$(OBJEXT) \
-	rygel-mp2ts-transcoder-bin.$(OBJEXT) \
-	rygel-mp3-transcoder-bin.$(OBJEXT) \
-	rygel-l16-transcoder-bin.$(OBJEXT) rygel-gst-utils.$(OBJEXT) \
-	rygel-media-db.$(OBJEXT) rygel-metadata-extractor.$(OBJEXT) \
-	rygel-media-db-container.$(OBJEXT) \
+	rygel-media-db.$(OBJEXT) rygel-media-db-container.$(OBJEXT) \
 	rygel-media-db-object-factory.$(OBJEXT) \
-	rygel-log-handler.$(OBJEXT)
+	rygel-log-handler.$(OBJEXT) rygel-network-manager.$(OBJEXT) \
+	rygel-network-device.$(OBJEXT)
 am_rygel_OBJECTS = $(am__objects_1) rygel-dbus-service.$(OBJEXT) \
 	rygel-root-device.$(OBJEXT) \
 	rygel-root-device-factory.$(OBJEXT) rygel-main.$(OBJEXT)
@@ -130,7 +115,6 @@ am__DEPENDENCIES_1 =
 rygel_DEPENDENCIES = $(am__DEPENDENCIES_1) $(am__DEPENDENCIES_1) \
 	$(am__DEPENDENCIES_1) $(am__DEPENDENCIES_1) \
 	$(am__DEPENDENCIES_1) $(am__DEPENDENCIES_1) \
-	$(am__DEPENDENCIES_1) $(am__DEPENDENCIES_1) \
 	librygel-configuration.a
 AM_V_lt = $(am__v_lt_$(V))
 am__v_lt_ = $(am__v_lt_$(AM_DEFAULT_VERBOSITY))
@@ -191,7 +175,6 @@ am__nobase_list = $(am__nobase_strip_set
 am__base_list = \
   sed '$$!N;$$!N;$$!N;$$!N;$$!N;$$!N;$$!N;s/\n/ /g' | \
   sed '$$!N;$$!N;$$!N;$$!N;s/\n/ /g'
-DATA = $(vapi_DATA)
 HEADERS = $(librygelinc_HEADERS)
 ETAGS = etags
 CTAGS = ctags
@@ -232,8 +215,6 @@ GMSGFMT = @GMSGFMT@
 GREP = @GREP@
 GTK_CFLAGS = @GTK_CFLAGS@
 GTK_LIBS = @GTK_LIBS@
-GUPNP_VALA_CFLAGS = @GUPNP_VALA_CFLAGS@
-GUPNP_VALA_LIBS = @GUPNP_VALA_LIBS@
 HAVE_GTK = @HAVE_GTK@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
@@ -248,8 +229,8 @@ LIBDBUS_GLIB_CFLAGS = @LIBDBUS_GLIB_CFLA
 LIBDBUS_GLIB_LIBS = @LIBDBUS_GLIB_LIBS@
 LIBGIO_CFLAGS = @LIBGIO_CFLAGS@
 LIBGIO_LIBS = @LIBGIO_LIBS@
-LIBGSTREAMER_CFLAGS = @LIBGSTREAMER_CFLAGS@
-LIBGSTREAMER_LIBS = @LIBGSTREAMER_LIBS@
+LIBGLIB_CFLAGS = @LIBGLIB_CFLAGS@
+LIBGLIB_LIBS = @LIBGLIB_LIBS@
 LIBGUPNP_AV_CFLAGS = @LIBGUPNP_AV_CFLAGS@
 LIBGUPNP_AV_LIBS = @LIBGUPNP_AV_LIBS@
 LIBGUPNP_CFLAGS = @LIBGUPNP_CFLAGS@
@@ -261,6 +242,8 @@ LIBSOUP_LIBS = @LIBSOUP_LIBS@
 LIBSQLITE3_CFLAGS = @LIBSQLITE3_CFLAGS@
 LIBSQLITE3_LIBS = @LIBSQLITE3_LIBS@
 LIBTOOL = @LIBTOOL@
+LIBVLC_CFLAGS = @LIBVLC_CFLAGS@
+LIBVLC_LIBS = @LIBVLC_LIBS@
 LIPO = @LIPO@
 LN_S = @LN_S@
 LTLIBOBJS = @LTLIBOBJS@
@@ -281,6 +264,7 @@ PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
 PACKAGE_NAME = @PACKAGE_NAME@
 PACKAGE_STRING = @PACKAGE_STRING@
 PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_URL = @PACKAGE_URL@
 PACKAGE_VERSION = @PACKAGE_VERSION@
 PATH_SEPARATOR = @PATH_SEPARATOR@
 PKG_CONFIG = @PKG_CONFIG@
@@ -294,8 +278,6 @@ SET_MAKE = @SET_MAKE@
 SHELL = @SHELL@
 STRIP = @STRIP@
 USE_NLS = @USE_NLS@
-UUID_CFLAGS = @UUID_CFLAGS@
-UUID_LIBS = @UUID_LIBS@
 VALAC = @VALAC@
 VAPIDIR = @VAPIDIR@
 VERSION = @VERSION@
@@ -358,9 +340,13 @@ top_srcdir = @top_srcdir@
 @UNINSTALLED_TRUE@desktopdir = $(shareddir)
 @UNINSTALLED_FALSE@plugindir = $(libdir)/rygel-1.0
 @UNINSTALLED_TRUE@plugindir = $(abs_top_builddir)/src/plugins
+DATA_DIR = $(shareddir:$(prefix)%=%)
+SYS_CONFIG_DIR = $(sysconfdir:$(prefix)%=%)
+PLUGIN_DIR = $(plugindir:$(prefix)%=%)
+DESKTOP_DIR = $(desktopdir:$(prefix)%=%)
 AM_CFLAGS = $(LIBGUPNP_CFLAGS) \
 	    $(LIBGUPNP_AV_CFLAGS) \
-	    $(LIBGSTREAMER_CFLAGS) \
+	    $(LIBGLIB_CFLAGS) \
 	    $(GIO_CFLAGS) \
 	    $(GEE_CFLAGS) \
 	    $(UUID_CFLAGS) \
@@ -368,8 +354,8 @@ AM_CFLAGS = $(LIBGUPNP_CFLAGS) \
 	    $(LIBDBUS_GLIB_CFLAGS) \
 	    $(LIBSQLITE3_CFLAGS) \
 	    -I$(top_srcdir) \
-	    -DDATA_DIR='"$(shareddir)"' -DSYS_CONFIG_DIR='"$(sysconfdir)"'\
-	    -DPLUGIN_DIR='"$(plugindir)"' -DDESKTOP_DIR='"$(desktopdir)"'\
+	    -DDATA_DIR='"$(DATA_DIR)"' -DSYS_CONFIG_DIR='"$(SYS_CONFIG_DIR)"'\
+	    -DPLUGIN_DIR='"$(PLUGIN_DIR)"' -DDESKTOP_DIR='"$(DESKTOP_DIR)"'\
 	    -include config.h
 
 librygelincdir = $(includedir)/rygel-1.0
@@ -389,17 +375,12 @@ VAPI_SOURCE_FILES = rygel-configuration.
 		    rygel-cmdline-config.vala \
 		    rygel-content-directory.vala \
 		    rygel-connection-manager.vala \
-		    rygel-transcode-manager.vala \
 		    rygel-http-server.vala \
 		    rygel-state-machine.vala \
 		    rygel-http-request.vala \
 		    rygel-http-request-handler.vala \
 		    rygel-http-identity-handler.vala \
-		    rygel-http-transcode-handler.vala \
-		    rygel-http-seek.vala \
 		    rygel-http-response.vala \
-		    rygel-live-response.vala \
-		    rygel-seekable-response.vala \
 		    rygel-resource-info.vala \
 		    rygel-icon-info.vala \
 		    rygel-plugin.vala \
@@ -414,28 +395,20 @@ VAPI_SOURCE_FILES = rygel-configuration.
 		    rygel-thumbnailer.vala \
 		    rygel-browse.vala \
 		    rygel-didl-lite-writer.vala \
-		    rygel-transcoder.vala \
-		    rygel-mp2ts-transcoder.vala \
-		    rygel-mp3-transcoder.vala \
-		    rygel-l16-transcoder.vala \
-		    rygel-mp2ts-transcoder-bin.vala \
-		    rygel-mp3-transcoder-bin.vala \
-		    rygel-l16-transcoder-bin.vala \
-		    rygel-gst-utils.vala \
 		    rygel-media-db.vala \
-		    rygel-metadata-extractor.vala \
 		    rygel-media-db-container.vala \
 		    rygel-media-db-object-factory.vala \
-		    rygel-log-handler.vala
+		    rygel-log-handler.vala \
+		    rygel-network-manager.vala \
+		    rygel-network-device.c
 
 rygel_VALAFLAGS = \
-	-H rygel.h -C --library=rygel-1.0 --vapidir=$(srcdir) --thread \
+	-H rygel.h -C --library=rygel-1.0 --vapidir=$(srcdir) --vapidir=$(top_srcdir)/vapi --thread \
 	--pkg cstuff --pkg gupnp-1.0 --pkg gupnp-av-1.0 --pkg dbus-glib-1 \
-	--pkg gstreamer-0.10 --pkg gio-2.0 --pkg gee-1.0 --pkg sqlite3
+	--pkg gmodule-2.0 --pkg gio-2.0 --pkg gee-1.0 --pkg sqlite3 --pkg rygel-network-device
 
 rygel_LDADD = $(LIBGUPNP_LIBS) \
 	      $(LIBGUPNP_AV_LIBS) \
-	      $(LIBGSTREAMER_LIBS) \
 	      $(GIO_LIBS) \
 	      $(GEE_LIBS) \
 	      $(UUID_LIBS) \
@@ -448,7 +421,6 @@ rygel_LDFLAGS = -export-dynamic
 VAPI_FILES = rygel-1.0.vapi
 DEPS_FILES = rygel-1.0.deps
 vapidir = $(VAPIDIR)
-vapi_DATA = $(VAPI_FILES) $(DEPS_FILES)
 noinst_LIBRARIES = librygel-configuration.a
 librygel_configuration_a_SOURCES = rygel-configuration.c \
 				   rygel-user-config.c \
@@ -565,18 +537,12 @@ distclean-compile:
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/rygel-content-directory.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/rygel-dbus-service.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/rygel-didl-lite-writer.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/rygel-gst-utils.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/rygel-http-identity-handler.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/rygel-http-request-handler.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/rygel-http-request.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/rygel-http-response.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/rygel-http-seek.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/rygel-http-server.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/rygel-http-transcode-handler.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/rygel-icon-info.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/rygel-l16-transcoder-bin.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/rygel-l16-transcoder.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/rygel-live-response.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/rygel-log-handler.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/rygel-main.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/rygel-media-container.Po@am__quote@
@@ -587,24 +553,18 @@ distclean-compile:
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/rygel-media-object-search.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/rygel-media-object.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/rygel-meta-config.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/rygel-metadata-extractor.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/rygel-mp2ts-transcoder-bin.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/rygel-mp2ts-transcoder.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/rygel-mp3-transcoder-bin.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/rygel-mp3-transcoder.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/rygel-network-device.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/rygel-network-manager.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/rygel-plugin-loader.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/rygel-plugin.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/rygel-resource-info.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/rygel-root-device-factory.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/rygel-root-device.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/rygel-seekable-response.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/rygel-simple-async-result.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/rygel-simple-container.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/rygel-state-machine.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/rygel-thumbnail.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/rygel-thumbnailer.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/rygel-transcode-manager.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/rygel-transcoder.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/rygel-user-config.Po@am__quote@
 
 .c.o:
@@ -660,11 +620,6 @@ $(srcdir)/rygel-connection-manager.c: $(
 	  rm -f $(srcdir)/rygel_vala.stamp; \
 	  $(am__cd) $(srcdir) && $(MAKE) $(AM_MAKEFLAGS) rygel_vala.stamp; \
 	fi
-$(srcdir)/rygel-transcode-manager.c: $(srcdir)/rygel_vala.stamp
-	@if test -f $@; then :; else \
-	  rm -f $(srcdir)/rygel_vala.stamp; \
-	  $(am__cd) $(srcdir) && $(MAKE) $(AM_MAKEFLAGS) rygel_vala.stamp; \
-	fi
 $(srcdir)/rygel-http-server.c: $(srcdir)/rygel_vala.stamp
 	@if test -f $@; then :; else \
 	  rm -f $(srcdir)/rygel_vala.stamp; \
@@ -690,31 +645,11 @@ $(srcdir)/rygel-http-identity-handler.c:
 	  rm -f $(srcdir)/rygel_vala.stamp; \
 	  $(am__cd) $(srcdir) && $(MAKE) $(AM_MAKEFLAGS) rygel_vala.stamp; \
 	fi
-$(srcdir)/rygel-http-transcode-handler.c: $(srcdir)/rygel_vala.stamp
-	@if test -f $@; then :; else \
-	  rm -f $(srcdir)/rygel_vala.stamp; \
-	  $(am__cd) $(srcdir) && $(MAKE) $(AM_MAKEFLAGS) rygel_vala.stamp; \
-	fi
-$(srcdir)/rygel-http-seek.c: $(srcdir)/rygel_vala.stamp
-	@if test -f $@; then :; else \
-	  rm -f $(srcdir)/rygel_vala.stamp; \
-	  $(am__cd) $(srcdir) && $(MAKE) $(AM_MAKEFLAGS) rygel_vala.stamp; \
-	fi
 $(srcdir)/rygel-http-response.c: $(srcdir)/rygel_vala.stamp
 	@if test -f $@; then :; else \
 	  rm -f $(srcdir)/rygel_vala.stamp; \
 	  $(am__cd) $(srcdir) && $(MAKE) $(AM_MAKEFLAGS) rygel_vala.stamp; \
 	fi
-$(srcdir)/rygel-live-response.c: $(srcdir)/rygel_vala.stamp
-	@if test -f $@; then :; else \
-	  rm -f $(srcdir)/rygel_vala.stamp; \
-	  $(am__cd) $(srcdir) && $(MAKE) $(AM_MAKEFLAGS) rygel_vala.stamp; \
-	fi
-$(srcdir)/rygel-seekable-response.c: $(srcdir)/rygel_vala.stamp
-	@if test -f $@; then :; else \
-	  rm -f $(srcdir)/rygel_vala.stamp; \
-	  $(am__cd) $(srcdir) && $(MAKE) $(AM_MAKEFLAGS) rygel_vala.stamp; \
-	fi
 $(srcdir)/rygel-resource-info.c: $(srcdir)/rygel_vala.stamp
 	@if test -f $@; then :; else \
 	  rm -f $(srcdir)/rygel_vala.stamp; \
@@ -785,67 +720,27 @@ $(srcdir)/rygel-didl-lite-writer.c: $(sr
 	  rm -f $(srcdir)/rygel_vala.stamp; \
 	  $(am__cd) $(srcdir) && $(MAKE) $(AM_MAKEFLAGS) rygel_vala.stamp; \
 	fi
-$(srcdir)/rygel-transcoder.c: $(srcdir)/rygel_vala.stamp
-	@if test -f $@; then :; else \
-	  rm -f $(srcdir)/rygel_vala.stamp; \
-	  $(am__cd) $(srcdir) && $(MAKE) $(AM_MAKEFLAGS) rygel_vala.stamp; \
-	fi
-$(srcdir)/rygel-mp2ts-transcoder.c: $(srcdir)/rygel_vala.stamp
-	@if test -f $@; then :; else \
-	  rm -f $(srcdir)/rygel_vala.stamp; \
-	  $(am__cd) $(srcdir) && $(MAKE) $(AM_MAKEFLAGS) rygel_vala.stamp; \
-	fi
-$(srcdir)/rygel-mp3-transcoder.c: $(srcdir)/rygel_vala.stamp
-	@if test -f $@; then :; else \
-	  rm -f $(srcdir)/rygel_vala.stamp; \
-	  $(am__cd) $(srcdir) && $(MAKE) $(AM_MAKEFLAGS) rygel_vala.stamp; \
-	fi
-$(srcdir)/rygel-l16-transcoder.c: $(srcdir)/rygel_vala.stamp
-	@if test -f $@; then :; else \
-	  rm -f $(srcdir)/rygel_vala.stamp; \
-	  $(am__cd) $(srcdir) && $(MAKE) $(AM_MAKEFLAGS) rygel_vala.stamp; \
-	fi
-$(srcdir)/rygel-mp2ts-transcoder-bin.c: $(srcdir)/rygel_vala.stamp
-	@if test -f $@; then :; else \
-	  rm -f $(srcdir)/rygel_vala.stamp; \
-	  $(am__cd) $(srcdir) && $(MAKE) $(AM_MAKEFLAGS) rygel_vala.stamp; \
-	fi
-$(srcdir)/rygel-mp3-transcoder-bin.c: $(srcdir)/rygel_vala.stamp
-	@if test -f $@; then :; else \
-	  rm -f $(srcdir)/rygel_vala.stamp; \
-	  $(am__cd) $(srcdir) && $(MAKE) $(AM_MAKEFLAGS) rygel_vala.stamp; \
-	fi
-$(srcdir)/rygel-l16-transcoder-bin.c: $(srcdir)/rygel_vala.stamp
-	@if test -f $@; then :; else \
-	  rm -f $(srcdir)/rygel_vala.stamp; \
-	  $(am__cd) $(srcdir) && $(MAKE) $(AM_MAKEFLAGS) rygel_vala.stamp; \
-	fi
-$(srcdir)/rygel-gst-utils.c: $(srcdir)/rygel_vala.stamp
-	@if test -f $@; then :; else \
-	  rm -f $(srcdir)/rygel_vala.stamp; \
-	  $(am__cd) $(srcdir) && $(MAKE) $(AM_MAKEFLAGS) rygel_vala.stamp; \
-	fi
 $(srcdir)/rygel-media-db.c: $(srcdir)/rygel_vala.stamp
 	@if test -f $@; then :; else \
 	  rm -f $(srcdir)/rygel_vala.stamp; \
 	  $(am__cd) $(srcdir) && $(MAKE) $(AM_MAKEFLAGS) rygel_vala.stamp; \
 	fi
-$(srcdir)/rygel-metadata-extractor.c: $(srcdir)/rygel_vala.stamp
+$(srcdir)/rygel-media-db-container.c: $(srcdir)/rygel_vala.stamp
 	@if test -f $@; then :; else \
 	  rm -f $(srcdir)/rygel_vala.stamp; \
 	  $(am__cd) $(srcdir) && $(MAKE) $(AM_MAKEFLAGS) rygel_vala.stamp; \
 	fi
-$(srcdir)/rygel-media-db-container.c: $(srcdir)/rygel_vala.stamp
+$(srcdir)/rygel-media-db-object-factory.c: $(srcdir)/rygel_vala.stamp
 	@if test -f $@; then :; else \
 	  rm -f $(srcdir)/rygel_vala.stamp; \
 	  $(am__cd) $(srcdir) && $(MAKE) $(AM_MAKEFLAGS) rygel_vala.stamp; \
 	fi
-$(srcdir)/rygel-media-db-object-factory.c: $(srcdir)/rygel_vala.stamp
+$(srcdir)/rygel-log-handler.c: $(srcdir)/rygel_vala.stamp
 	@if test -f $@; then :; else \
 	  rm -f $(srcdir)/rygel_vala.stamp; \
 	  $(am__cd) $(srcdir) && $(MAKE) $(AM_MAKEFLAGS) rygel_vala.stamp; \
 	fi
-$(srcdir)/rygel-log-handler.c: $(srcdir)/rygel_vala.stamp
+$(srcdir)/rygel-network-manager.c: $(srcdir)/rygel_vala.stamp
 	@if test -f $@; then :; else \
 	  rm -f $(srcdir)/rygel_vala.stamp; \
 	  $(am__cd) $(srcdir) && $(MAKE) $(AM_MAKEFLAGS) rygel_vala.stamp; \
@@ -887,26 +782,6 @@ mostlyclean-libtool:
 
 clean-libtool:
 	-rm -rf .libs _libs
-install-vapiDATA: $(vapi_DATA)
-	@$(NORMAL_INSTALL)
-	test -z "$(vapidir)" || $(MKDIR_P) "$(DESTDIR)$(vapidir)"
-	@list='$(vapi_DATA)'; test -n "$(vapidir)" || list=; \
-	for p in $$list; do \
-	  if test -f "$$p"; then d=; else d="$(srcdir)/"; fi; \
-	  echo "$$d$$p"; \
-	done | $(am__base_list) | \
-	while read files; do \
-	  echo " $(INSTALL_DATA) $$files '$(DESTDIR)$(vapidir)'"; \
-	  $(INSTALL_DATA) $$files "$(DESTDIR)$(vapidir)" || exit $$?; \
-	done
-
-uninstall-vapiDATA:
-	@$(NORMAL_UNINSTALL)
-	@list='$(vapi_DATA)'; test -n "$(vapidir)" || list=; \
-	files=`for p in $$list; do echo $$p; done | sed -e 's|^.*/||'`; \
-	test -n "$$files" || exit 0; \
-	echo " ( cd '$(DESTDIR)$(vapidir)' && rm -f" $$files ")"; \
-	cd "$(DESTDIR)$(vapidir)" && rm -f $$files
 install-librygelincHEADERS: $(librygelinc_HEADERS)
 	@$(NORMAL_INSTALL)
 	test -z "$(librygelincdir)" || $(MKDIR_P) "$(DESTDIR)$(librygelincdir)"
@@ -1013,9 +888,9 @@ distdir: $(DISTFILES)
 check-am: all-am
 check: $(BUILT_SOURCES)
 	$(MAKE) $(AM_MAKEFLAGS) check-am
-all-am: Makefile $(LIBRARIES) $(PROGRAMS) $(DATA) $(HEADERS)
+all-am: Makefile $(LIBRARIES) $(PROGRAMS) $(HEADERS)
 installdirs:
-	for dir in "$(DESTDIR)$(bindir)" "$(DESTDIR)$(vapidir)" "$(DESTDIR)$(librygelincdir)"; do \
+	for dir in "$(DESTDIR)$(bindir)" "$(DESTDIR)$(librygelincdir)"; do \
 	  test -z "$$dir" || $(MKDIR_P) "$$dir"; \
 	done
 install: $(BUILT_SOURCES)
@@ -1052,18 +927,12 @@ maintainer-clean-generic:
 	-rm -f rygel-content-directory.c
 	-rm -f rygel-dbus-service.c
 	-rm -f rygel-didl-lite-writer.c
-	-rm -f rygel-gst-utils.c
 	-rm -f rygel-http-identity-handler.c
 	-rm -f rygel-http-request-handler.c
 	-rm -f rygel-http-request.c
 	-rm -f rygel-http-response.c
-	-rm -f rygel-http-seek.c
 	-rm -f rygel-http-server.c
-	-rm -f rygel-http-transcode-handler.c
 	-rm -f rygel-icon-info.c
-	-rm -f rygel-l16-transcoder-bin.c
-	-rm -f rygel-l16-transcoder.c
-	-rm -f rygel-live-response.c
 	-rm -f rygel-log-handler.c
 	-rm -f rygel-main.c
 	-rm -f rygel-media-container.c
@@ -1074,24 +943,17 @@ maintainer-clean-generic:
 	-rm -f rygel-media-object-search.c
 	-rm -f rygel-media-object.c
 	-rm -f rygel-meta-config.c
-	-rm -f rygel-metadata-extractor.c
-	-rm -f rygel-mp2ts-transcoder-bin.c
-	-rm -f rygel-mp2ts-transcoder.c
-	-rm -f rygel-mp3-transcoder-bin.c
-	-rm -f rygel-mp3-transcoder.c
+	-rm -f rygel-network-manager.c
 	-rm -f rygel-plugin-loader.c
 	-rm -f rygel-plugin.c
 	-rm -f rygel-resource-info.c
 	-rm -f rygel-root-device-factory.c
 	-rm -f rygel-root-device.c
-	-rm -f rygel-seekable-response.c
 	-rm -f rygel-simple-async-result.c
 	-rm -f rygel-simple-container.c
 	-rm -f rygel-state-machine.c
 	-rm -f rygel-thumbnail.c
 	-rm -f rygel-thumbnailer.c
-	-rm -f rygel-transcode-manager.c
-	-rm -f rygel-transcoder.c
 	-rm -f rygel-user-config.c
 	-rm -f rygel.h
 	-rm -f rygel_vala.stamp
@@ -1120,7 +982,7 @@ info: info-am
 
 info-am:
 
-install-data-am: install-librygelincHEADERS install-vapiDATA
+install-data-am: install-librygelincHEADERS
 
 install-dvi: install-dvi-am
 
@@ -1166,8 +1028,7 @@ ps: ps-am
 
 ps-am:
 
-uninstall-am: uninstall-binPROGRAMS uninstall-librygelincHEADERS \
-	uninstall-vapiDATA
+uninstall-am: uninstall-binPROGRAMS uninstall-librygelincHEADERS
 
 .MAKE: all check install install-am install-strip
 
@@ -1180,13 +1041,14 @@ uninstall-am: uninstall-binPROGRAMS unin
 	install-exec install-exec-am install-html install-html-am \
 	install-info install-info-am install-librygelincHEADERS \
 	install-man install-pdf install-pdf-am install-ps \
-	install-ps-am install-strip install-vapiDATA installcheck \
-	installcheck-am installdirs maintainer-clean \
-	maintainer-clean-generic mostlyclean mostlyclean-compile \
-	mostlyclean-generic mostlyclean-libtool pdf pdf-am ps ps-am \
-	tags uninstall uninstall-am uninstall-binPROGRAMS \
-	uninstall-librygelincHEADERS uninstall-vapiDATA
+	install-ps-am install-strip installcheck installcheck-am \
+	installdirs maintainer-clean maintainer-clean-generic \
+	mostlyclean mostlyclean-compile mostlyclean-generic \
+	mostlyclean-libtool pdf pdf-am ps ps-am tags uninstall \
+	uninstall-am uninstall-binPROGRAMS \
+	uninstall-librygelincHEADERS
 
+#vapi_DATA = $(VAPI_FILES) $(DEPS_FILES)
 rygel-1.0.vapi rygel.h: $(VAPI_SOURCE_FILES)
 
 # Tell versions [3.59,3.63) of GNU make to not export all variables.
--- a/src/rygel/rygel-1.0.vapi
+++ /dev/null
@@ -1,340 +0,0 @@
-/* rygel-1.0.vapi generated by valac, do not modify. */
-
-[CCode (cprefix = "Gst", lower_case_cprefix = "gst_")]
-namespace Gst {
-}
-[CCode (cprefix = "Rygel", lower_case_cprefix = "rygel_")]
-namespace Rygel {
-	[CCode (cheader_filename = "rygel.h")]
-	public class CmdlineConfig : GLib.Object, Rygel.Configuration {
-		public CmdlineConfig ();
-		public static Rygel.CmdlineConfig get_default ();
-		public static void parse_args (ref unowned string[] args) throws Rygel.CmdlineConfigError, GLib.OptionError;
-	}
-	[CCode (cheader_filename = "rygel.h")]
-	public class ConnectionManager : GUPnP.Service {
-		protected string connection_ids;
-		protected string sink_protocol_info;
-		public const string DESCRIPTION_PATH;
-		public const string UPNP_ID;
-		public const string UPNP_TYPE;
-		public ConnectionManager ();
-		public override void constructed ();
-		protected string source_protocol_info { owned get; }
-	}
-	[CCode (cheader_filename = "rygel.h")]
-	public class ContentDirectory : GUPnP.Service {
-		protected string feature_list;
-		public Rygel.MediaContainer root_container;
-		protected string search_caps;
-		protected string sort_caps;
-		public uint32 system_update_id;
-		public const string DESCRIPTION_PATH;
-		public const string UPNP_ID;
-		public const string UPNP_TYPE;
-		public ContentDirectory ();
-		public override void constructed ();
-		public virtual Rygel.MediaContainer? create_root_container ();
-	}
-	[CCode (cheader_filename = "rygel.h")]
-	[DBus (name = "org.gnome.Rygel1")]
-	public class DBusService : GLib.Object {
-		public DBusService (Rygel.Main main) throws DBus.Error;
-		public void Shutdown ();
-	}
-	[CCode (ref_function = "rygel_icon_info_ref", unref_function = "rygel_icon_info_unref", cheader_filename = "rygel.h")]
-	public class IconInfo {
-		public int depth;
-		public int height;
-		public string mime_type;
-		public string path;
-		public long size;
-		public int width;
-		public IconInfo (string mime_type);
-	}
-	[CCode (cheader_filename = "rygel.h")]
-	public class LogHandler : GLib.Object {
-		public GLib.LogLevelFlags levels;
-		public static Rygel.LogHandler get_default ();
-	}
-	[CCode (cheader_filename = "rygel.h")]
-	public class Main : GLib.Object {
-		public void exit (int exit_code);
-	}
-	[CCode (cheader_filename = "rygel.h")]
-	public abstract class MediaContainer : Rygel.MediaObject {
-		public uint child_count;
-		public uint32 update_id;
-		public MediaContainer (string id, Rygel.MediaContainer? parent, string title, uint child_count);
-		public abstract void find_object (string id, GLib.Cancellable? cancellable, GLib.AsyncReadyCallback callback);
-		public abstract Rygel.MediaObject? find_object_finish (GLib.AsyncResult res) throws GLib.Error;
-		public abstract void get_children (uint offset, uint max_count, GLib.Cancellable? cancellable, GLib.AsyncReadyCallback callback);
-		public abstract Gee.List<Rygel.MediaObject>? get_children_finish (GLib.AsyncResult res) throws GLib.Error;
-		public MediaContainer.root (string title, uint child_count);
-		public void updated ();
-		public signal void container_updated (Rygel.MediaContainer container);
-	}
-	[CCode (cheader_filename = "rygel.h")]
-	public class MediaDB : GLib.Object {
-		public static Rygel.MediaDB? create (string name) throws Rygel.MediaDBError;
-		public static Rygel.MediaDB? create_with_factory (string name, Rygel.MediaDBObjectFactory factory) throws Rygel.MediaDBError;
-		public bool exists (string object_id, out int64 timestamp) throws Rygel.MediaDBError;
-		public int get_child_count (string container_id) throws Rygel.MediaDBError;
-		public Gee.ArrayList<string> get_child_ids (string container_id) throws Rygel.MediaDBError;
-		public Gee.ArrayList<Rygel.MediaObject> get_children (string container_id, long offset, long max_count);
-		public Rygel.MediaContainer? get_container (string container_id) throws Rygel.MediaDBError;
-		public Rygel.MediaItem? get_item (string item_id) throws Rygel.MediaDBError;
-		public Rygel.MediaObject? get_object (string object_id) throws Rygel.MediaDBError;
-		public void remove_by_id (string id) throws Rygel.MediaDBError;
-		public void remove_object (Rygel.MediaObject obj) throws Rygel.MediaDBError;
-		public void save_container (Rygel.MediaContainer container) throws GLib.Error;
-		public void save_item (Rygel.MediaItem item) throws GLib.Error;
-		public void save_object (Rygel.MediaObject obj) throws GLib.Error;
-		public void update_object (Rygel.MediaObject obj) throws GLib.Error;
-		public signal void container_added (string container_id);
-		public signal void container_removed (string container_id);
-		public signal void container_updated (string container_id);
-		public signal void item_added (string item_id);
-		public signal void item_removed (string item_id);
-		public signal void item_updated (string item_id);
-		public signal void object_added (string object_id);
-		public signal void object_removed (string object_id);
-		public signal void object_updated (string object_id);
-	}
-	[CCode (cheader_filename = "rygel.h")]
-	public class MediaDBContainer : Rygel.MediaContainer {
-		protected Rygel.MediaDB media_db;
-		public MediaDBContainer (Rygel.MediaDB media_db, string id, string title);
-		public override void find_object (string id, GLib.Cancellable? cancellable, GLib.AsyncReadyCallback callback);
-		public override Rygel.MediaObject? find_object_finish (GLib.AsyncResult res);
-		public override void get_children (uint offset, uint max_count, GLib.Cancellable? cancellable, GLib.AsyncReadyCallback callback);
-		public override Gee.List<Rygel.MediaObject>? get_children_finish (GLib.AsyncResult res) throws GLib.Error;
-	}
-	[CCode (cheader_filename = "rygel.h")]
-	public class MediaDBObjectFactory : GLib.Object {
-		public MediaDBObjectFactory ();
-		public virtual Rygel.MediaContainer get_container (Rygel.MediaDB media_db, string id, string title, uint child_count);
-		public virtual Rygel.MediaItem get_item (Rygel.MediaDB media_db, Rygel.MediaContainer parent, string id, string title, string upnp_class);
-	}
-	[CCode (cheader_filename = "rygel.h")]
-	public class MediaItem : Rygel.MediaObject {
-		public string album;
-		public string author;
-		public int bitrate;
-		public int bits_per_sample;
-		public int color_depth;
-		public string date;
-		public string dlna_profile;
-		public long duration;
-		public int height;
-		public string mime_type;
-		public int n_audio_channels;
-		public int pixel_height;
-		public int pixel_width;
-		public int sample_freq;
-		public long size;
-		public Gee.ArrayList<Rygel.Thumbnail> thumbnails;
-		public int track_number;
-		public string upnp_class;
-		public int width;
-		public const string AUDIO_CLASS;
-		public const string IMAGE_CLASS;
-		public const string MUSIC_CLASS;
-		public const string VIDEO_CLASS;
-		public MediaItem (string id, Rygel.MediaContainer parent, string title, string upnp_class);
-		public void add_uri (string uri, Rygel.Thumbnail? thumbnail);
-		public virtual Gst.Element? create_stream_source ();
-		public virtual bool should_stream ();
-	}
-	[CCode (cheader_filename = "rygel.h")]
-	public abstract class MediaObject : GLib.Object {
-		public string id;
-		public uint64 modified;
-		public weak Rygel.MediaContainer parent;
-		public Rygel.MediaContainer parent_ref;
-		public string title;
-		public Gee.ArrayList<string> uris;
-		public MediaObject ();
-	}
-	[CCode (cheader_filename = "rygel.h")]
-	public class MetaConfig : GLib.Object, Rygel.Configuration {
-		public MetaConfig ();
-		public static Rygel.MetaConfig get_default ();
-	}
-	[CCode (cheader_filename = "rygel.h")]
-	public class MetadataExtractor : GLib.Object {
-		public const string TAG_RYGEL_CHANNELS;
-		public const string TAG_RYGEL_DEPTH;
-		public const string TAG_RYGEL_DURATION;
-		public const string TAG_RYGEL_HEIGHT;
-		public const string TAG_RYGEL_MIME;
-		public const string TAG_RYGEL_MTIME;
-		public const string TAG_RYGEL_RATE;
-		public const string TAG_RYGEL_SIZE;
-		public const string TAG_RYGEL_WIDTH;
-		public MetadataExtractor ();
-		public void extract (GLib.File file);
-		public signal void error (GLib.File file, GLib.Error err);
-		public signal void extraction_done (GLib.File file, Gst.TagList tag_list);
-	}
-	[CCode (cheader_filename = "rygel.h")]
-	public class Plugin : GUPnP.ResourceFactory {
-		public string desc_path;
-		public Gee.ArrayList<Rygel.IconInfo> icon_infos;
-		public string name;
-		public Gee.ArrayList<Rygel.ResourceInfo> resource_infos;
-		public string title;
-		public Plugin (string desc_path, string name, string? title);
-		public Plugin.MediaServer (string name, string? title);
-		public void add_icon (Rygel.IconInfo icon_info);
-		public void add_resource (Rygel.ResourceInfo resource_info);
-		public bool available { get; set; }
-	}
-	[CCode (cheader_filename = "rygel.h")]
-	public class PluginLoader : GLib.Object {
-		public PluginLoader ();
-		public void add_plugin (Rygel.Plugin plugin);
-		public Rygel.Plugin? get_plugin_by_name (string name);
-		public Gee.Collection<Rygel.Plugin> list_plugins ();
-		public void load_plugins ();
-		public signal void plugin_available (Rygel.Plugin plugin);
-	}
-	[CCode (ref_function = "rygel_resource_info_ref", unref_function = "rygel_resource_info_unref", cheader_filename = "rygel.h")]
-	public class ResourceInfo {
-		public string description_path;
-		public GLib.Type type;
-		public string upnp_id;
-		public string upnp_type;
-		public ResourceInfo (string upnp_id, string upnp_type, string description_path, GLib.Type type);
-	}
-	[CCode (cheader_filename = "rygel.h")]
-	public class RootDevice : GUPnP.RootDevice {
-		public RootDevice (GUPnP.Context context, Rygel.Plugin plugin, GUPnP.XMLDoc description_doc, string description_path, string description_dir);
-	}
-	[CCode (ref_function = "rygel_root_device_factory_ref", unref_function = "rygel_root_device_factory_unref", cheader_filename = "rygel.h")]
-	public class RootDeviceFactory {
-		public GUPnP.Context context;
-		public RootDeviceFactory (GUPnP.Context context) throws GLib.Error;
-		public Rygel.RootDevice create (Rygel.Plugin plugin) throws GLib.Error;
-	}
-	[CCode (cheader_filename = "rygel.h")]
-	public class SimpleAsyncResult<G> : GLib.Object, GLib.AsyncResult {
-		protected GLib.AsyncReadyCallback callback;
-		public G data;
-		public GLib.Error error;
-		protected GLib.Object source_object;
-		public SimpleAsyncResult (GLib.Object source_object, GLib.AsyncReadyCallback callback);
-		public void complete ();
-		public void complete_in_idle ();
-	}
-	[CCode (cheader_filename = "rygel.h")]
-	public class SimpleContainer : Rygel.MediaContainer {
-		public Gee.ArrayList<Rygel.MediaObject> children;
-		public SimpleContainer (string id, Rygel.MediaContainer? parent, string title);
-		public void add_child (Rygel.MediaObject child);
-		public override void find_object (string id, GLib.Cancellable? cancellable, GLib.AsyncReadyCallback callback);
-		public override Rygel.MediaObject? find_object_finish (GLib.AsyncResult res) throws GLib.Error;
-		public override void get_children (uint offset, uint max_count, GLib.Cancellable? cancellable, GLib.AsyncReadyCallback callback);
-		public override Gee.List<Rygel.MediaObject>? get_children_finish (GLib.AsyncResult res) throws GLib.Error;
-		public void remove_child (Rygel.MediaObject child);
-		public SimpleContainer.root (string title);
-	}
-	[CCode (cheader_filename = "rygel.h")]
-	public class Thumbnail : Rygel.IconInfo {
-		public string dlna_profile;
-		public string uri;
-		public Thumbnail (string mime_type = "image/jpeg", string dlna_profile = "JPEG_TN");
-	}
-	[CCode (cheader_filename = "rygel.h")]
-	public class UserConfig : GLib.Object, Rygel.Configuration {
-		protected GLib.KeyFile key_file;
-		protected const string CONFIG_FILE;
-		protected const string ENABLED_KEY;
-		protected const string IFACE_KEY;
-		protected const string LOG_LEVEL_KEY;
-		protected const string LPCM_TRANSCODER_KEY;
-		protected const string MP2TS_TRANSCODER_KEY;
-		protected const string MP3_TRANSCODER_KEY;
-		protected const string PORT_KEY;
-		protected const string TITLE_KEY;
-		protected const string TRANSCODING_KEY;
-		public UserConfig (bool read_only = true) throws GLib.Error;
-		public static Rygel.UserConfig get_default () throws GLib.Error;
-		public void save ();
-		public void set_bool (string section, string key, bool value);
-		public void set_int (string section, string key, int value);
-		public void set_interface (string value);
-		public void set_lpcm_transcoder (bool value);
-		public void set_mp2ts_transcoder (bool value);
-		public void set_mp3_transcoder (bool value);
-		public void set_port (int value);
-		public void set_string (string section, string key, string value);
-		public void set_string_list (string section, string key, Gee.ArrayList<string> str_list);
-		public void set_transcoding (bool value);
-		public void set_upnp_enabled (bool value);
-	}
-	[CCode (cheader_filename = "rygel.h")]
-	public interface Configuration : GLib.Object {
-		public abstract bool get_bool (string section, string key) throws GLib.Error;
-		public abstract bool get_enabled (string section) throws GLib.Error;
-		public abstract int get_int (string section, string key, int min, int max) throws GLib.Error;
-		public abstract Gee.ArrayList<int> get_int_list (string section, string key) throws GLib.Error;
-		public abstract string get_interface () throws GLib.Error;
-		public abstract Rygel.LogLevel get_log_level () throws GLib.Error;
-		public abstract bool get_lpcm_transcoder () throws GLib.Error;
-		public abstract bool get_mp2ts_transcoder () throws GLib.Error;
-		public abstract bool get_mp3_transcoder () throws GLib.Error;
-		public abstract int get_port () throws GLib.Error;
-		public abstract string get_string (string section, string key) throws GLib.Error;
-		public abstract Gee.ArrayList<string> get_string_list (string section, string key) throws GLib.Error;
-		public abstract string get_title (string section) throws GLib.Error;
-		public abstract bool get_transcoding () throws GLib.Error;
-		public abstract bool get_upnp_enabled () throws GLib.Error;
-	}
-	[CCode (cheader_filename = "rygel.h")]
-	public interface StateMachine : GLib.Object {
-		public abstract void run ();
-		public abstract GLib.Cancellable cancellable { get; set; }
-		public signal void completed ();
-	}
-	[CCode (cprefix = "RYGEL_LOG_LEVEL_", cheader_filename = "rygel.h")]
-	public enum LogLevel {
-		INVALID,
-		CRITICAL,
-		ERROR,
-		WARNING,
-		INFO,
-		DEFAULT,
-		DEBUG
-	}
-	[CCode (cprefix = "RYGEL_MEDIA_DB_OBJECT_TYPE_", cheader_filename = "rygel.h")]
-	public enum MediaDBObjectType {
-		CONTAINER,
-		ITEM
-	}
-	[CCode (cprefix = "RYGEL_CMDLINE_CONFIG_ERROR_", cheader_filename = "rygel.h")]
-	public errordomain CmdlineConfigError {
-		VERSION_ONLY,
-	}
-	[CCode (cprefix = "RYGEL_CONFIGURATION_ERROR_", cheader_filename = "rygel.h")]
-	public errordomain ConfigurationError {
-		NO_VALUE_SET,
-		VALUE_OUT_OF_RANGE,
-	}
-	[CCode (cprefix = "RYGEL_CONTENT_DIRECTORY_ERROR_", cheader_filename = "rygel.h")]
-	public errordomain ContentDirectoryError {
-		NO_SUCH_OBJECT,
-		INVALID_ARGS,
-	}
-	[CCode (cprefix = "RYGEL_MEDIA_DB_ERROR_", cheader_filename = "rygel.h")]
-	public errordomain MediaDBError {
-		SQLITE_ERROR,
-		GENERAL_ERROR,
-		INVALID_TYPE,
-	}
-}
-[CCode (cprefix = "ROOT_DEVICE_FACTORY_ERROR_", cheader_filename = "rygel.h")]
-public errordomain RootDeviceFactoryError {
-	XML_PARSE,
-	PLUGIN_DISABLED,
-}
--- a/src/rygel/rygel-browse.c
+++ /dev/null
@@ -1,719 +0,0 @@
-/* rygel-browse.c generated by valac, the Vala compiler
- * generated from rygel-browse.vala, do not modify */
-
-/*
- * Copyright (C) 2008 Zeeshan Ali <zeenix@gmail.com>.
- * Copyright (C) 2007 OpenedHand Ltd.
- *
- * Author: Zeeshan Ali <zeenix@gmail.com>
- *         Jorn Baayen <jorn@openedhand.com>
- *
- * This file is part of Rygel.
- *
- * Rygel is free software; you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * Rygel is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this program; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
- */
-
-#include <glib.h>
-#include <glib-object.h>
-#include <gio/gio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <libgupnp/gupnp.h>
-#include <libgupnp-av/gupnp-av.h>
-#include <gee.h>
-
-
-#define RYGEL_TYPE_STATE_MACHINE (rygel_state_machine_get_type ())
-#define RYGEL_STATE_MACHINE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_STATE_MACHINE, RygelStateMachine))
-#define RYGEL_IS_STATE_MACHINE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_STATE_MACHINE))
-#define RYGEL_STATE_MACHINE_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), RYGEL_TYPE_STATE_MACHINE, RygelStateMachineIface))
-
-typedef struct _RygelStateMachine RygelStateMachine;
-typedef struct _RygelStateMachineIface RygelStateMachineIface;
-
-#define RYGEL_TYPE_BROWSE (rygel_browse_get_type ())
-#define RYGEL_BROWSE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_BROWSE, RygelBrowse))
-#define RYGEL_BROWSE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_BROWSE, RygelBrowseClass))
-#define RYGEL_IS_BROWSE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_BROWSE))
-#define RYGEL_IS_BROWSE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_BROWSE))
-#define RYGEL_BROWSE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_BROWSE, RygelBrowseClass))
-
-typedef struct _RygelBrowse RygelBrowse;
-typedef struct _RygelBrowseClass RygelBrowseClass;
-typedef struct _RygelBrowsePrivate RygelBrowsePrivate;
-
-#define RYGEL_TYPE_MEDIA_OBJECT (rygel_media_object_get_type ())
-#define RYGEL_MEDIA_OBJECT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_MEDIA_OBJECT, RygelMediaObject))
-#define RYGEL_MEDIA_OBJECT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_MEDIA_OBJECT, RygelMediaObjectClass))
-#define RYGEL_IS_MEDIA_OBJECT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_MEDIA_OBJECT))
-#define RYGEL_IS_MEDIA_OBJECT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_MEDIA_OBJECT))
-#define RYGEL_MEDIA_OBJECT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_MEDIA_OBJECT, RygelMediaObjectClass))
-
-typedef struct _RygelMediaObject RygelMediaObject;
-typedef struct _RygelMediaObjectClass RygelMediaObjectClass;
-
-#define RYGEL_TYPE_MEDIA_CONTAINER (rygel_media_container_get_type ())
-#define RYGEL_MEDIA_CONTAINER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_MEDIA_CONTAINER, RygelMediaContainer))
-#define RYGEL_MEDIA_CONTAINER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_MEDIA_CONTAINER, RygelMediaContainerClass))
-#define RYGEL_IS_MEDIA_CONTAINER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_MEDIA_CONTAINER))
-#define RYGEL_IS_MEDIA_CONTAINER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_MEDIA_CONTAINER))
-#define RYGEL_MEDIA_CONTAINER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_MEDIA_CONTAINER, RygelMediaContainerClass))
-
-typedef struct _RygelMediaContainer RygelMediaContainer;
-typedef struct _RygelMediaContainerClass RygelMediaContainerClass;
-
-#define RYGEL_TYPE_DIDL_LITE_WRITER (rygel_didl_lite_writer_get_type ())
-#define RYGEL_DIDL_LITE_WRITER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_DIDL_LITE_WRITER, RygelDIDLLiteWriter))
-#define RYGEL_DIDL_LITE_WRITER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_DIDL_LITE_WRITER, RygelDIDLLiteWriterClass))
-#define RYGEL_IS_DIDL_LITE_WRITER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_DIDL_LITE_WRITER))
-#define RYGEL_IS_DIDL_LITE_WRITER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_DIDL_LITE_WRITER))
-#define RYGEL_DIDL_LITE_WRITER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_DIDL_LITE_WRITER, RygelDIDLLiteWriterClass))
-
-typedef struct _RygelDIDLLiteWriter RygelDIDLLiteWriter;
-typedef struct _RygelDIDLLiteWriterClass RygelDIDLLiteWriterClass;
-#define _g_free0(var) (var = (g_free (var), NULL))
-#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
-
-#define RYGEL_TYPE_CONTENT_DIRECTORY (rygel_content_directory_get_type ())
-#define RYGEL_CONTENT_DIRECTORY(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_CONTENT_DIRECTORY, RygelContentDirectory))
-#define RYGEL_CONTENT_DIRECTORY_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_CONTENT_DIRECTORY, RygelContentDirectoryClass))
-#define RYGEL_IS_CONTENT_DIRECTORY(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_CONTENT_DIRECTORY))
-#define RYGEL_IS_CONTENT_DIRECTORY_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_CONTENT_DIRECTORY))
-#define RYGEL_CONTENT_DIRECTORY_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_CONTENT_DIRECTORY, RygelContentDirectoryClass))
-
-typedef struct _RygelContentDirectory RygelContentDirectory;
-typedef struct _RygelContentDirectoryClass RygelContentDirectoryClass;
-typedef struct _RygelContentDirectoryPrivate RygelContentDirectoryPrivate;
-
-#define RYGEL_TYPE_TRANSCODE_MANAGER (rygel_transcode_manager_get_type ())
-#define RYGEL_TRANSCODE_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_TRANSCODE_MANAGER, RygelTranscodeManager))
-#define RYGEL_TRANSCODE_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_TRANSCODE_MANAGER, RygelTranscodeManagerClass))
-#define RYGEL_IS_TRANSCODE_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_TRANSCODE_MANAGER))
-#define RYGEL_IS_TRANSCODE_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_TRANSCODE_MANAGER))
-#define RYGEL_TRANSCODE_MANAGER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_TRANSCODE_MANAGER, RygelTranscodeManagerClass))
-
-typedef struct _RygelTranscodeManager RygelTranscodeManager;
-typedef struct _RygelTranscodeManagerClass RygelTranscodeManagerClass;
-
-#define RYGEL_TYPE_HTTP_SERVER (rygel_http_server_get_type ())
-#define RYGEL_HTTP_SERVER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_HTTP_SERVER, RygelHTTPServer))
-#define RYGEL_HTTP_SERVER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_HTTP_SERVER, RygelHTTPServerClass))
-#define RYGEL_IS_HTTP_SERVER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_HTTP_SERVER))
-#define RYGEL_IS_HTTP_SERVER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_HTTP_SERVER))
-#define RYGEL_HTTP_SERVER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_HTTP_SERVER, RygelHTTPServerClass))
-
-typedef struct _RygelHTTPServer RygelHTTPServer;
-typedef struct _RygelHTTPServerClass RygelHTTPServerClass;
-#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
-typedef struct _RygelMediaObjectPrivate RygelMediaObjectPrivate;
-typedef struct _RygelMediaContainerPrivate RygelMediaContainerPrivate;
-
-struct _RygelStateMachineIface {
-	GTypeInterface parent_iface;
-	void (*run) (RygelStateMachine* self);
-	GCancellable* (*get_cancellable) (RygelStateMachine* self);
-	void (*set_cancellable) (RygelStateMachine* self, GCancellable* value);
-};
-
-struct _RygelBrowse {
-	GObject parent_instance;
-	RygelBrowsePrivate * priv;
-	char* object_id;
-	char* browse_flag;
-	char* filter;
-	guint index;
-	guint requested_count;
-	char* sort_criteria;
-	guint number_returned;
-	guint total_matches;
-	guint update_id;
-};
-
-struct _RygelBrowseClass {
-	GObjectClass parent_class;
-};
-
-struct _RygelBrowsePrivate {
-	gboolean fetch_metadata;
-	RygelMediaObject* media_object;
-	RygelMediaContainer* root_container;
-	guint32 system_update_id;
-	GUPnPServiceAction* action;
-	RygelDIDLLiteWriter* didl_writer;
-	GCancellable* _cancellable;
-};
-
-struct _RygelContentDirectory {
-	GUPnPService parent_instance;
-	RygelContentDirectoryPrivate * priv;
-	char* feature_list;
-	char* search_caps;
-	char* sort_caps;
-	RygelHTTPServer* http_server;
-	RygelMediaContainer* root_container;
-	GCancellable* cancellable;
-	guint32 system_update_id;
-};
-
-struct _RygelContentDirectoryClass {
-	GUPnPServiceClass parent_class;
-	RygelMediaContainer* (*create_root_container) (RygelContentDirectory* self);
-	void (*browse_cb) (RygelContentDirectory* self, RygelContentDirectory* content_dir, GUPnPServiceAction* action);
-};
-
-typedef enum  {
-	RYGEL_CONTENT_DIRECTORY_ERROR_NO_SUCH_OBJECT = 701,
-	RYGEL_CONTENT_DIRECTORY_ERROR_INVALID_ARGS = 402
-} RygelContentDirectoryError;
-#define RYGEL_CONTENT_DIRECTORY_ERROR rygel_content_directory_error_quark ()
-struct _RygelMediaObject {
-	GObject parent_instance;
-	RygelMediaObjectPrivate * priv;
-	char* id;
-	char* title;
-	guint64 modified;
-	GeeArrayList* uris;
-	RygelMediaContainer* parent;
-	RygelMediaContainer* parent_ref;
-};
-
-struct _RygelMediaObjectClass {
-	GObjectClass parent_class;
-};
-
-struct _RygelMediaContainer {
-	RygelMediaObject parent_instance;
-	RygelMediaContainerPrivate * priv;
-	guint child_count;
-	guint32 update_id;
-};
-
-struct _RygelMediaContainerClass {
-	RygelMediaObjectClass parent_class;
-	void (*get_children) (RygelMediaContainer* self, guint offset, guint max_count, GCancellable* cancellable, GAsyncReadyCallback callback, void* callback_target);
-	GeeList* (*get_children_finish) (RygelMediaContainer* self, GAsyncResult* res, GError** error);
-	void (*find_object) (RygelMediaContainer* self, const char* id, GCancellable* cancellable, GAsyncReadyCallback callback, void* callback_target);
-	RygelMediaObject* (*find_object_finish) (RygelMediaContainer* self, GAsyncResult* res, GError** error);
-};
-
-
-static gpointer rygel_browse_parent_class = NULL;
-static RygelStateMachineIface* rygel_browse_rygel_state_machine_parent_iface = NULL;
-
-GType rygel_state_machine_get_type (void);
-GType rygel_browse_get_type (void);
-GType rygel_media_object_get_type (void);
-GType rygel_media_container_get_type (void);
-GType rygel_didl_lite_writer_get_type (void);
-#define RYGEL_BROWSE_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), RYGEL_TYPE_BROWSE, RygelBrowsePrivate))
-enum  {
-	RYGEL_BROWSE_DUMMY_PROPERTY,
-	RYGEL_BROWSE_CANCELLABLE
-};
-GType rygel_content_directory_get_type (void);
-GType rygel_transcode_manager_get_type (void);
-GType rygel_http_server_get_type (void);
-void rygel_state_machine_set_cancellable (RygelStateMachine* self, GCancellable* value);
-RygelDIDLLiteWriter* rygel_didl_lite_writer_new (RygelHTTPServer* http_server);
-RygelDIDLLiteWriter* rygel_didl_lite_writer_construct (GType object_type, RygelHTTPServer* http_server);
-RygelBrowse* rygel_browse_new (RygelContentDirectory* content_dir, GUPnPServiceAction* action);
-RygelBrowse* rygel_browse_construct (GType object_type, RygelContentDirectory* content_dir, GUPnPServiceAction* action);
-static void rygel_browse_parse_args (RygelBrowse* self);
-static void rygel_browse_real_run (RygelStateMachine* base);
-static void rygel_browse_handle_error (RygelBrowse* self, GError* _error_);
-GQuark rygel_content_directory_error_quark (void);
-static void rygel_browse_handle_metadata_request (RygelBrowse* self);
-static void rygel_browse_handle_children_request (RygelBrowse* self);
-static void rygel_browse_got_media_object (RygelBrowse* self);
-void rygel_media_container_find_object (RygelMediaContainer* self, const char* id, GCancellable* cancellable, GAsyncReadyCallback callback, void* callback_target);
-GCancellable* rygel_state_machine_get_cancellable (RygelStateMachine* self);
-static void rygel_browse_on_media_object_found (RygelBrowse* self, GObject* source_object, GAsyncResult* res);
-static void _rygel_browse_on_media_object_found_gasync_ready_callback (GObject* source_object, GAsyncResult* res, gpointer self);
-static void rygel_browse_fetch_media_object (RygelBrowse* self);
-RygelMediaObject* rygel_media_container_find_object_finish (RygelMediaContainer* self, GAsyncResult* res, GError** error);
-void rygel_didl_lite_writer_serialize (RygelDIDLLiteWriter* self, RygelMediaObject* media_object, GError** error);
-static void rygel_browse_conclude (RygelBrowse* self);
-static void rygel_browse_fetch_children (RygelBrowse* self);
-static void rygel_browse_serialize_children (RygelBrowse* self, GeeList* children);
-void rygel_media_container_get_children (RygelMediaContainer* self, guint offset, guint max_count, GCancellable* cancellable, GAsyncReadyCallback callback, void* callback_target);
-static void rygel_browse_on_children_fetched (RygelBrowse* self, GObject* source_object, GAsyncResult* res);
-static void _rygel_browse_on_children_fetched_gasync_ready_callback (GObject* source_object, GAsyncResult* res, gpointer self);
-GeeList* rygel_media_container_get_children_finish (RygelMediaContainer* self, GAsyncResult* res, GError** error);
-static void rygel_browse_finalize (GObject* obj);
-static void rygel_browse_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
-static void rygel_browse_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);
-static int _vala_strcmp0 (const char * str1, const char * str2);
-
-
-
-static gpointer _g_object_ref0 (gpointer self) {
-	return self ? g_object_ref (self) : NULL;
-}
-
-
-RygelBrowse* rygel_browse_construct (GType object_type, RygelContentDirectory* content_dir, GUPnPServiceAction* action) {
-	RygelBrowse * self;
-	RygelMediaContainer* _tmp0_;
-	GUPnPServiceAction* _tmp1_;
-	RygelDIDLLiteWriter* _tmp2_;
-	g_return_val_if_fail (content_dir != NULL, NULL);
-	g_return_val_if_fail (action != NULL, NULL);
-	self = (RygelBrowse*) g_object_new (object_type, NULL);
-	self->priv->root_container = (_tmp0_ = _g_object_ref0 (content_dir->root_container), _g_object_unref0 (self->priv->root_container), _tmp0_);
-	self->priv->system_update_id = content_dir->system_update_id;
-	rygel_state_machine_set_cancellable ((RygelStateMachine*) self, content_dir->cancellable);
-	self->priv->action = (_tmp1_ = action, action = NULL, _tmp1_);
-	self->priv->didl_writer = (_tmp2_ = rygel_didl_lite_writer_new (content_dir->http_server), _g_object_unref0 (self->priv->didl_writer), _tmp2_);
-	return self;
-}
-
-
-RygelBrowse* rygel_browse_new (RygelContentDirectory* content_dir, GUPnPServiceAction* action) {
-	return rygel_browse_construct (RYGEL_TYPE_BROWSE, content_dir, action);
-}
-
-
-static void rygel_browse_real_run (RygelStateMachine* base) {
-	RygelBrowse * self;
-	self = (RygelBrowse*) base;
-	rygel_browse_parse_args (self);
-}
-
-
-static void rygel_browse_got_media_object (RygelBrowse* self) {
-	g_return_if_fail (self != NULL);
-	if (self->priv->media_object == NULL) {
-		GError* _tmp0_;
-		rygel_browse_handle_error (self, _tmp0_ = g_error_new_literal (RYGEL_CONTENT_DIRECTORY_ERROR, RYGEL_CONTENT_DIRECTORY_ERROR_NO_SUCH_OBJECT, "No such object"));
-		_g_error_free0 (_tmp0_);
-		return;
-	}
-	if (self->priv->fetch_metadata) {
-		rygel_browse_handle_metadata_request (self);
-	} else {
-		rygel_browse_handle_children_request (self);
-	}
-}
-
-
-static void _rygel_browse_on_media_object_found_gasync_ready_callback (GObject* source_object, GAsyncResult* res, gpointer self) {
-	rygel_browse_on_media_object_found (self, source_object, res);
-}
-
-
-static void rygel_browse_fetch_media_object (RygelBrowse* self) {
-	g_return_if_fail (self != NULL);
-	if (_vala_strcmp0 (self->object_id, ((RygelMediaObject*) self->priv->root_container)->id) == 0) {
-		RygelMediaObject* _tmp0_;
-		self->priv->media_object = (_tmp0_ = _g_object_ref0 ((RygelMediaObject*) self->priv->root_container), _g_object_unref0 (self->priv->media_object), _tmp0_);
-		rygel_browse_got_media_object (self);
-		return;
-	}
-	rygel_media_container_find_object (self->priv->root_container, self->object_id, rygel_state_machine_get_cancellable ((RygelStateMachine*) self), _rygel_browse_on_media_object_found_gasync_ready_callback, self);
-}
-
-
-static void rygel_browse_on_media_object_found (RygelBrowse* self, GObject* source_object, GAsyncResult* res) {
-	GError * _inner_error_;
-	RygelMediaContainer* container;
-	g_return_if_fail (self != NULL);
-	g_return_if_fail (res != NULL);
-	_inner_error_ = NULL;
-	container = _g_object_ref0 (RYGEL_MEDIA_CONTAINER (source_object));
-	{
-		RygelMediaObject* _tmp0_;
-		RygelMediaObject* _tmp1_;
-		_tmp0_ = rygel_media_container_find_object_finish (container, res, &_inner_error_);
-		if (_inner_error_ != NULL) {
-			goto __catch35_g_error;
-			goto __finally35;
-		}
-		self->priv->media_object = (_tmp1_ = _tmp0_, _g_object_unref0 (self->priv->media_object), _tmp1_);
-	}
-	goto __finally35;
-	__catch35_g_error:
-	{
-		GError * err;
-		err = _inner_error_;
-		_inner_error_ = NULL;
-		{
-			rygel_browse_handle_error (self, err);
-			_g_error_free0 (err);
-			_g_object_unref0 (container);
-			return;
-		}
-	}
-	__finally35:
-	if (_inner_error_ != NULL) {
-		_g_object_unref0 (container);
-		g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
-		g_clear_error (&_inner_error_);
-		return;
-	}
-	rygel_browse_got_media_object (self);
-	_g_object_unref0 (container);
-}
-
-
-static void rygel_browse_handle_metadata_request (RygelBrowse* self) {
-	GError * _inner_error_;
-	g_return_if_fail (self != NULL);
-	_inner_error_ = NULL;
-	if (RYGEL_IS_MEDIA_CONTAINER (self->priv->media_object)) {
-		self->update_id = (guint) RYGEL_MEDIA_CONTAINER (self->priv->media_object)->update_id;
-	} else {
-		self->update_id = (guint) G_MAXUINT32;
-	}
-	{
-		rygel_didl_lite_writer_serialize (self->priv->didl_writer, self->priv->media_object, &_inner_error_);
-		if (_inner_error_ != NULL) {
-			goto __catch36_g_error;
-			goto __finally36;
-		}
-	}
-	goto __finally36;
-	__catch36_g_error:
-	{
-		GError * err;
-		err = _inner_error_;
-		_inner_error_ = NULL;
-		{
-			rygel_browse_handle_error (self, err);
-			_g_error_free0 (err);
-			return;
-		}
-	}
-	__finally36:
-	if (_inner_error_ != NULL) {
-		g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
-		g_clear_error (&_inner_error_);
-		return;
-	}
-	self->number_returned = (guint) 1;
-	self->total_matches = (guint) 1;
-	rygel_browse_conclude (self);
-}
-
-
-static void rygel_browse_handle_children_request (RygelBrowse* self) {
-	RygelMediaContainer* container;
-	g_return_if_fail (self != NULL);
-	if (!RYGEL_IS_MEDIA_CONTAINER (self->priv->media_object)) {
-		GError* _tmp0_;
-		rygel_browse_handle_error (self, _tmp0_ = g_error_new_literal (RYGEL_CONTENT_DIRECTORY_ERROR, RYGEL_CONTENT_DIRECTORY_ERROR_NO_SUCH_OBJECT, "No such object"));
-		_g_error_free0 (_tmp0_);
-		return;
-	}
-	container = _g_object_ref0 (RYGEL_MEDIA_CONTAINER (self->priv->media_object));
-	self->total_matches = container->child_count;
-	self->update_id = (guint) container->update_id;
-	if (self->requested_count == 0) {
-		self->requested_count = self->total_matches;
-	}
-	rygel_browse_fetch_children (self);
-	_g_object_unref0 (container);
-}
-
-
-static void rygel_browse_parse_args (RygelBrowse* self) {
-	gboolean _tmp0_ = FALSE;
-	g_return_if_fail (self != NULL);
-	gupnp_service_action_get (self->priv->action, "ObjectID", G_TYPE_STRING, &self->object_id, "BrowseFlag", G_TYPE_STRING, &self->browse_flag, "Filter", G_TYPE_STRING, &self->filter, "StartingIndex", G_TYPE_UINT, &self->index, "RequestedCount", G_TYPE_UINT, &self->requested_count, "SortCriteria", G_TYPE_STRING, &self->sort_criteria, NULL);
-	if (self->browse_flag != NULL) {
-		_tmp0_ = _vala_strcmp0 (self->browse_flag, "BrowseDirectChildren") == 0;
-	} else {
-		_tmp0_ = FALSE;
-	}
-	if (_tmp0_) {
-		self->priv->fetch_metadata = FALSE;
-	} else {
-		gboolean _tmp1_ = FALSE;
-		if (self->browse_flag != NULL) {
-			_tmp1_ = _vala_strcmp0 (self->browse_flag, "BrowseMetadata") == 0;
-		} else {
-			_tmp1_ = FALSE;
-		}
-		if (_tmp1_) {
-			self->priv->fetch_metadata = TRUE;
-		} else {
-			GError* _tmp2_;
-			self->priv->fetch_metadata = FALSE;
-			rygel_browse_handle_error (self, _tmp2_ = g_error_new_literal (RYGEL_CONTENT_DIRECTORY_ERROR, RYGEL_CONTENT_DIRECTORY_ERROR_INVALID_ARGS, "Invalid Args"));
-			_g_error_free0 (_tmp2_);
-			return;
-		}
-	}
-	if (self->object_id == NULL) {
-		gupnp_service_action_get (self->priv->action, "ContainerID", G_TYPE_STRING, &self->object_id, NULL);
-	}
-	if (self->object_id == NULL) {
-		GError* _tmp3_;
-		rygel_browse_handle_error (self, _tmp3_ = g_error_new_literal (RYGEL_CONTENT_DIRECTORY_ERROR, RYGEL_CONTENT_DIRECTORY_ERROR_NO_SUCH_OBJECT, "No such object"));
-		_g_error_free0 (_tmp3_);
-		return;
-	}
-	rygel_browse_fetch_media_object (self);
-}
-
-
-static void rygel_browse_conclude (RygelBrowse* self) {
-	char* didl;
-	g_return_if_fail (self != NULL);
-	gupnp_didl_lite_writer_filter ((GUPnPDIDLLiteWriter*) self->priv->didl_writer, self->filter);
-	didl = gupnp_didl_lite_writer_get_string ((GUPnPDIDLLiteWriter*) self->priv->didl_writer);
-	if (self->update_id == G_MAXUINT32) {
-		self->update_id = (guint) self->priv->system_update_id;
-	}
-	gupnp_service_action_set (self->priv->action, "Result", G_TYPE_STRING, didl, "NumberReturned", G_TYPE_UINT, self->number_returned, "TotalMatches", G_TYPE_UINT, self->total_matches, "UpdateID", G_TYPE_UINT, self->update_id, NULL);
-	gupnp_service_action_return (self->priv->action);
-	g_signal_emit_by_name ((RygelStateMachine*) self, "completed");
-	_g_free0 (didl);
-}
-
-
-static void rygel_browse_handle_error (RygelBrowse* self, GError* _error_) {
-	g_return_if_fail (self != NULL);
-	if (_error_->domain == RYGEL_CONTENT_DIRECTORY_ERROR) {
-		g_warning ("rygel-browse.vala:221: Failed to browse '%s': %s\n", self->object_id, _error_->message);
-		gupnp_service_action_return_error (self->priv->action, (guint) _error_->code, _error_->message);
-	} else {
-		g_warning ("rygel-browse.vala:226: Failed to browse '%s': %s\n", self->object_id, _error_->message);
-		gupnp_service_action_return_error (self->priv->action, (guint) 701, _error_->message);
-	}
-	g_signal_emit_by_name ((RygelStateMachine*) self, "completed");
-}
-
-
-static void rygel_browse_serialize_children (RygelBrowse* self, GeeList* children) {
-	GError * _inner_error_;
-	g_return_if_fail (self != NULL);
-	_inner_error_ = NULL;
-	if (children == NULL) {
-		GError* _tmp0_;
-		rygel_browse_handle_error (self, _tmp0_ = g_error_new_literal (RYGEL_CONTENT_DIRECTORY_ERROR, RYGEL_CONTENT_DIRECTORY_ERROR_NO_SUCH_OBJECT, "No such object"));
-		_g_error_free0 (_tmp0_);
-		return;
-	}
-	{
-		gint i;
-		i = 0;
-		{
-			gboolean _tmp1_;
-			_tmp1_ = TRUE;
-			while (TRUE) {
-				if (!_tmp1_) {
-					i++;
-				}
-				_tmp1_ = FALSE;
-				if (!(i < gee_collection_get_size ((GeeCollection*) children))) {
-					break;
-				}
-				{
-					RygelMediaObject* _tmp2_;
-					rygel_didl_lite_writer_serialize (self->priv->didl_writer, _tmp2_ = (RygelMediaObject*) gee_list_get (children, i), &_inner_error_);
-					if (_inner_error_ != NULL) {
-						goto __catch37_g_error;
-						goto __finally37;
-					}
-					_g_object_unref0 (_tmp2_);
-				}
-				goto __finally37;
-				__catch37_g_error:
-				{
-					GError * err;
-					err = _inner_error_;
-					_inner_error_ = NULL;
-					{
-						rygel_browse_handle_error (self, err);
-						_g_error_free0 (err);
-						return;
-					}
-				}
-				__finally37:
-				if (_inner_error_ != NULL) {
-					g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
-					g_clear_error (&_inner_error_);
-					return;
-				}
-			}
-		}
-	}
-	rygel_browse_conclude (self);
-}
-
-
-static void _rygel_browse_on_children_fetched_gasync_ready_callback (GObject* source_object, GAsyncResult* res, gpointer self) {
-	rygel_browse_on_children_fetched (self, source_object, res);
-}
-
-
-static void rygel_browse_fetch_children (RygelBrowse* self) {
-	RygelMediaContainer* container;
-	g_return_if_fail (self != NULL);
-	container = _g_object_ref0 (RYGEL_MEDIA_CONTAINER (self->priv->media_object));
-	rygel_media_container_get_children (container, self->index, self->requested_count, rygel_state_machine_get_cancellable ((RygelStateMachine*) self), _rygel_browse_on_children_fetched_gasync_ready_callback, self);
-	_g_object_unref0 (container);
-}
-
-
-static void rygel_browse_on_children_fetched (RygelBrowse* self, GObject* source_object, GAsyncResult* res) {
-	GError * _inner_error_;
-	RygelMediaContainer* container;
-	g_return_if_fail (self != NULL);
-	g_return_if_fail (res != NULL);
-	_inner_error_ = NULL;
-	container = _g_object_ref0 (RYGEL_MEDIA_CONTAINER (source_object));
-	{
-		GeeList* children;
-		children = rygel_media_container_get_children_finish (container, res, &_inner_error_);
-		if (_inner_error_ != NULL) {
-			goto __catch38_g_error;
-			goto __finally38;
-		}
-		self->number_returned = (guint) gee_collection_get_size ((GeeCollection*) children);
-		rygel_browse_serialize_children (self, children);
-		_g_object_unref0 (children);
-	}
-	goto __finally38;
-	__catch38_g_error:
-	{
-		GError * err;
-		err = _inner_error_;
-		_inner_error_ = NULL;
-		{
-			rygel_browse_handle_error (self, err);
-			_g_error_free0 (err);
-		}
-	}
-	__finally38:
-	if (_inner_error_ != NULL) {
-		_g_object_unref0 (container);
-		g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
-		g_clear_error (&_inner_error_);
-		return;
-	}
-	_g_object_unref0 (container);
-}
-
-
-static GCancellable* rygel_browse_real_get_cancellable (RygelStateMachine* base) {
-	GCancellable* result;
-	RygelBrowse* self;
-	self = (RygelBrowse*) base;
-	result = self->priv->_cancellable;
-	return result;
-}
-
-
-static void rygel_browse_real_set_cancellable (RygelStateMachine* base, GCancellable* value) {
-	RygelBrowse* self;
-	GCancellable* _tmp0_;
-	self = (RygelBrowse*) base;
-	self->priv->_cancellable = (_tmp0_ = _g_object_ref0 (value), _g_object_unref0 (self->priv->_cancellable), _tmp0_);
-	g_object_notify ((GObject *) self, "cancellable");
-}
-
-
-static void rygel_browse_class_init (RygelBrowseClass * klass) {
-	rygel_browse_parent_class = g_type_class_peek_parent (klass);
-	g_type_class_add_private (klass, sizeof (RygelBrowsePrivate));
-	G_OBJECT_CLASS (klass)->get_property = rygel_browse_get_property;
-	G_OBJECT_CLASS (klass)->set_property = rygel_browse_set_property;
-	G_OBJECT_CLASS (klass)->finalize = rygel_browse_finalize;
-	g_object_class_override_property (G_OBJECT_CLASS (klass), RYGEL_BROWSE_CANCELLABLE, "cancellable");
-}
-
-
-static void rygel_browse_rygel_state_machine_interface_init (RygelStateMachineIface * iface) {
-	rygel_browse_rygel_state_machine_parent_iface = g_type_interface_peek_parent (iface);
-	iface->run = rygel_browse_real_run;
-	iface->get_cancellable = rygel_browse_real_get_cancellable;
-	iface->set_cancellable = rygel_browse_real_set_cancellable;
-}
-
-
-static void rygel_browse_instance_init (RygelBrowse * self) {
-	self->priv = RYGEL_BROWSE_GET_PRIVATE (self);
-}
-
-
-static void rygel_browse_finalize (GObject* obj) {
-	RygelBrowse * self;
-	self = RYGEL_BROWSE (obj);
-	_g_free0 (self->object_id);
-	_g_free0 (self->browse_flag);
-	_g_free0 (self->filter);
-	_g_free0 (self->sort_criteria);
-	_g_object_unref0 (self->priv->media_object);
-	_g_object_unref0 (self->priv->root_container);
-	_g_object_unref0 (self->priv->didl_writer);
-	_g_object_unref0 (self->priv->_cancellable);
-	G_OBJECT_CLASS (rygel_browse_parent_class)->finalize (obj);
-}
-
-
-GType rygel_browse_get_type (void) {
-	static GType rygel_browse_type_id = 0;
-	if (rygel_browse_type_id == 0) {
-		static const GTypeInfo g_define_type_info = { sizeof (RygelBrowseClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) rygel_browse_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (RygelBrowse), 0, (GInstanceInitFunc) rygel_browse_instance_init, NULL };
-		static const GInterfaceInfo rygel_state_machine_info = { (GInterfaceInitFunc) rygel_browse_rygel_state_machine_interface_init, (GInterfaceFinalizeFunc) NULL, NULL};
-		rygel_browse_type_id = g_type_register_static (G_TYPE_OBJECT, "RygelBrowse", &g_define_type_info, 0);
-		g_type_add_interface_static (rygel_browse_type_id, RYGEL_TYPE_STATE_MACHINE, &rygel_state_machine_info);
-	}
-	return rygel_browse_type_id;
-}
-
-
-static void rygel_browse_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
-	RygelBrowse * self;
-	self = RYGEL_BROWSE (object);
-	switch (property_id) {
-		case RYGEL_BROWSE_CANCELLABLE:
-		g_value_set_object (value, rygel_state_machine_get_cancellable ((RygelStateMachine*) self));
-		break;
-		default:
-		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
-		break;
-	}
-}
-
-
-static void rygel_browse_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
-	RygelBrowse * self;
-	self = RYGEL_BROWSE (object);
-	switch (property_id) {
-		case RYGEL_BROWSE_CANCELLABLE:
-		rygel_state_machine_set_cancellable ((RygelStateMachine*) self, g_value_get_object (value));
-		break;
-		default:
-		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
-		break;
-	}
-}
-
-
-static int _vala_strcmp0 (const char * str1, const char * str2) {
-	if (str1 == NULL) {
-		return -(str1 != str2);
-	}
-	if (str2 == NULL) {
-		return str1 != str2;
-	}
-	return strcmp (str1, str2);
-}
-
-
-
-
--- a/src/rygel/rygel-cmdline-config.c
+++ /dev/null
@@ -1,994 +0,0 @@
-/* rygel-cmdline-config.c generated by valac, the Vala compiler
- * generated from rygel-cmdline-config.vala, do not modify */
-
-/*
- * Copyright (C) 2008,2009 Nokia Corporation.
- * Copyright (C) 2008,2009 Zeeshan Ali (Khattak) <zeeshanak@gnome.org>.
- *
- * Author: Zeeshan Ali (Khattak) <zeeshanak@gnome.org>
- *                               <zeeshan.ali@nokia.com>
- *
- * This file is part of Rygel.
- *
- * Rygel is free software; you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * Rygel is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this program; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
- */
-
-#include <glib.h>
-#include <glib-object.h>
-#include <stdlib.h>
-#include <string.h>
-#include <gee.h>
-#include <gst/gst.h>
-#include <stdio.h>
-
-
-#define RYGEL_TYPE_CONFIGURATION (rygel_configuration_get_type ())
-#define RYGEL_CONFIGURATION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_CONFIGURATION, RygelConfiguration))
-#define RYGEL_IS_CONFIGURATION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_CONFIGURATION))
-#define RYGEL_CONFIGURATION_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), RYGEL_TYPE_CONFIGURATION, RygelConfigurationIface))
-
-typedef struct _RygelConfiguration RygelConfiguration;
-typedef struct _RygelConfigurationIface RygelConfigurationIface;
-
-#define RYGEL_TYPE_LOG_LEVEL (rygel_log_level_get_type ())
-
-#define RYGEL_TYPE_CMDLINE_CONFIG (rygel_cmdline_config_get_type ())
-#define RYGEL_CMDLINE_CONFIG(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_CMDLINE_CONFIG, RygelCmdlineConfig))
-#define RYGEL_CMDLINE_CONFIG_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_CMDLINE_CONFIG, RygelCmdlineConfigClass))
-#define RYGEL_IS_CMDLINE_CONFIG(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_CMDLINE_CONFIG))
-#define RYGEL_IS_CMDLINE_CONFIG_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_CMDLINE_CONFIG))
-#define RYGEL_CMDLINE_CONFIG_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_CMDLINE_CONFIG, RygelCmdlineConfigClass))
-
-typedef struct _RygelCmdlineConfig RygelCmdlineConfig;
-typedef struct _RygelCmdlineConfigClass RygelCmdlineConfigClass;
-typedef struct _RygelCmdlineConfigPrivate RygelCmdlineConfigPrivate;
-#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
-#define _g_free0(var) (var = (g_free (var), NULL))
-#define _g_option_context_free0(var) ((var == NULL) ? NULL : (var = (g_option_context_free (var), NULL)))
-
-typedef enum  {
-	RYGEL_CMDLINE_CONFIG_ERROR_VERSION_ONLY
-} RygelCmdlineConfigError;
-#define RYGEL_CMDLINE_CONFIG_ERROR rygel_cmdline_config_error_quark ()
-typedef enum  {
-	RYGEL_LOG_LEVEL_INVALID = 0,
-	RYGEL_LOG_LEVEL_CRITICAL = 1,
-	RYGEL_LOG_LEVEL_ERROR = 2,
-	RYGEL_LOG_LEVEL_WARNING = 3,
-	RYGEL_LOG_LEVEL_INFO = 4,
-	RYGEL_LOG_LEVEL_DEFAULT = 4,
-	RYGEL_LOG_LEVEL_DEBUG = 5
-} RygelLogLevel;
-
-struct _RygelConfigurationIface {
-	GTypeInterface parent_iface;
-	gboolean (*get_upnp_enabled) (RygelConfiguration* self, GError** error);
-	char* (*get_interface) (RygelConfiguration* self, GError** error);
-	gint (*get_port) (RygelConfiguration* self, GError** error);
-	gboolean (*get_transcoding) (RygelConfiguration* self, GError** error);
-	gboolean (*get_mp3_transcoder) (RygelConfiguration* self, GError** error);
-	gboolean (*get_mp2ts_transcoder) (RygelConfiguration* self, GError** error);
-	gboolean (*get_lpcm_transcoder) (RygelConfiguration* self, GError** error);
-	RygelLogLevel (*get_log_level) (RygelConfiguration* self, GError** error);
-	gboolean (*get_enabled) (RygelConfiguration* self, const char* section, GError** error);
-	char* (*get_title) (RygelConfiguration* self, const char* section, GError** error);
-	char* (*get_string) (RygelConfiguration* self, const char* section, const char* key, GError** error);
-	GeeArrayList* (*get_string_list) (RygelConfiguration* self, const char* section, const char* key, GError** error);
-	gint (*get_int) (RygelConfiguration* self, const char* section, const char* key, gint min, gint max, GError** error);
-	GeeArrayList* (*get_int_list) (RygelConfiguration* self, const char* section, const char* key, GError** error);
-	gboolean (*get_bool) (RygelConfiguration* self, const char* section, const char* key, GError** error);
-};
-
-struct _RygelCmdlineConfig {
-	GObject parent_instance;
-	RygelCmdlineConfigPrivate * priv;
-};
-
-struct _RygelCmdlineConfigClass {
-	GObjectClass parent_class;
-};
-
-typedef enum  {
-	RYGEL_CONFIGURATION_ERROR_NO_VALUE_SET,
-	RYGEL_CONFIGURATION_ERROR_VALUE_OUT_OF_RANGE
-} RygelConfigurationError;
-#define RYGEL_CONFIGURATION_ERROR rygel_configuration_error_quark ()
-
-static char* rygel_cmdline_config_iface;
-static char* rygel_cmdline_config_iface = NULL;
-static gint rygel_cmdline_config_port;
-static gint rygel_cmdline_config_port = 0;
-static gboolean rygel_cmdline_config_no_transcoding;
-static gboolean rygel_cmdline_config_no_transcoding = FALSE;
-static gboolean rygel_cmdline_config_no_mp3_trans;
-static gboolean rygel_cmdline_config_no_mp3_trans = FALSE;
-static gboolean rygel_cmdline_config_no_mp2ts_trans;
-static gboolean rygel_cmdline_config_no_mp2ts_trans = FALSE;
-static gboolean rygel_cmdline_config_no_lpcm_trans;
-static gboolean rygel_cmdline_config_no_lpcm_trans = FALSE;
-static RygelLogLevel rygel_cmdline_config_log_level;
-static RygelLogLevel rygel_cmdline_config_log_level = RYGEL_LOG_LEVEL_INVALID;
-static gboolean rygel_cmdline_config_version;
-static gboolean rygel_cmdline_config_version = FALSE;
-static char** rygel_cmdline_config_disabled_plugins;
-static char** rygel_cmdline_config_disabled_plugins = NULL;
-static char** rygel_cmdline_config_plugin_titles;
-static char** rygel_cmdline_config_plugin_titles = NULL;
-static char** rygel_cmdline_config_plugin_options;
-static char** rygel_cmdline_config_plugin_options = NULL;
-static RygelCmdlineConfig* rygel_cmdline_config_config;
-static RygelCmdlineConfig* rygel_cmdline_config_config = NULL;
-static gpointer rygel_cmdline_config_parent_class = NULL;
-static RygelConfigurationIface* rygel_cmdline_config_rygel_configuration_parent_iface = NULL;
-
-GQuark rygel_cmdline_config_error_quark (void);
-GType rygel_log_level_get_type (void);
-GType rygel_configuration_get_type (void);
-GType rygel_cmdline_config_get_type (void);
-enum  {
-	RYGEL_CMDLINE_CONFIG_DUMMY_PROPERTY
-};
-RygelCmdlineConfig* rygel_cmdline_config_new (void);
-RygelCmdlineConfig* rygel_cmdline_config_construct (GType object_type);
-RygelCmdlineConfig* rygel_cmdline_config_get_default (void);
-void rygel_cmdline_config_parse_args (char*** args, int* args_length1, GError** error);
-GQuark rygel_configuration_error_quark (void);
-static gboolean rygel_cmdline_config_real_get_upnp_enabled (RygelConfiguration* base, GError** error);
-static char* rygel_cmdline_config_real_get_interface (RygelConfiguration* base, GError** error);
-static gint rygel_cmdline_config_real_get_port (RygelConfiguration* base, GError** error);
-static gboolean rygel_cmdline_config_real_get_transcoding (RygelConfiguration* base, GError** error);
-static gboolean rygel_cmdline_config_real_get_mp3_transcoder (RygelConfiguration* base, GError** error);
-static gboolean rygel_cmdline_config_real_get_mp2ts_transcoder (RygelConfiguration* base, GError** error);
-static gboolean rygel_cmdline_config_real_get_lpcm_transcoder (RygelConfiguration* base, GError** error);
-static RygelLogLevel rygel_cmdline_config_real_get_log_level (RygelConfiguration* base, GError** error);
-static gboolean rygel_cmdline_config_real_get_enabled (RygelConfiguration* base, const char* section, GError** error);
-static char* rygel_cmdline_config_real_get_title (RygelConfiguration* base, const char* section, GError** error);
-static char* rygel_cmdline_config_real_get_string (RygelConfiguration* base, const char* section, const char* key, GError** error);
-static GeeArrayList* rygel_cmdline_config_real_get_string_list (RygelConfiguration* base, const char* section, const char* key, GError** error);
-static gint rygel_cmdline_config_real_get_int (RygelConfiguration* base, const char* section, const char* key, gint min, gint max, GError** error);
-static GeeArrayList* rygel_cmdline_config_real_get_int_list (RygelConfiguration* base, const char* section, const char* key, GError** error);
-static gboolean rygel_cmdline_config_real_get_bool (RygelConfiguration* base, const char* section, const char* key, GError** error);
-static void rygel_cmdline_config_finalize (GObject* obj);
-static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
-static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);
-static gint _vala_array_length (gpointer array);
-static int _vala_strcmp0 (const char * str1, const char * str2);
-
-static const GOptionEntry RYGEL_CMDLINE_CONFIG_options[] = {{"version", (gchar) 0, 0, G_OPTION_ARG_NONE, &rygel_cmdline_config_version, "Display version number", NULL}, {"network-interface", 'n', 0, G_OPTION_ARG_STRING, &rygel_cmdline_config_iface, "Network Interface", "INTERFACE"}, {"port", 'p', 0, G_OPTION_ARG_INT, &rygel_cmdline_config_port, "Port", "PORT"}, {"disable-transcoding", 't', 0, G_OPTION_ARG_NONE, &rygel_cmdline_config_no_transcoding, "Disable transcoding", NULL}, {"disable-mp3-transcoder", 'm', 0, G_OPTION_ARG_NONE, &rygel_cmdline_config_no_mp3_trans, "Disable MP3 transcoder", NULL}, {"disable-mp2ts-transcoder", 's', 0, G_OPTION_ARG_NONE, &rygel_cmdline_config_no_mp2ts_trans, "Disable mpeg2 transport stream transcoder", NULL}, {"disable-lpcm-transcoder", 'l', 0, G_OPTION_ARG_NONE, &rygel_cmdline_config_no_lpcm_trans, "Disable Linear PCM transcoder", NULL}, {"log-level", 'g', 0, G_OPTION_ARG_INT, &rygel_cmdline_config_log_level, "Log level. 1=critical,2=error,3=warning,4=message/info,5=debug", "N"}, {"disable-plugin", 'd', 0, G_OPTION_ARG_STRING_ARRAY, &rygel_cmdline_config_disabled_plugins, "Disable plugin", "PluginName"}, {"title", 'i', 0, G_OPTION_ARG_STRING_ARRAY, &rygel_cmdline_config_plugin_titles, "Set plugin titles", "PluginName:TITLE"}, {"plugin-option", 'o', 0, G_OPTION_ARG_STRING_ARRAY, &rygel_cmdline_config_plugin_options, "Set plugin options", "PluginName:OPTION:VALUE1[,VALUE2,..]"}, {NULL}};
-
-
-GQuark rygel_cmdline_config_error_quark (void) {
-	return g_quark_from_static_string ("rygel_cmdline_config_error-quark");
-}
-
-
-static gpointer _g_object_ref0 (gpointer self) {
-	return self ? g_object_ref (self) : NULL;
-}
-
-
-RygelCmdlineConfig* rygel_cmdline_config_get_default (void) {
-	RygelCmdlineConfig* result;
-	if (rygel_cmdline_config_config == NULL) {
-		RygelCmdlineConfig* _tmp0_;
-		rygel_cmdline_config_config = (_tmp0_ = rygel_cmdline_config_new (), _g_object_unref0 (rygel_cmdline_config_config), _tmp0_);
-	}
-	result = _g_object_ref0 (rygel_cmdline_config_config);
-	return result;
-}
-
-
-void rygel_cmdline_config_parse_args (char*** args, int* args_length1, GError** error) {
-	GError * _inner_error_;
-	char* parameter_string;
-	GOptionContext* opt_context;
-	_inner_error_ = NULL;
-	parameter_string = g_strdup ("- " PACKAGE_NAME);
-	opt_context = g_option_context_new (parameter_string);
-	g_option_context_set_help_enabled (opt_context, TRUE);
-	g_option_context_add_main_entries (opt_context, RYGEL_CMDLINE_CONFIG_options, NULL);
-	g_option_context_add_group (opt_context, gst_init_get_option_group ());
-	g_option_context_parse (opt_context, args_length1, args, &_inner_error_);
-	if (_inner_error_ != NULL) {
-		if ((_inner_error_->domain == RYGEL_CMDLINE_CONFIG_ERROR) || (_inner_error_->domain == G_OPTION_ERROR)) {
-			g_propagate_error (error, _inner_error_);
-			_g_free0 (parameter_string);
-			_g_option_context_free0 (opt_context);
-			return;
-		} else {
-			_g_free0 (parameter_string);
-			_g_option_context_free0 (opt_context);
-			g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
-			g_clear_error (&_inner_error_);
-			return;
-		}
-	}
-	if (rygel_cmdline_config_version) {
-		fprintf (stdout, "%s\n", PACKAGE_STRING);
-		_inner_error_ = g_error_new_literal (RYGEL_CMDLINE_CONFIG_ERROR, RYGEL_CMDLINE_CONFIG_ERROR_VERSION_ONLY, "");
-		if (_inner_error_ != NULL) {
-			if ((_inner_error_->domain == RYGEL_CMDLINE_CONFIG_ERROR) || (_inner_error_->domain == G_OPTION_ERROR)) {
-				g_propagate_error (error, _inner_error_);
-				_g_free0 (parameter_string);
-				_g_option_context_free0 (opt_context);
-				return;
-			} else {
-				_g_free0 (parameter_string);
-				_g_option_context_free0 (opt_context);
-				g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
-				g_clear_error (&_inner_error_);
-				return;
-			}
-		}
-	}
-	_g_free0 (parameter_string);
-	_g_option_context_free0 (opt_context);
-}
-
-
-static gboolean rygel_cmdline_config_real_get_upnp_enabled (RygelConfiguration* base, GError** error) {
-	RygelCmdlineConfig * self;
-	gboolean result;
-	GError * _inner_error_;
-	self = (RygelCmdlineConfig*) base;
-	_inner_error_ = NULL;
-	_inner_error_ = g_error_new_literal (RYGEL_CONFIGURATION_ERROR, RYGEL_CONFIGURATION_ERROR_NO_VALUE_SET, "No value available");
-	if (_inner_error_ != NULL) {
-		g_propagate_error (error, _inner_error_);
-		return FALSE;
-	}
-}
-
-
-static char* rygel_cmdline_config_real_get_interface (RygelConfiguration* base, GError** error) {
-	RygelCmdlineConfig * self;
-	char* result;
-	GError * _inner_error_;
-	self = (RygelCmdlineConfig*) base;
-	_inner_error_ = NULL;
-	if (rygel_cmdline_config_iface == NULL) {
-		_inner_error_ = g_error_new_literal (RYGEL_CONFIGURATION_ERROR, RYGEL_CONFIGURATION_ERROR_NO_VALUE_SET, "No value available");
-		if (_inner_error_ != NULL) {
-			g_propagate_error (error, _inner_error_);
-			return NULL;
-		}
-	}
-	result = g_strdup (rygel_cmdline_config_iface);
-	return result;
-}
-
-
-static gint rygel_cmdline_config_real_get_port (RygelConfiguration* base, GError** error) {
-	RygelCmdlineConfig * self;
-	gint result;
-	GError * _inner_error_;
-	self = (RygelCmdlineConfig*) base;
-	_inner_error_ = NULL;
-	if (rygel_cmdline_config_port == (-1)) {
-		_inner_error_ = g_error_new_literal (RYGEL_CONFIGURATION_ERROR, RYGEL_CONFIGURATION_ERROR_NO_VALUE_SET, "No value available");
-		if (_inner_error_ != NULL) {
-			g_propagate_error (error, _inner_error_);
-			return 0;
-		}
-	}
-	result = rygel_cmdline_config_port;
-	return result;
-}
-
-
-static gboolean rygel_cmdline_config_real_get_transcoding (RygelConfiguration* base, GError** error) {
-	RygelCmdlineConfig * self;
-	gboolean result;
-	self = (RygelCmdlineConfig*) base;
-	result = !rygel_cmdline_config_no_transcoding;
-	return result;
-}
-
-
-static gboolean rygel_cmdline_config_real_get_mp3_transcoder (RygelConfiguration* base, GError** error) {
-	RygelCmdlineConfig * self;
-	gboolean result;
-	self = (RygelCmdlineConfig*) base;
-	result = !rygel_cmdline_config_no_mp3_trans;
-	return result;
-}
-
-
-static gboolean rygel_cmdline_config_real_get_mp2ts_transcoder (RygelConfiguration* base, GError** error) {
-	RygelCmdlineConfig * self;
-	gboolean result;
-	self = (RygelCmdlineConfig*) base;
-	result = !rygel_cmdline_config_no_mp2ts_trans;
-	return result;
-}
-
-
-static gboolean rygel_cmdline_config_real_get_lpcm_transcoder (RygelConfiguration* base, GError** error) {
-	RygelCmdlineConfig * self;
-	gboolean result;
-	self = (RygelCmdlineConfig*) base;
-	result = !rygel_cmdline_config_no_lpcm_trans;
-	return result;
-}
-
-
-static RygelLogLevel rygel_cmdline_config_real_get_log_level (RygelConfiguration* base, GError** error) {
-	RygelCmdlineConfig * self;
-	RygelLogLevel result;
-	GError * _inner_error_;
-	self = (RygelCmdlineConfig*) base;
-	_inner_error_ = NULL;
-	if (rygel_cmdline_config_log_level == RYGEL_LOG_LEVEL_INVALID) {
-		_inner_error_ = g_error_new_literal (RYGEL_CONFIGURATION_ERROR, RYGEL_CONFIGURATION_ERROR_NO_VALUE_SET, "No value available");
-		if (_inner_error_ != NULL) {
-			g_propagate_error (error, _inner_error_);
-			return 0;
-		}
-	}
-	result = rygel_cmdline_config_log_level;
-	return result;
-}
-
-
-static gboolean rygel_cmdline_config_real_get_enabled (RygelConfiguration* base, const char* section, GError** error) {
-	RygelCmdlineConfig * self;
-	gboolean result;
-	GError * _inner_error_;
-	gboolean disabled;
-	self = (RygelCmdlineConfig*) base;
-	g_return_val_if_fail (section != NULL, FALSE);
-	_inner_error_ = NULL;
-	disabled = FALSE;
-	{
-		char** plugin_collection;
-		int plugin_collection_length1;
-		int plugin_it;
-		plugin_collection = rygel_cmdline_config_disabled_plugins;
-		plugin_collection_length1 = _vala_array_length (rygel_cmdline_config_disabled_plugins);
-		for (plugin_it = 0; plugin_it < _vala_array_length (rygel_cmdline_config_disabled_plugins); plugin_it = plugin_it + 1) {
-			char* plugin;
-			plugin = g_strdup (plugin_collection[plugin_it]);
-			{
-				if (_vala_strcmp0 (plugin, section) == 0) {
-					disabled = TRUE;
-					_g_free0 (plugin);
-					break;
-				}
-				_g_free0 (plugin);
-			}
-		}
-	}
-	if (disabled) {
-		result = FALSE;
-		return result;
-	} else {
-		_inner_error_ = g_error_new_literal (RYGEL_CONFIGURATION_ERROR, RYGEL_CONFIGURATION_ERROR_NO_VALUE_SET, "No value available");
-		if (_inner_error_ != NULL) {
-			g_propagate_error (error, _inner_error_);
-			return FALSE;
-		}
-	}
-}
-
-
-static char* rygel_cmdline_config_real_get_title (RygelConfiguration* base, const char* section, GError** error) {
-	RygelCmdlineConfig * self;
-	char* result;
-	GError * _inner_error_;
-	char* title;
-	self = (RygelCmdlineConfig*) base;
-	g_return_val_if_fail (section != NULL, NULL);
-	_inner_error_ = NULL;
-	title = NULL;
-	{
-		char** plugin_title_collection;
-		int plugin_title_collection_length1;
-		int plugin_title_it;
-		plugin_title_collection = rygel_cmdline_config_plugin_titles;
-		plugin_title_collection_length1 = _vala_array_length (rygel_cmdline_config_plugin_titles);
-		for (plugin_title_it = 0; plugin_title_it < _vala_array_length (rygel_cmdline_config_plugin_titles); plugin_title_it = plugin_title_it + 1) {
-			char* plugin_title;
-			plugin_title = g_strdup (plugin_title_collection[plugin_title_it]);
-			{
-				char** _tmp1_;
-				gint tokens_size;
-				gint tokens_length1;
-				char** _tmp0_;
-				char** tokens;
-				gboolean _tmp2_ = FALSE;
-				gboolean _tmp3_ = FALSE;
-				tokens = (_tmp1_ = _tmp0_ = g_strsplit (plugin_title, ":", 2), tokens_length1 = _vala_array_length (_tmp0_), tokens_size = tokens_length1, _tmp1_);
-				if (tokens[0] != NULL) {
-					_tmp3_ = tokens[1] != NULL;
-				} else {
-					_tmp3_ = FALSE;
-				}
-				if (_tmp3_) {
-					_tmp2_ = _vala_strcmp0 (tokens[0], section) == 0;
-				} else {
-					_tmp2_ = FALSE;
-				}
-				if (_tmp2_) {
-					char* _tmp4_;
-					title = (_tmp4_ = g_strdup (tokens[1]), _g_free0 (title), _tmp4_);
-					_g_free0 (plugin_title);
-					tokens = (_vala_array_free (tokens, tokens_length1, (GDestroyNotify) g_free), NULL);
-					break;
-				}
-				_g_free0 (plugin_title);
-				tokens = (_vala_array_free (tokens, tokens_length1, (GDestroyNotify) g_free), NULL);
-			}
-		}
-	}
-	if (title != NULL) {
-		result = title;
-		return result;
-	} else {
-		_inner_error_ = g_error_new_literal (RYGEL_CONFIGURATION_ERROR, RYGEL_CONFIGURATION_ERROR_NO_VALUE_SET, "No value available");
-		if (_inner_error_ != NULL) {
-			g_propagate_error (error, _inner_error_);
-			_g_free0 (title);
-			return NULL;
-		}
-	}
-	_g_free0 (title);
-}
-
-
-static char* rygel_cmdline_config_real_get_string (RygelConfiguration* base, const char* section, const char* key, GError** error) {
-	RygelCmdlineConfig * self;
-	char* result;
-	GError * _inner_error_;
-	char* value;
-	self = (RygelCmdlineConfig*) base;
-	g_return_val_if_fail (section != NULL, NULL);
-	g_return_val_if_fail (key != NULL, NULL);
-	_inner_error_ = NULL;
-	value = NULL;
-	{
-		char** option_collection;
-		int option_collection_length1;
-		int option_it;
-		option_collection = rygel_cmdline_config_plugin_options;
-		option_collection_length1 = _vala_array_length (rygel_cmdline_config_plugin_options);
-		for (option_it = 0; option_it < _vala_array_length (rygel_cmdline_config_plugin_options); option_it = option_it + 1) {
-			char* option;
-			option = g_strdup (option_collection[option_it]);
-			{
-				char** _tmp1_;
-				gint tokens_size;
-				gint tokens_length1;
-				char** _tmp0_;
-				char** tokens;
-				gboolean _tmp2_ = FALSE;
-				gboolean _tmp3_ = FALSE;
-				gboolean _tmp4_ = FALSE;
-				gboolean _tmp5_ = FALSE;
-				tokens = (_tmp1_ = _tmp0_ = g_strsplit (option, ":", 3), tokens_length1 = _vala_array_length (_tmp0_), tokens_size = tokens_length1, _tmp1_);
-				if (tokens[0] != NULL) {
-					_tmp5_ = tokens[1] != NULL;
-				} else {
-					_tmp5_ = FALSE;
-				}
-				if (_tmp5_) {
-					_tmp4_ = tokens[2] != NULL;
-				} else {
-					_tmp4_ = FALSE;
-				}
-				if (_tmp4_) {
-					_tmp3_ = _vala_strcmp0 (tokens[0], section) == 0;
-				} else {
-					_tmp3_ = FALSE;
-				}
-				if (_tmp3_) {
-					_tmp2_ = _vala_strcmp0 (tokens[1], key) == 0;
-				} else {
-					_tmp2_ = FALSE;
-				}
-				if (_tmp2_) {
-					char* _tmp6_;
-					value = (_tmp6_ = g_strdup (tokens[2]), _g_free0 (value), _tmp6_);
-					_g_free0 (option);
-					tokens = (_vala_array_free (tokens, tokens_length1, (GDestroyNotify) g_free), NULL);
-					break;
-				}
-				_g_free0 (option);
-				tokens = (_vala_array_free (tokens, tokens_length1, (GDestroyNotify) g_free), NULL);
-			}
-		}
-	}
-	if (value != NULL) {
-		result = value;
-		return result;
-	} else {
-		_inner_error_ = g_error_new_literal (RYGEL_CONFIGURATION_ERROR, RYGEL_CONFIGURATION_ERROR_NO_VALUE_SET, "No value available");
-		if (_inner_error_ != NULL) {
-			g_propagate_error (error, _inner_error_);
-			_g_free0 (value);
-			return NULL;
-		}
-	}
-	_g_free0 (value);
-}
-
-
-static GeeArrayList* rygel_cmdline_config_real_get_string_list (RygelConfiguration* base, const char* section, const char* key, GError** error) {
-	RygelCmdlineConfig * self;
-	GeeArrayList* result;
-	GError * _inner_error_;
-	GeeArrayList* value;
-	self = (RygelCmdlineConfig*) base;
-	g_return_val_if_fail (section != NULL, NULL);
-	g_return_val_if_fail (key != NULL, NULL);
-	_inner_error_ = NULL;
-	value = NULL;
-	{
-		char** option_collection;
-		int option_collection_length1;
-		int option_it;
-		option_collection = rygel_cmdline_config_plugin_options;
-		option_collection_length1 = _vala_array_length (rygel_cmdline_config_plugin_options);
-		for (option_it = 0; option_it < _vala_array_length (rygel_cmdline_config_plugin_options); option_it = option_it + 1) {
-			char* option;
-			option = g_strdup (option_collection[option_it]);
-			{
-				char** _tmp1_;
-				gint tokens_size;
-				gint tokens_length1;
-				char** _tmp0_;
-				char** tokens;
-				gboolean _tmp2_ = FALSE;
-				gboolean _tmp3_ = FALSE;
-				gboolean _tmp4_ = FALSE;
-				gboolean _tmp5_ = FALSE;
-				tokens = (_tmp1_ = _tmp0_ = g_strsplit (option, ":", 3), tokens_length1 = _vala_array_length (_tmp0_), tokens_size = tokens_length1, _tmp1_);
-				if (tokens[0] != NULL) {
-					_tmp5_ = tokens[1] != NULL;
-				} else {
-					_tmp5_ = FALSE;
-				}
-				if (_tmp5_) {
-					_tmp4_ = tokens[2] != NULL;
-				} else {
-					_tmp4_ = FALSE;
-				}
-				if (_tmp4_) {
-					_tmp3_ = _vala_strcmp0 (tokens[0], section) == 0;
-				} else {
-					_tmp3_ = FALSE;
-				}
-				if (_tmp3_) {
-					_tmp2_ = _vala_strcmp0 (tokens[1], key) == 0;
-				} else {
-					_tmp2_ = FALSE;
-				}
-				if (_tmp2_) {
-					GeeArrayList* _tmp6_;
-					value = (_tmp6_ = gee_array_list_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, g_direct_equal), _g_object_unref0 (value), _tmp6_);
-					{
-						char** _tmp7_;
-						char** val_token_collection;
-						int val_token_collection_length1;
-						int val_token_it;
-						val_token_collection = _tmp7_ = g_strsplit (tokens[2], ",", -1);
-						val_token_collection_length1 = _vala_array_length (_tmp7_);
-						for (val_token_it = 0; val_token_it < _vala_array_length (_tmp7_); val_token_it = val_token_it + 1) {
-							char* val_token;
-							val_token = g_strdup (val_token_collection[val_token_it]);
-							{
-								gee_abstract_collection_add ((GeeAbstractCollection*) value, val_token);
-								_g_free0 (val_token);
-							}
-						}
-						val_token_collection = (_vala_array_free (val_token_collection, val_token_collection_length1, (GDestroyNotify) g_free), NULL);
-					}
-					_g_free0 (option);
-					tokens = (_vala_array_free (tokens, tokens_length1, (GDestroyNotify) g_free), NULL);
-					break;
-				}
-				_g_free0 (option);
-				tokens = (_vala_array_free (tokens, tokens_length1, (GDestroyNotify) g_free), NULL);
-			}
-		}
-	}
-	if (value != NULL) {
-		result = value;
-		return result;
-	} else {
-		_inner_error_ = g_error_new_literal (RYGEL_CONFIGURATION_ERROR, RYGEL_CONFIGURATION_ERROR_NO_VALUE_SET, "No value available");
-		if (_inner_error_ != NULL) {
-			g_propagate_error (error, _inner_error_);
-			_g_object_unref0 (value);
-			return NULL;
-		}
-	}
-	_g_object_unref0 (value);
-}
-
-
-static gint rygel_cmdline_config_real_get_int (RygelConfiguration* base, const char* section, const char* key, gint min, gint max, GError** error) {
-	RygelCmdlineConfig * self;
-	gint result;
-	GError * _inner_error_;
-	gint value;
-	gboolean value_set;
-	self = (RygelCmdlineConfig*) base;
-	g_return_val_if_fail (section != NULL, 0);
-	g_return_val_if_fail (key != NULL, 0);
-	_inner_error_ = NULL;
-	value = 0;
-	value_set = FALSE;
-	{
-		char** option_collection;
-		int option_collection_length1;
-		int option_it;
-		option_collection = rygel_cmdline_config_plugin_options;
-		option_collection_length1 = _vala_array_length (rygel_cmdline_config_plugin_options);
-		for (option_it = 0; option_it < _vala_array_length (rygel_cmdline_config_plugin_options); option_it = option_it + 1) {
-			char* option;
-			option = g_strdup (option_collection[option_it]);
-			{
-				char** _tmp1_;
-				gint tokens_size;
-				gint tokens_length1;
-				char** _tmp0_;
-				char** tokens;
-				gboolean _tmp2_ = FALSE;
-				gboolean _tmp3_ = FALSE;
-				gboolean _tmp4_ = FALSE;
-				gboolean _tmp5_ = FALSE;
-				tokens = (_tmp1_ = _tmp0_ = g_strsplit (option, ":", 3), tokens_length1 = _vala_array_length (_tmp0_), tokens_size = tokens_length1, _tmp1_);
-				if (tokens[0] != NULL) {
-					_tmp5_ = tokens[1] != NULL;
-				} else {
-					_tmp5_ = FALSE;
-				}
-				if (_tmp5_) {
-					_tmp4_ = tokens[2] != NULL;
-				} else {
-					_tmp4_ = FALSE;
-				}
-				if (_tmp4_) {
-					_tmp3_ = _vala_strcmp0 (tokens[0], section) == 0;
-				} else {
-					_tmp3_ = FALSE;
-				}
-				if (_tmp3_) {
-					_tmp2_ = _vala_strcmp0 (tokens[1], key) == 0;
-				} else {
-					_tmp2_ = FALSE;
-				}
-				if (_tmp2_) {
-					gboolean _tmp6_ = FALSE;
-					value = atoi (tokens[2]);
-					if (value >= min) {
-						_tmp6_ = value <= max;
-					} else {
-						_tmp6_ = FALSE;
-					}
-					if (_tmp6_) {
-						value_set = TRUE;
-					}
-					_g_free0 (option);
-					tokens = (_vala_array_free (tokens, tokens_length1, (GDestroyNotify) g_free), NULL);
-					break;
-				}
-				_g_free0 (option);
-				tokens = (_vala_array_free (tokens, tokens_length1, (GDestroyNotify) g_free), NULL);
-			}
-		}
-	}
-	if (value_set) {
-		result = value;
-		return result;
-	} else {
-		_inner_error_ = g_error_new_literal (RYGEL_CONFIGURATION_ERROR, RYGEL_CONFIGURATION_ERROR_NO_VALUE_SET, "No value available");
-		if (_inner_error_ != NULL) {
-			g_propagate_error (error, _inner_error_);
-			return 0;
-		}
-	}
-}
-
-
-static GeeArrayList* rygel_cmdline_config_real_get_int_list (RygelConfiguration* base, const char* section, const char* key, GError** error) {
-	RygelCmdlineConfig * self;
-	GeeArrayList* result;
-	GError * _inner_error_;
-	GeeArrayList* value;
-	self = (RygelCmdlineConfig*) base;
-	g_return_val_if_fail (section != NULL, NULL);
-	g_return_val_if_fail (key != NULL, NULL);
-	_inner_error_ = NULL;
-	value = NULL;
-	{
-		char** option_collection;
-		int option_collection_length1;
-		int option_it;
-		option_collection = rygel_cmdline_config_plugin_options;
-		option_collection_length1 = _vala_array_length (rygel_cmdline_config_plugin_options);
-		for (option_it = 0; option_it < _vala_array_length (rygel_cmdline_config_plugin_options); option_it = option_it + 1) {
-			char* option;
-			option = g_strdup (option_collection[option_it]);
-			{
-				char** _tmp1_;
-				gint tokens_size;
-				gint tokens_length1;
-				char** _tmp0_;
-				char** tokens;
-				gboolean _tmp2_ = FALSE;
-				gboolean _tmp3_ = FALSE;
-				gboolean _tmp4_ = FALSE;
-				gboolean _tmp5_ = FALSE;
-				tokens = (_tmp1_ = _tmp0_ = g_strsplit (option, ":", 3), tokens_length1 = _vala_array_length (_tmp0_), tokens_size = tokens_length1, _tmp1_);
-				if (tokens[0] != NULL) {
-					_tmp5_ = tokens[1] != NULL;
-				} else {
-					_tmp5_ = FALSE;
-				}
-				if (_tmp5_) {
-					_tmp4_ = tokens[2] != NULL;
-				} else {
-					_tmp4_ = FALSE;
-				}
-				if (_tmp4_) {
-					_tmp3_ = _vala_strcmp0 (tokens[0], section) == 0;
-				} else {
-					_tmp3_ = FALSE;
-				}
-				if (_tmp3_) {
-					_tmp2_ = _vala_strcmp0 (tokens[1], key) == 0;
-				} else {
-					_tmp2_ = FALSE;
-				}
-				if (_tmp2_) {
-					GeeArrayList* _tmp6_;
-					value = (_tmp6_ = gee_array_list_new (G_TYPE_INT, NULL, NULL, g_direct_equal), _g_object_unref0 (value), _tmp6_);
-					{
-						char** _tmp7_;
-						char** val_token_collection;
-						int val_token_collection_length1;
-						int val_token_it;
-						val_token_collection = _tmp7_ = g_strsplit (tokens[2], ",", -1);
-						val_token_collection_length1 = _vala_array_length (_tmp7_);
-						for (val_token_it = 0; val_token_it < _vala_array_length (_tmp7_); val_token_it = val_token_it + 1) {
-							char* val_token;
-							val_token = g_strdup (val_token_collection[val_token_it]);
-							{
-								gee_abstract_collection_add ((GeeAbstractCollection*) value, GINT_TO_POINTER (atoi (val_token)));
-								_g_free0 (val_token);
-							}
-						}
-						val_token_collection = (_vala_array_free (val_token_collection, val_token_collection_length1, (GDestroyNotify) g_free), NULL);
-					}
-					_g_free0 (option);
-					tokens = (_vala_array_free (tokens, tokens_length1, (GDestroyNotify) g_free), NULL);
-					break;
-				}
-				_g_free0 (option);
-				tokens = (_vala_array_free (tokens, tokens_length1, (GDestroyNotify) g_free), NULL);
-			}
-		}
-	}
-	if (value != NULL) {
-		result = value;
-		return result;
-	} else {
-		_inner_error_ = g_error_new_literal (RYGEL_CONFIGURATION_ERROR, RYGEL_CONFIGURATION_ERROR_NO_VALUE_SET, "No value available");
-		if (_inner_error_ != NULL) {
-			g_propagate_error (error, _inner_error_);
-			_g_object_unref0 (value);
-			return NULL;
-		}
-	}
-	_g_object_unref0 (value);
-}
-
-
-static gboolean string_to_bool (const char* self) {
-	gboolean result;
-	g_return_val_if_fail (self != NULL, FALSE);
-	if (_vala_strcmp0 (self, "true") == 0) {
-		result = TRUE;
-		return result;
-	} else {
-		result = FALSE;
-		return result;
-	}
-}
-
-
-static gboolean rygel_cmdline_config_real_get_bool (RygelConfiguration* base, const char* section, const char* key, GError** error) {
-	RygelCmdlineConfig * self;
-	gboolean result;
-	GError * _inner_error_;
-	gboolean value;
-	gboolean value_set;
-	self = (RygelCmdlineConfig*) base;
-	g_return_val_if_fail (section != NULL, FALSE);
-	g_return_val_if_fail (key != NULL, FALSE);
-	_inner_error_ = NULL;
-	value = FALSE;
-	value_set = FALSE;
-	{
-		char** option_collection;
-		int option_collection_length1;
-		int option_it;
-		option_collection = rygel_cmdline_config_plugin_options;
-		option_collection_length1 = _vala_array_length (rygel_cmdline_config_plugin_options);
-		for (option_it = 0; option_it < _vala_array_length (rygel_cmdline_config_plugin_options); option_it = option_it + 1) {
-			char* option;
-			option = g_strdup (option_collection[option_it]);
-			{
-				char** _tmp1_;
-				gint tokens_size;
-				gint tokens_length1;
-				char** _tmp0_;
-				char** tokens;
-				gboolean _tmp2_ = FALSE;
-				gboolean _tmp3_ = FALSE;
-				gboolean _tmp4_ = FALSE;
-				gboolean _tmp5_ = FALSE;
-				tokens = (_tmp1_ = _tmp0_ = g_strsplit (option, ":", 3), tokens_length1 = _vala_array_length (_tmp0_), tokens_size = tokens_length1, _tmp1_);
-				if (tokens[0] != NULL) {
-					_tmp5_ = tokens[1] != NULL;
-				} else {
-					_tmp5_ = FALSE;
-				}
-				if (_tmp5_) {
-					_tmp4_ = tokens[2] != NULL;
-				} else {
-					_tmp4_ = FALSE;
-				}
-				if (_tmp4_) {
-					_tmp3_ = _vala_strcmp0 (tokens[0], section) == 0;
-				} else {
-					_tmp3_ = FALSE;
-				}
-				if (_tmp3_) {
-					_tmp2_ = _vala_strcmp0 (tokens[1], key) == 0;
-				} else {
-					_tmp2_ = FALSE;
-				}
-				if (_tmp2_) {
-					value = string_to_bool (tokens[2]);
-					value_set = TRUE;
-					_g_free0 (option);
-					tokens = (_vala_array_free (tokens, tokens_length1, (GDestroyNotify) g_free), NULL);
-					break;
-				}
-				_g_free0 (option);
-				tokens = (_vala_array_free (tokens, tokens_length1, (GDestroyNotify) g_free), NULL);
-			}
-		}
-	}
-	if (value_set) {
-		result = value;
-		return result;
-	} else {
-		_inner_error_ = g_error_new_literal (RYGEL_CONFIGURATION_ERROR, RYGEL_CONFIGURATION_ERROR_NO_VALUE_SET, "No value available");
-		if (_inner_error_ != NULL) {
-			g_propagate_error (error, _inner_error_);
-			return FALSE;
-		}
-	}
-}
-
-
-RygelCmdlineConfig* rygel_cmdline_config_construct (GType object_type) {
-	RygelCmdlineConfig * self;
-	self = (RygelCmdlineConfig*) g_object_new (object_type, NULL);
-	return self;
-}
-
-
-RygelCmdlineConfig* rygel_cmdline_config_new (void) {
-	return rygel_cmdline_config_construct (RYGEL_TYPE_CMDLINE_CONFIG);
-}
-
-
-static void rygel_cmdline_config_class_init (RygelCmdlineConfigClass * klass) {
-	rygel_cmdline_config_parent_class = g_type_class_peek_parent (klass);
-	G_OBJECT_CLASS (klass)->finalize = rygel_cmdline_config_finalize;
-	rygel_cmdline_config_port = -1;
-}
-
-
-static void rygel_cmdline_config_rygel_configuration_interface_init (RygelConfigurationIface * iface) {
-	rygel_cmdline_config_rygel_configuration_parent_iface = g_type_interface_peek_parent (iface);
-	iface->get_upnp_enabled = rygel_cmdline_config_real_get_upnp_enabled;
-	iface->get_interface = rygel_cmdline_config_real_get_interface;
-	iface->get_port = rygel_cmdline_config_real_get_port;
-	iface->get_transcoding = rygel_cmdline_config_real_get_transcoding;
-	iface->get_mp3_transcoder = rygel_cmdline_config_real_get_mp3_transcoder;
-	iface->get_mp2ts_transcoder = rygel_cmdline_config_real_get_mp2ts_transcoder;
-	iface->get_lpcm_transcoder = rygel_cmdline_config_real_get_lpcm_transcoder;
-	iface->get_log_level = rygel_cmdline_config_real_get_log_level;
-	iface->get_enabled = rygel_cmdline_config_real_get_enabled;
-	iface->get_title = rygel_cmdline_config_real_get_title;
-	iface->get_string = rygel_cmdline_config_real_get_string;
-	iface->get_string_list = rygel_cmdline_config_real_get_string_list;
-	iface->get_int = rygel_cmdline_config_real_get_int;
-	iface->get_int_list = rygel_cmdline_config_real_get_int_list;
-	iface->get_bool = rygel_cmdline_config_real_get_bool;
-}
-
-
-static void rygel_cmdline_config_instance_init (RygelCmdlineConfig * self) {
-}
-
-
-static void rygel_cmdline_config_finalize (GObject* obj) {
-	RygelCmdlineConfig * self;
-	self = RYGEL_CMDLINE_CONFIG (obj);
-	G_OBJECT_CLASS (rygel_cmdline_config_parent_class)->finalize (obj);
-}
-
-
-GType rygel_cmdline_config_get_type (void) {
-	static GType rygel_cmdline_config_type_id = 0;
-	if (rygel_cmdline_config_type_id == 0) {
-		static const GTypeInfo g_define_type_info = { sizeof (RygelCmdlineConfigClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) rygel_cmdline_config_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (RygelCmdlineConfig), 0, (GInstanceInitFunc) rygel_cmdline_config_instance_init, NULL };
-		static const GInterfaceInfo rygel_configuration_info = { (GInterfaceInitFunc) rygel_cmdline_config_rygel_configuration_interface_init, (GInterfaceFinalizeFunc) NULL, NULL};
-		rygel_cmdline_config_type_id = g_type_register_static (G_TYPE_OBJECT, "RygelCmdlineConfig", &g_define_type_info, 0);
-		g_type_add_interface_static (rygel_cmdline_config_type_id, RYGEL_TYPE_CONFIGURATION, &rygel_configuration_info);
-	}
-	return rygel_cmdline_config_type_id;
-}
-
-
-static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
-	if ((array != NULL) && (destroy_func != NULL)) {
-		int i;
-		for (i = 0; i < array_length; i = i + 1) {
-			if (((gpointer*) array)[i] != NULL) {
-				destroy_func (((gpointer*) array)[i]);
-			}
-		}
-	}
-}
-
-
-static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
-	_vala_array_destroy (array, array_length, destroy_func);
-	g_free (array);
-}
-
-
-static gint _vala_array_length (gpointer array) {
-	int length;
-	length = 0;
-	if (array) {
-		while (((gpointer*) array)[length]) {
-			length++;
-		}
-	}
-	return length;
-}
-
-
-static int _vala_strcmp0 (const char * str1, const char * str2) {
-	if (str1 == NULL) {
-		return -(str1 != str2);
-	}
-	if (str2 == NULL) {
-		return str1 != str2;
-	}
-	return strcmp (str1, str2);
-}
-
-
-
-
--- a/src/rygel/rygel-configuration.c
+++ /dev/null
@@ -1,202 +0,0 @@
-/* rygel-configuration.c generated by valac, the Vala compiler
- * generated from rygel-configuration.vala, do not modify */
-
-/*
- * Copyright (C) 2008,2009 Nokia Corporation.
- * Copyright (C) 2008,2009 Zeeshan Ali (Khattak) <zeeshanak@gnome.org>.
- *
- * Author: Zeeshan Ali (Khattak) <zeeshanak@gnome.org>
- *                               <zeeshan.ali@nokia.com>
- *
- * This file is part of Rygel.
- *
- * Rygel is free software; you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * Rygel is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this program; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
- */
-
-#include <glib.h>
-#include <glib-object.h>
-#include <stdlib.h>
-#include <string.h>
-#include <gee.h>
-
-
-#define RYGEL_TYPE_CONFIGURATION (rygel_configuration_get_type ())
-#define RYGEL_CONFIGURATION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_CONFIGURATION, RygelConfiguration))
-#define RYGEL_IS_CONFIGURATION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_CONFIGURATION))
-#define RYGEL_CONFIGURATION_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), RYGEL_TYPE_CONFIGURATION, RygelConfigurationIface))
-
-typedef struct _RygelConfiguration RygelConfiguration;
-typedef struct _RygelConfigurationIface RygelConfigurationIface;
-
-#define RYGEL_TYPE_LOG_LEVEL (rygel_log_level_get_type ())
-
-typedef enum  {
-	RYGEL_CONFIGURATION_ERROR_NO_VALUE_SET,
-	RYGEL_CONFIGURATION_ERROR_VALUE_OUT_OF_RANGE
-} RygelConfigurationError;
-#define RYGEL_CONFIGURATION_ERROR rygel_configuration_error_quark ()
-typedef enum  {
-	RYGEL_LOG_LEVEL_INVALID = 0,
-	RYGEL_LOG_LEVEL_CRITICAL = 1,
-	RYGEL_LOG_LEVEL_ERROR = 2,
-	RYGEL_LOG_LEVEL_WARNING = 3,
-	RYGEL_LOG_LEVEL_INFO = 4,
-	RYGEL_LOG_LEVEL_DEFAULT = 4,
-	RYGEL_LOG_LEVEL_DEBUG = 5
-} RygelLogLevel;
-
-struct _RygelConfigurationIface {
-	GTypeInterface parent_iface;
-	gboolean (*get_upnp_enabled) (RygelConfiguration* self, GError** error);
-	char* (*get_interface) (RygelConfiguration* self, GError** error);
-	gint (*get_port) (RygelConfiguration* self, GError** error);
-	gboolean (*get_transcoding) (RygelConfiguration* self, GError** error);
-	gboolean (*get_mp3_transcoder) (RygelConfiguration* self, GError** error);
-	gboolean (*get_mp2ts_transcoder) (RygelConfiguration* self, GError** error);
-	gboolean (*get_lpcm_transcoder) (RygelConfiguration* self, GError** error);
-	RygelLogLevel (*get_log_level) (RygelConfiguration* self, GError** error);
-	gboolean (*get_enabled) (RygelConfiguration* self, const char* section, GError** error);
-	char* (*get_title) (RygelConfiguration* self, const char* section, GError** error);
-	char* (*get_string) (RygelConfiguration* self, const char* section, const char* key, GError** error);
-	GeeArrayList* (*get_string_list) (RygelConfiguration* self, const char* section, const char* key, GError** error);
-	gint (*get_int) (RygelConfiguration* self, const char* section, const char* key, gint min, gint max, GError** error);
-	GeeArrayList* (*get_int_list) (RygelConfiguration* self, const char* section, const char* key, GError** error);
-	gboolean (*get_bool) (RygelConfiguration* self, const char* section, const char* key, GError** error);
-};
-
-
-
-GQuark rygel_configuration_error_quark (void);
-GType rygel_log_level_get_type (void);
-GType rygel_configuration_get_type (void);
-gboolean rygel_configuration_get_upnp_enabled (RygelConfiguration* self, GError** error);
-char* rygel_configuration_get_interface (RygelConfiguration* self, GError** error);
-gint rygel_configuration_get_port (RygelConfiguration* self, GError** error);
-gboolean rygel_configuration_get_transcoding (RygelConfiguration* self, GError** error);
-gboolean rygel_configuration_get_mp3_transcoder (RygelConfiguration* self, GError** error);
-gboolean rygel_configuration_get_mp2ts_transcoder (RygelConfiguration* self, GError** error);
-gboolean rygel_configuration_get_lpcm_transcoder (RygelConfiguration* self, GError** error);
-RygelLogLevel rygel_configuration_get_log_level (RygelConfiguration* self, GError** error);
-gboolean rygel_configuration_get_enabled (RygelConfiguration* self, const char* section, GError** error);
-char* rygel_configuration_get_title (RygelConfiguration* self, const char* section, GError** error);
-char* rygel_configuration_get_string (RygelConfiguration* self, const char* section, const char* key, GError** error);
-GeeArrayList* rygel_configuration_get_string_list (RygelConfiguration* self, const char* section, const char* key, GError** error);
-gint rygel_configuration_get_int (RygelConfiguration* self, const char* section, const char* key, gint min, gint max, GError** error);
-GeeArrayList* rygel_configuration_get_int_list (RygelConfiguration* self, const char* section, const char* key, GError** error);
-gboolean rygel_configuration_get_bool (RygelConfiguration* self, const char* section, const char* key, GError** error);
-
-
-
-GQuark rygel_configuration_error_quark (void) {
-	return g_quark_from_static_string ("rygel_configuration_error-quark");
-}
-
-
-gboolean rygel_configuration_get_upnp_enabled (RygelConfiguration* self, GError** error) {
-	return RYGEL_CONFIGURATION_GET_INTERFACE (self)->get_upnp_enabled (self, error);
-}
-
-
-char* rygel_configuration_get_interface (RygelConfiguration* self, GError** error) {
-	return RYGEL_CONFIGURATION_GET_INTERFACE (self)->get_interface (self, error);
-}
-
-
-gint rygel_configuration_get_port (RygelConfiguration* self, GError** error) {
-	return RYGEL_CONFIGURATION_GET_INTERFACE (self)->get_port (self, error);
-}
-
-
-gboolean rygel_configuration_get_transcoding (RygelConfiguration* self, GError** error) {
-	return RYGEL_CONFIGURATION_GET_INTERFACE (self)->get_transcoding (self, error);
-}
-
-
-gboolean rygel_configuration_get_mp3_transcoder (RygelConfiguration* self, GError** error) {
-	return RYGEL_CONFIGURATION_GET_INTERFACE (self)->get_mp3_transcoder (self, error);
-}
-
-
-gboolean rygel_configuration_get_mp2ts_transcoder (RygelConfiguration* self, GError** error) {
-	return RYGEL_CONFIGURATION_GET_INTERFACE (self)->get_mp2ts_transcoder (self, error);
-}
-
-
-gboolean rygel_configuration_get_lpcm_transcoder (RygelConfiguration* self, GError** error) {
-	return RYGEL_CONFIGURATION_GET_INTERFACE (self)->get_lpcm_transcoder (self, error);
-}
-
-
-RygelLogLevel rygel_configuration_get_log_level (RygelConfiguration* self, GError** error) {
-	return RYGEL_CONFIGURATION_GET_INTERFACE (self)->get_log_level (self, error);
-}
-
-
-gboolean rygel_configuration_get_enabled (RygelConfiguration* self, const char* section, GError** error) {
-	return RYGEL_CONFIGURATION_GET_INTERFACE (self)->get_enabled (self, section, error);
-}
-
-
-char* rygel_configuration_get_title (RygelConfiguration* self, const char* section, GError** error) {
-	return RYGEL_CONFIGURATION_GET_INTERFACE (self)->get_title (self, section, error);
-}
-
-
-char* rygel_configuration_get_string (RygelConfiguration* self, const char* section, const char* key, GError** error) {
-	return RYGEL_CONFIGURATION_GET_INTERFACE (self)->get_string (self, section, key, error);
-}
-
-
-GeeArrayList* rygel_configuration_get_string_list (RygelConfiguration* self, const char* section, const char* key, GError** error) {
-	return RYGEL_CONFIGURATION_GET_INTERFACE (self)->get_string_list (self, section, key, error);
-}
-
-
-gint rygel_configuration_get_int (RygelConfiguration* self, const char* section, const char* key, gint min, gint max, GError** error) {
-	return RYGEL_CONFIGURATION_GET_INTERFACE (self)->get_int (self, section, key, min, max, error);
-}
-
-
-GeeArrayList* rygel_configuration_get_int_list (RygelConfiguration* self, const char* section, const char* key, GError** error) {
-	return RYGEL_CONFIGURATION_GET_INTERFACE (self)->get_int_list (self, section, key, error);
-}
-
-
-gboolean rygel_configuration_get_bool (RygelConfiguration* self, const char* section, const char* key, GError** error) {
-	return RYGEL_CONFIGURATION_GET_INTERFACE (self)->get_bool (self, section, key, error);
-}
-
-
-static void rygel_configuration_base_init (RygelConfigurationIface * iface) {
-	static gboolean initialized = FALSE;
-	if (!initialized) {
-		initialized = TRUE;
-	}
-}
-
-
-GType rygel_configuration_get_type (void) {
-	static GType rygel_configuration_type_id = 0;
-	if (rygel_configuration_type_id == 0) {
-		static const GTypeInfo g_define_type_info = { sizeof (RygelConfigurationIface), (GBaseInitFunc) rygel_configuration_base_init, (GBaseFinalizeFunc) NULL, (GClassInitFunc) NULL, (GClassFinalizeFunc) NULL, NULL, 0, 0, (GInstanceInitFunc) NULL, NULL };
-		rygel_configuration_type_id = g_type_register_static (G_TYPE_INTERFACE, "RygelConfiguration", &g_define_type_info, 0);
-		g_type_interface_add_prerequisite (rygel_configuration_type_id, G_TYPE_OBJECT);
-	}
-	return rygel_configuration_type_id;
-}
-
-
-
-
--- a/src/rygel/rygel-connection-manager.c
+++ /dev/null
@@ -1,409 +0,0 @@
-/* rygel-connection-manager.c generated by valac, the Vala compiler
- * generated from rygel-connection-manager.vala, do not modify */
-
-/*
- * Copyright (C) 2008 OpenedHand Ltd.
- * Copyright (C) 2008 Zeeshan Ali <zeenix@gmail.com>.
- *
- * Author: Jorn Baayen <jorn@openedhand.com>
- *         Zeeshan Ali <zeenix@gmail.com>
- *
- * This file is part of Rygel.
- *
- * Rygel is free software; you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * Rygel is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this program; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
- */
-
-#include <glib.h>
-#include <glib-object.h>
-#include <libgupnp/gupnp.h>
-#include <stdlib.h>
-#include <string.h>
-#include <gee.h>
-#include <gio/gio.h>
-
-
-#define RYGEL_TYPE_CONNECTION_MANAGER (rygel_connection_manager_get_type ())
-#define RYGEL_CONNECTION_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_CONNECTION_MANAGER, RygelConnectionManager))
-#define RYGEL_CONNECTION_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_CONNECTION_MANAGER, RygelConnectionManagerClass))
-#define RYGEL_IS_CONNECTION_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_CONNECTION_MANAGER))
-#define RYGEL_IS_CONNECTION_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_CONNECTION_MANAGER))
-#define RYGEL_CONNECTION_MANAGER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_CONNECTION_MANAGER, RygelConnectionManagerClass))
-
-typedef struct _RygelConnectionManager RygelConnectionManager;
-typedef struct _RygelConnectionManagerClass RygelConnectionManagerClass;
-typedef struct _RygelConnectionManagerPrivate RygelConnectionManagerPrivate;
-#define _g_free0(var) (var = (g_free (var), NULL))
-
-#define RYGEL_TYPE_TRANSCODE_MANAGER (rygel_transcode_manager_get_type ())
-#define RYGEL_TRANSCODE_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_TRANSCODE_MANAGER, RygelTranscodeManager))
-#define RYGEL_TRANSCODE_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_TRANSCODE_MANAGER, RygelTranscodeManagerClass))
-#define RYGEL_IS_TRANSCODE_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_TRANSCODE_MANAGER))
-#define RYGEL_IS_TRANSCODE_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_TRANSCODE_MANAGER))
-#define RYGEL_TRANSCODE_MANAGER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_TRANSCODE_MANAGER, RygelTranscodeManagerClass))
-
-typedef struct _RygelTranscodeManager RygelTranscodeManager;
-typedef struct _RygelTranscodeManagerClass RygelTranscodeManagerClass;
-
-#define RYGEL_TYPE_HTTP_SERVER (rygel_http_server_get_type ())
-#define RYGEL_HTTP_SERVER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_HTTP_SERVER, RygelHTTPServer))
-#define RYGEL_HTTP_SERVER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_HTTP_SERVER, RygelHTTPServerClass))
-#define RYGEL_IS_HTTP_SERVER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_HTTP_SERVER))
-#define RYGEL_IS_HTTP_SERVER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_HTTP_SERVER))
-#define RYGEL_HTTP_SERVER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_HTTP_SERVER, RygelHTTPServerClass))
-
-typedef struct _RygelHTTPServer RygelHTTPServer;
-typedef struct _RygelHTTPServerClass RygelHTTPServerClass;
-
-#define RYGEL_TYPE_ROOT_DEVICE (rygel_root_device_get_type ())
-#define RYGEL_ROOT_DEVICE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_ROOT_DEVICE, RygelRootDevice))
-#define RYGEL_ROOT_DEVICE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_ROOT_DEVICE, RygelRootDeviceClass))
-#define RYGEL_IS_ROOT_DEVICE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_ROOT_DEVICE))
-#define RYGEL_IS_ROOT_DEVICE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_ROOT_DEVICE))
-#define RYGEL_ROOT_DEVICE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_ROOT_DEVICE, RygelRootDeviceClass))
-
-typedef struct _RygelRootDevice RygelRootDevice;
-typedef struct _RygelRootDeviceClass RygelRootDeviceClass;
-typedef struct _RygelRootDevicePrivate RygelRootDevicePrivate;
-
-#define RYGEL_TYPE_CONTENT_DIRECTORY (rygel_content_directory_get_type ())
-#define RYGEL_CONTENT_DIRECTORY(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_CONTENT_DIRECTORY, RygelContentDirectory))
-#define RYGEL_CONTENT_DIRECTORY_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_CONTENT_DIRECTORY, RygelContentDirectoryClass))
-#define RYGEL_IS_CONTENT_DIRECTORY(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_CONTENT_DIRECTORY))
-#define RYGEL_IS_CONTENT_DIRECTORY_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_CONTENT_DIRECTORY))
-#define RYGEL_CONTENT_DIRECTORY_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_CONTENT_DIRECTORY, RygelContentDirectoryClass))
-
-typedef struct _RygelContentDirectory RygelContentDirectory;
-typedef struct _RygelContentDirectoryClass RygelContentDirectoryClass;
-typedef struct _RygelContentDirectoryPrivate RygelContentDirectoryPrivate;
-
-#define RYGEL_TYPE_MEDIA_OBJECT (rygel_media_object_get_type ())
-#define RYGEL_MEDIA_OBJECT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_MEDIA_OBJECT, RygelMediaObject))
-#define RYGEL_MEDIA_OBJECT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_MEDIA_OBJECT, RygelMediaObjectClass))
-#define RYGEL_IS_MEDIA_OBJECT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_MEDIA_OBJECT))
-#define RYGEL_IS_MEDIA_OBJECT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_MEDIA_OBJECT))
-#define RYGEL_MEDIA_OBJECT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_MEDIA_OBJECT, RygelMediaObjectClass))
-
-typedef struct _RygelMediaObject RygelMediaObject;
-typedef struct _RygelMediaObjectClass RygelMediaObjectClass;
-
-#define RYGEL_TYPE_MEDIA_CONTAINER (rygel_media_container_get_type ())
-#define RYGEL_MEDIA_CONTAINER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_MEDIA_CONTAINER, RygelMediaContainer))
-#define RYGEL_MEDIA_CONTAINER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_MEDIA_CONTAINER, RygelMediaContainerClass))
-#define RYGEL_IS_MEDIA_CONTAINER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_MEDIA_CONTAINER))
-#define RYGEL_IS_MEDIA_CONTAINER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_MEDIA_CONTAINER))
-#define RYGEL_MEDIA_CONTAINER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_MEDIA_CONTAINER, RygelMediaContainerClass))
-
-typedef struct _RygelMediaContainer RygelMediaContainer;
-typedef struct _RygelMediaContainerClass RygelMediaContainerClass;
-#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
-
-struct _RygelConnectionManager {
-	GUPnPService parent_instance;
-	RygelConnectionManagerPrivate * priv;
-	char* sink_protocol_info;
-	char* connection_ids;
-};
-
-struct _RygelConnectionManagerClass {
-	GUPnPServiceClass parent_class;
-};
-
-struct _RygelRootDevice {
-	GUPnPRootDevice parent_instance;
-	RygelRootDevicePrivate * priv;
-	GeeArrayList* services;
-};
-
-struct _RygelRootDeviceClass {
-	GUPnPRootDeviceClass parent_class;
-};
-
-struct _RygelContentDirectory {
-	GUPnPService parent_instance;
-	RygelContentDirectoryPrivate * priv;
-	char* feature_list;
-	char* search_caps;
-	char* sort_caps;
-	RygelHTTPServer* http_server;
-	RygelMediaContainer* root_container;
-	GCancellable* cancellable;
-	guint32 system_update_id;
-};
-
-struct _RygelContentDirectoryClass {
-	GUPnPServiceClass parent_class;
-	RygelMediaContainer* (*create_root_container) (RygelContentDirectory* self);
-	void (*browse_cb) (RygelContentDirectory* self, RygelContentDirectory* content_dir, GUPnPServiceAction* action);
-};
-
-
-static gpointer rygel_connection_manager_parent_class = NULL;
-
-GType rygel_connection_manager_get_type (void);
-enum  {
-	RYGEL_CONNECTION_MANAGER_DUMMY_PROPERTY,
-	RYGEL_CONNECTION_MANAGER_SOURCE_PROTOCOL_INFO
-};
-#define RYGEL_CONNECTION_MANAGER_UPNP_ID "urn:upnp-org:serviceId:ConnectionManager"
-#define RYGEL_CONNECTION_MANAGER_UPNP_TYPE "urn:schemas-upnp-org:service:ConnectionManager:2"
-#define RYGEL_CONNECTION_MANAGER_DESCRIPTION_PATH "xml/ConnectionManager.xml"
-static void rygel_connection_manager_query_source_protocol_info_cb (RygelConnectionManager* self, RygelConnectionManager* cm, const char* var, GValue* val);
-static void _rygel_connection_manager_query_source_protocol_info_cb_gupnp_service_query_variable (RygelConnectionManager* _sender, const char* variable, GValue* value, gpointer self);
-static void rygel_connection_manager_query_sink_protocol_info_cb (RygelConnectionManager* self, RygelConnectionManager* cm, const char* var, GValue* val);
-static void _rygel_connection_manager_query_sink_protocol_info_cb_gupnp_service_query_variable (RygelConnectionManager* _sender, const char* variable, GValue* value, gpointer self);
-static void rygel_connection_manager_query_current_connection_ids_cb (RygelConnectionManager* self, RygelConnectionManager* cm, const char* var, GValue* val);
-static void _rygel_connection_manager_query_current_connection_ids_cb_gupnp_service_query_variable (RygelConnectionManager* _sender, const char* variable, GValue* value, gpointer self);
-static void rygel_connection_manager_get_protocol_info_cb (RygelConnectionManager* self, RygelConnectionManager* cm, GUPnPServiceAction* action);
-static void _rygel_connection_manager_get_protocol_info_cb_gupnp_service_action_invoked (RygelConnectionManager* _sender, GUPnPServiceAction* action, gpointer self);
-static void rygel_connection_manager_get_current_connection_ids_cb (RygelConnectionManager* self, RygelConnectionManager* cm, GUPnPServiceAction* action);
-static void _rygel_connection_manager_get_current_connection_ids_cb_gupnp_service_action_invoked (RygelConnectionManager* _sender, GUPnPServiceAction* action, gpointer self);
-static void rygel_connection_manager_get_current_connection_info_cb (RygelConnectionManager* self, RygelConnectionManager* cm, GUPnPServiceAction* action);
-static void _rygel_connection_manager_get_current_connection_info_cb_gupnp_service_action_invoked (RygelConnectionManager* _sender, GUPnPServiceAction* action, gpointer self);
-static void rygel_connection_manager_real_constructed (GObject* base);
-char* rygel_connection_manager_get_source_protocol_info (RygelConnectionManager* self);
-GType rygel_transcode_manager_get_type (void);
-GType rygel_http_server_get_type (void);
-GType rygel_root_device_get_type (void);
-GType rygel_content_directory_get_type (void);
-GType rygel_media_object_get_type (void);
-GType rygel_media_container_get_type (void);
-static RygelHTTPServer* rygel_connection_manager_get_http_server (RygelConnectionManager* self);
-RygelConnectionManager* rygel_connection_manager_new (void);
-RygelConnectionManager* rygel_connection_manager_construct (GType object_type);
-char* rygel_transcode_manager_get_protocol_info (RygelTranscodeManager* self);
-static void rygel_connection_manager_finalize (GObject* obj);
-static void rygel_connection_manager_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
-
-
-
-static void _rygel_connection_manager_query_source_protocol_info_cb_gupnp_service_query_variable (RygelConnectionManager* _sender, const char* variable, GValue* value, gpointer self) {
-	rygel_connection_manager_query_source_protocol_info_cb (self, _sender, variable, value);
-}
-
-
-static void _rygel_connection_manager_query_sink_protocol_info_cb_gupnp_service_query_variable (RygelConnectionManager* _sender, const char* variable, GValue* value, gpointer self) {
-	rygel_connection_manager_query_sink_protocol_info_cb (self, _sender, variable, value);
-}
-
-
-static void _rygel_connection_manager_query_current_connection_ids_cb_gupnp_service_query_variable (RygelConnectionManager* _sender, const char* variable, GValue* value, gpointer self) {
-	rygel_connection_manager_query_current_connection_ids_cb (self, _sender, variable, value);
-}
-
-
-static void _rygel_connection_manager_get_protocol_info_cb_gupnp_service_action_invoked (RygelConnectionManager* _sender, GUPnPServiceAction* action, gpointer self) {
-	rygel_connection_manager_get_protocol_info_cb (self, _sender, action);
-}
-
-
-static void _rygel_connection_manager_get_current_connection_ids_cb_gupnp_service_action_invoked (RygelConnectionManager* _sender, GUPnPServiceAction* action, gpointer self) {
-	rygel_connection_manager_get_current_connection_ids_cb (self, _sender, action);
-}
-
-
-static void _rygel_connection_manager_get_current_connection_info_cb_gupnp_service_action_invoked (RygelConnectionManager* _sender, GUPnPServiceAction* action, gpointer self) {
-	rygel_connection_manager_get_current_connection_info_cb (self, _sender, action);
-}
-
-
-static void rygel_connection_manager_real_constructed (GObject* base) {
-	RygelConnectionManager * self;
-	char* _tmp0_;
-	char* _tmp1_;
-	self = (RygelConnectionManager*) base;
-	self->sink_protocol_info = (_tmp0_ = g_strdup (""), _g_free0 (self->sink_protocol_info), _tmp0_);
-	self->connection_ids = (_tmp1_ = g_strdup ("0"), _g_free0 (self->connection_ids), _tmp1_);
-	g_signal_connect_object ((GUPnPService*) self, "query-variable::SourceProtocolInfo", (GCallback) _rygel_connection_manager_query_source_protocol_info_cb_gupnp_service_query_variable, self, 0);
-	g_signal_connect_object ((GUPnPService*) self, "query-variable::SinkProtocolInfo", (GCallback) _rygel_connection_manager_query_sink_protocol_info_cb_gupnp_service_query_variable, self, 0);
-	g_signal_connect_object ((GUPnPService*) self, "query-variable::CurrentConnectionIDs", (GCallback) _rygel_connection_manager_query_current_connection_ids_cb_gupnp_service_query_variable, self, 0);
-	g_signal_connect_object ((GUPnPService*) self, "action-invoked::GetProtocolInfo", (GCallback) _rygel_connection_manager_get_protocol_info_cb_gupnp_service_action_invoked, self, 0);
-	g_signal_connect_object ((GUPnPService*) self, "action-invoked::GetCurrentConnectionIDs", (GCallback) _rygel_connection_manager_get_current_connection_ids_cb_gupnp_service_action_invoked, self, 0);
-	g_signal_connect_object ((GUPnPService*) self, "action-invoked::GetCurrentConnectionInfo", (GCallback) _rygel_connection_manager_get_current_connection_info_cb_gupnp_service_action_invoked, self, 0);
-}
-
-
-static void rygel_connection_manager_query_source_protocol_info_cb (RygelConnectionManager* self, RygelConnectionManager* cm, const char* var, GValue* val) {
-	char* _tmp0_;
-	g_return_if_fail (self != NULL);
-	g_return_if_fail (cm != NULL);
-	g_return_if_fail (var != NULL);
-	g_value_init (val, G_TYPE_STRING);
-	g_value_set_string (val, _tmp0_ = rygel_connection_manager_get_source_protocol_info (self));
-	_g_free0 (_tmp0_);
-}
-
-
-static void rygel_connection_manager_query_sink_protocol_info_cb (RygelConnectionManager* self, RygelConnectionManager* cm, const char* var, GValue* val) {
-	g_return_if_fail (self != NULL);
-	g_return_if_fail (cm != NULL);
-	g_return_if_fail (var != NULL);
-	g_value_init (val, G_TYPE_STRING);
-	g_value_set_string (val, self->sink_protocol_info);
-}
-
-
-static void rygel_connection_manager_query_current_connection_ids_cb (RygelConnectionManager* self, RygelConnectionManager* cm, const char* var, GValue* val) {
-	g_return_if_fail (self != NULL);
-	g_return_if_fail (cm != NULL);
-	g_return_if_fail (var != NULL);
-	g_value_init (val, G_TYPE_STRING);
-	g_value_set_string (val, self->connection_ids);
-}
-
-
-static void rygel_connection_manager_get_protocol_info_cb (RygelConnectionManager* self, RygelConnectionManager* cm, GUPnPServiceAction* action) {
-	char* _tmp0_;
-	g_return_if_fail (self != NULL);
-	g_return_if_fail (cm != NULL);
-	g_return_if_fail (action != NULL);
-	gupnp_service_action_set (action, "Source", G_TYPE_STRING, _tmp0_ = rygel_connection_manager_get_source_protocol_info (self), "Sink", G_TYPE_STRING, self->sink_protocol_info, NULL);
-	_g_free0 (_tmp0_);
-	gupnp_service_action_return (action);
-}
-
-
-static void rygel_connection_manager_get_current_connection_ids_cb (RygelConnectionManager* self, RygelConnectionManager* cm, GUPnPServiceAction* action) {
-	g_return_if_fail (self != NULL);
-	g_return_if_fail (cm != NULL);
-	g_return_if_fail (action != NULL);
-	gupnp_service_action_set (action, "ConnectionIDs", G_TYPE_STRING, self->connection_ids, NULL);
-	gupnp_service_action_return (action);
-}
-
-
-static void rygel_connection_manager_get_current_connection_info_cb (RygelConnectionManager* self, RygelConnectionManager* cm, GUPnPServiceAction* action) {
-	gint connection_id = 0;
-	g_return_if_fail (self != NULL);
-	g_return_if_fail (cm != NULL);
-	g_return_if_fail (action != NULL);
-	gupnp_service_action_get (action, "ConnectionID", G_TYPE_INT, &connection_id, NULL);
-	if (connection_id != 0) {
-		gupnp_service_action_return_error (action, (guint) 706, "Invalid connection reference");
-		return;
-	}
-	gupnp_service_action_set (action, "ResID", G_TYPE_INT, -1, "AVTransportID", G_TYPE_INT, -1, "ProtocolInfo", G_TYPE_STRING, "", "PeerConnectionManager", G_TYPE_STRING, "", "PeerConnectionID", G_TYPE_INT, -1, "Direction", G_TYPE_STRING, "Input", "Status", G_TYPE_STRING, "Unknown", NULL);
-	gupnp_service_action_return (action);
-}
-
-
-static gpointer _g_object_ref0 (gpointer self) {
-	return self ? g_object_ref (self) : NULL;
-}
-
-
-static RygelHTTPServer* rygel_connection_manager_get_http_server (RygelConnectionManager* self) {
-	RygelHTTPServer* result;
-	RygelHTTPServer* server;
-	GUPnPRootDevice* _tmp0_ = NULL;
-	RygelRootDevice* root_device;
-	g_return_val_if_fail (self != NULL, NULL);
-	server = NULL;
-	root_device = RYGEL_ROOT_DEVICE ((g_object_get ((GUPnPService*) self, "root-device", &_tmp0_, NULL), _tmp0_));
-	{
-		GeeIterator* _service_it;
-		_service_it = gee_abstract_collection_iterator ((GeeAbstractCollection*) root_device->services);
-		while (TRUE) {
-			GUPnPServiceInfo* service;
-			if (!gee_iterator_next (_service_it)) {
-				break;
-			}
-			service = (GUPnPServiceInfo*) gee_iterator_get (_service_it);
-			if (g_type_is_a (G_TYPE_FROM_INSTANCE ((GObject*) service), RYGEL_TYPE_CONTENT_DIRECTORY)) {
-				RygelContentDirectory* content_directory;
-				RygelHTTPServer* _tmp1_;
-				content_directory = _g_object_ref0 (RYGEL_CONTENT_DIRECTORY (service));
-				server = (_tmp1_ = _g_object_ref0 (content_directory->http_server), _g_object_unref0 (server), _tmp1_);
-				_g_object_unref0 (content_directory);
-			}
-			_g_object_unref0 (service);
-		}
-		_g_object_unref0 (_service_it);
-	}
-	result = server;
-	_g_object_unref0 (root_device);
-	return result;
-}
-
-
-RygelConnectionManager* rygel_connection_manager_construct (GType object_type) {
-	RygelConnectionManager * self;
-	self = g_object_newv (object_type, 0, NULL);
-	return self;
-}
-
-
-RygelConnectionManager* rygel_connection_manager_new (void) {
-	return rygel_connection_manager_construct (RYGEL_TYPE_CONNECTION_MANAGER);
-}
-
-
-char* rygel_connection_manager_get_source_protocol_info (RygelConnectionManager* self) {
-	char* result;
-	RygelHTTPServer* _tmp0_;
-	char* _tmp1_;
-	g_return_val_if_fail (self != NULL, NULL);
-	result = (_tmp1_ = rygel_transcode_manager_get_protocol_info ((RygelTranscodeManager*) (_tmp0_ = rygel_connection_manager_get_http_server (self))), _g_object_unref0 (_tmp0_), _tmp1_);
-	return result;
-}
-
-
-static void rygel_connection_manager_class_init (RygelConnectionManagerClass * klass) {
-	rygel_connection_manager_parent_class = g_type_class_peek_parent (klass);
-	G_OBJECT_CLASS (klass)->constructed = rygel_connection_manager_real_constructed;
-	G_OBJECT_CLASS (klass)->get_property = rygel_connection_manager_get_property;
-	G_OBJECT_CLASS (klass)->finalize = rygel_connection_manager_finalize;
-	g_object_class_install_property (G_OBJECT_CLASS (klass), RYGEL_CONNECTION_MANAGER_SOURCE_PROTOCOL_INFO, g_param_spec_string ("source-protocol-info", "source-protocol-info", "source-protocol-info", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
-}
-
-
-static void rygel_connection_manager_instance_init (RygelConnectionManager * self) {
-}
-
-
-static void rygel_connection_manager_finalize (GObject* obj) {
-	RygelConnectionManager * self;
-	self = RYGEL_CONNECTION_MANAGER (obj);
-	_g_free0 (self->sink_protocol_info);
-	_g_free0 (self->connection_ids);
-	G_OBJECT_CLASS (rygel_connection_manager_parent_class)->finalize (obj);
-}
-
-
-GType rygel_connection_manager_get_type (void) {
-	static GType rygel_connection_manager_type_id = 0;
-	if (rygel_connection_manager_type_id == 0) {
-		static const GTypeInfo g_define_type_info = { sizeof (RygelConnectionManagerClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) rygel_connection_manager_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (RygelConnectionManager), 0, (GInstanceInitFunc) rygel_connection_manager_instance_init, NULL };
-		rygel_connection_manager_type_id = g_type_register_static (GUPNP_TYPE_SERVICE, "RygelConnectionManager", &g_define_type_info, 0);
-	}
-	return rygel_connection_manager_type_id;
-}
-
-
-static void rygel_connection_manager_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
-	RygelConnectionManager * self;
-	self = RYGEL_CONNECTION_MANAGER (object);
-	switch (property_id) {
-		case RYGEL_CONNECTION_MANAGER_SOURCE_PROTOCOL_INFO:
-		g_value_set_string (value, rygel_connection_manager_get_source_protocol_info (self));
-		break;
-		default:
-		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
-		break;
-	}
-}
-
-
-
-
--- a/src/rygel/rygel-content-directory.c
+++ /dev/null
@@ -1,627 +0,0 @@
-/* rygel-content-directory.c generated by valac, the Vala compiler
- * generated from rygel-content-directory.vala, do not modify */
-
-/*
- * Copyright (C) 2008 Zeeshan Ali <zeenix@gmail.com>.
- * Copyright (C) 2007 OpenedHand Ltd.
- *
- * Author: Zeeshan Ali <zeenix@gmail.com>
- *         Jorn Baayen <jorn@openedhand.com>
- *
- * This file is part of Rygel.
- *
- * Rygel is free software; you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * Rygel is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this program; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
- */
-
-#include <glib.h>
-#include <glib-object.h>
-#include <libgupnp/gupnp.h>
-#include <stdlib.h>
-#include <string.h>
-#include <gio/gio.h>
-#include <gee.h>
-
-
-#define RYGEL_TYPE_CONTENT_DIRECTORY (rygel_content_directory_get_type ())
-#define RYGEL_CONTENT_DIRECTORY(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_CONTENT_DIRECTORY, RygelContentDirectory))
-#define RYGEL_CONTENT_DIRECTORY_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_CONTENT_DIRECTORY, RygelContentDirectoryClass))
-#define RYGEL_IS_CONTENT_DIRECTORY(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_CONTENT_DIRECTORY))
-#define RYGEL_IS_CONTENT_DIRECTORY_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_CONTENT_DIRECTORY))
-#define RYGEL_CONTENT_DIRECTORY_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_CONTENT_DIRECTORY, RygelContentDirectoryClass))
-
-typedef struct _RygelContentDirectory RygelContentDirectory;
-typedef struct _RygelContentDirectoryClass RygelContentDirectoryClass;
-typedef struct _RygelContentDirectoryPrivate RygelContentDirectoryPrivate;
-
-#define RYGEL_TYPE_MEDIA_OBJECT (rygel_media_object_get_type ())
-#define RYGEL_MEDIA_OBJECT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_MEDIA_OBJECT, RygelMediaObject))
-#define RYGEL_MEDIA_OBJECT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_MEDIA_OBJECT, RygelMediaObjectClass))
-#define RYGEL_IS_MEDIA_OBJECT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_MEDIA_OBJECT))
-#define RYGEL_IS_MEDIA_OBJECT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_MEDIA_OBJECT))
-#define RYGEL_MEDIA_OBJECT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_MEDIA_OBJECT, RygelMediaObjectClass))
-
-typedef struct _RygelMediaObject RygelMediaObject;
-typedef struct _RygelMediaObjectClass RygelMediaObjectClass;
-
-#define RYGEL_TYPE_MEDIA_CONTAINER (rygel_media_container_get_type ())
-#define RYGEL_MEDIA_CONTAINER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_MEDIA_CONTAINER, RygelMediaContainer))
-#define RYGEL_MEDIA_CONTAINER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_MEDIA_CONTAINER, RygelMediaContainerClass))
-#define RYGEL_IS_MEDIA_CONTAINER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_MEDIA_CONTAINER))
-#define RYGEL_IS_MEDIA_CONTAINER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_MEDIA_CONTAINER))
-#define RYGEL_MEDIA_CONTAINER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_MEDIA_CONTAINER, RygelMediaContainerClass))
-
-typedef struct _RygelMediaContainer RygelMediaContainer;
-typedef struct _RygelMediaContainerClass RygelMediaContainerClass;
-
-#define RYGEL_TYPE_TRANSCODE_MANAGER (rygel_transcode_manager_get_type ())
-#define RYGEL_TRANSCODE_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_TRANSCODE_MANAGER, RygelTranscodeManager))
-#define RYGEL_TRANSCODE_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_TRANSCODE_MANAGER, RygelTranscodeManagerClass))
-#define RYGEL_IS_TRANSCODE_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_TRANSCODE_MANAGER))
-#define RYGEL_IS_TRANSCODE_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_TRANSCODE_MANAGER))
-#define RYGEL_TRANSCODE_MANAGER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_TRANSCODE_MANAGER, RygelTranscodeManagerClass))
-
-typedef struct _RygelTranscodeManager RygelTranscodeManager;
-typedef struct _RygelTranscodeManagerClass RygelTranscodeManagerClass;
-
-#define RYGEL_TYPE_HTTP_SERVER (rygel_http_server_get_type ())
-#define RYGEL_HTTP_SERVER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_HTTP_SERVER, RygelHTTPServer))
-#define RYGEL_HTTP_SERVER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_HTTP_SERVER, RygelHTTPServerClass))
-#define RYGEL_IS_HTTP_SERVER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_HTTP_SERVER))
-#define RYGEL_IS_HTTP_SERVER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_HTTP_SERVER))
-#define RYGEL_HTTP_SERVER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_HTTP_SERVER, RygelHTTPServerClass))
-
-typedef struct _RygelHTTPServer RygelHTTPServer;
-typedef struct _RygelHTTPServerClass RygelHTTPServerClass;
-
-#define RYGEL_TYPE_BROWSE (rygel_browse_get_type ())
-#define RYGEL_BROWSE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_BROWSE, RygelBrowse))
-#define RYGEL_BROWSE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_BROWSE, RygelBrowseClass))
-#define RYGEL_IS_BROWSE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_BROWSE))
-#define RYGEL_IS_BROWSE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_BROWSE))
-#define RYGEL_BROWSE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_BROWSE, RygelBrowseClass))
-
-typedef struct _RygelBrowse RygelBrowse;
-typedef struct _RygelBrowseClass RygelBrowseClass;
-#define _g_free0(var) (var = (g_free (var), NULL))
-#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
-#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
-
-#define RYGEL_TYPE_STATE_MACHINE (rygel_state_machine_get_type ())
-#define RYGEL_STATE_MACHINE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_STATE_MACHINE, RygelStateMachine))
-#define RYGEL_IS_STATE_MACHINE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_STATE_MACHINE))
-#define RYGEL_STATE_MACHINE_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), RYGEL_TYPE_STATE_MACHINE, RygelStateMachineIface))
-
-typedef struct _RygelStateMachine RygelStateMachine;
-typedef struct _RygelStateMachineIface RygelStateMachineIface;
-typedef struct _RygelMediaObjectPrivate RygelMediaObjectPrivate;
-typedef struct _RygelMediaContainerPrivate RygelMediaContainerPrivate;
-
-typedef enum  {
-	RYGEL_CONTENT_DIRECTORY_ERROR_NO_SUCH_OBJECT = 701,
-	RYGEL_CONTENT_DIRECTORY_ERROR_INVALID_ARGS = 402
-} RygelContentDirectoryError;
-#define RYGEL_CONTENT_DIRECTORY_ERROR rygel_content_directory_error_quark ()
-struct _RygelContentDirectory {
-	GUPnPService parent_instance;
-	RygelContentDirectoryPrivate * priv;
-	char* feature_list;
-	char* search_caps;
-	char* sort_caps;
-	RygelHTTPServer* http_server;
-	RygelMediaContainer* root_container;
-	GCancellable* cancellable;
-	guint32 system_update_id;
-};
-
-struct _RygelContentDirectoryClass {
-	GUPnPServiceClass parent_class;
-	RygelMediaContainer* (*create_root_container) (RygelContentDirectory* self);
-	void (*browse_cb) (RygelContentDirectory* self, RygelContentDirectory* content_dir, GUPnPServiceAction* action);
-};
-
-struct _RygelContentDirectoryPrivate {
-	GeeArrayList* updated_containers;
-	gboolean clear_updated_containers;
-	guint update_notify_id;
-	GeeArrayList* browses;
-};
-
-struct _RygelStateMachineIface {
-	GTypeInterface parent_iface;
-	void (*run) (RygelStateMachine* self);
-	GCancellable* (*get_cancellable) (RygelStateMachine* self);
-	void (*set_cancellable) (RygelStateMachine* self, GCancellable* value);
-};
-
-struct _RygelMediaObject {
-	GObject parent_instance;
-	RygelMediaObjectPrivate * priv;
-	char* id;
-	char* title;
-	guint64 modified;
-	GeeArrayList* uris;
-	RygelMediaContainer* parent;
-	RygelMediaContainer* parent_ref;
-};
-
-struct _RygelMediaObjectClass {
-	GObjectClass parent_class;
-};
-
-struct _RygelMediaContainer {
-	RygelMediaObject parent_instance;
-	RygelMediaContainerPrivate * priv;
-	guint child_count;
-	guint32 update_id;
-};
-
-struct _RygelMediaContainerClass {
-	RygelMediaObjectClass parent_class;
-	void (*get_children) (RygelMediaContainer* self, guint offset, guint max_count, GCancellable* cancellable, GAsyncReadyCallback callback, void* callback_target);
-	GeeList* (*get_children_finish) (RygelMediaContainer* self, GAsyncResult* res, GError** error);
-	void (*find_object) (RygelMediaContainer* self, const char* id, GCancellable* cancellable, GAsyncReadyCallback callback, void* callback_target);
-	RygelMediaObject* (*find_object_finish) (RygelMediaContainer* self, GAsyncResult* res, GError** error);
-};
-
-
-static gpointer rygel_content_directory_parent_class = NULL;
-
-GQuark rygel_content_directory_error_quark (void);
-GType rygel_content_directory_get_type (void);
-GType rygel_media_object_get_type (void);
-GType rygel_media_container_get_type (void);
-GType rygel_transcode_manager_get_type (void);
-GType rygel_http_server_get_type (void);
-GType rygel_browse_get_type (void);
-#define RYGEL_CONTENT_DIRECTORY_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), RYGEL_TYPE_CONTENT_DIRECTORY, RygelContentDirectoryPrivate))
-enum  {
-	RYGEL_CONTENT_DIRECTORY_DUMMY_PROPERTY
-};
-#define RYGEL_CONTENT_DIRECTORY_UPNP_ID "urn:upnp-org:serviceId:ContentDirectory"
-#define RYGEL_CONTENT_DIRECTORY_UPNP_TYPE "urn:schemas-upnp-org:service:ContentDirectory:2"
-#define RYGEL_CONTENT_DIRECTORY_DESCRIPTION_PATH "xml/ContentDirectory.xml"
-RygelMediaContainer* rygel_content_directory_create_root_container (RygelContentDirectory* self);
-static RygelMediaContainer* rygel_content_directory_real_create_root_container (RygelContentDirectory* self);
-RygelHTTPServer* rygel_http_server_new (RygelContentDirectory* content_dir, const char* name, GError** error);
-RygelHTTPServer* rygel_http_server_construct (GType object_type, RygelContentDirectory* content_dir, const char* name, GError** error);
-static void rygel_content_directory_on_container_updated (RygelContentDirectory* self, RygelMediaContainer* root_container, RygelMediaContainer* updated_container);
-static void _rygel_content_directory_on_container_updated_rygel_media_container_container_updated (RygelMediaContainer* _sender, RygelMediaContainer* container, gpointer self);
-static void rygel_content_directory_browse_cb (RygelContentDirectory* self, RygelContentDirectory* content_dir, GUPnPServiceAction* action);
-static void _rygel_content_directory_browse_cb_gupnp_service_action_invoked (RygelContentDirectory* _sender, GUPnPServiceAction* action, gpointer self);
-static void rygel_content_directory_get_system_update_id_cb (RygelContentDirectory* self, RygelContentDirectory* content_dir, GUPnPServiceAction* action);
-static void _rygel_content_directory_get_system_update_id_cb_gupnp_service_action_invoked (RygelContentDirectory* _sender, GUPnPServiceAction* action, gpointer self);
-static void rygel_content_directory_query_system_update_id (RygelContentDirectory* self, RygelContentDirectory* content_dir, const char* variable, GValue* value);
-static void _rygel_content_directory_query_system_update_id_gupnp_service_query_variable (RygelContentDirectory* _sender, const char* variable, GValue* value, gpointer self);
-static void rygel_content_directory_query_container_update_ids (RygelContentDirectory* self, RygelContentDirectory* content_dir, const char* variable, GValue* value);
-static void _rygel_content_directory_query_container_update_ids_gupnp_service_query_variable (RygelContentDirectory* _sender, const char* variable, GValue* value, gpointer self);
-static void rygel_content_directory_get_search_capabilities_cb (RygelContentDirectory* self, RygelContentDirectory* content_dir, GUPnPServiceAction* action);
-static void _rygel_content_directory_get_search_capabilities_cb_gupnp_service_action_invoked (RygelContentDirectory* _sender, GUPnPServiceAction* action, gpointer self);
-static void rygel_content_directory_query_search_capabilities (RygelContentDirectory* self, RygelContentDirectory* content_dir, const char* variable, GValue* value);
-static void _rygel_content_directory_query_search_capabilities_gupnp_service_query_variable (RygelContentDirectory* _sender, const char* variable, GValue* value, gpointer self);
-static void rygel_content_directory_get_sort_capabilities_cb (RygelContentDirectory* self, RygelContentDirectory* content_dir, GUPnPServiceAction* action);
-static void _rygel_content_directory_get_sort_capabilities_cb_gupnp_service_action_invoked (RygelContentDirectory* _sender, GUPnPServiceAction* action, gpointer self);
-static void rygel_content_directory_query_sort_capabilities (RygelContentDirectory* self, RygelContentDirectory* content_dir, const char* variable, GValue* value);
-static void _rygel_content_directory_query_sort_capabilities_gupnp_service_query_variable (RygelContentDirectory* _sender, const char* variable, GValue* value, gpointer self);
-static void rygel_content_directory_get_feature_list_cb (RygelContentDirectory* self, RygelContentDirectory* content_dir, GUPnPServiceAction* action);
-static void _rygel_content_directory_get_feature_list_cb_gupnp_service_action_invoked (RygelContentDirectory* _sender, GUPnPServiceAction* action, gpointer self);
-static void rygel_content_directory_query_feature_list (RygelContentDirectory* self, RygelContentDirectory* content_dir, const char* variable, GValue* value);
-static void _rygel_content_directory_query_feature_list_gupnp_service_query_variable (RygelContentDirectory* _sender, const char* variable, GValue* value, gpointer self);
-GType rygel_state_machine_get_type (void);
-void rygel_state_machine_run (RygelStateMachine* self);
-static void rygel_content_directory_real_constructed (GObject* base);
-RygelBrowse* rygel_browse_new (RygelContentDirectory* content_dir, GUPnPServiceAction* action);
-RygelBrowse* rygel_browse_construct (GType object_type, RygelContentDirectory* content_dir, GUPnPServiceAction* action);
-static void rygel_content_directory_on_browse_completed (RygelContentDirectory* self, RygelBrowse* browse);
-static void _rygel_content_directory_on_browse_completed_rygel_state_machine_completed (RygelBrowse* _sender, gpointer self);
-static void rygel_content_directory_real_browse_cb (RygelContentDirectory* self, RygelContentDirectory* content_dir, GUPnPServiceAction* action);
-static char* rygel_content_directory_create_container_update_ids (RygelContentDirectory* self);
-static gboolean rygel_content_directory_update_notify (RygelContentDirectory* self);
-static gboolean _rygel_content_directory_update_notify_gsource_func (gpointer self);
-RygelContentDirectory* rygel_content_directory_new (void);
-RygelContentDirectory* rygel_content_directory_construct (GType object_type);
-static void rygel_content_directory_finalize (GObject* obj);
-static int _vala_strcmp0 (const char * str1, const char * str2);
-
-
-
-GQuark rygel_content_directory_error_quark (void) {
-	return g_quark_from_static_string ("rygel_content_directory_error-quark");
-}
-
-
-static RygelMediaContainer* rygel_content_directory_real_create_root_container (RygelContentDirectory* self) {
-	RygelMediaContainer* result;
-	g_return_val_if_fail (self != NULL, NULL);
-	result = NULL;
-	return result;
-}
-
-
-RygelMediaContainer* rygel_content_directory_create_root_container (RygelContentDirectory* self) {
-	return RYGEL_CONTENT_DIRECTORY_GET_CLASS (self)->create_root_container (self);
-}
-
-
-static void _rygel_content_directory_on_container_updated_rygel_media_container_container_updated (RygelMediaContainer* _sender, RygelMediaContainer* container, gpointer self) {
-	rygel_content_directory_on_container_updated (self, _sender, container);
-}
-
-
-static void _rygel_content_directory_browse_cb_gupnp_service_action_invoked (RygelContentDirectory* _sender, GUPnPServiceAction* action, gpointer self) {
-	rygel_content_directory_browse_cb (self, _sender, action);
-}
-
-
-static void _rygel_content_directory_get_system_update_id_cb_gupnp_service_action_invoked (RygelContentDirectory* _sender, GUPnPServiceAction* action, gpointer self) {
-	rygel_content_directory_get_system_update_id_cb (self, _sender, action);
-}
-
-
-static void _rygel_content_directory_query_system_update_id_gupnp_service_query_variable (RygelContentDirectory* _sender, const char* variable, GValue* value, gpointer self) {
-	rygel_content_directory_query_system_update_id (self, _sender, variable, value);
-}
-
-
-static void _rygel_content_directory_query_container_update_ids_gupnp_service_query_variable (RygelContentDirectory* _sender, const char* variable, GValue* value, gpointer self) {
-	rygel_content_directory_query_container_update_ids (self, _sender, variable, value);
-}
-
-
-static void _rygel_content_directory_get_search_capabilities_cb_gupnp_service_action_invoked (RygelContentDirectory* _sender, GUPnPServiceAction* action, gpointer self) {
-	rygel_content_directory_get_search_capabilities_cb (self, _sender, action);
-}
-
-
-static void _rygel_content_directory_query_search_capabilities_gupnp_service_query_variable (RygelContentDirectory* _sender, const char* variable, GValue* value, gpointer self) {
-	rygel_content_directory_query_search_capabilities (self, _sender, variable, value);
-}
-
-
-static void _rygel_content_directory_get_sort_capabilities_cb_gupnp_service_action_invoked (RygelContentDirectory* _sender, GUPnPServiceAction* action, gpointer self) {
-	rygel_content_directory_get_sort_capabilities_cb (self, _sender, action);
-}
-
-
-static void _rygel_content_directory_query_sort_capabilities_gupnp_service_query_variable (RygelContentDirectory* _sender, const char* variable, GValue* value, gpointer self) {
-	rygel_content_directory_query_sort_capabilities (self, _sender, variable, value);
-}
-
-
-static void _rygel_content_directory_get_feature_list_cb_gupnp_service_action_invoked (RygelContentDirectory* _sender, GUPnPServiceAction* action, gpointer self) {
-	rygel_content_directory_get_feature_list_cb (self, _sender, action);
-}
-
-
-static void _rygel_content_directory_query_feature_list_gupnp_service_query_variable (RygelContentDirectory* _sender, const char* variable, GValue* value, gpointer self) {
-	rygel_content_directory_query_feature_list (self, _sender, variable, value);
-}
-
-
-static void rygel_content_directory_real_constructed (GObject* base) {
-	RygelContentDirectory * self;
-	GError * _inner_error_;
-	GCancellable* _tmp0_;
-	RygelMediaContainer* _tmp1_;
-	GeeArrayList* _tmp4_;
-	GeeArrayList* _tmp5_;
-	char* _tmp6_;
-	char* _tmp7_;
-	char* _tmp8_;
-	self = (RygelContentDirectory*) base;
-	_inner_error_ = NULL;
-	self->cancellable = (_tmp0_ = g_cancellable_new (), _g_object_unref0 (self->cancellable), _tmp0_);
-	self->root_container = (_tmp1_ = rygel_content_directory_create_root_container (self), _g_object_unref0 (self->root_container), _tmp1_);
-	{
-		RygelHTTPServer* _tmp2_;
-		RygelHTTPServer* _tmp3_;
-		_tmp2_ = rygel_http_server_new (self, g_type_name (G_TYPE_FROM_INSTANCE ((GObject*) self)), &_inner_error_);
-		if (_inner_error_ != NULL) {
-			goto __catch21_g_error;
-			goto __finally21;
-		}
-		self->http_server = (_tmp3_ = _tmp2_, _g_object_unref0 (self->http_server), _tmp3_);
-	}
-	goto __finally21;
-	__catch21_g_error:
-	{
-		GError * err;
-		err = _inner_error_;
-		_inner_error_ = NULL;
-		{
-			g_critical ("rygel-content-directory.vala:77: Failed to create HTTP server for %s: %s", g_type_name (G_TYPE_FROM_INSTANCE ((GObject*) self)), err->message);
-			_g_error_free0 (err);
-			return;
-		}
-	}
-	__finally21:
-	if (_inner_error_ != NULL) {
-		g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
-		g_clear_error (&_inner_error_);
-		return;
-	}
-	self->priv->browses = (_tmp4_ = gee_array_list_new (RYGEL_TYPE_BROWSE, (GBoxedCopyFunc) g_object_ref, g_object_unref, g_direct_equal), _g_object_unref0 (self->priv->browses), _tmp4_);
-	self->priv->updated_containers = (_tmp5_ = gee_array_list_new (RYGEL_TYPE_MEDIA_CONTAINER, (GBoxedCopyFunc) g_object_ref, g_object_unref, g_direct_equal), _g_object_unref0 (self->priv->updated_containers), _tmp5_);
-	g_signal_connect_object (self->root_container, "container-updated", (GCallback) _rygel_content_directory_on_container_updated_rygel_media_container_container_updated, self, 0);
-	self->feature_list = (_tmp6_ = g_strdup ("<?xml version=\"1.0\" encoding=\"UTF-8\"?>" "<Features xmlns=\"urn:schemas-upnp-org:av:avs\" " "xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" " "xsi:schemaLocation=\"urn:schemas-upnp-org:av:avs" "http://www.upnp.org/schemas/av/avs-v1-20060531.xsd\">" "</Features>"), _g_free0 (self->feature_list), _tmp6_);
-	self->search_caps = (_tmp7_ = g_strdup (""), _g_free0 (self->search_caps), _tmp7_);
-	self->sort_caps = (_tmp8_ = g_strdup (""), _g_free0 (self->sort_caps), _tmp8_);
-	g_signal_connect_object ((GUPnPService*) self, "action-invoked::Browse", (GCallback) _rygel_content_directory_browse_cb_gupnp_service_action_invoked, self, 0);
-	g_signal_connect_object ((GUPnPService*) self, "action-invoked::GetSystemUpdateID", (GCallback) _rygel_content_directory_get_system_update_id_cb_gupnp_service_action_invoked, self, 0);
-	g_signal_connect_object ((GUPnPService*) self, "query-variable::SystemUpdateID", (GCallback) _rygel_content_directory_query_system_update_id_gupnp_service_query_variable, self, 0);
-	g_signal_connect_object ((GUPnPService*) self, "query-variable::ContainerUpdateIDs", (GCallback) _rygel_content_directory_query_container_update_ids_gupnp_service_query_variable, self, 0);
-	g_signal_connect_object ((GUPnPService*) self, "action-invoked::GetSearchCapabilities", (GCallback) _rygel_content_directory_get_search_capabilities_cb_gupnp_service_action_invoked, self, 0);
-	g_signal_connect_object ((GUPnPService*) self, "query-variable::SearchCapabilities", (GCallback) _rygel_content_directory_query_search_capabilities_gupnp_service_query_variable, self, 0);
-	g_signal_connect_object ((GUPnPService*) self, "action-invoked::GetSortCapabilities", (GCallback) _rygel_content_directory_get_sort_capabilities_cb_gupnp_service_action_invoked, self, 0);
-	g_signal_connect_object ((GUPnPService*) self, "query-variable::SortCapabilities", (GCallback) _rygel_content_directory_query_sort_capabilities_gupnp_service_query_variable, self, 0);
-	g_signal_connect_object ((GUPnPService*) self, "action-invoked::GetFeatureList", (GCallback) _rygel_content_directory_get_feature_list_cb_gupnp_service_action_invoked, self, 0);
-	g_signal_connect_object ((GUPnPService*) self, "query-variable::FeatureList", (GCallback) _rygel_content_directory_query_feature_list_gupnp_service_query_variable, self, 0);
-	rygel_state_machine_run ((RygelStateMachine*) self->http_server);
-}
-
-
-static void _rygel_content_directory_on_browse_completed_rygel_state_machine_completed (RygelBrowse* _sender, gpointer self) {
-	rygel_content_directory_on_browse_completed (self, _sender);
-}
-
-
-static void rygel_content_directory_real_browse_cb (RygelContentDirectory* self, RygelContentDirectory* content_dir, GUPnPServiceAction* action) {
-	RygelBrowse* browse;
-	g_return_if_fail (self != NULL);
-	g_return_if_fail (content_dir != NULL);
-	g_return_if_fail (action != NULL);
-	browse = rygel_browse_new (self, action);
-	gee_abstract_collection_add ((GeeAbstractCollection*) self->priv->browses, browse);
-	g_signal_connect_object ((RygelStateMachine*) browse, "completed", (GCallback) _rygel_content_directory_on_browse_completed_rygel_state_machine_completed, self, 0);
-	rygel_state_machine_run ((RygelStateMachine*) browse);
-	_g_object_unref0 (browse);
-}
-
-
-void rygel_content_directory_browse_cb (RygelContentDirectory* self, RygelContentDirectory* content_dir, GUPnPServiceAction* action) {
-	RYGEL_CONTENT_DIRECTORY_GET_CLASS (self)->browse_cb (self, content_dir, action);
-}
-
-
-static void rygel_content_directory_get_system_update_id_cb (RygelContentDirectory* self, RygelContentDirectory* content_dir, GUPnPServiceAction* action) {
-	g_return_if_fail (self != NULL);
-	g_return_if_fail (content_dir != NULL);
-	g_return_if_fail (action != NULL);
-	gupnp_service_action_set (action, "Id", G_TYPE_UINT, self->system_update_id, NULL);
-	gupnp_service_action_return (action);
-}
-
-
-static void rygel_content_directory_query_system_update_id (RygelContentDirectory* self, RygelContentDirectory* content_dir, const char* variable, GValue* value) {
-	g_return_if_fail (self != NULL);
-	g_return_if_fail (content_dir != NULL);
-	g_return_if_fail (variable != NULL);
-	g_value_init (value, G_TYPE_UINT);
-	g_value_set_uint (value, (guint) self->system_update_id);
-}
-
-
-static void rygel_content_directory_query_container_update_ids (RygelContentDirectory* self, RygelContentDirectory* content_dir, const char* variable, GValue* value) {
-	char* update_ids;
-	g_return_if_fail (self != NULL);
-	g_return_if_fail (content_dir != NULL);
-	g_return_if_fail (variable != NULL);
-	update_ids = rygel_content_directory_create_container_update_ids (self);
-	g_value_init (value, G_TYPE_STRING);
-	g_value_set_string (value, update_ids);
-	_g_free0 (update_ids);
-}
-
-
-static void rygel_content_directory_get_search_capabilities_cb (RygelContentDirectory* self, RygelContentDirectory* content_dir, GUPnPServiceAction* action) {
-	g_return_if_fail (self != NULL);
-	g_return_if_fail (content_dir != NULL);
-	g_return_if_fail (action != NULL);
-	gupnp_service_action_set (action, "SearchCaps", G_TYPE_STRING, self->search_caps, NULL);
-	gupnp_service_action_return (action);
-}
-
-
-static void rygel_content_directory_query_search_capabilities (RygelContentDirectory* self, RygelContentDirectory* content_dir, const char* variable, GValue* value) {
-	g_return_if_fail (self != NULL);
-	g_return_if_fail (content_dir != NULL);
-	g_return_if_fail (variable != NULL);
-	g_value_init (value, G_TYPE_STRING);
-	g_value_set_string (value, self->search_caps);
-}
-
-
-static void rygel_content_directory_get_sort_capabilities_cb (RygelContentDirectory* self, RygelContentDirectory* content_dir, GUPnPServiceAction* action) {
-	g_return_if_fail (self != NULL);
-	g_return_if_fail (content_dir != NULL);
-	g_return_if_fail (action != NULL);
-	gupnp_service_action_set (action, "SortCaps", G_TYPE_STRING, self->sort_caps, NULL);
-	gupnp_service_action_return (action);
-}
-
-
-static void rygel_content_directory_query_sort_capabilities (RygelContentDirectory* self, RygelContentDirectory* content_dir, const char* variable, GValue* value) {
-	g_return_if_fail (self != NULL);
-	g_return_if_fail (content_dir != NULL);
-	g_return_if_fail (variable != NULL);
-	g_value_init (value, G_TYPE_STRING);
-	g_value_set_string (value, self->sort_caps);
-}
-
-
-static void rygel_content_directory_get_feature_list_cb (RygelContentDirectory* self, RygelContentDirectory* content_dir, GUPnPServiceAction* action) {
-	g_return_if_fail (self != NULL);
-	g_return_if_fail (content_dir != NULL);
-	g_return_if_fail (action != NULL);
-	gupnp_service_action_set (action, "FeatureList", G_TYPE_STRING, self->feature_list, NULL);
-	gupnp_service_action_return (action);
-}
-
-
-static void rygel_content_directory_query_feature_list (RygelContentDirectory* self, RygelContentDirectory* content_dir, const char* variable, GValue* value) {
-	g_return_if_fail (self != NULL);
-	g_return_if_fail (content_dir != NULL);
-	g_return_if_fail (variable != NULL);
-	g_value_init (value, G_TYPE_STRING);
-	g_value_set_string (value, self->feature_list);
-}
-
-
-static void rygel_content_directory_on_browse_completed (RygelContentDirectory* self, RygelBrowse* browse) {
-	g_return_if_fail (self != NULL);
-	g_return_if_fail (browse != NULL);
-	gee_abstract_collection_remove ((GeeAbstractCollection*) self->priv->browses, browse);
-}
-
-
-static char* rygel_content_directory_create_container_update_ids (RygelContentDirectory* self) {
-	char* result;
-	char* update_ids;
-	g_return_val_if_fail (self != NULL, NULL);
-	update_ids = g_strdup ("");
-	{
-		GeeIterator* _container_it;
-		_container_it = gee_abstract_collection_iterator ((GeeAbstractCollection*) self->priv->updated_containers);
-		while (TRUE) {
-			RygelMediaContainer* container;
-			char* _tmp4_;
-			char* _tmp3_;
-			char* _tmp2_;
-			char* _tmp1_;
-			if (!gee_iterator_next (_container_it)) {
-				break;
-			}
-			container = (RygelMediaContainer*) gee_iterator_get (_container_it);
-			if (_vala_strcmp0 (update_ids, "") != 0) {
-				char* _tmp0_;
-				update_ids = (_tmp0_ = g_strconcat (update_ids, ",", NULL), _g_free0 (update_ids), _tmp0_);
-			}
-			update_ids = (_tmp4_ = g_strconcat (update_ids, _tmp3_ = g_strconcat (_tmp1_ = g_strconcat (((RygelMediaObject*) container)->id, ",", NULL), _tmp2_ = g_strdup_printf ("%u", container->update_id), NULL), NULL), _g_free0 (update_ids), _tmp4_);
-			_g_free0 (_tmp3_);
-			_g_free0 (_tmp2_);
-			_g_free0 (_tmp1_);
-			_g_object_unref0 (container);
-		}
-		_g_object_unref0 (_container_it);
-	}
-	result = update_ids;
-	return result;
-}
-
-
-static gboolean _rygel_content_directory_update_notify_gsource_func (gpointer self) {
-	return rygel_content_directory_update_notify (self);
-}
-
-
-static void rygel_content_directory_on_container_updated (RygelContentDirectory* self, RygelMediaContainer* root_container, RygelMediaContainer* updated_container) {
-	g_return_if_fail (self != NULL);
-	g_return_if_fail (root_container != NULL);
-	g_return_if_fail (updated_container != NULL);
-	self->system_update_id++;
-	if (self->priv->clear_updated_containers) {
-		gee_abstract_collection_clear ((GeeAbstractCollection*) self->priv->updated_containers);
-		self->priv->clear_updated_containers = FALSE;
-	}
-	gee_abstract_collection_remove ((GeeAbstractCollection*) self->priv->updated_containers, updated_container);
-	gee_abstract_collection_add ((GeeAbstractCollection*) self->priv->updated_containers, updated_container);
-	if (self->priv->update_notify_id == 0) {
-		self->priv->update_notify_id = g_timeout_add_full (G_PRIORITY_DEFAULT, (guint) 200, _rygel_content_directory_update_notify_gsource_func, g_object_ref (self), g_object_unref);
-	}
-}
-
-
-static gboolean rygel_content_directory_update_notify (RygelContentDirectory* self) {
-	gboolean result;
-	char* update_ids;
-	g_return_val_if_fail (self != NULL, FALSE);
-	update_ids = rygel_content_directory_create_container_update_ids (self);
-	gupnp_service_notify ((GUPnPService*) self, "ContainerUpdateIDs", G_TYPE_STRING, update_ids, NULL);
-	gupnp_service_notify ((GUPnPService*) self, "SystemUpdateID", G_TYPE_UINT, self->system_update_id, NULL);
-	self->priv->clear_updated_containers = TRUE;
-	self->priv->update_notify_id = (guint) 0;
-	result = FALSE;
-	_g_free0 (update_ids);
-	return result;
-}
-
-
-RygelContentDirectory* rygel_content_directory_construct (GType object_type) {
-	RygelContentDirectory * self;
-	self = g_object_newv (object_type, 0, NULL);
-	return self;
-}
-
-
-RygelContentDirectory* rygel_content_directory_new (void) {
-	return rygel_content_directory_construct (RYGEL_TYPE_CONTENT_DIRECTORY);
-}
-
-
-static void rygel_content_directory_class_init (RygelContentDirectoryClass * klass) {
-	rygel_content_directory_parent_class = g_type_class_peek_parent (klass);
-	g_type_class_add_private (klass, sizeof (RygelContentDirectoryPrivate));
-	RYGEL_CONTENT_DIRECTORY_CLASS (klass)->create_root_container = rygel_content_directory_real_create_root_container;
-	G_OBJECT_CLASS (klass)->constructed = rygel_content_directory_real_constructed;
-	RYGEL_CONTENT_DIRECTORY_CLASS (klass)->browse_cb = rygel_content_directory_real_browse_cb;
-	G_OBJECT_CLASS (klass)->finalize = rygel_content_directory_finalize;
-}
-
-
-static void rygel_content_directory_instance_init (RygelContentDirectory * self) {
-	self->priv = RYGEL_CONTENT_DIRECTORY_GET_PRIVATE (self);
-}
-
-
-static void rygel_content_directory_finalize (GObject* obj) {
-	RygelContentDirectory * self;
-	self = RYGEL_CONTENT_DIRECTORY (obj);
-	{
-		g_cancellable_cancel (self->cancellable);
-	}
-	_g_free0 (self->feature_list);
-	_g_free0 (self->search_caps);
-	_g_free0 (self->sort_caps);
-	_g_object_unref0 (self->http_server);
-	_g_object_unref0 (self->root_container);
-	_g_object_unref0 (self->priv->updated_containers);
-	_g_object_unref0 (self->priv->browses);
-	_g_object_unref0 (self->cancellable);
-	G_OBJECT_CLASS (rygel_content_directory_parent_class)->finalize (obj);
-}
-
-
-GType rygel_content_directory_get_type (void) {
-	static GType rygel_content_directory_type_id = 0;
-	if (rygel_content_directory_type_id == 0) {
-		static const GTypeInfo g_define_type_info = { sizeof (RygelContentDirectoryClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) rygel_content_directory_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (RygelContentDirectory), 0, (GInstanceInitFunc) rygel_content_directory_instance_init, NULL };
-		rygel_content_directory_type_id = g_type_register_static (GUPNP_TYPE_SERVICE, "RygelContentDirectory", &g_define_type_info, 0);
-	}
-	return rygel_content_directory_type_id;
-}
-
-
-static int _vala_strcmp0 (const char * str1, const char * str2) {
-	if (str1 == NULL) {
-		return -(str1 != str2);
-	}
-	if (str2 == NULL) {
-		return str1 != str2;
-	}
-	return strcmp (str1, str2);
-}
-
-
-
-
--- a/src/rygel/rygel-dbus-service.c
+++ /dev/null
@@ -1,350 +0,0 @@
-/* rygel-dbus-service.c generated by valac, the Vala compiler
- * generated from rygel-dbus-service.vala, do not modify */
-
-/*
- * Copyright (C) 2008 Nokia Corporation.
- * Copyright (C) 2008 Zeeshan Ali (Khattak) <zeeshanak@gnome.org>.
- *
- * Author: Zeeshan Ali (Khattak) <zeeshanak@gnome.org>
- *
- * This file is part of Rygel.
- *
- * Rygel is free software; you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * Rygel is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this program; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
- */
-
-#include <glib.h>
-#include <glib-object.h>
-#include <stdlib.h>
-#include <string.h>
-#include <dbus/dbus-glib-lowlevel.h>
-#include <dbus/dbus-glib.h>
-#include <dbus/dbus.h>
-
-
-#define RYGEL_TYPE_DBUS_SERVICE (rygel_dbus_service_get_type ())
-#define RYGEL_DBUS_SERVICE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_DBUS_SERVICE, RygelDBusService))
-#define RYGEL_DBUS_SERVICE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_DBUS_SERVICE, RygelDBusServiceClass))
-#define RYGEL_IS_DBUS_SERVICE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_DBUS_SERVICE))
-#define RYGEL_IS_DBUS_SERVICE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_DBUS_SERVICE))
-#define RYGEL_DBUS_SERVICE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_DBUS_SERVICE, RygelDBusServiceClass))
-
-typedef struct _RygelDBusService RygelDBusService;
-typedef struct _RygelDBusServiceClass RygelDBusServiceClass;
-typedef struct _RygelDBusServicePrivate RygelDBusServicePrivate;
-
-#define RYGEL_TYPE_MAIN (rygel_main_get_type ())
-#define RYGEL_MAIN(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_MAIN, RygelMain))
-#define RYGEL_MAIN_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_MAIN, RygelMainClass))
-#define RYGEL_IS_MAIN(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_MAIN))
-#define RYGEL_IS_MAIN_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_MAIN))
-#define RYGEL_MAIN_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_MAIN, RygelMainClass))
-
-typedef struct _RygelMain RygelMain;
-typedef struct _RygelMainClass RygelMainClass;
-#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
-#define _dbus_g_connection_unref0(var) ((var == NULL) ? NULL : (var = (dbus_g_connection_unref (var), NULL)))
-typedef struct _DBusObjectVTable _DBusObjectVTable;
-
-struct _RygelDBusService {
-	GObject parent_instance;
-	RygelDBusServicePrivate * priv;
-};
-
-struct _RygelDBusServiceClass {
-	GObjectClass parent_class;
-};
-
-struct _RygelDBusServicePrivate {
-	RygelMain* main;
-};
-
-struct _DBusObjectVTable {
-	void (*register_object) (DBusConnection*, const char*, void*);
-};
-
-
-static char* rygel_dbus_service_RYGEL_SERVICE;
-static char* rygel_dbus_service_RYGEL_SERVICE = NULL;
-static char* rygel_dbus_service_RYGEL_PATH;
-static char* rygel_dbus_service_RYGEL_PATH = NULL;
-static gpointer rygel_dbus_service_parent_class = NULL;
-
-GType rygel_dbus_service_get_type (void);
-GType rygel_main_get_type (void);
-#define RYGEL_DBUS_SERVICE_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), RYGEL_TYPE_DBUS_SERVICE, RygelDBusServicePrivate))
-enum  {
-	RYGEL_DBUS_SERVICE_DUMMY_PROPERTY
-};
-guint _dynamic_request_name2 (DBusGProxy* self, const char* param1, guint param2, GError** error);
-RygelDBusService* rygel_dbus_service_new (RygelMain* main, GError** error);
-RygelDBusService* rygel_dbus_service_construct (GType object_type, RygelMain* main, GError** error);
-void rygel_main_exit (RygelMain* self, gint exit_code);
-void rygel_dbus_service_Shutdown (RygelDBusService* self);
-void rygel_dbus_service_dbus_register_object (DBusConnection* connection, const char* path, void* object);
-void _rygel_dbus_service_dbus_unregister (DBusConnection* connection, void* _user_data_);
-DBusHandlerResult rygel_dbus_service_dbus_message (DBusConnection* connection, DBusMessage* message, void* object);
-static DBusHandlerResult _dbus_rygel_dbus_service_introspect (RygelDBusService* self, DBusConnection* connection, DBusMessage* message);
-static DBusHandlerResult _dbus_rygel_dbus_service_property_get_all (RygelDBusService* self, DBusConnection* connection, DBusMessage* message);
-static DBusHandlerResult _dbus_rygel_dbus_service_Shutdown (RygelDBusService* self, DBusConnection* connection, DBusMessage* message);
-static void rygel_dbus_service_finalize (GObject* obj);
-static void _vala_dbus_register_object (DBusConnection* connection, const char* path, void* object);
-static void _vala_dbus_unregister_object (gpointer connection, GObject* object);
-
-static const DBusObjectPathVTable _rygel_dbus_service_dbus_path_vtable = {_rygel_dbus_service_dbus_unregister, rygel_dbus_service_dbus_message};
-static const _DBusObjectVTable _rygel_dbus_service_dbus_vtable = {rygel_dbus_service_dbus_register_object};
-
-
-static gpointer _g_object_ref0 (gpointer self) {
-	return self ? g_object_ref (self) : NULL;
-}
-
-
-guint _dynamic_request_name2 (DBusGProxy* self, const char* param1, guint param2, GError** error) {
-	guint result;
-	dbus_g_proxy_call (self, "RequestName", error, G_TYPE_STRING, param1, G_TYPE_UINT, param2, G_TYPE_INVALID, G_TYPE_UINT, &result, G_TYPE_INVALID);
-	if (*error) {
-		return 0U;
-	}
-	return result;
-}
-
-
-RygelDBusService* rygel_dbus_service_construct (GType object_type, RygelMain* main, GError** error) {
-	GError * _inner_error_;
-	RygelDBusService * self;
-	RygelMain* _tmp0_;
-	DBusGConnection* conn;
-	DBusGProxy* bus;
-	guint request_name_result;
-	g_return_val_if_fail (main != NULL, NULL);
-	_inner_error_ = NULL;
-	self = (RygelDBusService*) g_object_new (object_type, NULL);
-	self->priv->main = (_tmp0_ = _g_object_ref0 (main), _g_object_unref0 (self->priv->main), _tmp0_);
-	conn = dbus_g_bus_get (DBUS_BUS_SESSION, &_inner_error_);
-	if (_inner_error_ != NULL) {
-		if (_inner_error_->domain == DBUS_GERROR) {
-			g_propagate_error (error, _inner_error_);
-			return;
-		} else {
-			g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
-			g_clear_error (&_inner_error_);
-			return NULL;
-		}
-	}
-	bus = dbus_g_proxy_new_for_name (conn, "org.freedesktop.DBus", "/org/freedesktop/DBus", "org.freedesktop.DBus");
-	request_name_result = _dynamic_request_name2 (bus, rygel_dbus_service_RYGEL_SERVICE, (guint) 0, &_inner_error_);
-	if (_inner_error_ != NULL) {
-		if (_inner_error_->domain == DBUS_GERROR) {
-			g_propagate_error (error, _inner_error_);
-			_dbus_g_connection_unref0 (conn);
-			_g_object_unref0 (bus);
-			return;
-		} else {
-			_dbus_g_connection_unref0 (conn);
-			_g_object_unref0 (bus);
-			g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
-			g_clear_error (&_inner_error_);
-			return NULL;
-		}
-	}
-	if (request_name_result != DBUS_REQUEST_NAME_REPLY_PRIMARY_OWNER) {
-		g_warning ("rygel-dbus-service.vala:45: Failed to start D-Bus service, name '%s' already taken", rygel_dbus_service_RYGEL_SERVICE);
-	} else {
-		_vala_dbus_register_object (dbus_g_connection_get_connection (conn), rygel_dbus_service_RYGEL_PATH, (GObject*) self);
-	}
-	_dbus_g_connection_unref0 (conn);
-	_g_object_unref0 (bus);
-	return self;
-}
-
-
-RygelDBusService* rygel_dbus_service_new (RygelMain* main, GError** error) {
-	return rygel_dbus_service_construct (RYGEL_TYPE_DBUS_SERVICE, main, error);
-}
-
-
-void rygel_dbus_service_Shutdown (RygelDBusService* self) {
-	g_return_if_fail (self != NULL);
-	rygel_main_exit (self->priv->main, 0);
-}
-
-
-void _rygel_dbus_service_dbus_unregister (DBusConnection* connection, void* _user_data_) {
-}
-
-
-static DBusHandlerResult _dbus_rygel_dbus_service_introspect (RygelDBusService* self, DBusConnection* connection, DBusMessage* message) {
-	DBusMessage* reply;
-	DBusMessageIter iter;
-	GString* xml_data;
-	char** children;
-	int i;
-	reply = dbus_message_new_method_return (message);
-	dbus_message_iter_init_append (reply, &iter);
-	xml_data = g_string_new ("<!DOCTYPE node PUBLIC \"-//freedesktop//DTD D-BUS Object Introspection 1.0//EN\" \"http://www.freedesktop.org/standards/dbus/1.0/introspect.dtd\">\n");
-	g_string_append (xml_data, "<node>\n<interface name=\"org.freedesktop.DBus.Introspectable\">\n  <method name=\"Introspect\">\n    <arg name=\"data\" direction=\"out\" type=\"s\"/>\n  </method>\n</interface>\n<interface name=\"org.freedesktop.DBus.Properties\">\n  <method name=\"Get\">\n    <arg name=\"interface\" direction=\"in\" type=\"s\"/>\n    <arg name=\"propname\" direction=\"in\" type=\"s\"/>\n    <arg name=\"value\" direction=\"out\" type=\"v\"/>\n  </method>\n  <method name=\"Set\">\n    <arg name=\"interface\" direction=\"in\" type=\"s\"/>\n    <arg name=\"propname\" direction=\"in\" type=\"s\"/>\n    <arg name=\"value\" direction=\"in\" type=\"v\"/>\n  </method>\n  <method name=\"GetAll\">\n    <arg name=\"interface\" direction=\"in\" type=\"s\"/>\n    <arg name=\"props\" direction=\"out\" type=\"a{sv}\"/>\n  </method>\n</interface>\n<interface name=\"org.gnome.Rygel1\">\n  <method name=\"Shutdown\">\n  </method>\n</interface>\n");
-	dbus_connection_list_registered (connection, g_object_get_data ((GObject *) self, "dbus_object_path"), &children);
-	for (i = 0; children[i]; i++) {
-		g_string_append_printf (xml_data, "<node name=\"%s\"/>\n", children[i]);
-	}
-	dbus_free_string_array (children);
-	g_string_append (xml_data, "</node>\n");
-	dbus_message_iter_append_basic (&iter, DBUS_TYPE_STRING, &xml_data->str);
-	g_string_free (xml_data, TRUE);
-	if (reply) {
-		dbus_connection_send (connection, reply, NULL);
-		dbus_message_unref (reply);
-		return DBUS_HANDLER_RESULT_HANDLED;
-	} else {
-		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
-	}
-}
-
-
-static DBusHandlerResult _dbus_rygel_dbus_service_property_get_all (RygelDBusService* self, DBusConnection* connection, DBusMessage* message) {
-	DBusMessage* reply;
-	DBusMessageIter iter, reply_iter, subiter;
-	char* interface_name;
-	const char* _tmp0_;
-	if (strcmp (dbus_message_get_signature (message), "s")) {
-		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
-	}
-	dbus_message_iter_init (message, &iter);
-	reply = dbus_message_new_method_return (message);
-	dbus_message_iter_init_append (reply, &reply_iter);
-	dbus_message_iter_get_basic (&iter, &_tmp0_);
-	dbus_message_iter_next (&iter);
-	interface_name = g_strdup (_tmp0_);
-	if (strcmp (interface_name, "org.gnome.Rygel1") == 0) {
-		dbus_message_iter_open_container (&reply_iter, DBUS_TYPE_ARRAY, "{sv}", &subiter);
-		dbus_message_iter_close_container (&reply_iter, &subiter);
-	} else {
-		dbus_message_unref (reply);
-		reply = NULL;
-	}
-	g_free (interface_name);
-	if (reply) {
-		dbus_connection_send (connection, reply, NULL);
-		dbus_message_unref (reply);
-		return DBUS_HANDLER_RESULT_HANDLED;
-	} else {
-		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
-	}
-}
-
-
-static DBusHandlerResult _dbus_rygel_dbus_service_Shutdown (RygelDBusService* self, DBusConnection* connection, DBusMessage* message) {
-	DBusMessageIter iter;
-	GError* error;
-	DBusMessage* reply;
-	error = NULL;
-	if (strcmp (dbus_message_get_signature (message), "")) {
-		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
-	}
-	dbus_message_iter_init (message, &iter);
-	rygel_dbus_service_Shutdown (self);
-	reply = dbus_message_new_method_return (message);
-	dbus_message_iter_init_append (reply, &iter);
-	if (reply) {
-		dbus_connection_send (connection, reply, NULL);
-		dbus_message_unref (reply);
-		return DBUS_HANDLER_RESULT_HANDLED;
-	} else {
-		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
-	}
-}
-
-
-DBusHandlerResult rygel_dbus_service_dbus_message (DBusConnection* connection, DBusMessage* message, void* object) {
-	DBusHandlerResult result;
-	result = DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
-	if (dbus_message_is_method_call (message, "org.freedesktop.DBus.Introspectable", "Introspect")) {
-		result = _dbus_rygel_dbus_service_introspect (object, connection, message);
-	} else if (dbus_message_is_method_call (message, "org.freedesktop.DBus.Properties", "GetAll")) {
-		result = _dbus_rygel_dbus_service_property_get_all (object, connection, message);
-	} else if (dbus_message_is_method_call (message, "org.gnome.Rygel1", "Shutdown")) {
-		result = _dbus_rygel_dbus_service_Shutdown (object, connection, message);
-	}
-	if (result == DBUS_HANDLER_RESULT_HANDLED) {
-		return result;
-	} else {
-		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
-	}
-}
-
-
-void rygel_dbus_service_dbus_register_object (DBusConnection* connection, const char* path, void* object) {
-	if (!g_object_get_data (object, "dbus_object_path")) {
-		g_object_set_data (object, "dbus_object_path", g_strdup (path));
-		dbus_connection_register_object_path (connection, path, &_rygel_dbus_service_dbus_path_vtable, object);
-		g_object_weak_ref (object, _vala_dbus_unregister_object, connection);
-	}
-}
-
-
-static void rygel_dbus_service_class_init (RygelDBusServiceClass * klass) {
-	rygel_dbus_service_parent_class = g_type_class_peek_parent (klass);
-	g_type_class_add_private (klass, sizeof (RygelDBusServicePrivate));
-	G_OBJECT_CLASS (klass)->finalize = rygel_dbus_service_finalize;
-	g_type_set_qdata (RYGEL_TYPE_DBUS_SERVICE, g_quark_from_static_string ("DBusObjectVTable"), (void*) (&_rygel_dbus_service_dbus_vtable));
-	rygel_dbus_service_RYGEL_SERVICE = g_strdup ("org.gnome.Rygel1");
-	rygel_dbus_service_RYGEL_PATH = g_strdup ("/org/gnome/Rygel1");
-}
-
-
-static void rygel_dbus_service_instance_init (RygelDBusService * self) {
-	self->priv = RYGEL_DBUS_SERVICE_GET_PRIVATE (self);
-}
-
-
-static void rygel_dbus_service_finalize (GObject* obj) {
-	RygelDBusService * self;
-	self = RYGEL_DBUS_SERVICE (obj);
-	_g_object_unref0 (self->priv->main);
-	G_OBJECT_CLASS (rygel_dbus_service_parent_class)->finalize (obj);
-}
-
-
-GType rygel_dbus_service_get_type (void) {
-	static GType rygel_dbus_service_type_id = 0;
-	if (rygel_dbus_service_type_id == 0) {
-		static const GTypeInfo g_define_type_info = { sizeof (RygelDBusServiceClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) rygel_dbus_service_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (RygelDBusService), 0, (GInstanceInitFunc) rygel_dbus_service_instance_init, NULL };
-		rygel_dbus_service_type_id = g_type_register_static (G_TYPE_OBJECT, "RygelDBusService", &g_define_type_info, 0);
-	}
-	return rygel_dbus_service_type_id;
-}
-
-
-static void _vala_dbus_register_object (DBusConnection* connection, const char* path, void* object) {
-	const _DBusObjectVTable * vtable;
-	vtable = g_type_get_qdata (G_TYPE_FROM_INSTANCE (object), g_quark_from_static_string ("DBusObjectVTable"));
-	if (vtable) {
-		vtable->register_object (connection, path, object);
-	} else {
-		g_warning ("Object does not implement any D-Bus interface");
-	}
-}
-
-
-static void _vala_dbus_unregister_object (gpointer connection, GObject* object) {
-	char* path;
-	path = g_object_steal_data ((GObject*) object, "dbus_object_path");
-	dbus_connection_unregister_object_path (connection, path);
-	g_free (path);
-}
-
-
-
-
--- a/src/rygel/rygel-didl-lite-writer.c
+++ /dev/null
@@ -1,471 +0,0 @@
-/* rygel-didl-lite-writer.c generated by valac, the Vala compiler
- * generated from rygel-didl-lite-writer.vala, do not modify */
-
-/*
- * Copyright (C) 2009 Nokia Corporation.
- *
- * Author: Zeeshan Ali (Khattak) <zeeshanak@gnome.org>
- *                               <zeeshan.ali@nokia.com>
- *
- * This file is part of Rygel.
- *
- * Rygel is free software; you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * Rygel is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this program; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
- */
-
-#include <glib.h>
-#include <glib-object.h>
-#include <libgupnp-av/gupnp-av.h>
-#include <stdlib.h>
-#include <string.h>
-#include <gee.h>
-#include <gst/gst.h>
-#include <gio/gio.h>
-#include <libgupnp/gupnp.h>
-#include <libgssdp/gssdp.h>
-
-
-#define RYGEL_TYPE_DIDL_LITE_WRITER (rygel_didl_lite_writer_get_type ())
-#define RYGEL_DIDL_LITE_WRITER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_DIDL_LITE_WRITER, RygelDIDLLiteWriter))
-#define RYGEL_DIDL_LITE_WRITER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_DIDL_LITE_WRITER, RygelDIDLLiteWriterClass))
-#define RYGEL_IS_DIDL_LITE_WRITER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_DIDL_LITE_WRITER))
-#define RYGEL_IS_DIDL_LITE_WRITER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_DIDL_LITE_WRITER))
-#define RYGEL_DIDL_LITE_WRITER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_DIDL_LITE_WRITER, RygelDIDLLiteWriterClass))
-
-typedef struct _RygelDIDLLiteWriter RygelDIDLLiteWriter;
-typedef struct _RygelDIDLLiteWriterClass RygelDIDLLiteWriterClass;
-typedef struct _RygelDIDLLiteWriterPrivate RygelDIDLLiteWriterPrivate;
-
-#define RYGEL_TYPE_TRANSCODE_MANAGER (rygel_transcode_manager_get_type ())
-#define RYGEL_TRANSCODE_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_TRANSCODE_MANAGER, RygelTranscodeManager))
-#define RYGEL_TRANSCODE_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_TRANSCODE_MANAGER, RygelTranscodeManagerClass))
-#define RYGEL_IS_TRANSCODE_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_TRANSCODE_MANAGER))
-#define RYGEL_IS_TRANSCODE_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_TRANSCODE_MANAGER))
-#define RYGEL_TRANSCODE_MANAGER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_TRANSCODE_MANAGER, RygelTranscodeManagerClass))
-
-typedef struct _RygelTranscodeManager RygelTranscodeManager;
-typedef struct _RygelTranscodeManagerClass RygelTranscodeManagerClass;
-
-#define RYGEL_TYPE_HTTP_SERVER (rygel_http_server_get_type ())
-#define RYGEL_HTTP_SERVER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_HTTP_SERVER, RygelHTTPServer))
-#define RYGEL_HTTP_SERVER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_HTTP_SERVER, RygelHTTPServerClass))
-#define RYGEL_IS_HTTP_SERVER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_HTTP_SERVER))
-#define RYGEL_IS_HTTP_SERVER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_HTTP_SERVER))
-#define RYGEL_HTTP_SERVER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_HTTP_SERVER, RygelHTTPServerClass))
-
-typedef struct _RygelHTTPServer RygelHTTPServer;
-typedef struct _RygelHTTPServerClass RygelHTTPServerClass;
-#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
-
-#define RYGEL_TYPE_MEDIA_OBJECT (rygel_media_object_get_type ())
-#define RYGEL_MEDIA_OBJECT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_MEDIA_OBJECT, RygelMediaObject))
-#define RYGEL_MEDIA_OBJECT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_MEDIA_OBJECT, RygelMediaObjectClass))
-#define RYGEL_IS_MEDIA_OBJECT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_MEDIA_OBJECT))
-#define RYGEL_IS_MEDIA_OBJECT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_MEDIA_OBJECT))
-#define RYGEL_MEDIA_OBJECT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_MEDIA_OBJECT, RygelMediaObjectClass))
-
-typedef struct _RygelMediaObject RygelMediaObject;
-typedef struct _RygelMediaObjectClass RygelMediaObjectClass;
-
-#define RYGEL_TYPE_MEDIA_ITEM (rygel_media_item_get_type ())
-#define RYGEL_MEDIA_ITEM(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_MEDIA_ITEM, RygelMediaItem))
-#define RYGEL_MEDIA_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_MEDIA_ITEM, RygelMediaItemClass))
-#define RYGEL_IS_MEDIA_ITEM(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_MEDIA_ITEM))
-#define RYGEL_IS_MEDIA_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_MEDIA_ITEM))
-#define RYGEL_MEDIA_ITEM_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_MEDIA_ITEM, RygelMediaItemClass))
-
-typedef struct _RygelMediaItem RygelMediaItem;
-typedef struct _RygelMediaItemClass RygelMediaItemClass;
-
-#define RYGEL_TYPE_MEDIA_CONTAINER (rygel_media_container_get_type ())
-#define RYGEL_MEDIA_CONTAINER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_MEDIA_CONTAINER, RygelMediaContainer))
-#define RYGEL_MEDIA_CONTAINER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_MEDIA_CONTAINER, RygelMediaContainerClass))
-#define RYGEL_IS_MEDIA_CONTAINER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_MEDIA_CONTAINER))
-#define RYGEL_IS_MEDIA_CONTAINER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_MEDIA_CONTAINER))
-#define RYGEL_MEDIA_CONTAINER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_MEDIA_CONTAINER, RygelMediaContainerClass))
-
-typedef struct _RygelMediaContainer RygelMediaContainer;
-typedef struct _RygelMediaContainerClass RygelMediaContainerClass;
-typedef struct _RygelMediaObjectPrivate RygelMediaObjectPrivate;
-typedef struct _RygelMediaItemPrivate RygelMediaItemPrivate;
-
-#define RYGEL_TYPE_ICON_INFO (rygel_icon_info_get_type ())
-#define RYGEL_ICON_INFO(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_ICON_INFO, RygelIconInfo))
-#define RYGEL_ICON_INFO_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_ICON_INFO, RygelIconInfoClass))
-#define RYGEL_IS_ICON_INFO(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_ICON_INFO))
-#define RYGEL_IS_ICON_INFO_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_ICON_INFO))
-#define RYGEL_ICON_INFO_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_ICON_INFO, RygelIconInfoClass))
-
-typedef struct _RygelIconInfo RygelIconInfo;
-typedef struct _RygelIconInfoClass RygelIconInfoClass;
-
-#define RYGEL_TYPE_THUMBNAIL (rygel_thumbnail_get_type ())
-#define RYGEL_THUMBNAIL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_THUMBNAIL, RygelThumbnail))
-#define RYGEL_THUMBNAIL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_THUMBNAIL, RygelThumbnailClass))
-#define RYGEL_IS_THUMBNAIL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_THUMBNAIL))
-#define RYGEL_IS_THUMBNAIL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_THUMBNAIL))
-#define RYGEL_THUMBNAIL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_THUMBNAIL, RygelThumbnailClass))
-
-typedef struct _RygelThumbnail RygelThumbnail;
-typedef struct _RygelThumbnailClass RygelThumbnailClass;
-typedef struct _RygelTranscodeManagerPrivate RygelTranscodeManagerPrivate;
-
-#define RYGEL_TYPE_STATE_MACHINE (rygel_state_machine_get_type ())
-#define RYGEL_STATE_MACHINE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_STATE_MACHINE, RygelStateMachine))
-#define RYGEL_IS_STATE_MACHINE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_STATE_MACHINE))
-#define RYGEL_STATE_MACHINE_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), RYGEL_TYPE_STATE_MACHINE, RygelStateMachineIface))
-
-typedef struct _RygelStateMachine RygelStateMachine;
-typedef struct _RygelStateMachineIface RygelStateMachineIface;
-typedef struct _RygelHTTPServerPrivate RygelHTTPServerPrivate;
-typedef struct _RygelMediaContainerPrivate RygelMediaContainerPrivate;
-
-typedef enum  {
-	RYGEL_DIDL_LITE_WRITER_ERROR_UNSUPPORTED_OBJECT
-} RygelDIDLLiteWriterError;
-#define RYGEL_DIDL_LITE_WRITER_ERROR rygel_didl_lite_writer_error_quark ()
-struct _RygelDIDLLiteWriter {
-	GUPnPDIDLLiteWriter parent_instance;
-	RygelDIDLLiteWriterPrivate * priv;
-};
-
-struct _RygelDIDLLiteWriterClass {
-	GUPnPDIDLLiteWriterClass parent_class;
-};
-
-struct _RygelDIDLLiteWriterPrivate {
-	RygelHTTPServer* http_server;
-};
-
-struct _RygelMediaObject {
-	GObject parent_instance;
-	RygelMediaObjectPrivate * priv;
-	char* id;
-	char* title;
-	guint64 modified;
-	GeeArrayList* uris;
-	RygelMediaContainer* parent;
-	RygelMediaContainer* parent_ref;
-};
-
-struct _RygelMediaObjectClass {
-	GObjectClass parent_class;
-};
-
-struct _RygelMediaItem {
-	RygelMediaObject parent_instance;
-	RygelMediaItemPrivate * priv;
-	char* author;
-	char* album;
-	char* date;
-	char* upnp_class;
-	char* mime_type;
-	char* dlna_profile;
-	glong size;
-	glong duration;
-	gint bitrate;
-	gint sample_freq;
-	gint bits_per_sample;
-	gint n_audio_channels;
-	gint track_number;
-	gint width;
-	gint height;
-	gint pixel_width;
-	gint pixel_height;
-	gint color_depth;
-	GeeArrayList* thumbnails;
-};
-
-struct _RygelMediaItemClass {
-	RygelMediaObjectClass parent_class;
-	GstElement* (*create_stream_source) (RygelMediaItem* self);
-	gboolean (*should_stream) (RygelMediaItem* self);
-};
-
-struct _RygelTranscodeManager {
-	GObject parent_instance;
-	RygelTranscodeManagerPrivate * priv;
-};
-
-struct _RygelTranscodeManagerClass {
-	GObjectClass parent_class;
-	char* (*create_uri_for_item) (RygelTranscodeManager* self, RygelMediaItem* item, gint thumbnail_index, const char* transcode_target, char** protocol);
-	void (*add_resources) (RygelTranscodeManager* self, GUPnPDIDLLiteItem* didl_item, RygelMediaItem* item, GError** error);
-	char* (*get_protocol) (RygelTranscodeManager* self);
-	char* (*get_protocol_info) (RygelTranscodeManager* self);
-};
-
-struct _RygelStateMachineIface {
-	GTypeInterface parent_iface;
-	void (*run) (RygelStateMachine* self);
-	GCancellable* (*get_cancellable) (RygelStateMachine* self);
-	void (*set_cancellable) (RygelStateMachine* self, GCancellable* value);
-};
-
-struct _RygelHTTPServer {
-	RygelTranscodeManager parent_instance;
-	RygelHTTPServerPrivate * priv;
-	RygelMediaContainer* root_container;
-	GUPnPContext* context;
-};
-
-struct _RygelHTTPServerClass {
-	RygelTranscodeManagerClass parent_class;
-};
-
-struct _RygelMediaContainer {
-	RygelMediaObject parent_instance;
-	RygelMediaContainerPrivate * priv;
-	guint child_count;
-	guint32 update_id;
-};
-
-struct _RygelMediaContainerClass {
-	RygelMediaObjectClass parent_class;
-	void (*get_children) (RygelMediaContainer* self, guint offset, guint max_count, GCancellable* cancellable, GAsyncReadyCallback callback, void* callback_target);
-	GeeList* (*get_children_finish) (RygelMediaContainer* self, GAsyncResult* res, GError** error);
-	void (*find_object) (RygelMediaContainer* self, const char* id, GCancellable* cancellable, GAsyncReadyCallback callback, void* callback_target);
-	RygelMediaObject* (*find_object_finish) (RygelMediaContainer* self, GAsyncResult* res, GError** error);
-};
-
-
-static gpointer rygel_didl_lite_writer_parent_class = NULL;
-
-GQuark rygel_didl_lite_writer_error_quark (void);
-GType rygel_didl_lite_writer_get_type (void);
-GType rygel_transcode_manager_get_type (void);
-GType rygel_http_server_get_type (void);
-#define RYGEL_DIDL_LITE_WRITER_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), RYGEL_TYPE_DIDL_LITE_WRITER, RygelDIDLLiteWriterPrivate))
-enum  {
-	RYGEL_DIDL_LITE_WRITER_DUMMY_PROPERTY
-};
-RygelDIDLLiteWriter* rygel_didl_lite_writer_new (RygelHTTPServer* http_server);
-RygelDIDLLiteWriter* rygel_didl_lite_writer_construct (GType object_type, RygelHTTPServer* http_server);
-GType rygel_media_object_get_type (void);
-GType rygel_media_item_get_type (void);
-static void rygel_didl_lite_writer_serialize_item (RygelDIDLLiteWriter* self, RygelMediaItem* item, GError** error);
-GType rygel_media_container_get_type (void);
-static void rygel_didl_lite_writer_serialize_container (RygelDIDLLiteWriter* self, RygelMediaContainer* container, GError** error);
-void rygel_didl_lite_writer_serialize (RygelDIDLLiteWriter* self, RygelMediaObject* media_object, GError** error);
-gpointer rygel_icon_info_ref (gpointer instance);
-void rygel_icon_info_unref (gpointer instance);
-GParamSpec* rygel_param_spec_icon_info (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
-void rygel_value_set_icon_info (GValue* value, gpointer v_object);
-gpointer rygel_value_get_icon_info (const GValue* value);
-GType rygel_icon_info_get_type (void);
-GType rygel_thumbnail_get_type (void);
-#define RYGEL_MEDIA_ITEM_VIDEO_CLASS "object.item.videoItem"
-#define RYGEL_MEDIA_ITEM_MUSIC_CLASS "object.item.audioItem.musicTrack"
-void rygel_transcode_manager_add_resources (RygelTranscodeManager* self, GUPnPDIDLLiteItem* didl_item, RygelMediaItem* item, GError** error);
-GType rygel_state_machine_get_type (void);
-void rygel_media_item_add_resources (RygelMediaItem* self, GUPnPDIDLLiteItem* didl_item, gboolean allow_internal, GError** error);
-static void rygel_didl_lite_writer_finalize (GObject* obj);
-static int _vala_strcmp0 (const char * str1, const char * str2);
-
-
-
-GQuark rygel_didl_lite_writer_error_quark (void) {
-	return g_quark_from_static_string ("rygel_didl_lite_writer_error-quark");
-}
-
-
-static gpointer _g_object_ref0 (gpointer self) {
-	return self ? g_object_ref (self) : NULL;
-}
-
-
-RygelDIDLLiteWriter* rygel_didl_lite_writer_construct (GType object_type, RygelHTTPServer* http_server) {
-	RygelDIDLLiteWriter * self;
-	RygelHTTPServer* _tmp0_;
-	g_return_val_if_fail (http_server != NULL, NULL);
-	self = g_object_newv (object_type, 0, NULL);
-	self->priv->http_server = (_tmp0_ = _g_object_ref0 (http_server), _g_object_unref0 (self->priv->http_server), _tmp0_);
-	return self;
-}
-
-
-RygelDIDLLiteWriter* rygel_didl_lite_writer_new (RygelHTTPServer* http_server) {
-	return rygel_didl_lite_writer_construct (RYGEL_TYPE_DIDL_LITE_WRITER, http_server);
-}
-
-
-void rygel_didl_lite_writer_serialize (RygelDIDLLiteWriter* self, RygelMediaObject* media_object, GError** error) {
-	GError * _inner_error_;
-	g_return_if_fail (self != NULL);
-	g_return_if_fail (media_object != NULL);
-	_inner_error_ = NULL;
-	if (RYGEL_IS_MEDIA_ITEM (media_object)) {
-		rygel_didl_lite_writer_serialize_item (self, RYGEL_MEDIA_ITEM (media_object), &_inner_error_);
-		if (_inner_error_ != NULL) {
-			g_propagate_error (error, _inner_error_);
-			return;
-		}
-	} else {
-		if (RYGEL_IS_MEDIA_CONTAINER (media_object)) {
-			rygel_didl_lite_writer_serialize_container (self, RYGEL_MEDIA_CONTAINER (media_object), &_inner_error_);
-			if (_inner_error_ != NULL) {
-				g_propagate_error (error, _inner_error_);
-				return;
-			}
-		} else {
-			_inner_error_ = g_error_new_literal (RYGEL_DIDL_LITE_WRITER_ERROR, RYGEL_DIDL_LITE_WRITER_ERROR_UNSUPPORTED_OBJECT, "Unable to serialize unsupported object");
-			if (_inner_error_ != NULL) {
-				g_propagate_error (error, _inner_error_);
-				return;
-			}
-		}
-	}
-}
-
-
-static void rygel_didl_lite_writer_serialize_item (RygelDIDLLiteWriter* self, RygelMediaItem* item, GError** error) {
-	GError * _inner_error_;
-	GUPnPDIDLLiteItem* didl_item;
-	gboolean _tmp0_ = FALSE;
-	gboolean _tmp1_ = FALSE;
-	gboolean _tmp2_ = FALSE;
-	gboolean _tmp3_ = FALSE;
-	gboolean internal_allowed;
-	g_return_if_fail (self != NULL);
-	g_return_if_fail (item != NULL);
-	_inner_error_ = NULL;
-	didl_item = gupnp_didl_lite_writer_add_item ((GUPnPDIDLLiteWriter*) self);
-	gupnp_didl_lite_object_set_id ((GUPnPDIDLLiteObject*) didl_item, ((RygelMediaObject*) item)->id);
-	if (((RygelMediaObject*) item)->parent != NULL) {
-		gupnp_didl_lite_object_set_parent_id ((GUPnPDIDLLiteObject*) didl_item, ((RygelMediaObject*) ((RygelMediaObject*) item)->parent)->id);
-	} else {
-		gupnp_didl_lite_object_set_parent_id ((GUPnPDIDLLiteObject*) didl_item, "0");
-	}
-	gupnp_didl_lite_object_set_restricted ((GUPnPDIDLLiteObject*) didl_item, FALSE);
-	gupnp_didl_lite_object_set_title ((GUPnPDIDLLiteObject*) didl_item, ((RygelMediaObject*) item)->title);
-	gupnp_didl_lite_object_set_upnp_class ((GUPnPDIDLLiteObject*) didl_item, item->upnp_class);
-	if (item->author != NULL) {
-		_tmp0_ = _vala_strcmp0 (item->author, "") != 0;
-	} else {
-		_tmp0_ = FALSE;
-	}
-	if (_tmp0_) {
-		gupnp_didl_lite_object_set_creator ((GUPnPDIDLLiteObject*) didl_item, item->author);
-		if (g_str_has_prefix (item->upnp_class, RYGEL_MEDIA_ITEM_VIDEO_CLASS)) {
-			gupnp_didl_lite_object_set_author ((GUPnPDIDLLiteObject*) didl_item, item->author);
-		} else {
-			if (g_str_has_prefix (item->upnp_class, RYGEL_MEDIA_ITEM_MUSIC_CLASS)) {
-				gupnp_didl_lite_object_set_artist ((GUPnPDIDLLiteObject*) didl_item, item->author);
-			}
-		}
-	}
-	if (item->track_number >= 0) {
-		gupnp_didl_lite_object_set_track_number ((GUPnPDIDLLiteObject*) didl_item, item->track_number);
-	}
-	if (item->album != NULL) {
-		_tmp1_ = _vala_strcmp0 (item->album, "") != 0;
-	} else {
-		_tmp1_ = FALSE;
-	}
-	if (_tmp1_) {
-		gupnp_didl_lite_object_set_album ((GUPnPDIDLLiteObject*) didl_item, item->album);
-	}
-	if (item->date != NULL) {
-		_tmp2_ = _vala_strcmp0 (item->date, "") != 0;
-	} else {
-		_tmp2_ = FALSE;
-	}
-	if (_tmp2_) {
-		gupnp_didl_lite_object_set_date ((GUPnPDIDLLiteObject*) didl_item, item->date);
-	}
-	rygel_transcode_manager_add_resources ((RygelTranscodeManager*) self->priv->http_server, didl_item, item, &_inner_error_);
-	if (_inner_error_ != NULL) {
-		g_propagate_error (error, _inner_error_);
-		_g_object_unref0 (didl_item);
-		return;
-	}
-	if (_vala_strcmp0 (gssdp_client_get_interface ((GSSDPClient*) self->priv->http_server->context), "lo") == 0) {
-		_tmp3_ = TRUE;
-	} else {
-		_tmp3_ = _vala_strcmp0 (gssdp_client_get_host_ip ((GSSDPClient*) self->priv->http_server->context), "127.0.0.1") == 0;
-	}
-	internal_allowed = _tmp3_;
-	rygel_media_item_add_resources (item, didl_item, internal_allowed, &_inner_error_);
-	if (_inner_error_ != NULL) {
-		g_propagate_error (error, _inner_error_);
-		_g_object_unref0 (didl_item);
-		return;
-	}
-	_g_object_unref0 (didl_item);
-}
-
-
-static void rygel_didl_lite_writer_serialize_container (RygelDIDLLiteWriter* self, RygelMediaContainer* container, GError** error) {
-	GUPnPDIDLLiteContainer* didl_container;
-	g_return_if_fail (self != NULL);
-	g_return_if_fail (container != NULL);
-	didl_container = gupnp_didl_lite_writer_add_container ((GUPnPDIDLLiteWriter*) self);
-	if (((RygelMediaObject*) container)->parent != NULL) {
-		gupnp_didl_lite_object_set_parent_id ((GUPnPDIDLLiteObject*) didl_container, ((RygelMediaObject*) ((RygelMediaObject*) container)->parent)->id);
-	} else {
-		gupnp_didl_lite_object_set_parent_id ((GUPnPDIDLLiteObject*) didl_container, "-1");
-	}
-	gupnp_didl_lite_object_set_id ((GUPnPDIDLLiteObject*) didl_container, ((RygelMediaObject*) container)->id);
-	gupnp_didl_lite_object_set_title ((GUPnPDIDLLiteObject*) didl_container, ((RygelMediaObject*) container)->title);
-	gupnp_didl_lite_container_set_child_count (didl_container, container->child_count);
-	gupnp_didl_lite_object_set_restricted ((GUPnPDIDLLiteObject*) didl_container, FALSE);
-	gupnp_didl_lite_container_set_searchable (didl_container, FALSE);
-	gupnp_didl_lite_object_set_upnp_class ((GUPnPDIDLLiteObject*) didl_container, "object.container.storageFolder");
-	_g_object_unref0 (didl_container);
-}
-
-
-static void rygel_didl_lite_writer_class_init (RygelDIDLLiteWriterClass * klass) {
-	rygel_didl_lite_writer_parent_class = g_type_class_peek_parent (klass);
-	g_type_class_add_private (klass, sizeof (RygelDIDLLiteWriterPrivate));
-	G_OBJECT_CLASS (klass)->finalize = rygel_didl_lite_writer_finalize;
-}
-
-
-static void rygel_didl_lite_writer_instance_init (RygelDIDLLiteWriter * self) {
-	self->priv = RYGEL_DIDL_LITE_WRITER_GET_PRIVATE (self);
-}
-
-
-static void rygel_didl_lite_writer_finalize (GObject* obj) {
-	RygelDIDLLiteWriter * self;
-	self = RYGEL_DIDL_LITE_WRITER (obj);
-	_g_object_unref0 (self->priv->http_server);
-	G_OBJECT_CLASS (rygel_didl_lite_writer_parent_class)->finalize (obj);
-}
-
-
-GType rygel_didl_lite_writer_get_type (void) {
-	static GType rygel_didl_lite_writer_type_id = 0;
-	if (rygel_didl_lite_writer_type_id == 0) {
-		static const GTypeInfo g_define_type_info = { sizeof (RygelDIDLLiteWriterClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) rygel_didl_lite_writer_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (RygelDIDLLiteWriter), 0, (GInstanceInitFunc) rygel_didl_lite_writer_instance_init, NULL };
-		rygel_didl_lite_writer_type_id = g_type_register_static (GUPNP_TYPE_DIDL_LITE_WRITER, "RygelDIDLLiteWriter", &g_define_type_info, 0);
-	}
-	return rygel_didl_lite_writer_type_id;
-}
-
-
-static int _vala_strcmp0 (const char * str1, const char * str2) {
-	if (str1 == NULL) {
-		return -(str1 != str2);
-	}
-	if (str2 == NULL) {
-		return str1 != str2;
-	}
-	return strcmp (str1, str2);
-}
-
-
-
-
--- a/src/rygel/rygel-gst-utils.c
+++ /dev/null
@@ -1,271 +0,0 @@
-/* rygel-gst-utils.c generated by valac, the Vala compiler
- * generated from rygel-gst-utils.vala, do not modify */
-
-/*
- * Copyright (C) 2009 Nokia Corporation.
- *
- * Author: Zeeshan Ali (Khattak) <zeeshanak@gnome.org>
- *                               <zeeshan.ali@nokia.com>
- *
- * This file is part of Rygel.
- *
- * Rygel is free software; you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * Rygel is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this program; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
- */
-
-#include <glib.h>
-#include <glib-object.h>
-#include <gst/gst.h>
-#include <stdlib.h>
-#include <string.h>
-#include <gobject/gvaluecollector.h>
-
-
-#define RYGEL_TYPE_GST_UTILS (rygel_gst_utils_get_type ())
-#define RYGEL_GST_UTILS(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_GST_UTILS, RygelGstUtils))
-#define RYGEL_GST_UTILS_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_GST_UTILS, RygelGstUtilsClass))
-#define RYGEL_IS_GST_UTILS(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_GST_UTILS))
-#define RYGEL_IS_GST_UTILS_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_GST_UTILS))
-#define RYGEL_GST_UTILS_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_GST_UTILS, RygelGstUtilsClass))
-
-typedef struct _RygelGstUtils RygelGstUtils;
-typedef struct _RygelGstUtilsClass RygelGstUtilsClass;
-typedef struct _RygelGstUtilsPrivate RygelGstUtilsPrivate;
-#define _gst_object_unref0(var) ((var == NULL) ? NULL : (var = (gst_object_unref (var), NULL)))
-#define _gst_message_unref0(var) ((var == NULL) ? NULL : (var = (gst_message_unref (var), NULL)))
-typedef struct _RygelParamSpecGstUtils RygelParamSpecGstUtils;
-
-struct _RygelGstUtils {
-	GTypeInstance parent_instance;
-	volatile int ref_count;
-	RygelGstUtilsPrivate * priv;
-};
-
-struct _RygelGstUtilsClass {
-	GTypeClass parent_class;
-	void (*finalize) (RygelGstUtils *self);
-};
-
-typedef enum  {
-	RYGEL_LIVE_RESPONSE_ERROR_MISSING_PLUGIN,
-	RYGEL_LIVE_RESPONSE_ERROR_LINK
-} RygelLiveResponseError;
-#define RYGEL_LIVE_RESPONSE_ERROR rygel_live_response_error_quark ()
-struct _RygelParamSpecGstUtils {
-	GParamSpec parent_instance;
-};
-
-
-static gpointer rygel_gst_utils_parent_class = NULL;
-
-gpointer rygel_gst_utils_ref (gpointer instance);
-void rygel_gst_utils_unref (gpointer instance);
-GParamSpec* rygel_param_spec_gst_utils (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
-void rygel_value_set_gst_utils (GValue* value, gpointer v_object);
-gpointer rygel_value_get_gst_utils (const GValue* value);
-GType rygel_gst_utils_get_type (void);
-enum  {
-	RYGEL_GST_UTILS_DUMMY_PROPERTY
-};
-GQuark rygel_live_response_error_quark (void);
-GstElement* rygel_gst_utils_create_element (const char* factoryname, const char* name, GError** error);
-void rygel_gst_utils_post_error (GstElement* dest, GError* _error_);
-RygelGstUtils* rygel_gst_utils_construct (GType object_type);
-static void rygel_gst_utils_finalize (RygelGstUtils* obj);
-
-
-
-GstElement* rygel_gst_utils_create_element (const char* factoryname, const char* name, GError** error) {
-	GstElement* result;
-	GError * _inner_error_;
-	GstElement* element;
-	g_return_val_if_fail (factoryname != NULL, NULL);
-	_inner_error_ = NULL;
-	element = gst_element_factory_make (factoryname, name);
-	if (element == NULL) {
-		_inner_error_ = g_error_new (RYGEL_LIVE_RESPONSE_ERROR, RYGEL_LIVE_RESPONSE_ERROR_MISSING_PLUGIN, "Required element factory '%s' missing", factoryname);
-		if (_inner_error_ != NULL) {
-			g_propagate_error (error, _inner_error_);
-			_gst_object_unref0 (element);
-			return NULL;
-		}
-	}
-	result = element;
-	return result;
-}
-
-
-static gpointer _gst_message_ref0 (gpointer self) {
-	return self ? gst_message_ref (self) : NULL;
-}
-
-
-void rygel_gst_utils_post_error (GstElement* dest, GError* _error_) {
-	GstMessage* msg;
-	g_return_if_fail (dest != NULL);
-	msg = gst_message_new_error ((GstObject*) dest, _error_, _error_->message);
-	gst_element_post_message (dest, _gst_message_ref0 (msg));
-	_gst_message_unref0 (msg);
-}
-
-
-RygelGstUtils* rygel_gst_utils_construct (GType object_type) {
-	RygelGstUtils* self;
-	self = (RygelGstUtils*) g_type_create_instance (object_type);
-	return self;
-}
-
-
-static void rygel_value_gst_utils_init (GValue* value) {
-	value->data[0].v_pointer = NULL;
-}
-
-
-static void rygel_value_gst_utils_free_value (GValue* value) {
-	if (value->data[0].v_pointer) {
-		rygel_gst_utils_unref (value->data[0].v_pointer);
-	}
-}
-
-
-static void rygel_value_gst_utils_copy_value (const GValue* src_value, GValue* dest_value) {
-	if (src_value->data[0].v_pointer) {
-		dest_value->data[0].v_pointer = rygel_gst_utils_ref (src_value->data[0].v_pointer);
-	} else {
-		dest_value->data[0].v_pointer = NULL;
-	}
-}
-
-
-static gpointer rygel_value_gst_utils_peek_pointer (const GValue* value) {
-	return value->data[0].v_pointer;
-}
-
-
-static gchar* rygel_value_gst_utils_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
-	if (collect_values[0].v_pointer) {
-		RygelGstUtils* object;
-		object = collect_values[0].v_pointer;
-		if (object->parent_instance.g_class == NULL) {
-			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
-		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
-			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
-		}
-		value->data[0].v_pointer = rygel_gst_utils_ref (object);
-	} else {
-		value->data[0].v_pointer = NULL;
-	}
-	return NULL;
-}
-
-
-static gchar* rygel_value_gst_utils_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
-	RygelGstUtils** object_p;
-	object_p = collect_values[0].v_pointer;
-	if (!object_p) {
-		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
-	}
-	if (!value->data[0].v_pointer) {
-		*object_p = NULL;
-	} else if (collect_flags && G_VALUE_NOCOPY_CONTENTS) {
-		*object_p = value->data[0].v_pointer;
-	} else {
-		*object_p = rygel_gst_utils_ref (value->data[0].v_pointer);
-	}
-	return NULL;
-}
-
-
-GParamSpec* rygel_param_spec_gst_utils (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
-	RygelParamSpecGstUtils* spec;
-	g_return_val_if_fail (g_type_is_a (object_type, RYGEL_TYPE_GST_UTILS), NULL);
-	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
-	G_PARAM_SPEC (spec)->value_type = object_type;
-	return G_PARAM_SPEC (spec);
-}
-
-
-gpointer rygel_value_get_gst_utils (const GValue* value) {
-	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, RYGEL_TYPE_GST_UTILS), NULL);
-	return value->data[0].v_pointer;
-}
-
-
-void rygel_value_set_gst_utils (GValue* value, gpointer v_object) {
-	RygelGstUtils* old;
-	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, RYGEL_TYPE_GST_UTILS));
-	old = value->data[0].v_pointer;
-	if (v_object) {
-		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, RYGEL_TYPE_GST_UTILS));
-		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
-		value->data[0].v_pointer = v_object;
-		rygel_gst_utils_ref (value->data[0].v_pointer);
-	} else {
-		value->data[0].v_pointer = NULL;
-	}
-	if (old) {
-		rygel_gst_utils_unref (old);
-	}
-}
-
-
-static void rygel_gst_utils_class_init (RygelGstUtilsClass * klass) {
-	rygel_gst_utils_parent_class = g_type_class_peek_parent (klass);
-	RYGEL_GST_UTILS_CLASS (klass)->finalize = rygel_gst_utils_finalize;
-}
-
-
-static void rygel_gst_utils_instance_init (RygelGstUtils * self) {
-	self->ref_count = 1;
-}
-
-
-static void rygel_gst_utils_finalize (RygelGstUtils* obj) {
-	RygelGstUtils * self;
-	self = RYGEL_GST_UTILS (obj);
-}
-
-
-GType rygel_gst_utils_get_type (void) {
-	static GType rygel_gst_utils_type_id = 0;
-	if (rygel_gst_utils_type_id == 0) {
-		static const GTypeValueTable g_define_type_value_table = { rygel_value_gst_utils_init, rygel_value_gst_utils_free_value, rygel_value_gst_utils_copy_value, rygel_value_gst_utils_peek_pointer, "p", rygel_value_gst_utils_collect_value, "p", rygel_value_gst_utils_lcopy_value };
-		static const GTypeInfo g_define_type_info = { sizeof (RygelGstUtilsClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) rygel_gst_utils_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (RygelGstUtils), 0, (GInstanceInitFunc) rygel_gst_utils_instance_init, &g_define_type_value_table };
-		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
-		rygel_gst_utils_type_id = g_type_register_fundamental (g_type_fundamental_next (), "RygelGstUtils", &g_define_type_info, &g_define_type_fundamental_info, G_TYPE_FLAG_ABSTRACT);
-	}
-	return rygel_gst_utils_type_id;
-}
-
-
-gpointer rygel_gst_utils_ref (gpointer instance) {
-	RygelGstUtils* self;
-	self = instance;
-	g_atomic_int_inc (&self->ref_count);
-	return instance;
-}
-
-
-void rygel_gst_utils_unref (gpointer instance) {
-	RygelGstUtils* self;
-	self = instance;
-	if (g_atomic_int_dec_and_test (&self->ref_count)) {
-		RYGEL_GST_UTILS_GET_CLASS (self)->finalize (self);
-		g_type_free_instance ((GTypeInstance *) self);
-	}
-}
-
-
-
-
--- a/src/rygel/rygel-gst-utils.vala
+++ /dev/null
@@ -1,44 +0,0 @@
-/*
- * Copyright (C) 2009 Nokia Corporation.
- *
- * Author: Zeeshan Ali (Khattak) <zeeshanak@gnome.org>
- *                               <zeeshan.ali@nokia.com>
- *
- * This file is part of Rygel.
- *
- * Rygel is free software; you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * Rygel is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this program; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
- */
-
-using Gst;
-
-internal abstract class Rygel.GstUtils {
-    public static Element create_element (string factoryname,
-                                             string? name)
-                                             throws Error {
-        Element element = ElementFactory.make (factoryname, name);
-        if (element == null) {
-            throw new LiveResponseError.MISSING_PLUGIN (
-                                "Required element factory '%s' missing",
-                                factoryname);
-        }
-
-        return element;
-    }
-
-    public static void post_error (Element dest, Error error) {
-        Message msg = new Message.error (dest, error, error.message);
-        dest.post_message (msg);
-    }
-}
--- a/src/rygel/rygel-http-identity-handler.c
+++ /dev/null
@@ -1,580 +0,0 @@
-/* rygel-http-identity-handler.c generated by valac, the Vala compiler
- * generated from rygel-http-identity-handler.vala, do not modify */
-
-/*
- * Copyright (C) 2008, 2009 Nokia Corporation.
- *
- * Author: Zeeshan Ali (Khattak) <zeeshanak@gnome.org>
- *                               <zeeshan.ali@nokia.com>
- *
- * This file is part of Rygel.
- *
- * Rygel is free software; you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * Rygel is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this program; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
- */
-
-#include <glib.h>
-#include <glib-object.h>
-#include <libsoup/soup.h>
-#include <libgupnp-av/gupnp-av.h>
-#include <gio/gio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <gee.h>
-#include <gst/gst.h>
-
-
-#define RYGEL_TYPE_HTTP_REQUEST_HANDLER (rygel_http_request_handler_get_type ())
-#define RYGEL_HTTP_REQUEST_HANDLER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_HTTP_REQUEST_HANDLER, RygelHTTPRequestHandler))
-#define RYGEL_HTTP_REQUEST_HANDLER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_HTTP_REQUEST_HANDLER, RygelHTTPRequestHandlerClass))
-#define RYGEL_IS_HTTP_REQUEST_HANDLER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_HTTP_REQUEST_HANDLER))
-#define RYGEL_IS_HTTP_REQUEST_HANDLER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_HTTP_REQUEST_HANDLER))
-#define RYGEL_HTTP_REQUEST_HANDLER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_HTTP_REQUEST_HANDLER, RygelHTTPRequestHandlerClass))
-
-typedef struct _RygelHTTPRequestHandler RygelHTTPRequestHandler;
-typedef struct _RygelHTTPRequestHandlerClass RygelHTTPRequestHandlerClass;
-typedef struct _RygelHTTPRequestHandlerPrivate RygelHTTPRequestHandlerPrivate;
-
-#define RYGEL_TYPE_HTTP_REQUEST (rygel_http_request_get_type ())
-#define RYGEL_HTTP_REQUEST(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_HTTP_REQUEST, RygelHTTPRequest))
-#define RYGEL_HTTP_REQUEST_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_HTTP_REQUEST, RygelHTTPRequestClass))
-#define RYGEL_IS_HTTP_REQUEST(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_HTTP_REQUEST))
-#define RYGEL_IS_HTTP_REQUEST_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_HTTP_REQUEST))
-#define RYGEL_HTTP_REQUEST_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_HTTP_REQUEST, RygelHTTPRequestClass))
-
-typedef struct _RygelHTTPRequest RygelHTTPRequest;
-typedef struct _RygelHTTPRequestClass RygelHTTPRequestClass;
-
-#define RYGEL_TYPE_HTTP_RESPONSE (rygel_http_response_get_type ())
-#define RYGEL_HTTP_RESPONSE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_HTTP_RESPONSE, RygelHTTPResponse))
-#define RYGEL_HTTP_RESPONSE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_HTTP_RESPONSE, RygelHTTPResponseClass))
-#define RYGEL_IS_HTTP_RESPONSE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_HTTP_RESPONSE))
-#define RYGEL_IS_HTTP_RESPONSE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_HTTP_RESPONSE))
-#define RYGEL_HTTP_RESPONSE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_HTTP_RESPONSE, RygelHTTPResponseClass))
-
-typedef struct _RygelHTTPResponse RygelHTTPResponse;
-typedef struct _RygelHTTPResponseClass RygelHTTPResponseClass;
-
-#define RYGEL_TYPE_HTTP_IDENTITY_HANDLER (rygel_http_identity_handler_get_type ())
-#define RYGEL_HTTP_IDENTITY_HANDLER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_HTTP_IDENTITY_HANDLER, RygelHTTPIdentityHandler))
-#define RYGEL_HTTP_IDENTITY_HANDLER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_HTTP_IDENTITY_HANDLER, RygelHTTPIdentityHandlerClass))
-#define RYGEL_IS_HTTP_IDENTITY_HANDLER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_HTTP_IDENTITY_HANDLER))
-#define RYGEL_IS_HTTP_IDENTITY_HANDLER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_HTTP_IDENTITY_HANDLER))
-#define RYGEL_HTTP_IDENTITY_HANDLER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_HTTP_IDENTITY_HANDLER, RygelHTTPIdentityHandlerClass))
-
-typedef struct _RygelHTTPIdentityHandler RygelHTTPIdentityHandler;
-typedef struct _RygelHTTPIdentityHandlerClass RygelHTTPIdentityHandlerClass;
-typedef struct _RygelHTTPIdentityHandlerPrivate RygelHTTPIdentityHandlerPrivate;
-
-#define RYGEL_TYPE_STATE_MACHINE (rygel_state_machine_get_type ())
-#define RYGEL_STATE_MACHINE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_STATE_MACHINE, RygelStateMachine))
-#define RYGEL_IS_STATE_MACHINE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_STATE_MACHINE))
-#define RYGEL_STATE_MACHINE_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), RYGEL_TYPE_STATE_MACHINE, RygelStateMachineIface))
-
-typedef struct _RygelStateMachine RygelStateMachine;
-typedef struct _RygelStateMachineIface RygelStateMachineIface;
-typedef struct _RygelHTTPRequestPrivate RygelHTTPRequestPrivate;
-
-#define RYGEL_TYPE_TRANSCODE_MANAGER (rygel_transcode_manager_get_type ())
-#define RYGEL_TRANSCODE_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_TRANSCODE_MANAGER, RygelTranscodeManager))
-#define RYGEL_TRANSCODE_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_TRANSCODE_MANAGER, RygelTranscodeManagerClass))
-#define RYGEL_IS_TRANSCODE_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_TRANSCODE_MANAGER))
-#define RYGEL_IS_TRANSCODE_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_TRANSCODE_MANAGER))
-#define RYGEL_TRANSCODE_MANAGER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_TRANSCODE_MANAGER, RygelTranscodeManagerClass))
-
-typedef struct _RygelTranscodeManager RygelTranscodeManager;
-typedef struct _RygelTranscodeManagerClass RygelTranscodeManagerClass;
-
-#define RYGEL_TYPE_HTTP_SERVER (rygel_http_server_get_type ())
-#define RYGEL_HTTP_SERVER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_HTTP_SERVER, RygelHTTPServer))
-#define RYGEL_HTTP_SERVER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_HTTP_SERVER, RygelHTTPServerClass))
-#define RYGEL_IS_HTTP_SERVER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_HTTP_SERVER))
-#define RYGEL_IS_HTTP_SERVER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_HTTP_SERVER))
-#define RYGEL_HTTP_SERVER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_HTTP_SERVER, RygelHTTPServerClass))
-
-typedef struct _RygelHTTPServer RygelHTTPServer;
-typedef struct _RygelHTTPServerClass RygelHTTPServerClass;
-
-#define RYGEL_TYPE_MEDIA_OBJECT (rygel_media_object_get_type ())
-#define RYGEL_MEDIA_OBJECT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_MEDIA_OBJECT, RygelMediaObject))
-#define RYGEL_MEDIA_OBJECT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_MEDIA_OBJECT, RygelMediaObjectClass))
-#define RYGEL_IS_MEDIA_OBJECT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_MEDIA_OBJECT))
-#define RYGEL_IS_MEDIA_OBJECT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_MEDIA_OBJECT))
-#define RYGEL_MEDIA_OBJECT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_MEDIA_OBJECT, RygelMediaObjectClass))
-
-typedef struct _RygelMediaObject RygelMediaObject;
-typedef struct _RygelMediaObjectClass RygelMediaObjectClass;
-
-#define RYGEL_TYPE_MEDIA_ITEM (rygel_media_item_get_type ())
-#define RYGEL_MEDIA_ITEM(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_MEDIA_ITEM, RygelMediaItem))
-#define RYGEL_MEDIA_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_MEDIA_ITEM, RygelMediaItemClass))
-#define RYGEL_IS_MEDIA_ITEM(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_MEDIA_ITEM))
-#define RYGEL_IS_MEDIA_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_MEDIA_ITEM))
-#define RYGEL_MEDIA_ITEM_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_MEDIA_ITEM, RygelMediaItemClass))
-
-typedef struct _RygelMediaItem RygelMediaItem;
-typedef struct _RygelMediaItemClass RygelMediaItemClass;
-
-#define RYGEL_TYPE_ICON_INFO (rygel_icon_info_get_type ())
-#define RYGEL_ICON_INFO(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_ICON_INFO, RygelIconInfo))
-#define RYGEL_ICON_INFO_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_ICON_INFO, RygelIconInfoClass))
-#define RYGEL_IS_ICON_INFO(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_ICON_INFO))
-#define RYGEL_IS_ICON_INFO_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_ICON_INFO))
-#define RYGEL_ICON_INFO_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_ICON_INFO, RygelIconInfoClass))
-
-typedef struct _RygelIconInfo RygelIconInfo;
-typedef struct _RygelIconInfoClass RygelIconInfoClass;
-
-#define RYGEL_TYPE_THUMBNAIL (rygel_thumbnail_get_type ())
-#define RYGEL_THUMBNAIL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_THUMBNAIL, RygelThumbnail))
-#define RYGEL_THUMBNAIL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_THUMBNAIL, RygelThumbnailClass))
-#define RYGEL_IS_THUMBNAIL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_THUMBNAIL))
-#define RYGEL_IS_THUMBNAIL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_THUMBNAIL))
-#define RYGEL_THUMBNAIL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_THUMBNAIL, RygelThumbnailClass))
-
-typedef struct _RygelThumbnail RygelThumbnail;
-typedef struct _RygelThumbnailClass RygelThumbnailClass;
-
-#define RYGEL_TYPE_HTTP_SEEK (rygel_http_seek_get_type ())
-#define RYGEL_HTTP_SEEK(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_HTTP_SEEK, RygelHTTPSeek))
-#define RYGEL_HTTP_SEEK_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_HTTP_SEEK, RygelHTTPSeekClass))
-#define RYGEL_IS_HTTP_SEEK(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_HTTP_SEEK))
-#define RYGEL_IS_HTTP_SEEK_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_HTTP_SEEK))
-#define RYGEL_HTTP_SEEK_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_HTTP_SEEK, RygelHTTPSeekClass))
-
-typedef struct _RygelHTTPSeek RygelHTTPSeek;
-typedef struct _RygelHTTPSeekClass RygelHTTPSeekClass;
-typedef struct _RygelIconInfoPrivate RygelIconInfoPrivate;
-#define _g_free0(var) (var = (g_free (var), NULL))
-typedef struct _RygelMediaObjectPrivate RygelMediaObjectPrivate;
-
-#define RYGEL_TYPE_MEDIA_CONTAINER (rygel_media_container_get_type ())
-#define RYGEL_MEDIA_CONTAINER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_MEDIA_CONTAINER, RygelMediaContainer))
-#define RYGEL_MEDIA_CONTAINER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_MEDIA_CONTAINER, RygelMediaContainerClass))
-#define RYGEL_IS_MEDIA_CONTAINER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_MEDIA_CONTAINER))
-#define RYGEL_IS_MEDIA_CONTAINER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_MEDIA_CONTAINER))
-#define RYGEL_MEDIA_CONTAINER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_MEDIA_CONTAINER, RygelMediaContainerClass))
-
-typedef struct _RygelMediaContainer RygelMediaContainer;
-typedef struct _RygelMediaContainerClass RygelMediaContainerClass;
-typedef struct _RygelMediaItemPrivate RygelMediaItemPrivate;
-typedef struct _RygelThumbnailPrivate RygelThumbnailPrivate;
-
-#define RYGEL_TYPE_SEEKABLE_RESPONSE (rygel_seekable_response_get_type ())
-#define RYGEL_SEEKABLE_RESPONSE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_SEEKABLE_RESPONSE, RygelSeekableResponse))
-#define RYGEL_SEEKABLE_RESPONSE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_SEEKABLE_RESPONSE, RygelSeekableResponseClass))
-#define RYGEL_IS_SEEKABLE_RESPONSE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_SEEKABLE_RESPONSE))
-#define RYGEL_IS_SEEKABLE_RESPONSE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_SEEKABLE_RESPONSE))
-#define RYGEL_SEEKABLE_RESPONSE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_SEEKABLE_RESPONSE, RygelSeekableResponseClass))
-
-typedef struct _RygelSeekableResponse RygelSeekableResponse;
-typedef struct _RygelSeekableResponseClass RygelSeekableResponseClass;
-#define _gst_object_unref0(var) ((var == NULL) ? NULL : (var = (gst_object_unref (var), NULL)))
-#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
-
-#define RYGEL_TYPE_LIVE_RESPONSE (rygel_live_response_get_type ())
-#define RYGEL_LIVE_RESPONSE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_LIVE_RESPONSE, RygelLiveResponse))
-#define RYGEL_LIVE_RESPONSE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_LIVE_RESPONSE, RygelLiveResponseClass))
-#define RYGEL_IS_LIVE_RESPONSE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_LIVE_RESPONSE))
-#define RYGEL_IS_LIVE_RESPONSE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_LIVE_RESPONSE))
-#define RYGEL_LIVE_RESPONSE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_LIVE_RESPONSE, RygelLiveResponseClass))
-
-typedef struct _RygelLiveResponse RygelLiveResponse;
-typedef struct _RygelLiveResponseClass RygelLiveResponseClass;
-
-typedef enum  {
-	RYGEL_HTTP_REQUEST_ERROR_UNACCEPTABLE = SOUP_STATUS_NOT_ACCEPTABLE,
-	RYGEL_HTTP_REQUEST_ERROR_BAD_REQUEST = SOUP_STATUS_BAD_REQUEST,
-	RYGEL_HTTP_REQUEST_ERROR_NOT_FOUND = SOUP_STATUS_NOT_FOUND
-} RygelHTTPRequestError;
-#define RYGEL_HTTP_REQUEST_ERROR rygel_http_request_error_quark ()
-struct _RygelHTTPRequestHandler {
-	GObject parent_instance;
-	RygelHTTPRequestHandlerPrivate * priv;
-};
-
-struct _RygelHTTPRequestHandlerClass {
-	GObjectClass parent_class;
-	void (*add_response_headers) (RygelHTTPRequestHandler* self, RygelHTTPRequest* request, GError** error);
-	RygelHTTPResponse* (*render_body) (RygelHTTPRequestHandler* self, RygelHTTPRequest* request, GError** error);
-	GUPnPDIDLLiteResource* (*add_resource) (RygelHTTPRequestHandler* self, GUPnPDIDLLiteItem* didl_item, RygelHTTPRequest* request, GError** error);
-};
-
-struct _RygelHTTPIdentityHandler {
-	RygelHTTPRequestHandler parent_instance;
-	RygelHTTPIdentityHandlerPrivate * priv;
-};
-
-struct _RygelHTTPIdentityHandlerClass {
-	RygelHTTPRequestHandlerClass parent_class;
-};
-
-struct _RygelStateMachineIface {
-	GTypeInterface parent_iface;
-	void (*run) (RygelStateMachine* self);
-	GCancellable* (*get_cancellable) (RygelStateMachine* self);
-	void (*set_cancellable) (RygelStateMachine* self, GCancellable* value);
-};
-
-struct _RygelHTTPRequest {
-	GObject parent_instance;
-	RygelHTTPRequestPrivate * priv;
-	RygelHTTPServer* http_server;
-	SoupServer* server;
-	SoupMessage* msg;
-	RygelMediaItem* item;
-	RygelThumbnail* thumbnail;
-	RygelHTTPSeek* byte_range;
-	RygelHTTPSeek* time_range;
-};
-
-struct _RygelHTTPRequestClass {
-	GObjectClass parent_class;
-};
-
-struct _RygelIconInfo {
-	GTypeInstance parent_instance;
-	volatile int ref_count;
-	RygelIconInfoPrivate * priv;
-	char* mime_type;
-	char* path;
-	glong size;
-	gint width;
-	gint height;
-	gint depth;
-};
-
-struct _RygelIconInfoClass {
-	GTypeClass parent_class;
-	void (*finalize) (RygelIconInfo *self);
-};
-
-struct _RygelMediaObject {
-	GObject parent_instance;
-	RygelMediaObjectPrivate * priv;
-	char* id;
-	char* title;
-	guint64 modified;
-	GeeArrayList* uris;
-	RygelMediaContainer* parent;
-	RygelMediaContainer* parent_ref;
-};
-
-struct _RygelMediaObjectClass {
-	GObjectClass parent_class;
-};
-
-struct _RygelMediaItem {
-	RygelMediaObject parent_instance;
-	RygelMediaItemPrivate * priv;
-	char* author;
-	char* album;
-	char* date;
-	char* upnp_class;
-	char* mime_type;
-	char* dlna_profile;
-	glong size;
-	glong duration;
-	gint bitrate;
-	gint sample_freq;
-	gint bits_per_sample;
-	gint n_audio_channels;
-	gint track_number;
-	gint width;
-	gint height;
-	gint pixel_width;
-	gint pixel_height;
-	gint color_depth;
-	GeeArrayList* thumbnails;
-};
-
-struct _RygelMediaItemClass {
-	RygelMediaObjectClass parent_class;
-	GstElement* (*create_stream_source) (RygelMediaItem* self);
-	gboolean (*should_stream) (RygelMediaItem* self);
-};
-
-struct _RygelThumbnail {
-	RygelIconInfo parent_instance;
-	RygelThumbnailPrivate * priv;
-	char* uri;
-	char* dlna_profile;
-};
-
-struct _RygelThumbnailClass {
-	RygelIconInfoClass parent_class;
-};
-
-
-static gpointer rygel_http_identity_handler_parent_class = NULL;
-
-GType rygel_http_request_handler_get_type (void);
-GType rygel_http_request_get_type (void);
-GQuark rygel_http_request_error_quark (void);
-GType rygel_http_response_get_type (void);
-GType rygel_http_identity_handler_get_type (void);
-enum  {
-	RYGEL_HTTP_IDENTITY_HANDLER_DUMMY_PROPERTY
-};
-RygelHTTPRequestHandler* rygel_http_request_handler_construct (GType object_type);
-void rygel_http_request_handler_set_cancellable (RygelHTTPRequestHandler* self, GCancellable* value);
-RygelHTTPIdentityHandler* rygel_http_identity_handler_new (GCancellable* cancellable);
-RygelHTTPIdentityHandler* rygel_http_identity_handler_construct (GType object_type, GCancellable* cancellable);
-GType rygel_state_machine_get_type (void);
-GType rygel_transcode_manager_get_type (void);
-GType rygel_http_server_get_type (void);
-GType rygel_media_object_get_type (void);
-GType rygel_media_item_get_type (void);
-gpointer rygel_icon_info_ref (gpointer instance);
-void rygel_icon_info_unref (gpointer instance);
-GParamSpec* rygel_param_spec_icon_info (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
-void rygel_value_set_icon_info (GValue* value, gpointer v_object);
-gpointer rygel_value_get_icon_info (const GValue* value);
-GType rygel_icon_info_get_type (void);
-GType rygel_thumbnail_get_type (void);
-GType rygel_http_seek_get_type (void);
-GType rygel_media_container_get_type (void);
-gboolean rygel_media_item_should_stream (RygelMediaItem* self);
-void rygel_http_seek_add_response_header (RygelHTTPSeek* self, SoupMessage* msg, gint64 length);
-void rygel_http_request_handler_add_response_headers (RygelHTTPRequestHandler* self, RygelHTTPRequest* request, GError** error);
-static void rygel_http_identity_handler_real_add_response_headers (RygelHTTPRequestHandler* base, RygelHTTPRequest* request, GError** error);
-GCancellable* rygel_http_request_handler_get_cancellable (RygelHTTPRequestHandler* self);
-RygelSeekableResponse* rygel_seekable_response_new (SoupServer* server, SoupMessage* msg, const char* uri, RygelHTTPSeek* seek, gsize file_length, GCancellable* cancellable);
-RygelSeekableResponse* rygel_seekable_response_construct (GType object_type, SoupServer* server, SoupMessage* msg, const char* uri, RygelHTTPSeek* seek, gsize file_length, GCancellable* cancellable);
-GType rygel_seekable_response_get_type (void);
-GstElement* rygel_media_item_create_stream_source (RygelMediaItem* self);
-RygelLiveResponse* rygel_live_response_new (SoupServer* server, SoupMessage* msg, const char* name, GstElement* src, RygelHTTPSeek* time_range, GCancellable* cancellable, GError** error);
-RygelLiveResponse* rygel_live_response_construct (GType object_type, SoupServer* server, SoupMessage* msg, const char* name, GstElement* src, RygelHTTPSeek* time_range, GCancellable* cancellable, GError** error);
-GType rygel_live_response_get_type (void);
-static RygelHTTPResponse* rygel_http_identity_handler_real_render_body (RygelHTTPRequestHandler* base, RygelHTTPRequest* request, GError** error);
-char* rygel_transcode_manager_get_protocol (RygelTranscodeManager* self);
-GUPnPDIDLLiteResource* rygel_thumbnail_add_resource (RygelThumbnail* self, GUPnPDIDLLiteItem* didl_item, const char* protocol);
-GUPnPDIDLLiteResource* rygel_media_item_add_resource (RygelMediaItem* self, GUPnPDIDLLiteItem* didl_item, const char* uri, const char* protocol, GError** error);
-static GUPnPDIDLLiteResource* rygel_http_identity_handler_real_add_resource (RygelHTTPRequestHandler* base, GUPnPDIDLLiteItem* didl_item, RygelHTTPRequest* request, GError** error);
-
-
-
-RygelHTTPIdentityHandler* rygel_http_identity_handler_construct (GType object_type, GCancellable* cancellable) {
-	RygelHTTPIdentityHandler * self;
-	self = (RygelHTTPIdentityHandler*) rygel_http_request_handler_construct (object_type);
-	rygel_http_request_handler_set_cancellable ((RygelHTTPRequestHandler*) self, cancellable);
-	return self;
-}
-
-
-RygelHTTPIdentityHandler* rygel_http_identity_handler_new (GCancellable* cancellable) {
-	return rygel_http_identity_handler_construct (RYGEL_TYPE_HTTP_IDENTITY_HANDLER, cancellable);
-}
-
-
-static void rygel_http_identity_handler_real_add_response_headers (RygelHTTPRequestHandler* base, RygelHTTPRequest* request, GError** error) {
-	RygelHTTPIdentityHandler * self;
-	GError * _inner_error_;
-	glong size = 0L;
-	char* mime_type;
-	gboolean _tmp2_ = FALSE;
-	self = (RygelHTTPIdentityHandler*) base;
-	g_return_if_fail (request != NULL);
-	_inner_error_ = NULL;
-	mime_type = NULL;
-	if (request->thumbnail != NULL) {
-		char* _tmp0_;
-		size = ((RygelIconInfo*) request->thumbnail)->size;
-		mime_type = (_tmp0_ = g_strdup (((RygelIconInfo*) request->thumbnail)->mime_type), _g_free0 (mime_type), _tmp0_);
-	} else {
-		char* _tmp1_;
-		size = request->item->size;
-		mime_type = (_tmp1_ = g_strdup (request->item->mime_type), _g_free0 (mime_type), _tmp1_);
-	}
-	soup_message_headers_append (request->msg->response_headers, "Content-Type", mime_type);
-	if (size >= 0) {
-		soup_message_headers_set_content_length (request->msg->response_headers, (gint64) size);
-	}
-	if (request->thumbnail == NULL) {
-		_tmp2_ = rygel_media_item_should_stream (request->item);
-	} else {
-		_tmp2_ = FALSE;
-	}
-	if (_tmp2_) {
-		if (request->time_range != NULL) {
-			rygel_http_seek_add_response_header (request->time_range, request->msg, (gint64) request->item->duration);
-		}
-	} else {
-		soup_message_headers_append (request->msg->response_headers, "Accept-Ranges", "bytes");
-		if (request->byte_range != NULL) {
-			rygel_http_seek_add_response_header (request->byte_range, request->msg, (gint64) size);
-		}
-	}
-	RYGEL_HTTP_REQUEST_HANDLER_CLASS (rygel_http_identity_handler_parent_class)->add_response_headers (RYGEL_HTTP_REQUEST_HANDLER (self), request, &_inner_error_);
-	if (_inner_error_ != NULL) {
-		if (_inner_error_->domain == RYGEL_HTTP_REQUEST_ERROR) {
-			g_propagate_error (error, _inner_error_);
-			_g_free0 (mime_type);
-			return;
-		} else {
-			_g_free0 (mime_type);
-			g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
-			g_clear_error (&_inner_error_);
-			return;
-		}
-	}
-	_g_free0 (mime_type);
-}
-
-
-static gpointer _g_object_ref0 (gpointer self) {
-	return self ? g_object_ref (self) : NULL;
-}
-
-
-static RygelHTTPResponse* rygel_http_identity_handler_real_render_body (RygelHTTPRequestHandler* base, RygelHTTPRequest* request, GError** error) {
-	RygelHTTPIdentityHandler * self;
-	RygelHTTPResponse* result;
-	GError * _inner_error_;
-	RygelMediaItem* item;
-	self = (RygelHTTPIdentityHandler*) base;
-	g_return_val_if_fail (request != NULL, NULL);
-	_inner_error_ = NULL;
-	if (request->thumbnail != NULL) {
-		result = (RygelHTTPResponse*) rygel_seekable_response_new (request->server, request->msg, request->thumbnail->uri, request->byte_range, (gsize) ((RygelIconInfo*) request->thumbnail)->size, rygel_http_request_handler_get_cancellable ((RygelHTTPRequestHandler*) self));
-		return result;
-	}
-	item = _g_object_ref0 (request->item);
-	if (rygel_media_item_should_stream (item)) {
-		GstElement* src;
-		RygelLiveResponse* _tmp0_;
-		src = rygel_media_item_create_stream_source (item);
-		if (src == NULL) {
-			_inner_error_ = g_error_new_literal (RYGEL_HTTP_REQUEST_ERROR, RYGEL_HTTP_REQUEST_ERROR_NOT_FOUND, "Not found");
-			if (_inner_error_ != NULL) {
-				if (_inner_error_->domain == RYGEL_HTTP_REQUEST_ERROR) {
-					g_propagate_error (error, _inner_error_);
-					_gst_object_unref0 (src);
-					_g_object_unref0 (item);
-					return NULL;
-				} else {
-					_gst_object_unref0 (src);
-					_g_object_unref0 (item);
-					g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
-					g_clear_error (&_inner_error_);
-					return NULL;
-				}
-			}
-		}
-		_tmp0_ = rygel_live_response_new (request->server, request->msg, "RygelLiveResponse", src, request->time_range, rygel_http_request_handler_get_cancellable ((RygelHTTPRequestHandler*) self), &_inner_error_);
-		if (_inner_error_ != NULL) {
-			if (_inner_error_->domain == RYGEL_HTTP_REQUEST_ERROR) {
-				g_propagate_error (error, _inner_error_);
-				_gst_object_unref0 (src);
-				_g_object_unref0 (item);
-				return NULL;
-			} else {
-				_gst_object_unref0 (src);
-				_g_object_unref0 (item);
-				g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
-				g_clear_error (&_inner_error_);
-				return NULL;
-			}
-		}
-		result = (RygelHTTPResponse*) _tmp0_;
-		_gst_object_unref0 (src);
-		_g_object_unref0 (item);
-		return result;
-	} else {
-		char* _tmp1_;
-		RygelHTTPResponse* _tmp2_;
-		if (gee_collection_get_size ((GeeCollection*) ((RygelMediaObject*) item)->uris) == 0) {
-			_inner_error_ = g_error_new (RYGEL_HTTP_REQUEST_ERROR, RYGEL_HTTP_REQUEST_ERROR_NOT_FOUND, "Requested item '%s' didn't provide a URI\n", ((RygelMediaObject*) item)->id);
-			if (_inner_error_ != NULL) {
-				if (_inner_error_->domain == RYGEL_HTTP_REQUEST_ERROR) {
-					g_propagate_error (error, _inner_error_);
-					_g_object_unref0 (item);
-					return NULL;
-				} else {
-					_g_object_unref0 (item);
-					g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
-					g_clear_error (&_inner_error_);
-					return NULL;
-				}
-			}
-		}
-		result = (_tmp2_ = (RygelHTTPResponse*) rygel_seekable_response_new (request->server, request->msg, _tmp1_ = (char*) gee_abstract_list_get ((GeeAbstractList*) ((RygelMediaObject*) item)->uris, 0), request->byte_range, (gsize) item->size, rygel_http_request_handler_get_cancellable ((RygelHTTPRequestHandler*) self)), _g_free0 (_tmp1_), _tmp2_);
-		_g_object_unref0 (item);
-		return result;
-	}
-	_g_object_unref0 (item);
-}
-
-
-static GUPnPDIDLLiteResource* rygel_http_identity_handler_real_add_resource (RygelHTTPRequestHandler* base, GUPnPDIDLLiteItem* didl_item, RygelHTTPRequest* request, GError** error) {
-	RygelHTTPIdentityHandler * self;
-	GUPnPDIDLLiteResource* result;
-	GError * _inner_error_;
-	char* protocol;
-	self = (RygelHTTPIdentityHandler*) base;
-	g_return_val_if_fail (didl_item != NULL, NULL);
-	g_return_val_if_fail (request != NULL, NULL);
-	_inner_error_ = NULL;
-	protocol = rygel_transcode_manager_get_protocol ((RygelTranscodeManager*) request->http_server);
-	if (request->thumbnail != NULL) {
-		result = rygel_thumbnail_add_resource (request->thumbnail, didl_item, protocol);
-		_g_free0 (protocol);
-		return result;
-	} else {
-		GUPnPDIDLLiteResource* _tmp0_;
-		_tmp0_ = rygel_media_item_add_resource (request->item, didl_item, NULL, protocol, &_inner_error_);
-		if (_inner_error_ != NULL) {
-			if (_inner_error_->domain == RYGEL_HTTP_REQUEST_ERROR) {
-				g_propagate_error (error, _inner_error_);
-				_g_free0 (protocol);
-				return NULL;
-			} else {
-				_g_free0 (protocol);
-				g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
-				g_clear_error (&_inner_error_);
-				return NULL;
-			}
-		}
-		result = _tmp0_;
-		_g_free0 (protocol);
-		return result;
-	}
-	_g_free0 (protocol);
-}
-
-
-static void rygel_http_identity_handler_class_init (RygelHTTPIdentityHandlerClass * klass) {
-	rygel_http_identity_handler_parent_class = g_type_class_peek_parent (klass);
-	RYGEL_HTTP_REQUEST_HANDLER_CLASS (klass)->add_response_headers = rygel_http_identity_handler_real_add_response_headers;
-	RYGEL_HTTP_REQUEST_HANDLER_CLASS (klass)->render_body = rygel_http_identity_handler_real_render_body;
-	RYGEL_HTTP_REQUEST_HANDLER_CLASS (klass)->add_resource = rygel_http_identity_handler_real_add_resource;
-}
-
-
-static void rygel_http_identity_handler_instance_init (RygelHTTPIdentityHandler * self) {
-}
-
-
-GType rygel_http_identity_handler_get_type (void) {
-	static GType rygel_http_identity_handler_type_id = 0;
-	if (rygel_http_identity_handler_type_id == 0) {
-		static const GTypeInfo g_define_type_info = { sizeof (RygelHTTPIdentityHandlerClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) rygel_http_identity_handler_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (RygelHTTPIdentityHandler), 0, (GInstanceInitFunc) rygel_http_identity_handler_instance_init, NULL };
-		rygel_http_identity_handler_type_id = g_type_register_static (RYGEL_TYPE_HTTP_REQUEST_HANDLER, "RygelHTTPIdentityHandler", &g_define_type_info, 0);
-	}
-	return rygel_http_identity_handler_type_id;
-}
-
-
-
-
--- a/src/rygel/rygel-http-request-handler.c
+++ /dev/null
@@ -1,438 +0,0 @@
-/* rygel-http-request-handler.c generated by valac, the Vala compiler
- * generated from rygel-http-request-handler.vala, do not modify */
-
-/*
- * Copyright (C) 2008, 2009 Nokia Corporation.
- *
- * Author: Zeeshan Ali (Khattak) <zeeshanak@gnome.org>
- *                               <zeeshan.ali@nokia.com>
- *
- * This file is part of Rygel.
- *
- * Rygel is free software; you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * Rygel is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this program; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
- */
-
-#include <glib.h>
-#include <glib-object.h>
-#include <libsoup/soup.h>
-#include <libgupnp-av/gupnp-av.h>
-#include <gio/gio.h>
-#include <stdlib.h>
-#include <string.h>
-
-
-#define RYGEL_TYPE_HTTP_REQUEST_HANDLER (rygel_http_request_handler_get_type ())
-#define RYGEL_HTTP_REQUEST_HANDLER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_HTTP_REQUEST_HANDLER, RygelHTTPRequestHandler))
-#define RYGEL_HTTP_REQUEST_HANDLER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_HTTP_REQUEST_HANDLER, RygelHTTPRequestHandlerClass))
-#define RYGEL_IS_HTTP_REQUEST_HANDLER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_HTTP_REQUEST_HANDLER))
-#define RYGEL_IS_HTTP_REQUEST_HANDLER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_HTTP_REQUEST_HANDLER))
-#define RYGEL_HTTP_REQUEST_HANDLER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_HTTP_REQUEST_HANDLER, RygelHTTPRequestHandlerClass))
-
-typedef struct _RygelHTTPRequestHandler RygelHTTPRequestHandler;
-typedef struct _RygelHTTPRequestHandlerClass RygelHTTPRequestHandlerClass;
-typedef struct _RygelHTTPRequestHandlerPrivate RygelHTTPRequestHandlerPrivate;
-
-#define RYGEL_TYPE_HTTP_REQUEST (rygel_http_request_get_type ())
-#define RYGEL_HTTP_REQUEST(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_HTTP_REQUEST, RygelHTTPRequest))
-#define RYGEL_HTTP_REQUEST_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_HTTP_REQUEST, RygelHTTPRequestClass))
-#define RYGEL_IS_HTTP_REQUEST(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_HTTP_REQUEST))
-#define RYGEL_IS_HTTP_REQUEST_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_HTTP_REQUEST))
-#define RYGEL_HTTP_REQUEST_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_HTTP_REQUEST, RygelHTTPRequestClass))
-
-typedef struct _RygelHTTPRequest RygelHTTPRequest;
-typedef struct _RygelHTTPRequestClass RygelHTTPRequestClass;
-
-#define RYGEL_TYPE_HTTP_RESPONSE (rygel_http_response_get_type ())
-#define RYGEL_HTTP_RESPONSE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_HTTP_RESPONSE, RygelHTTPResponse))
-#define RYGEL_HTTP_RESPONSE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_HTTP_RESPONSE, RygelHTTPResponseClass))
-#define RYGEL_IS_HTTP_RESPONSE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_HTTP_RESPONSE))
-#define RYGEL_IS_HTTP_RESPONSE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_HTTP_RESPONSE))
-#define RYGEL_HTTP_RESPONSE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_HTTP_RESPONSE, RygelHTTPResponseClass))
-
-typedef struct _RygelHTTPResponse RygelHTTPResponse;
-typedef struct _RygelHTTPResponseClass RygelHTTPResponseClass;
-#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
-
-#define RYGEL_TYPE_STATE_MACHINE (rygel_state_machine_get_type ())
-#define RYGEL_STATE_MACHINE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_STATE_MACHINE, RygelStateMachine))
-#define RYGEL_IS_STATE_MACHINE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_STATE_MACHINE))
-#define RYGEL_STATE_MACHINE_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), RYGEL_TYPE_STATE_MACHINE, RygelStateMachineIface))
-
-typedef struct _RygelStateMachine RygelStateMachine;
-typedef struct _RygelStateMachineIface RygelStateMachineIface;
-typedef struct _RygelHTTPRequestPrivate RygelHTTPRequestPrivate;
-
-#define RYGEL_TYPE_TRANSCODE_MANAGER (rygel_transcode_manager_get_type ())
-#define RYGEL_TRANSCODE_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_TRANSCODE_MANAGER, RygelTranscodeManager))
-#define RYGEL_TRANSCODE_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_TRANSCODE_MANAGER, RygelTranscodeManagerClass))
-#define RYGEL_IS_TRANSCODE_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_TRANSCODE_MANAGER))
-#define RYGEL_IS_TRANSCODE_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_TRANSCODE_MANAGER))
-#define RYGEL_TRANSCODE_MANAGER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_TRANSCODE_MANAGER, RygelTranscodeManagerClass))
-
-typedef struct _RygelTranscodeManager RygelTranscodeManager;
-typedef struct _RygelTranscodeManagerClass RygelTranscodeManagerClass;
-
-#define RYGEL_TYPE_HTTP_SERVER (rygel_http_server_get_type ())
-#define RYGEL_HTTP_SERVER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_HTTP_SERVER, RygelHTTPServer))
-#define RYGEL_HTTP_SERVER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_HTTP_SERVER, RygelHTTPServerClass))
-#define RYGEL_IS_HTTP_SERVER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_HTTP_SERVER))
-#define RYGEL_IS_HTTP_SERVER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_HTTP_SERVER))
-#define RYGEL_HTTP_SERVER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_HTTP_SERVER, RygelHTTPServerClass))
-
-typedef struct _RygelHTTPServer RygelHTTPServer;
-typedef struct _RygelHTTPServerClass RygelHTTPServerClass;
-
-#define RYGEL_TYPE_MEDIA_OBJECT (rygel_media_object_get_type ())
-#define RYGEL_MEDIA_OBJECT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_MEDIA_OBJECT, RygelMediaObject))
-#define RYGEL_MEDIA_OBJECT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_MEDIA_OBJECT, RygelMediaObjectClass))
-#define RYGEL_IS_MEDIA_OBJECT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_MEDIA_OBJECT))
-#define RYGEL_IS_MEDIA_OBJECT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_MEDIA_OBJECT))
-#define RYGEL_MEDIA_OBJECT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_MEDIA_OBJECT, RygelMediaObjectClass))
-
-typedef struct _RygelMediaObject RygelMediaObject;
-typedef struct _RygelMediaObjectClass RygelMediaObjectClass;
-
-#define RYGEL_TYPE_MEDIA_ITEM (rygel_media_item_get_type ())
-#define RYGEL_MEDIA_ITEM(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_MEDIA_ITEM, RygelMediaItem))
-#define RYGEL_MEDIA_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_MEDIA_ITEM, RygelMediaItemClass))
-#define RYGEL_IS_MEDIA_ITEM(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_MEDIA_ITEM))
-#define RYGEL_IS_MEDIA_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_MEDIA_ITEM))
-#define RYGEL_MEDIA_ITEM_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_MEDIA_ITEM, RygelMediaItemClass))
-
-typedef struct _RygelMediaItem RygelMediaItem;
-typedef struct _RygelMediaItemClass RygelMediaItemClass;
-
-#define RYGEL_TYPE_ICON_INFO (rygel_icon_info_get_type ())
-#define RYGEL_ICON_INFO(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_ICON_INFO, RygelIconInfo))
-#define RYGEL_ICON_INFO_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_ICON_INFO, RygelIconInfoClass))
-#define RYGEL_IS_ICON_INFO(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_ICON_INFO))
-#define RYGEL_IS_ICON_INFO_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_ICON_INFO))
-#define RYGEL_ICON_INFO_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_ICON_INFO, RygelIconInfoClass))
-
-typedef struct _RygelIconInfo RygelIconInfo;
-typedef struct _RygelIconInfoClass RygelIconInfoClass;
-
-#define RYGEL_TYPE_THUMBNAIL (rygel_thumbnail_get_type ())
-#define RYGEL_THUMBNAIL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_THUMBNAIL, RygelThumbnail))
-#define RYGEL_THUMBNAIL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_THUMBNAIL, RygelThumbnailClass))
-#define RYGEL_IS_THUMBNAIL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_THUMBNAIL))
-#define RYGEL_IS_THUMBNAIL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_THUMBNAIL))
-#define RYGEL_THUMBNAIL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_THUMBNAIL, RygelThumbnailClass))
-
-typedef struct _RygelThumbnail RygelThumbnail;
-typedef struct _RygelThumbnailClass RygelThumbnailClass;
-
-#define RYGEL_TYPE_HTTP_SEEK (rygel_http_seek_get_type ())
-#define RYGEL_HTTP_SEEK(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_HTTP_SEEK, RygelHTTPSeek))
-#define RYGEL_HTTP_SEEK_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_HTTP_SEEK, RygelHTTPSeekClass))
-#define RYGEL_IS_HTTP_SEEK(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_HTTP_SEEK))
-#define RYGEL_IS_HTTP_SEEK_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_HTTP_SEEK))
-#define RYGEL_HTTP_SEEK_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_HTTP_SEEK, RygelHTTPSeekClass))
-
-typedef struct _RygelHTTPSeek RygelHTTPSeek;
-typedef struct _RygelHTTPSeekClass RygelHTTPSeekClass;
-#define _g_free0(var) (var = (g_free (var), NULL))
-
-typedef enum  {
-	RYGEL_HTTP_REQUEST_ERROR_UNACCEPTABLE = SOUP_STATUS_NOT_ACCEPTABLE,
-	RYGEL_HTTP_REQUEST_ERROR_BAD_REQUEST = SOUP_STATUS_BAD_REQUEST,
-	RYGEL_HTTP_REQUEST_ERROR_NOT_FOUND = SOUP_STATUS_NOT_FOUND
-} RygelHTTPRequestError;
-#define RYGEL_HTTP_REQUEST_ERROR rygel_http_request_error_quark ()
-struct _RygelHTTPRequestHandler {
-	GObject parent_instance;
-	RygelHTTPRequestHandlerPrivate * priv;
-};
-
-struct _RygelHTTPRequestHandlerClass {
-	GObjectClass parent_class;
-	void (*add_response_headers) (RygelHTTPRequestHandler* self, RygelHTTPRequest* request, GError** error);
-	RygelHTTPResponse* (*render_body) (RygelHTTPRequestHandler* self, RygelHTTPRequest* request, GError** error);
-	GUPnPDIDLLiteResource* (*add_resource) (RygelHTTPRequestHandler* self, GUPnPDIDLLiteItem* didl_item, RygelHTTPRequest* request, GError** error);
-};
-
-struct _RygelHTTPRequestHandlerPrivate {
-	GCancellable* _cancellable;
-};
-
-struct _RygelStateMachineIface {
-	GTypeInterface parent_iface;
-	void (*run) (RygelStateMachine* self);
-	GCancellable* (*get_cancellable) (RygelStateMachine* self);
-	void (*set_cancellable) (RygelStateMachine* self, GCancellable* value);
-};
-
-struct _RygelHTTPRequest {
-	GObject parent_instance;
-	RygelHTTPRequestPrivate * priv;
-	RygelHTTPServer* http_server;
-	SoupServer* server;
-	SoupMessage* msg;
-	RygelMediaItem* item;
-	RygelThumbnail* thumbnail;
-	RygelHTTPSeek* byte_range;
-	RygelHTTPSeek* time_range;
-};
-
-struct _RygelHTTPRequestClass {
-	GObjectClass parent_class;
-};
-
-
-static gpointer rygel_http_request_handler_parent_class = NULL;
-
-GType rygel_http_request_handler_get_type (void);
-GType rygel_http_request_get_type (void);
-GQuark rygel_http_request_error_quark (void);
-GType rygel_http_response_get_type (void);
-#define RYGEL_HTTP_REQUEST_HANDLER_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), RYGEL_TYPE_HTTP_REQUEST_HANDLER, RygelHTTPRequestHandlerPrivate))
-enum  {
-	RYGEL_HTTP_REQUEST_HANDLER_DUMMY_PROPERTY,
-	RYGEL_HTTP_REQUEST_HANDLER_CANCELLABLE
-};
-GType rygel_state_machine_get_type (void);
-GType rygel_transcode_manager_get_type (void);
-GType rygel_http_server_get_type (void);
-GType rygel_media_object_get_type (void);
-GType rygel_media_item_get_type (void);
-gpointer rygel_icon_info_ref (gpointer instance);
-void rygel_icon_info_unref (gpointer instance);
-GParamSpec* rygel_param_spec_icon_info (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
-void rygel_value_set_icon_info (GValue* value, gpointer v_object);
-gpointer rygel_value_get_icon_info (const GValue* value);
-GType rygel_icon_info_get_type (void);
-GType rygel_thumbnail_get_type (void);
-GType rygel_http_seek_get_type (void);
-GUPnPDIDLLiteResource* rygel_http_request_handler_add_resource (RygelHTTPRequestHandler* self, GUPnPDIDLLiteItem* didl_item, RygelHTTPRequest* request, GError** error);
-void rygel_http_request_handler_add_response_headers (RygelHTTPRequestHandler* self, RygelHTTPRequest* request, GError** error);
-static void rygel_http_request_handler_real_add_response_headers (RygelHTTPRequestHandler* self, RygelHTTPRequest* request, GError** error);
-RygelHTTPResponse* rygel_http_request_handler_render_body (RygelHTTPRequestHandler* self, RygelHTTPRequest* request, GError** error);
-static RygelHTTPResponse* rygel_http_request_handler_real_render_body (RygelHTTPRequestHandler* self, RygelHTTPRequest* request, GError** error);
-static GUPnPDIDLLiteResource* rygel_http_request_handler_real_add_resource (RygelHTTPRequestHandler* self, GUPnPDIDLLiteItem* didl_item, RygelHTTPRequest* request, GError** error);
-RygelHTTPRequestHandler* rygel_http_request_handler_construct (GType object_type);
-GCancellable* rygel_http_request_handler_get_cancellable (RygelHTTPRequestHandler* self);
-void rygel_http_request_handler_set_cancellable (RygelHTTPRequestHandler* self, GCancellable* value);
-static void rygel_http_request_handler_finalize (GObject* obj);
-static void rygel_http_request_handler_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
-static void rygel_http_request_handler_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);
-static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
-static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);
-static gint _vala_array_length (gpointer array);
-
-
-
-static void rygel_http_request_handler_real_add_response_headers (RygelHTTPRequestHandler* self, RygelHTTPRequest* request, GError** error) {
-	GError * _inner_error_;
-	char* mode;
-	GUPnPDIDLLiteWriter* didl_writer;
-	GUPnPDIDLLiteItem* didl_item;
-	GUPnPDIDLLiteResource* resource;
-	char** _tmp3_;
-	gint tokens_size;
-	gint tokens_length1;
-	char** _tmp1_;
-	char* _tmp0_;
-	char** _tmp2_;
-	char** tokens;
-	g_return_if_fail (self != NULL);
-	g_return_if_fail (request != NULL);
-	_inner_error_ = NULL;
-	mode = g_strdup (soup_message_headers_get (request->msg->request_headers, "transferMode.dlna.org"));
-	if (mode != NULL) {
-		soup_message_headers_append (request->msg->response_headers, "transferMode.dlna.org", mode);
-	}
-	didl_writer = gupnp_didl_lite_writer_new (NULL);
-	didl_item = gupnp_didl_lite_writer_add_item (didl_writer);
-	resource = rygel_http_request_handler_add_resource (self, didl_item, request, &_inner_error_);
-	if (_inner_error_ != NULL) {
-		if (_inner_error_->domain == RYGEL_HTTP_REQUEST_ERROR) {
-			g_propagate_error (error, _inner_error_);
-			_g_free0 (mode);
-			_g_object_unref0 (didl_writer);
-			_g_object_unref0 (didl_item);
-			return;
-		} else {
-			_g_free0 (mode);
-			_g_object_unref0 (didl_writer);
-			_g_object_unref0 (didl_item);
-			g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
-			g_clear_error (&_inner_error_);
-			return;
-		}
-	}
-	tokens = (_tmp3_ = (_tmp2_ = _tmp1_ = g_strsplit (_tmp0_ = gupnp_protocol_info_to_string (gupnp_didl_lite_resource_get_protocol_info (resource)), ":", 4), _g_free0 (_tmp0_), _tmp2_), tokens_length1 = _vala_array_length (_tmp1_), tokens_size = tokens_length1, _tmp3_);
-	g_assert (tokens_length1 == 4);
-	soup_message_headers_append (request->msg->response_headers, "contentFeatures.dlna.org", tokens[3]);
-	_g_free0 (mode);
-	_g_object_unref0 (didl_writer);
-	_g_object_unref0 (didl_item);
-	_g_object_unref0 (resource);
-	tokens = (_vala_array_free (tokens, tokens_length1, (GDestroyNotify) g_free), NULL);
-}
-
-
-void rygel_http_request_handler_add_response_headers (RygelHTTPRequestHandler* self, RygelHTTPRequest* request, GError** error) {
-	RYGEL_HTTP_REQUEST_HANDLER_GET_CLASS (self)->add_response_headers (self, request, error);
-}
-
-
-static RygelHTTPResponse* rygel_http_request_handler_real_render_body (RygelHTTPRequestHandler* self, RygelHTTPRequest* request, GError** error) {
-	g_return_val_if_fail (self != NULL, NULL);
-	g_critical ("Type `%s' does not implement abstract method `rygel_http_request_handler_render_body'", g_type_name (G_TYPE_FROM_INSTANCE (self)));
-	return NULL;
-}
-
-
-RygelHTTPResponse* rygel_http_request_handler_render_body (RygelHTTPRequestHandler* self, RygelHTTPRequest* request, GError** error) {
-	return RYGEL_HTTP_REQUEST_HANDLER_GET_CLASS (self)->render_body (self, request, error);
-}
-
-
-static GUPnPDIDLLiteResource* rygel_http_request_handler_real_add_resource (RygelHTTPRequestHandler* self, GUPnPDIDLLiteItem* didl_item, RygelHTTPRequest* request, GError** error) {
-	g_return_val_if_fail (self != NULL, NULL);
-	g_critical ("Type `%s' does not implement abstract method `rygel_http_request_handler_add_resource'", g_type_name (G_TYPE_FROM_INSTANCE (self)));
-	return NULL;
-}
-
-
-GUPnPDIDLLiteResource* rygel_http_request_handler_add_resource (RygelHTTPRequestHandler* self, GUPnPDIDLLiteItem* didl_item, RygelHTTPRequest* request, GError** error) {
-	return RYGEL_HTTP_REQUEST_HANDLER_GET_CLASS (self)->add_resource (self, didl_item, request, error);
-}
-
-
-RygelHTTPRequestHandler* rygel_http_request_handler_construct (GType object_type) {
-	RygelHTTPRequestHandler * self;
-	self = (RygelHTTPRequestHandler*) g_object_new (object_type, NULL);
-	return self;
-}
-
-
-GCancellable* rygel_http_request_handler_get_cancellable (RygelHTTPRequestHandler* self) {
-	GCancellable* result;
-	g_return_val_if_fail (self != NULL, NULL);
-	result = self->priv->_cancellable;
-	return result;
-}
-
-
-static gpointer _g_object_ref0 (gpointer self) {
-	return self ? g_object_ref (self) : NULL;
-}
-
-
-void rygel_http_request_handler_set_cancellable (RygelHTTPRequestHandler* self, GCancellable* value) {
-	GCancellable* _tmp0_;
-	g_return_if_fail (self != NULL);
-	self->priv->_cancellable = (_tmp0_ = _g_object_ref0 (value), _g_object_unref0 (self->priv->_cancellable), _tmp0_);
-	g_object_notify ((GObject *) self, "cancellable");
-}
-
-
-static void rygel_http_request_handler_class_init (RygelHTTPRequestHandlerClass * klass) {
-	rygel_http_request_handler_parent_class = g_type_class_peek_parent (klass);
-	g_type_class_add_private (klass, sizeof (RygelHTTPRequestHandlerPrivate));
-	RYGEL_HTTP_REQUEST_HANDLER_CLASS (klass)->add_response_headers = rygel_http_request_handler_real_add_response_headers;
-	RYGEL_HTTP_REQUEST_HANDLER_CLASS (klass)->render_body = rygel_http_request_handler_real_render_body;
-	RYGEL_HTTP_REQUEST_HANDLER_CLASS (klass)->add_resource = rygel_http_request_handler_real_add_resource;
-	G_OBJECT_CLASS (klass)->get_property = rygel_http_request_handler_get_property;
-	G_OBJECT_CLASS (klass)->set_property = rygel_http_request_handler_set_property;
-	G_OBJECT_CLASS (klass)->finalize = rygel_http_request_handler_finalize;
-	g_object_class_install_property (G_OBJECT_CLASS (klass), RYGEL_HTTP_REQUEST_HANDLER_CANCELLABLE, g_param_spec_object ("cancellable", "cancellable", "cancellable", G_TYPE_CANCELLABLE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
-}
-
-
-static void rygel_http_request_handler_instance_init (RygelHTTPRequestHandler * self) {
-	self->priv = RYGEL_HTTP_REQUEST_HANDLER_GET_PRIVATE (self);
-}
-
-
-static void rygel_http_request_handler_finalize (GObject* obj) {
-	RygelHTTPRequestHandler * self;
-	self = RYGEL_HTTP_REQUEST_HANDLER (obj);
-	_g_object_unref0 (self->priv->_cancellable);
-	G_OBJECT_CLASS (rygel_http_request_handler_parent_class)->finalize (obj);
-}
-
-
-GType rygel_http_request_handler_get_type (void) {
-	static GType rygel_http_request_handler_type_id = 0;
-	if (rygel_http_request_handler_type_id == 0) {
-		static const GTypeInfo g_define_type_info = { sizeof (RygelHTTPRequestHandlerClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) rygel_http_request_handler_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (RygelHTTPRequestHandler), 0, (GInstanceInitFunc) rygel_http_request_handler_instance_init, NULL };
-		rygel_http_request_handler_type_id = g_type_register_static (G_TYPE_OBJECT, "RygelHTTPRequestHandler", &g_define_type_info, G_TYPE_FLAG_ABSTRACT);
-	}
-	return rygel_http_request_handler_type_id;
-}
-
-
-static void rygel_http_request_handler_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
-	RygelHTTPRequestHandler * self;
-	self = RYGEL_HTTP_REQUEST_HANDLER (object);
-	switch (property_id) {
-		case RYGEL_HTTP_REQUEST_HANDLER_CANCELLABLE:
-		g_value_set_object (value, rygel_http_request_handler_get_cancellable (self));
-		break;
-		default:
-		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
-		break;
-	}
-}
-
-
-static void rygel_http_request_handler_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
-	RygelHTTPRequestHandler * self;
-	self = RYGEL_HTTP_REQUEST_HANDLER (object);
-	switch (property_id) {
-		case RYGEL_HTTP_REQUEST_HANDLER_CANCELLABLE:
-		rygel_http_request_handler_set_cancellable (self, g_value_get_object (value));
-		break;
-		default:
-		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
-		break;
-	}
-}
-
-
-static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
-	if ((array != NULL) && (destroy_func != NULL)) {
-		int i;
-		for (i = 0; i < array_length; i = i + 1) {
-			if (((gpointer*) array)[i] != NULL) {
-				destroy_func (((gpointer*) array)[i]);
-			}
-		}
-	}
-}
-
-
-static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
-	_vala_array_destroy (array, array_length, destroy_func);
-	g_free (array);
-}
-
-
-static gint _vala_array_length (gpointer array) {
-	int length;
-	length = 0;
-	if (array) {
-		while (((gpointer*) array)[length]) {
-			length++;
-		}
-	}
-	return length;
-}
-
-
-
-
--- a/src/rygel/rygel-http-request.c
+++ /dev/null
@@ -1,830 +0,0 @@
-/* rygel-http-request.c generated by valac, the Vala compiler
- * generated from rygel-http-request.vala, do not modify */
-
-/*
- * Copyright (C) 2008, 2009 Nokia Corporation.
- * Copyright (C) 2006, 2007, 2008 OpenedHand Ltd.
- *
- * Author: Zeeshan Ali (Khattak) <zeeshanak@gnome.org>
- *                               <zeeshan.ali@nokia.com>
- *         Jorn Baayen <jorn.baayen@gmail.com>
- *
- * This file is part of Rygel.
- *
- * Rygel is free software; you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * Rygel is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this program; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
- */
-
-#include <glib.h>
-#include <glib-object.h>
-#include <libsoup/soup.h>
-#include <gio/gio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <libgupnp-av/gupnp-av.h>
-#include <libgupnp/gupnp.h>
-#include <gee.h>
-#include <gst/gst.h>
-
-
-#define RYGEL_TYPE_STATE_MACHINE (rygel_state_machine_get_type ())
-#define RYGEL_STATE_MACHINE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_STATE_MACHINE, RygelStateMachine))
-#define RYGEL_IS_STATE_MACHINE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_STATE_MACHINE))
-#define RYGEL_STATE_MACHINE_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), RYGEL_TYPE_STATE_MACHINE, RygelStateMachineIface))
-
-typedef struct _RygelStateMachine RygelStateMachine;
-typedef struct _RygelStateMachineIface RygelStateMachineIface;
-
-#define RYGEL_TYPE_HTTP_REQUEST (rygel_http_request_get_type ())
-#define RYGEL_HTTP_REQUEST(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_HTTP_REQUEST, RygelHTTPRequest))
-#define RYGEL_HTTP_REQUEST_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_HTTP_REQUEST, RygelHTTPRequestClass))
-#define RYGEL_IS_HTTP_REQUEST(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_HTTP_REQUEST))
-#define RYGEL_IS_HTTP_REQUEST_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_HTTP_REQUEST))
-#define RYGEL_HTTP_REQUEST_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_HTTP_REQUEST, RygelHTTPRequestClass))
-
-typedef struct _RygelHTTPRequest RygelHTTPRequest;
-typedef struct _RygelHTTPRequestClass RygelHTTPRequestClass;
-typedef struct _RygelHTTPRequestPrivate RygelHTTPRequestPrivate;
-
-#define RYGEL_TYPE_TRANSCODE_MANAGER (rygel_transcode_manager_get_type ())
-#define RYGEL_TRANSCODE_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_TRANSCODE_MANAGER, RygelTranscodeManager))
-#define RYGEL_TRANSCODE_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_TRANSCODE_MANAGER, RygelTranscodeManagerClass))
-#define RYGEL_IS_TRANSCODE_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_TRANSCODE_MANAGER))
-#define RYGEL_IS_TRANSCODE_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_TRANSCODE_MANAGER))
-#define RYGEL_TRANSCODE_MANAGER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_TRANSCODE_MANAGER, RygelTranscodeManagerClass))
-
-typedef struct _RygelTranscodeManager RygelTranscodeManager;
-typedef struct _RygelTranscodeManagerClass RygelTranscodeManagerClass;
-
-#define RYGEL_TYPE_HTTP_SERVER (rygel_http_server_get_type ())
-#define RYGEL_HTTP_SERVER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_HTTP_SERVER, RygelHTTPServer))
-#define RYGEL_HTTP_SERVER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_HTTP_SERVER, RygelHTTPServerClass))
-#define RYGEL_IS_HTTP_SERVER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_HTTP_SERVER))
-#define RYGEL_IS_HTTP_SERVER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_HTTP_SERVER))
-#define RYGEL_HTTP_SERVER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_HTTP_SERVER, RygelHTTPServerClass))
-
-typedef struct _RygelHTTPServer RygelHTTPServer;
-typedef struct _RygelHTTPServerClass RygelHTTPServerClass;
-
-#define RYGEL_TYPE_MEDIA_OBJECT (rygel_media_object_get_type ())
-#define RYGEL_MEDIA_OBJECT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_MEDIA_OBJECT, RygelMediaObject))
-#define RYGEL_MEDIA_OBJECT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_MEDIA_OBJECT, RygelMediaObjectClass))
-#define RYGEL_IS_MEDIA_OBJECT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_MEDIA_OBJECT))
-#define RYGEL_IS_MEDIA_OBJECT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_MEDIA_OBJECT))
-#define RYGEL_MEDIA_OBJECT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_MEDIA_OBJECT, RygelMediaObjectClass))
-
-typedef struct _RygelMediaObject RygelMediaObject;
-typedef struct _RygelMediaObjectClass RygelMediaObjectClass;
-
-#define RYGEL_TYPE_MEDIA_ITEM (rygel_media_item_get_type ())
-#define RYGEL_MEDIA_ITEM(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_MEDIA_ITEM, RygelMediaItem))
-#define RYGEL_MEDIA_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_MEDIA_ITEM, RygelMediaItemClass))
-#define RYGEL_IS_MEDIA_ITEM(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_MEDIA_ITEM))
-#define RYGEL_IS_MEDIA_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_MEDIA_ITEM))
-#define RYGEL_MEDIA_ITEM_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_MEDIA_ITEM, RygelMediaItemClass))
-
-typedef struct _RygelMediaItem RygelMediaItem;
-typedef struct _RygelMediaItemClass RygelMediaItemClass;
-
-#define RYGEL_TYPE_ICON_INFO (rygel_icon_info_get_type ())
-#define RYGEL_ICON_INFO(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_ICON_INFO, RygelIconInfo))
-#define RYGEL_ICON_INFO_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_ICON_INFO, RygelIconInfoClass))
-#define RYGEL_IS_ICON_INFO(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_ICON_INFO))
-#define RYGEL_IS_ICON_INFO_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_ICON_INFO))
-#define RYGEL_ICON_INFO_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_ICON_INFO, RygelIconInfoClass))
-
-typedef struct _RygelIconInfo RygelIconInfo;
-typedef struct _RygelIconInfoClass RygelIconInfoClass;
-
-#define RYGEL_TYPE_THUMBNAIL (rygel_thumbnail_get_type ())
-#define RYGEL_THUMBNAIL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_THUMBNAIL, RygelThumbnail))
-#define RYGEL_THUMBNAIL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_THUMBNAIL, RygelThumbnailClass))
-#define RYGEL_IS_THUMBNAIL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_THUMBNAIL))
-#define RYGEL_IS_THUMBNAIL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_THUMBNAIL))
-#define RYGEL_THUMBNAIL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_THUMBNAIL, RygelThumbnailClass))
-
-typedef struct _RygelThumbnail RygelThumbnail;
-typedef struct _RygelThumbnailClass RygelThumbnailClass;
-
-#define RYGEL_TYPE_HTTP_SEEK (rygel_http_seek_get_type ())
-#define RYGEL_HTTP_SEEK(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_HTTP_SEEK, RygelHTTPSeek))
-#define RYGEL_HTTP_SEEK_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_HTTP_SEEK, RygelHTTPSeekClass))
-#define RYGEL_IS_HTTP_SEEK(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_HTTP_SEEK))
-#define RYGEL_IS_HTTP_SEEK_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_HTTP_SEEK))
-#define RYGEL_HTTP_SEEK_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_HTTP_SEEK, RygelHTTPSeekClass))
-
-typedef struct _RygelHTTPSeek RygelHTTPSeek;
-typedef struct _RygelHTTPSeekClass RygelHTTPSeekClass;
-
-#define RYGEL_TYPE_MEDIA_CONTAINER (rygel_media_container_get_type ())
-#define RYGEL_MEDIA_CONTAINER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_MEDIA_CONTAINER, RygelMediaContainer))
-#define RYGEL_MEDIA_CONTAINER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_MEDIA_CONTAINER, RygelMediaContainerClass))
-#define RYGEL_IS_MEDIA_CONTAINER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_MEDIA_CONTAINER))
-#define RYGEL_IS_MEDIA_CONTAINER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_MEDIA_CONTAINER))
-#define RYGEL_MEDIA_CONTAINER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_MEDIA_CONTAINER, RygelMediaContainerClass))
-
-typedef struct _RygelMediaContainer RygelMediaContainer;
-typedef struct _RygelMediaContainerClass RygelMediaContainerClass;
-
-#define RYGEL_TYPE_HTTP_RESPONSE (rygel_http_response_get_type ())
-#define RYGEL_HTTP_RESPONSE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_HTTP_RESPONSE, RygelHTTPResponse))
-#define RYGEL_HTTP_RESPONSE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_HTTP_RESPONSE, RygelHTTPResponseClass))
-#define RYGEL_IS_HTTP_RESPONSE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_HTTP_RESPONSE))
-#define RYGEL_IS_HTTP_RESPONSE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_HTTP_RESPONSE))
-#define RYGEL_HTTP_RESPONSE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_HTTP_RESPONSE, RygelHTTPResponseClass))
-
-typedef struct _RygelHTTPResponse RygelHTTPResponse;
-typedef struct _RygelHTTPResponseClass RygelHTTPResponseClass;
-
-#define RYGEL_TYPE_HTTP_REQUEST_HANDLER (rygel_http_request_handler_get_type ())
-#define RYGEL_HTTP_REQUEST_HANDLER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_HTTP_REQUEST_HANDLER, RygelHTTPRequestHandler))
-#define RYGEL_HTTP_REQUEST_HANDLER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_HTTP_REQUEST_HANDLER, RygelHTTPRequestHandlerClass))
-#define RYGEL_IS_HTTP_REQUEST_HANDLER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_HTTP_REQUEST_HANDLER))
-#define RYGEL_IS_HTTP_REQUEST_HANDLER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_HTTP_REQUEST_HANDLER))
-#define RYGEL_HTTP_REQUEST_HANDLER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_HTTP_REQUEST_HANDLER, RygelHTTPRequestHandlerClass))
-
-typedef struct _RygelHTTPRequestHandler RygelHTTPRequestHandler;
-typedef struct _RygelHTTPRequestHandlerClass RygelHTTPRequestHandlerClass;
-#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
-#define _g_hash_table_unref0(var) ((var == NULL) ? NULL : (var = (g_hash_table_unref (var), NULL)))
-#define _g_free0(var) (var = (g_free (var), NULL))
-#define _rygel_icon_info_unref0(var) ((var == NULL) ? NULL : (var = (rygel_icon_info_unref (var), NULL)))
-typedef struct _RygelTranscodeManagerPrivate RygelTranscodeManagerPrivate;
-typedef struct _RygelHTTPServerPrivate RygelHTTPServerPrivate;
-#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
-
-#define RYGEL_TYPE_HTTP_IDENTITY_HANDLER (rygel_http_identity_handler_get_type ())
-#define RYGEL_HTTP_IDENTITY_HANDLER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_HTTP_IDENTITY_HANDLER, RygelHTTPIdentityHandler))
-#define RYGEL_HTTP_IDENTITY_HANDLER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_HTTP_IDENTITY_HANDLER, RygelHTTPIdentityHandlerClass))
-#define RYGEL_IS_HTTP_IDENTITY_HANDLER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_HTTP_IDENTITY_HANDLER))
-#define RYGEL_IS_HTTP_IDENTITY_HANDLER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_HTTP_IDENTITY_HANDLER))
-#define RYGEL_HTTP_IDENTITY_HANDLER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_HTTP_IDENTITY_HANDLER, RygelHTTPIdentityHandlerClass))
-
-typedef struct _RygelHTTPIdentityHandler RygelHTTPIdentityHandler;
-typedef struct _RygelHTTPIdentityHandlerClass RygelHTTPIdentityHandlerClass;
-typedef struct _RygelMediaObjectPrivate RygelMediaObjectPrivate;
-typedef struct _RygelMediaItemPrivate RygelMediaItemPrivate;
-
-#define RYGEL_TYPE_TRANSCODER (rygel_transcoder_get_type ())
-#define RYGEL_TRANSCODER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_TRANSCODER, RygelTranscoder))
-#define RYGEL_TRANSCODER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_TRANSCODER, RygelTranscoderClass))
-#define RYGEL_IS_TRANSCODER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_TRANSCODER))
-#define RYGEL_IS_TRANSCODER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_TRANSCODER))
-#define RYGEL_TRANSCODER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_TRANSCODER, RygelTranscoderClass))
-
-typedef struct _RygelTranscoder RygelTranscoder;
-typedef struct _RygelTranscoderClass RygelTranscoderClass;
-
-#define RYGEL_TYPE_HTTP_TRANSCODE_HANDLER (rygel_http_transcode_handler_get_type ())
-#define RYGEL_HTTP_TRANSCODE_HANDLER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_HTTP_TRANSCODE_HANDLER, RygelHTTPTranscodeHandler))
-#define RYGEL_HTTP_TRANSCODE_HANDLER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_HTTP_TRANSCODE_HANDLER, RygelHTTPTranscodeHandlerClass))
-#define RYGEL_IS_HTTP_TRANSCODE_HANDLER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_HTTP_TRANSCODE_HANDLER))
-#define RYGEL_IS_HTTP_TRANSCODE_HANDLER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_HTTP_TRANSCODE_HANDLER))
-#define RYGEL_HTTP_TRANSCODE_HANDLER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_HTTP_TRANSCODE_HANDLER, RygelHTTPTranscodeHandlerClass))
-
-typedef struct _RygelHTTPTranscodeHandler RygelHTTPTranscodeHandler;
-typedef struct _RygelHTTPTranscodeHandlerClass RygelHTTPTranscodeHandlerClass;
-
-typedef enum  {
-	RYGEL_HTTP_REQUEST_ERROR_UNACCEPTABLE = SOUP_STATUS_NOT_ACCEPTABLE,
-	RYGEL_HTTP_REQUEST_ERROR_BAD_REQUEST = SOUP_STATUS_BAD_REQUEST,
-	RYGEL_HTTP_REQUEST_ERROR_NOT_FOUND = SOUP_STATUS_NOT_FOUND
-} RygelHTTPRequestError;
-#define RYGEL_HTTP_REQUEST_ERROR rygel_http_request_error_quark ()
-struct _RygelStateMachineIface {
-	GTypeInterface parent_iface;
-	void (*run) (RygelStateMachine* self);
-	GCancellable* (*get_cancellable) (RygelStateMachine* self);
-	void (*set_cancellable) (RygelStateMachine* self, GCancellable* value);
-};
-
-struct _RygelHTTPRequest {
-	GObject parent_instance;
-	RygelHTTPRequestPrivate * priv;
-	RygelHTTPServer* http_server;
-	SoupServer* server;
-	SoupMessage* msg;
-	RygelMediaItem* item;
-	RygelThumbnail* thumbnail;
-	RygelHTTPSeek* byte_range;
-	RygelHTTPSeek* time_range;
-};
-
-struct _RygelHTTPRequestClass {
-	GObjectClass parent_class;
-};
-
-struct _RygelHTTPRequestPrivate {
-	RygelMediaContainer* root_container;
-	GHashTable* query;
-	GCancellable* _cancellable;
-	RygelHTTPResponse* response;
-	char* item_id;
-	gint thumbnail_index;
-	RygelHTTPRequestHandler* request_handler;
-};
-
-struct _RygelTranscodeManager {
-	GObject parent_instance;
-	RygelTranscodeManagerPrivate * priv;
-};
-
-struct _RygelTranscodeManagerClass {
-	GObjectClass parent_class;
-	char* (*create_uri_for_item) (RygelTranscodeManager* self, RygelMediaItem* item, gint thumbnail_index, const char* transcode_target, char** protocol);
-	void (*add_resources) (RygelTranscodeManager* self, GUPnPDIDLLiteItem* didl_item, RygelMediaItem* item, GError** error);
-	char* (*get_protocol) (RygelTranscodeManager* self);
-	char* (*get_protocol_info) (RygelTranscodeManager* self);
-};
-
-struct _RygelHTTPServer {
-	RygelTranscodeManager parent_instance;
-	RygelHTTPServerPrivate * priv;
-	RygelMediaContainer* root_container;
-	GUPnPContext* context;
-};
-
-struct _RygelHTTPServerClass {
-	RygelTranscodeManagerClass parent_class;
-};
-
-typedef enum  {
-	RYGEL_HTTP_SEEK_ERROR_INVALID_RANGE = SOUP_STATUS_BAD_REQUEST,
-	RYGEL_HTTP_SEEK_ERROR_OUT_OF_RANGE = SOUP_STATUS_REQUESTED_RANGE_NOT_SATISFIABLE
-} RygelHTTPSeekError;
-#define RYGEL_HTTP_SEEK_ERROR rygel_http_seek_error_quark ()
-struct _RygelMediaObject {
-	GObject parent_instance;
-	RygelMediaObjectPrivate * priv;
-	char* id;
-	char* title;
-	guint64 modified;
-	GeeArrayList* uris;
-	RygelMediaContainer* parent;
-	RygelMediaContainer* parent_ref;
-};
-
-struct _RygelMediaObjectClass {
-	GObjectClass parent_class;
-};
-
-struct _RygelMediaItem {
-	RygelMediaObject parent_instance;
-	RygelMediaItemPrivate * priv;
-	char* author;
-	char* album;
-	char* date;
-	char* upnp_class;
-	char* mime_type;
-	char* dlna_profile;
-	glong size;
-	glong duration;
-	gint bitrate;
-	gint sample_freq;
-	gint bits_per_sample;
-	gint n_audio_channels;
-	gint track_number;
-	gint width;
-	gint height;
-	gint pixel_width;
-	gint pixel_height;
-	gint color_depth;
-	GeeArrayList* thumbnails;
-};
-
-struct _RygelMediaItemClass {
-	RygelMediaObjectClass parent_class;
-	GstElement* (*create_stream_source) (RygelMediaItem* self);
-	gboolean (*should_stream) (RygelMediaItem* self);
-};
-
-
-static gpointer rygel_http_request_parent_class = NULL;
-static RygelStateMachineIface* rygel_http_request_rygel_state_machine_parent_iface = NULL;
-
-GQuark rygel_http_request_error_quark (void);
-GType rygel_state_machine_get_type (void);
-GType rygel_http_request_get_type (void);
-GType rygel_transcode_manager_get_type (void);
-GType rygel_http_server_get_type (void);
-GType rygel_media_object_get_type (void);
-GType rygel_media_item_get_type (void);
-gpointer rygel_icon_info_ref (gpointer instance);
-void rygel_icon_info_unref (gpointer instance);
-GParamSpec* rygel_param_spec_icon_info (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
-void rygel_value_set_icon_info (GValue* value, gpointer v_object);
-gpointer rygel_value_get_icon_info (const GValue* value);
-GType rygel_icon_info_get_type (void);
-GType rygel_thumbnail_get_type (void);
-GType rygel_http_seek_get_type (void);
-GType rygel_media_container_get_type (void);
-GType rygel_http_response_get_type (void);
-GType rygel_http_request_handler_get_type (void);
-#define RYGEL_HTTP_REQUEST_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), RYGEL_TYPE_HTTP_REQUEST, RygelHTTPRequestPrivate))
-enum  {
-	RYGEL_HTTP_REQUEST_DUMMY_PROPERTY,
-	RYGEL_HTTP_REQUEST_CANCELLABLE
-};
-GCancellable* rygel_state_machine_get_cancellable (RygelStateMachine* self);
-void rygel_state_machine_set_cancellable (RygelStateMachine* self, GCancellable* value);
-RygelHTTPRequest* rygel_http_request_new (RygelHTTPServer* http_server, SoupServer* server, SoupMessage* msg, GHashTable* query);
-RygelHTTPRequest* rygel_http_request_construct (GType object_type, RygelHTTPServer* http_server, SoupServer* server, SoupMessage* msg, GHashTable* query);
-static void rygel_http_request_handle_error (RygelHTTPRequest* self, GError* _error_);
-static void rygel_http_request_parse_query (RygelHTTPRequest* self, GError** error);
-RygelHTTPIdentityHandler* rygel_http_identity_handler_new (GCancellable* cancellable);
-RygelHTTPIdentityHandler* rygel_http_identity_handler_construct (GType object_type, GCancellable* cancellable);
-GType rygel_http_identity_handler_get_type (void);
-void rygel_media_container_find_object (RygelMediaContainer* self, const char* id, GCancellable* cancellable, GAsyncReadyCallback callback, void* callback_target);
-static void rygel_http_request_on_item_found (RygelHTTPRequest* self, GObject* source_object, GAsyncResult* res);
-static void _rygel_http_request_on_item_found_gasync_ready_callback (GObject* source_object, GAsyncResult* res, gpointer self);
-static void rygel_http_request_real_run (RygelStateMachine* base);
-void rygel_http_request_end (RygelHTTPRequest* self, guint status);
-static void rygel_http_request_on_response_completed (RygelHTTPRequest* self, RygelHTTPResponse* response);
-GQuark rygel_http_seek_error_quark (void);
-RygelHTTPSeek* rygel_http_seek_from_byte_range (SoupMessage* msg, GError** error);
-RygelHTTPSeek* rygel_http_seek_from_time_range (SoupMessage* msg, GError** error);
-void rygel_http_request_handler_add_response_headers (RygelHTTPRequestHandler* self, RygelHTTPRequest* request, GError** error);
-static void _lambda0_ (const char* name, const char* value, RygelHTTPRequest* self);
-static void __lambda0__soup_message_headers_foreach_func (const char* name, const char* value, gpointer self);
-RygelHTTPResponse* rygel_http_request_handler_render_body (RygelHTTPRequestHandler* self, RygelHTTPRequest* request, GError** error);
-static void _rygel_http_request_on_response_completed_rygel_state_machine_completed (RygelHTTPResponse* _sender, gpointer self);
-void rygel_http_response_run (RygelHTTPResponse* self);
-static void rygel_http_request_handle_item_request (RygelHTTPRequest* self);
-RygelMediaObject* rygel_media_container_find_object_finish (RygelMediaContainer* self, GAsyncResult* res, GError** error);
-GType rygel_transcoder_get_type (void);
-RygelTranscoder* rygel_transcode_manager_get_transcoder (RygelTranscodeManager* self, const char* target, GError** error);
-RygelHTTPTranscodeHandler* rygel_http_transcode_handler_new (RygelTranscoder* transcoder, GCancellable* cancellable);
-RygelHTTPTranscodeHandler* rygel_http_transcode_handler_construct (GType object_type, RygelTranscoder* transcoder, GCancellable* cancellable);
-GType rygel_http_transcode_handler_get_type (void);
-static void rygel_http_request_finalize (GObject* obj);
-static void rygel_http_request_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
-static void rygel_http_request_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);
-static int _vala_strcmp0 (const char * str1, const char * str2);
-
-
-
-GQuark rygel_http_request_error_quark (void) {
-	return g_quark_from_static_string ("rygel_http_request_error-quark");
-}
-
-
-static gpointer _g_object_ref0 (gpointer self) {
-	return self ? g_object_ref (self) : NULL;
-}
-
-
-static gpointer _g_hash_table_ref0 (gpointer self) {
-	return self ? g_hash_table_ref (self) : NULL;
-}
-
-
-RygelHTTPRequest* rygel_http_request_construct (GType object_type, RygelHTTPServer* http_server, SoupServer* server, SoupMessage* msg, GHashTable* query) {
-	RygelHTTPRequest * self;
-	RygelMediaContainer* _tmp0_;
-	SoupServer* _tmp1_;
-	SoupMessage* _tmp2_;
-	GHashTable* _tmp3_;
-	g_return_val_if_fail (http_server != NULL, NULL);
-	g_return_val_if_fail (server != NULL, NULL);
-	g_return_val_if_fail (msg != NULL, NULL);
-	self = (RygelHTTPRequest*) g_object_new (object_type, NULL);
-	self->http_server = http_server;
-	rygel_state_machine_set_cancellable ((RygelStateMachine*) self, rygel_state_machine_get_cancellable ((RygelStateMachine*) http_server));
-	self->priv->root_container = (_tmp0_ = _g_object_ref0 (http_server->root_container), _g_object_unref0 (self->priv->root_container), _tmp0_);
-	self->server = (_tmp1_ = _g_object_ref0 (server), _g_object_unref0 (self->server), _tmp1_);
-	self->msg = (_tmp2_ = _g_object_ref0 (msg), _g_object_unref0 (self->msg), _tmp2_);
-	self->priv->query = (_tmp3_ = _g_hash_table_ref0 (query), _g_hash_table_unref0 (self->priv->query), _tmp3_);
-	self->priv->thumbnail_index = -1;
-	return self;
-}
-
-
-RygelHTTPRequest* rygel_http_request_new (RygelHTTPServer* http_server, SoupServer* server, SoupMessage* msg, GHashTable* query) {
-	return rygel_http_request_construct (RYGEL_TYPE_HTTP_REQUEST, http_server, server, msg, query);
-}
-
-
-static void _rygel_http_request_on_item_found_gasync_ready_callback (GObject* source_object, GAsyncResult* res, gpointer self) {
-	rygel_http_request_on_item_found (self, source_object, res);
-}
-
-
-static void rygel_http_request_real_run (RygelStateMachine* base) {
-	RygelHTTPRequest * self;
-	GError * _inner_error_;
-	char* header;
-	gboolean _tmp0_ = FALSE;
-	gboolean _tmp1_ = FALSE;
-	char* _tmp3_;
-	char* _tmp2_ = NULL;
-	gboolean _tmp4_;
-	self = (RygelHTTPRequest*) base;
-	_inner_error_ = NULL;
-	soup_server_pause_message (self->server, self->msg);
-	header = g_strdup (soup_message_headers_get (self->msg->request_headers, "getcontentFeatures.dlna.org"));
-	if ((_tmp4_ = _vala_strcmp0 (_tmp3_ = (g_object_get (self->msg, "method", &_tmp2_, NULL), _tmp2_), "HEAD") != 0, _g_free0 (_tmp3_), _tmp4_)) {
-		char* _tmp6_;
-		char* _tmp5_ = NULL;
-		_tmp1_ = _vala_strcmp0 (_tmp6_ = (g_object_get (self->msg, "method", &_tmp5_, NULL), _tmp5_), "GET") != 0;
-		_g_free0 (_tmp6_);
-	} else {
-		_tmp1_ = FALSE;
-	}
-	if (_tmp1_) {
-		_tmp0_ = TRUE;
-	} else {
-		gboolean _tmp7_ = FALSE;
-		if (header != NULL) {
-			_tmp7_ = _vala_strcmp0 (header, "1") != 0;
-		} else {
-			_tmp7_ = FALSE;
-		}
-		_tmp0_ = _tmp7_;
-	}
-	if (_tmp0_) {
-		GError* _tmp8_;
-		rygel_http_request_handle_error (self, _tmp8_ = g_error_new_literal (RYGEL_HTTP_REQUEST_ERROR, RYGEL_HTTP_REQUEST_ERROR_BAD_REQUEST, "Invalid Request"));
-		_g_error_free0 (_tmp8_);
-		_g_free0 (header);
-		return;
-	}
-	{
-		rygel_http_request_parse_query (self, &_inner_error_);
-		if (_inner_error_ != NULL) {
-			goto __catch22_g_error;
-			goto __finally22;
-		}
-	}
-	goto __finally22;
-	__catch22_g_error:
-	{
-		GError * err;
-		err = _inner_error_;
-		_inner_error_ = NULL;
-		{
-			g_warning ("rygel-http-request.vala:87: Failed to parse query: %s", err->message);
-			_g_error_free0 (err);
-		}
-	}
-	__finally22:
-	if (_inner_error_ != NULL) {
-		_g_free0 (header);
-		g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
-		g_clear_error (&_inner_error_);
-		return;
-	}
-	if (self->priv->item_id == NULL) {
-		GError* _tmp9_;
-		rygel_http_request_handle_error (self, _tmp9_ = g_error_new_literal (RYGEL_HTTP_REQUEST_ERROR, RYGEL_HTTP_REQUEST_ERROR_NOT_FOUND, "Not Found"));
-		_g_error_free0 (_tmp9_);
-		_g_free0 (header);
-		return;
-	}
-	if (self->priv->request_handler == NULL) {
-		RygelHTTPRequestHandler* _tmp10_;
-		self->priv->request_handler = (_tmp10_ = (RygelHTTPRequestHandler*) rygel_http_identity_handler_new (rygel_state_machine_get_cancellable ((RygelStateMachine*) self)), _g_object_unref0 (self->priv->request_handler), _tmp10_);
-	}
-	rygel_media_container_find_object (self->priv->root_container, self->priv->item_id, NULL, _rygel_http_request_on_item_found_gasync_ready_callback, self);
-	_g_free0 (header);
-}
-
-
-static void rygel_http_request_on_response_completed (RygelHTTPRequest* self, RygelHTTPResponse* response) {
-	g_return_if_fail (self != NULL);
-	g_return_if_fail (response != NULL);
-	rygel_http_request_end (self, (guint) SOUP_STATUS_NONE);
-}
-
-
-static void _lambda0_ (const char* name, const char* value, RygelHTTPRequest* self) {
-	g_return_if_fail (name != NULL);
-	g_return_if_fail (value != NULL);
-	g_debug ("rygel-http-request.vala:118: %s : %s", name, value);
-}
-
-
-static void __lambda0__soup_message_headers_foreach_func (const char* name, const char* value, gpointer self) {
-	_lambda0_ (name, value, self);
-}
-
-
-static void _rygel_http_request_on_response_completed_rygel_state_machine_completed (RygelHTTPResponse* _sender, gpointer self) {
-	rygel_http_request_on_response_completed (self, _sender);
-}
-
-
-static void rygel_http_request_handle_item_request (RygelHTTPRequest* self) {
-	GError * _inner_error_;
-	g_return_if_fail (self != NULL);
-	_inner_error_ = NULL;
-	{
-		RygelHTTPSeek* _tmp0_;
-		RygelHTTPSeek* _tmp1_;
-		RygelHTTPSeek* _tmp2_;
-		RygelHTTPSeek* _tmp3_;
-		char* _tmp5_;
-		char* _tmp4_ = NULL;
-		gboolean _tmp6_;
-		RygelHTTPResponse* _tmp7_;
-		RygelHTTPResponse* _tmp8_;
-		_tmp0_ = rygel_http_seek_from_byte_range (self->msg, &_inner_error_);
-		if (_inner_error_ != NULL) {
-			goto __catch23_g_error;
-			goto __finally23;
-		}
-		self->byte_range = (_tmp1_ = _tmp0_, _g_object_unref0 (self->byte_range), _tmp1_);
-		_tmp2_ = rygel_http_seek_from_time_range (self->msg, &_inner_error_);
-		if (_inner_error_ != NULL) {
-			goto __catch23_g_error;
-			goto __finally23;
-		}
-		self->time_range = (_tmp3_ = _tmp2_, _g_object_unref0 (self->time_range), _tmp3_);
-		rygel_http_request_handler_add_response_headers (self->priv->request_handler, self, &_inner_error_);
-		if (_inner_error_ != NULL) {
-			goto __catch23_g_error;
-			goto __finally23;
-		}
-		g_debug ("rygel-http-request.vala:116: Following HTTP headers appended to response:");
-		soup_message_headers_foreach (self->msg->response_headers, __lambda0__soup_message_headers_foreach_func, self);
-		if ((_tmp6_ = _vala_strcmp0 (_tmp5_ = (g_object_get (self->msg, "method", &_tmp4_, NULL), _tmp4_), "HEAD") == 0, _g_free0 (_tmp5_), _tmp6_)) {
-			soup_server_unpause_message (self->server, self->msg);
-			rygel_http_request_end (self, (guint) SOUP_STATUS_OK);
-			return;
-		}
-		_tmp7_ = rygel_http_request_handler_render_body (self->priv->request_handler, self, &_inner_error_);
-		if (_inner_error_ != NULL) {
-			goto __catch23_g_error;
-			goto __finally23;
-		}
-		self->priv->response = (_tmp8_ = _tmp7_, _g_object_unref0 (self->priv->response), _tmp8_);
-		g_signal_connect_object ((RygelStateMachine*) self->priv->response, "completed", (GCallback) _rygel_http_request_on_response_completed_rygel_state_machine_completed, self, 0);
-		rygel_http_response_run (self->priv->response);
-	}
-	goto __finally23;
-	__catch23_g_error:
-	{
-		GError * _error_;
-		_error_ = _inner_error_;
-		_inner_error_ = NULL;
-		{
-			rygel_http_request_handle_error (self, _error_);
-			_g_error_free0 (_error_);
-		}
-	}
-	__finally23:
-	if (_inner_error_ != NULL) {
-		g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
-		g_clear_error (&_inner_error_);
-		return;
-	}
-}
-
-
-static void rygel_http_request_on_item_found (RygelHTTPRequest* self, GObject* source_object, GAsyncResult* res) {
-	GError * _inner_error_;
-	RygelMediaContainer* container;
-	RygelMediaObject* media_object;
-	gboolean _tmp2_ = FALSE;
-	RygelMediaItem* _tmp4_;
-	g_return_if_fail (self != NULL);
-	g_return_if_fail (res != NULL);
-	_inner_error_ = NULL;
-	container = _g_object_ref0 (RYGEL_MEDIA_CONTAINER (source_object));
-	media_object = NULL;
-	{
-		RygelMediaObject* _tmp0_;
-		RygelMediaObject* _tmp1_;
-		_tmp0_ = rygel_media_container_find_object_finish (container, res, &_inner_error_);
-		if (_inner_error_ != NULL) {
-			goto __catch24_g_error;
-			goto __finally24;
-		}
-		media_object = (_tmp1_ = _tmp0_, _g_object_unref0 (media_object), _tmp1_);
-	}
-	goto __finally24;
-	__catch24_g_error:
-	{
-		GError * err;
-		err = _inner_error_;
-		_inner_error_ = NULL;
-		{
-			rygel_http_request_handle_error (self, err);
-			_g_error_free0 (err);
-			_g_object_unref0 (container);
-			_g_object_unref0 (media_object);
-			return;
-		}
-	}
-	__finally24:
-	if (_inner_error_ != NULL) {
-		_g_object_unref0 (container);
-		_g_object_unref0 (media_object);
-		g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
-		g_clear_error (&_inner_error_);
-		return;
-	}
-	if (media_object == NULL) {
-		_tmp2_ = TRUE;
-	} else {
-		_tmp2_ = !RYGEL_IS_MEDIA_ITEM (media_object);
-	}
-	if (_tmp2_) {
-		GError* _tmp3_;
-		rygel_http_request_handle_error (self, _tmp3_ = g_error_new (RYGEL_HTTP_REQUEST_ERROR, RYGEL_HTTP_REQUEST_ERROR_NOT_FOUND, "requested item '%s' not found", self->priv->item_id));
-		_g_error_free0 (_tmp3_);
-		_g_object_unref0 (container);
-		_g_object_unref0 (media_object);
-		return;
-	}
-	self->item = (_tmp4_ = _g_object_ref0 (RYGEL_MEDIA_ITEM (media_object)), _g_object_unref0 (self->item), _tmp4_);
-	if (self->priv->thumbnail_index >= 0) {
-		RygelThumbnail* _tmp5_;
-		self->thumbnail = (_tmp5_ = (RygelThumbnail*) gee_abstract_list_get ((GeeAbstractList*) self->item->thumbnails, self->priv->thumbnail_index), _rygel_icon_info_unref0 (self->thumbnail), _tmp5_);
-	}
-	rygel_http_request_handle_item_request (self);
-	_g_object_unref0 (container);
-	_g_object_unref0 (media_object);
-}
-
-
-static void rygel_http_request_parse_query (RygelHTTPRequest* self, GError** error) {
-	GError * _inner_error_;
-	char* _tmp0_;
-	char* target;
-	char* index;
-	g_return_if_fail (self != NULL);
-	_inner_error_ = NULL;
-	if (self->priv->query == NULL) {
-		return;
-	}
-	self->priv->item_id = (_tmp0_ = g_strdup ((const char*) g_hash_table_lookup (self->priv->query, "itemid")), _g_free0 (self->priv->item_id), _tmp0_);
-	target = g_strdup ((const char*) g_hash_table_lookup (self->priv->query, "transcode"));
-	if (target != NULL) {
-		RygelTranscoder* transcoder;
-		RygelHTTPRequestHandler* _tmp1_;
-		g_debug ("rygel-http-request.vala:172: Transcoding target: %s", target);
-		transcoder = rygel_transcode_manager_get_transcoder ((RygelTranscodeManager*) self->http_server, target, &_inner_error_);
-		if (_inner_error_ != NULL) {
-			g_propagate_error (error, _inner_error_);
-			_g_free0 (target);
-			return;
-		}
-		self->priv->request_handler = (_tmp1_ = (RygelHTTPRequestHandler*) rygel_http_transcode_handler_new (transcoder, rygel_state_machine_get_cancellable ((RygelStateMachine*) self)), _g_object_unref0 (self->priv->request_handler), _tmp1_);
-		_g_object_unref0 (transcoder);
-	}
-	index = g_strdup ((const char*) g_hash_table_lookup (self->priv->query, "thumbnail"));
-	if (index != NULL) {
-		self->priv->thumbnail_index = atoi (index);
-	}
-	_g_free0 (target);
-	_g_free0 (index);
-}
-
-
-static void rygel_http_request_handle_error (RygelHTTPRequest* self, GError* _error_) {
-	guint status = 0U;
-	g_return_if_fail (self != NULL);
-	g_warning ("rygel-http-request.vala:186: %s", _error_->message);
-	if (_error_->domain == RYGEL_HTTP_REQUEST_ERROR) {
-		status = (guint) _error_->code;
-	} else {
-		status = (guint) SOUP_STATUS_NOT_FOUND;
-	}
-	soup_server_unpause_message (self->server, self->msg);
-	rygel_http_request_end (self, status);
-}
-
-
-void rygel_http_request_end (RygelHTTPRequest* self, guint status) {
-	g_return_if_fail (self != NULL);
-	if (status != SOUP_STATUS_NONE) {
-		soup_message_set_status (self->msg, status);
-	}
-	g_signal_emit_by_name ((RygelStateMachine*) self, "completed");
-}
-
-
-static GCancellable* rygel_http_request_real_get_cancellable (RygelStateMachine* base) {
-	GCancellable* result;
-	RygelHTTPRequest* self;
-	self = (RygelHTTPRequest*) base;
-	result = self->priv->_cancellable;
-	return result;
-}
-
-
-static void rygel_http_request_real_set_cancellable (RygelStateMachine* base, GCancellable* value) {
-	RygelHTTPRequest* self;
-	GCancellable* _tmp0_;
-	self = (RygelHTTPRequest*) base;
-	self->priv->_cancellable = (_tmp0_ = _g_object_ref0 (value), _g_object_unref0 (self->priv->_cancellable), _tmp0_);
-	g_object_notify ((GObject *) self, "cancellable");
-}
-
-
-static void rygel_http_request_class_init (RygelHTTPRequestClass * klass) {
-	rygel_http_request_parent_class = g_type_class_peek_parent (klass);
-	g_type_class_add_private (klass, sizeof (RygelHTTPRequestPrivate));
-	G_OBJECT_CLASS (klass)->get_property = rygel_http_request_get_property;
-	G_OBJECT_CLASS (klass)->set_property = rygel_http_request_set_property;
-	G_OBJECT_CLASS (klass)->finalize = rygel_http_request_finalize;
-	g_object_class_override_property (G_OBJECT_CLASS (klass), RYGEL_HTTP_REQUEST_CANCELLABLE, "cancellable");
-}
-
-
-static void rygel_http_request_rygel_state_machine_interface_init (RygelStateMachineIface * iface) {
-	rygel_http_request_rygel_state_machine_parent_iface = g_type_interface_peek_parent (iface);
-	iface->run = rygel_http_request_real_run;
-	iface->get_cancellable = rygel_http_request_real_get_cancellable;
-	iface->set_cancellable = rygel_http_request_real_set_cancellable;
-}
-
-
-static void rygel_http_request_instance_init (RygelHTTPRequest * self) {
-	self->priv = RYGEL_HTTP_REQUEST_GET_PRIVATE (self);
-}
-
-
-static void rygel_http_request_finalize (GObject* obj) {
-	RygelHTTPRequest * self;
-	self = RYGEL_HTTP_REQUEST (obj);
-	_g_object_unref0 (self->priv->root_container);
-	_g_object_unref0 (self->server);
-	_g_object_unref0 (self->msg);
-	_g_hash_table_unref0 (self->priv->query);
-	_g_object_unref0 (self->priv->_cancellable);
-	_g_object_unref0 (self->priv->response);
-	_g_free0 (self->priv->item_id);
-	_g_object_unref0 (self->item);
-	_rygel_icon_info_unref0 (self->thumbnail);
-	_g_object_unref0 (self->byte_range);
-	_g_object_unref0 (self->time_range);
-	_g_object_unref0 (self->priv->request_handler);
-	G_OBJECT_CLASS (rygel_http_request_parent_class)->finalize (obj);
-}
-
-
-GType rygel_http_request_get_type (void) {
-	static GType rygel_http_request_type_id = 0;
-	if (rygel_http_request_type_id == 0) {
-		static const GTypeInfo g_define_type_info = { sizeof (RygelHTTPRequestClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) rygel_http_request_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (RygelHTTPRequest), 0, (GInstanceInitFunc) rygel_http_request_instance_init, NULL };
-		static const GInterfaceInfo rygel_state_machine_info = { (GInterfaceInitFunc) rygel_http_request_rygel_state_machine_interface_init, (GInterfaceFinalizeFunc) NULL, NULL};
-		rygel_http_request_type_id = g_type_register_static (G_TYPE_OBJECT, "RygelHTTPRequest", &g_define_type_info, 0);
-		g_type_add_interface_static (rygel_http_request_type_id, RYGEL_TYPE_STATE_MACHINE, &rygel_state_machine_info);
-	}
-	return rygel_http_request_type_id;
-}
-
-
-static void rygel_http_request_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
-	RygelHTTPRequest * self;
-	self = RYGEL_HTTP_REQUEST (object);
-	switch (property_id) {
-		case RYGEL_HTTP_REQUEST_CANCELLABLE:
-		g_value_set_object (value, rygel_state_machine_get_cancellable ((RygelStateMachine*) self));
-		break;
-		default:
-		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
-		break;
-	}
-}
-
-
-static void rygel_http_request_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
-	RygelHTTPRequest * self;
-	self = RYGEL_HTTP_REQUEST (object);
-	switch (property_id) {
-		case RYGEL_HTTP_REQUEST_CANCELLABLE:
-		rygel_state_machine_set_cancellable ((RygelStateMachine*) self, g_value_get_object (value));
-		break;
-		default:
-		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
-		break;
-	}
-}
-
-
-static int _vala_strcmp0 (const char * str1, const char * str2) {
-	if (str1 == NULL) {
-		return -(str1 != str2);
-	}
-	if (str2 == NULL) {
-		return str1 != str2;
-	}
-	return strcmp (str1, str2);
-}
-
-
-
-
--- a/src/rygel/rygel-http-response.c
+++ /dev/null
@@ -1,313 +0,0 @@
-/* rygel-http-response.c generated by valac, the Vala compiler
- * generated from rygel-http-response.vala, do not modify */
-
-/*
- * Copyright (C) 2008 Nokia Corporation.
- *
- * Author: Zeeshan Ali (Khattak) <zeeshanak@gnome.org>
- *                               <zeeshan.ali@nokia.com>
- *
- * This file is part of Rygel.
- *
- * Rygel is free software; you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * Rygel is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this program; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
- */
-
-#include <glib.h>
-#include <glib-object.h>
-#include <gio/gio.h>
-#include <libsoup/soup.h>
-
-
-#define RYGEL_TYPE_STATE_MACHINE (rygel_state_machine_get_type ())
-#define RYGEL_STATE_MACHINE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_STATE_MACHINE, RygelStateMachine))
-#define RYGEL_IS_STATE_MACHINE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_STATE_MACHINE))
-#define RYGEL_STATE_MACHINE_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), RYGEL_TYPE_STATE_MACHINE, RygelStateMachineIface))
-
-typedef struct _RygelStateMachine RygelStateMachine;
-typedef struct _RygelStateMachineIface RygelStateMachineIface;
-
-#define RYGEL_TYPE_HTTP_RESPONSE (rygel_http_response_get_type ())
-#define RYGEL_HTTP_RESPONSE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_HTTP_RESPONSE, RygelHTTPResponse))
-#define RYGEL_HTTP_RESPONSE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_HTTP_RESPONSE, RygelHTTPResponseClass))
-#define RYGEL_IS_HTTP_RESPONSE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_HTTP_RESPONSE))
-#define RYGEL_IS_HTTP_RESPONSE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_HTTP_RESPONSE))
-#define RYGEL_HTTP_RESPONSE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_HTTP_RESPONSE, RygelHTTPResponseClass))
-
-typedef struct _RygelHTTPResponse RygelHTTPResponse;
-typedef struct _RygelHTTPResponseClass RygelHTTPResponseClass;
-typedef struct _RygelHTTPResponsePrivate RygelHTTPResponsePrivate;
-#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
-
-struct _RygelStateMachineIface {
-	GTypeInterface parent_iface;
-	void (*run) (RygelStateMachine* self);
-	GCancellable* (*get_cancellable) (RygelStateMachine* self);
-	void (*set_cancellable) (RygelStateMachine* self, GCancellable* value);
-};
-
-struct _RygelHTTPResponse {
-	GObject parent_instance;
-	RygelHTTPResponsePrivate * priv;
-	SoupMessage* msg;
-};
-
-struct _RygelHTTPResponseClass {
-	GObjectClass parent_class;
-	void (*run) (RygelHTTPResponse* self);
-	void (*end) (RygelHTTPResponse* self, gboolean aborted, guint status);
-};
-
-struct _RygelHTTPResponsePrivate {
-	SoupServer* _server;
-	GCancellable* _cancellable;
-};
-
-
-static gpointer rygel_http_response_parent_class = NULL;
-static RygelStateMachineIface* rygel_http_response_rygel_state_machine_parent_iface = NULL;
-
-GType rygel_state_machine_get_type (void);
-GType rygel_http_response_get_type (void);
-#define RYGEL_HTTP_RESPONSE_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), RYGEL_TYPE_HTTP_RESPONSE, RygelHTTPResponsePrivate))
-enum  {
-	RYGEL_HTTP_RESPONSE_DUMMY_PROPERTY,
-	RYGEL_HTTP_RESPONSE_SERVER,
-	RYGEL_HTTP_RESPONSE_CANCELLABLE
-};
-static void rygel_http_response_set_server (RygelHTTPResponse* self, SoupServer* value);
-void rygel_state_machine_set_cancellable (RygelStateMachine* self, GCancellable* value);
-static void rygel_http_response_on_request_aborted (RygelHTTPResponse* self, SoupServer* server, SoupMessage* msg, SoupClientContext* client);
-static void _rygel_http_response_on_request_aborted_soup_server_request_aborted (SoupServer* _sender, SoupMessage* msg, SoupClientContext* client, gpointer self);
-SoupServer* rygel_http_response_get_server (RygelHTTPResponse* self);
-RygelHTTPResponse* rygel_http_response_construct (GType object_type, SoupServer* server, SoupMessage* msg, gboolean partial, GCancellable* cancellable);
-GCancellable* rygel_state_machine_get_cancellable (RygelStateMachine* self);
-static void rygel_http_response_on_cancelled (RygelHTTPResponse* self, GCancellable* cancellable);
-static void _rygel_http_response_on_cancelled_g_cancellable_cancelled (GCancellable* _sender, gpointer self);
-void rygel_http_response_run (RygelHTTPResponse* self);
-static void rygel_http_response_real_run (RygelHTTPResponse* self);
-void rygel_http_response_end (RygelHTTPResponse* self, gboolean aborted, guint status);
-void rygel_http_response_push_data (RygelHTTPResponse* self, void* data, gsize length);
-static void rygel_http_response_real_end (RygelHTTPResponse* self, gboolean aborted, guint status);
-static void rygel_http_response_finalize (GObject* obj);
-static void rygel_http_response_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
-static void rygel_http_response_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);
-
-
-
-static gpointer _g_object_ref0 (gpointer self) {
-	return self ? g_object_ref (self) : NULL;
-}
-
-
-static void _rygel_http_response_on_request_aborted_soup_server_request_aborted (SoupServer* _sender, SoupMessage* msg, SoupClientContext* client, gpointer self) {
-	rygel_http_response_on_request_aborted (self, _sender, msg, client);
-}
-
-
-RygelHTTPResponse* rygel_http_response_construct (GType object_type, SoupServer* server, SoupMessage* msg, gboolean partial, GCancellable* cancellable) {
-	RygelHTTPResponse * self;
-	SoupMessage* _tmp0_;
-	g_return_val_if_fail (server != NULL, NULL);
-	g_return_val_if_fail (msg != NULL, NULL);
-	self = (RygelHTTPResponse*) g_object_new (object_type, NULL);
-	rygel_http_response_set_server (self, server);
-	self->msg = (_tmp0_ = _g_object_ref0 (msg), _g_object_unref0 (self->msg), _tmp0_);
-	rygel_state_machine_set_cancellable ((RygelStateMachine*) self, cancellable);
-	if (partial) {
-		soup_message_set_status (self->msg, (guint) SOUP_STATUS_PARTIAL_CONTENT);
-	} else {
-		soup_message_set_status (self->msg, (guint) SOUP_STATUS_OK);
-	}
-	soup_message_body_set_accumulate (self->msg->response_body, FALSE);
-	g_signal_connect_object (self->priv->_server, "request-aborted", (GCallback) _rygel_http_response_on_request_aborted_soup_server_request_aborted, self, 0);
-	return self;
-}
-
-
-static void _rygel_http_response_on_cancelled_g_cancellable_cancelled (GCancellable* _sender, gpointer self) {
-	rygel_http_response_on_cancelled (self, _sender);
-}
-
-
-static void rygel_http_response_real_run (RygelHTTPResponse* self) {
-	g_return_if_fail (self != NULL);
-	if (rygel_state_machine_get_cancellable ((RygelStateMachine*) self) != NULL) {
-		g_signal_connect_object (rygel_state_machine_get_cancellable ((RygelStateMachine*) self), "cancelled", (GCallback) _rygel_http_response_on_cancelled_g_cancellable_cancelled, self, 0);
-	}
-}
-
-
-void rygel_http_response_run (RygelHTTPResponse* self) {
-	RYGEL_HTTP_RESPONSE_GET_CLASS (self)->run (self);
-}
-
-
-static void rygel_http_response_on_cancelled (RygelHTTPResponse* self, GCancellable* cancellable) {
-	g_return_if_fail (self != NULL);
-	g_return_if_fail (cancellable != NULL);
-	rygel_http_response_end (self, TRUE, (guint) SOUP_STATUS_CANCELLED);
-}
-
-
-static void rygel_http_response_on_request_aborted (RygelHTTPResponse* self, SoupServer* server, SoupMessage* msg, SoupClientContext* client) {
-	g_return_if_fail (self != NULL);
-	g_return_if_fail (server != NULL);
-	g_return_if_fail (msg != NULL);
-	g_return_if_fail (client != NULL);
-	if (msg == self->msg) {
-		rygel_http_response_end (self, TRUE, (guint) SOUP_STATUS_NONE);
-	}
-}
-
-
-void rygel_http_response_push_data (RygelHTTPResponse* self, void* data, gsize length) {
-	g_return_if_fail (self != NULL);
-	soup_message_body_append (self->msg->response_body, SOUP_MEMORY_COPY, data, length);
-	soup_server_unpause_message (self->priv->_server, self->msg);
-}
-
-
-static void rygel_http_response_real_end (RygelHTTPResponse* self, gboolean aborted, guint status) {
-	g_return_if_fail (self != NULL);
-	if (status != SOUP_STATUS_NONE) {
-		soup_message_set_status (self->msg, status);
-	}
-	g_signal_emit_by_name ((RygelStateMachine*) self, "completed");
-}
-
-
-void rygel_http_response_end (RygelHTTPResponse* self, gboolean aborted, guint status) {
-	RYGEL_HTTP_RESPONSE_GET_CLASS (self)->end (self, aborted, status);
-}
-
-
-SoupServer* rygel_http_response_get_server (RygelHTTPResponse* self) {
-	SoupServer* result;
-	g_return_val_if_fail (self != NULL, NULL);
-	result = self->priv->_server;
-	return result;
-}
-
-
-static void rygel_http_response_set_server (RygelHTTPResponse* self, SoupServer* value) {
-	SoupServer* _tmp0_;
-	g_return_if_fail (self != NULL);
-	self->priv->_server = (_tmp0_ = _g_object_ref0 (value), _g_object_unref0 (self->priv->_server), _tmp0_);
-	g_object_notify ((GObject *) self, "server");
-}
-
-
-static GCancellable* rygel_http_response_real_get_cancellable (RygelStateMachine* base) {
-	GCancellable* result;
-	RygelHTTPResponse* self;
-	self = (RygelHTTPResponse*) base;
-	result = self->priv->_cancellable;
-	return result;
-}
-
-
-static void rygel_http_response_real_set_cancellable (RygelStateMachine* base, GCancellable* value) {
-	RygelHTTPResponse* self;
-	GCancellable* _tmp0_;
-	self = (RygelHTTPResponse*) base;
-	self->priv->_cancellable = (_tmp0_ = _g_object_ref0 (value), _g_object_unref0 (self->priv->_cancellable), _tmp0_);
-	g_object_notify ((GObject *) self, "cancellable");
-}
-
-
-static void rygel_http_response_class_init (RygelHTTPResponseClass * klass) {
-	rygel_http_response_parent_class = g_type_class_peek_parent (klass);
-	g_type_class_add_private (klass, sizeof (RygelHTTPResponsePrivate));
-	RYGEL_HTTP_RESPONSE_CLASS (klass)->run = rygel_http_response_real_run;
-	RYGEL_HTTP_RESPONSE_CLASS (klass)->end = rygel_http_response_real_end;
-	G_OBJECT_CLASS (klass)->get_property = rygel_http_response_get_property;
-	G_OBJECT_CLASS (klass)->set_property = rygel_http_response_set_property;
-	G_OBJECT_CLASS (klass)->finalize = rygel_http_response_finalize;
-	g_object_class_install_property (G_OBJECT_CLASS (klass), RYGEL_HTTP_RESPONSE_SERVER, g_param_spec_object ("server", "server", "server", SOUP_TYPE_SERVER, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
-	g_object_class_override_property (G_OBJECT_CLASS (klass), RYGEL_HTTP_RESPONSE_CANCELLABLE, "cancellable");
-}
-
-
-static void rygel_http_response_rygel_state_machine_interface_init (RygelStateMachineIface * iface) {
-	rygel_http_response_rygel_state_machine_parent_iface = g_type_interface_peek_parent (iface);
-	iface->run = (void (*)(RygelStateMachine*)) rygel_http_response_run;
-	iface->get_cancellable = rygel_http_response_real_get_cancellable;
-	iface->set_cancellable = rygel_http_response_real_set_cancellable;
-}
-
-
-static void rygel_http_response_instance_init (RygelHTTPResponse * self) {
-	self->priv = RYGEL_HTTP_RESPONSE_GET_PRIVATE (self);
-}
-
-
-static void rygel_http_response_finalize (GObject* obj) {
-	RygelHTTPResponse * self;
-	self = RYGEL_HTTP_RESPONSE (obj);
-	_g_object_unref0 (self->priv->_server);
-	_g_object_unref0 (self->msg);
-	_g_object_unref0 (self->priv->_cancellable);
-	G_OBJECT_CLASS (rygel_http_response_parent_class)->finalize (obj);
-}
-
-
-GType rygel_http_response_get_type (void) {
-	static GType rygel_http_response_type_id = 0;
-	if (rygel_http_response_type_id == 0) {
-		static const GTypeInfo g_define_type_info = { sizeof (RygelHTTPResponseClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) rygel_http_response_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (RygelHTTPResponse), 0, (GInstanceInitFunc) rygel_http_response_instance_init, NULL };
-		static const GInterfaceInfo rygel_state_machine_info = { (GInterfaceInitFunc) rygel_http_response_rygel_state_machine_interface_init, (GInterfaceFinalizeFunc) NULL, NULL};
-		rygel_http_response_type_id = g_type_register_static (G_TYPE_OBJECT, "RygelHTTPResponse", &g_define_type_info, G_TYPE_FLAG_ABSTRACT);
-		g_type_add_interface_static (rygel_http_response_type_id, RYGEL_TYPE_STATE_MACHINE, &rygel_state_machine_info);
-	}
-	return rygel_http_response_type_id;
-}
-
-
-static void rygel_http_response_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
-	RygelHTTPResponse * self;
-	self = RYGEL_HTTP_RESPONSE (object);
-	switch (property_id) {
-		case RYGEL_HTTP_RESPONSE_SERVER:
-		g_value_set_object (value, rygel_http_response_get_server (self));
-		break;
-		case RYGEL_HTTP_RESPONSE_CANCELLABLE:
-		g_value_set_object (value, rygel_state_machine_get_cancellable ((RygelStateMachine*) self));
-		break;
-		default:
-		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
-		break;
-	}
-}
-
-
-static void rygel_http_response_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
-	RygelHTTPResponse * self;
-	self = RYGEL_HTTP_RESPONSE (object);
-	switch (property_id) {
-		case RYGEL_HTTP_RESPONSE_SERVER:
-		rygel_http_response_set_server (self, g_value_get_object (value));
-		break;
-		case RYGEL_HTTP_RESPONSE_CANCELLABLE:
-		rygel_state_machine_set_cancellable ((RygelStateMachine*) self, g_value_get_object (value));
-		break;
-		default:
-		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
-		break;
-	}
-}
-
-
-
-
--- a/src/rygel/rygel-http-seek.c
+++ /dev/null
@@ -1,664 +0,0 @@
-/* rygel-http-seek.c generated by valac, the Vala compiler
- * generated from rygel-http-seek.vala, do not modify */
-
-/*
- * Copyright (C) 2008 Nokia Corporation.
- *
- * Author: Zeeshan Ali (Khattak) <zeeshanak@gnome.org>
- *                               <zeeshan.ali@nokia.com>
- *
- * This file is part of Rygel.
- *
- * Rygel is free software; you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * Rygel is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this program; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
- */
-
-#include <glib.h>
-#include <glib-object.h>
-#include <libsoup/soup.h>
-#include <gst/gst.h>
-#include <stdlib.h>
-#include <string.h>
-#include <float.h>
-#include <math.h>
-
-
-#define RYGEL_TYPE_HTTP_SEEK (rygel_http_seek_get_type ())
-#define RYGEL_HTTP_SEEK(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_HTTP_SEEK, RygelHTTPSeek))
-#define RYGEL_HTTP_SEEK_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_HTTP_SEEK, RygelHTTPSeekClass))
-#define RYGEL_IS_HTTP_SEEK(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_HTTP_SEEK))
-#define RYGEL_IS_HTTP_SEEK_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_HTTP_SEEK))
-#define RYGEL_HTTP_SEEK_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_HTTP_SEEK, RygelHTTPSeekClass))
-
-typedef struct _RygelHTTPSeek RygelHTTPSeek;
-typedef struct _RygelHTTPSeekClass RygelHTTPSeekClass;
-typedef struct _RygelHTTPSeekPrivate RygelHTTPSeekPrivate;
-#define _g_free0(var) (var = (g_free (var), NULL))
-
-typedef enum  {
-	RYGEL_HTTP_SEEK_ERROR_INVALID_RANGE = SOUP_STATUS_BAD_REQUEST,
-	RYGEL_HTTP_SEEK_ERROR_OUT_OF_RANGE = SOUP_STATUS_REQUESTED_RANGE_NOT_SATISFIABLE
-} RygelHTTPSeekError;
-#define RYGEL_HTTP_SEEK_ERROR rygel_http_seek_error_quark ()
-struct _RygelHTTPSeek {
-	GObject parent_instance;
-	RygelHTTPSeekPrivate * priv;
-};
-
-struct _RygelHTTPSeekClass {
-	GObjectClass parent_class;
-};
-
-struct _RygelHTTPSeekPrivate {
-	GstFormat _format;
-	gint64 _start;
-	gint64 _stop;
-};
-
-
-static gpointer rygel_http_seek_parent_class = NULL;
-
-GQuark rygel_http_seek_error_quark (void);
-GType rygel_http_seek_get_type (void);
-#define RYGEL_HTTP_SEEK_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), RYGEL_TYPE_HTTP_SEEK, RygelHTTPSeekPrivate))
-enum  {
-	RYGEL_HTTP_SEEK_DUMMY_PROPERTY,
-	RYGEL_HTTP_SEEK_FORMAT,
-	RYGEL_HTTP_SEEK_START,
-	RYGEL_HTTP_SEEK_STOP,
-	RYGEL_HTTP_SEEK_LENGTH
-};
-static void rygel_http_seek_set_format (RygelHTTPSeek* self, GstFormat value);
-static void rygel_http_seek_set_start (RygelHTTPSeek* self, gint64 value);
-static void rygel_http_seek_set_stop (RygelHTTPSeek* self, gint64 value);
-RygelHTTPSeek* rygel_http_seek_new (GstFormat format, gint64 start, gint64 stop);
-RygelHTTPSeek* rygel_http_seek_construct (GType object_type, GstFormat format, gint64 start, gint64 stop);
-RygelHTTPSeek* rygel_http_seek_from_byte_range (SoupMessage* msg, GError** error);
-RygelHTTPSeek* rygel_http_seek_from_time_range (SoupMessage* msg, GError** error);
-GstFormat rygel_http_seek_get_format (RygelHTTPSeek* self);
-gint64 rygel_http_seek_get_start (RygelHTTPSeek* self);
-gint64 rygel_http_seek_get_stop (RygelHTTPSeek* self);
-void rygel_http_seek_add_response_header (RygelHTTPSeek* self, SoupMessage* msg, gint64 length);
-gint64 rygel_http_seek_get_length (RygelHTTPSeek* self);
-static void rygel_http_seek_finalize (GObject* obj);
-static void rygel_http_seek_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
-static void rygel_http_seek_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);
-static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
-static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);
-static gint _vala_array_length (gpointer array);
-static int _vala_strcmp0 (const char * str1, const char * str2);
-
-
-
-GQuark rygel_http_seek_error_quark (void) {
-	return g_quark_from_static_string ("rygel_http_seek_error-quark");
-}
-
-
-RygelHTTPSeek* rygel_http_seek_construct (GType object_type, GstFormat format, gint64 start, gint64 stop) {
-	RygelHTTPSeek * self;
-	self = (RygelHTTPSeek*) g_object_new (object_type, NULL);
-	rygel_http_seek_set_format (self, format);
-	rygel_http_seek_set_start (self, start);
-	rygel_http_seek_set_stop (self, stop);
-	return self;
-}
-
-
-RygelHTTPSeek* rygel_http_seek_new (GstFormat format, gint64 start, gint64 stop) {
-	return rygel_http_seek_construct (RYGEL_TYPE_HTTP_SEEK, format, start, stop);
-}
-
-
-RygelHTTPSeek* rygel_http_seek_from_byte_range (SoupMessage* msg, GError** error) {
-	RygelHTTPSeek* result;
-	GError * _inner_error_;
-	char* range;
-	char* pos;
-	gint range_tokens_size;
-	gint range_tokens_length1;
-	char** range_tokens;
-	gint64 start;
-	gint64 stop;
-	char* _tmp0_;
-	char** _tmp2_;
-	char** _tmp1_;
-	gboolean _tmp3_ = FALSE;
-	char* _tmp4_;
-	char* _tmp5_;
-	g_return_val_if_fail (msg != NULL, NULL);
-	_inner_error_ = NULL;
-	range = NULL;
-	pos = NULL;
-	range_tokens = (range_tokens_length1 = 0, NULL);
-	start = (gint64) 0;
-	stop = (gint64) (-1);
-	range = (_tmp0_ = g_strdup (soup_message_headers_get (msg->request_headers, "Range")), _g_free0 (range), _tmp0_);
-	if (range == NULL) {
-		result = NULL;
-		_g_free0 (range);
-		_g_free0 (pos);
-		range_tokens = (_vala_array_free (range_tokens, range_tokens_length1, (GDestroyNotify) g_free), NULL);
-		return result;
-	}
-	if (!g_str_has_prefix (range, "bytes=")) {
-		_inner_error_ = g_error_new (RYGEL_HTTP_SEEK_ERROR, RYGEL_HTTP_SEEK_ERROR_INVALID_RANGE, "Invalid Range '%s'", range);
-		if (_inner_error_ != NULL) {
-			if (_inner_error_->domain == RYGEL_HTTP_SEEK_ERROR) {
-				g_propagate_error (error, _inner_error_);
-				_g_free0 (range);
-				_g_free0 (pos);
-				range_tokens = (_vala_array_free (range_tokens, range_tokens_length1, (GDestroyNotify) g_free), NULL);
-				return NULL;
-			} else {
-				_g_free0 (range);
-				_g_free0 (pos);
-				range_tokens = (_vala_array_free (range_tokens, range_tokens_length1, (GDestroyNotify) g_free), NULL);
-				g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
-				g_clear_error (&_inner_error_);
-				return NULL;
-			}
-		}
-	}
-	range_tokens = (_tmp2_ = _tmp1_ = g_strsplit (g_utf8_offset_to_pointer (range, (glong) 6), "-", 2), range_tokens = (_vala_array_free (range_tokens, range_tokens_length1, (GDestroyNotify) g_free), NULL), range_tokens_length1 = _vala_array_length (_tmp1_), range_tokens_size = range_tokens_length1, _tmp2_);
-	if (range_tokens[0] == NULL) {
-		_tmp3_ = TRUE;
-	} else {
-		_tmp3_ = range_tokens[1] == NULL;
-	}
-	if (_tmp3_) {
-		_inner_error_ = g_error_new (RYGEL_HTTP_SEEK_ERROR, RYGEL_HTTP_SEEK_ERROR_INVALID_RANGE, "Invalid Range '%s'", range);
-		if (_inner_error_ != NULL) {
-			if (_inner_error_->domain == RYGEL_HTTP_SEEK_ERROR) {
-				g_propagate_error (error, _inner_error_);
-				_g_free0 (range);
-				_g_free0 (pos);
-				range_tokens = (_vala_array_free (range_tokens, range_tokens_length1, (GDestroyNotify) g_free), NULL);
-				return NULL;
-			} else {
-				_g_free0 (range);
-				_g_free0 (pos);
-				range_tokens = (_vala_array_free (range_tokens, range_tokens_length1, (GDestroyNotify) g_free), NULL);
-				g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
-				g_clear_error (&_inner_error_);
-				return NULL;
-			}
-		}
-	}
-	pos = (_tmp4_ = g_strdup (range_tokens[0]), _g_free0 (pos), _tmp4_);
-	if (g_unichar_isdigit (g_utf8_get_char (g_utf8_offset_to_pointer (pos, 0)))) {
-		start = g_ascii_strtoll (pos, NULL, 0);
-	} else {
-		if (_vala_strcmp0 (pos, "") != 0) {
-			_inner_error_ = g_error_new (RYGEL_HTTP_SEEK_ERROR, RYGEL_HTTP_SEEK_ERROR_INVALID_RANGE, "Invalid Range '%s'", range);
-			if (_inner_error_ != NULL) {
-				if (_inner_error_->domain == RYGEL_HTTP_SEEK_ERROR) {
-					g_propagate_error (error, _inner_error_);
-					_g_free0 (range);
-					_g_free0 (pos);
-					range_tokens = (_vala_array_free (range_tokens, range_tokens_length1, (GDestroyNotify) g_free), NULL);
-					return NULL;
-				} else {
-					_g_free0 (range);
-					_g_free0 (pos);
-					range_tokens = (_vala_array_free (range_tokens, range_tokens_length1, (GDestroyNotify) g_free), NULL);
-					g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
-					g_clear_error (&_inner_error_);
-					return NULL;
-				}
-			}
-		}
-	}
-	pos = (_tmp5_ = g_strdup (range_tokens[1]), _g_free0 (pos), _tmp5_);
-	if (g_unichar_isdigit (g_utf8_get_char (g_utf8_offset_to_pointer (pos, 0)))) {
-		stop = g_ascii_strtoll (pos, NULL, 0);
-		if (stop < start) {
-			_inner_error_ = g_error_new (RYGEL_HTTP_SEEK_ERROR, RYGEL_HTTP_SEEK_ERROR_INVALID_RANGE, "Invalid Range '%s'", range);
-			if (_inner_error_ != NULL) {
-				if (_inner_error_->domain == RYGEL_HTTP_SEEK_ERROR) {
-					g_propagate_error (error, _inner_error_);
-					_g_free0 (range);
-					_g_free0 (pos);
-					range_tokens = (_vala_array_free (range_tokens, range_tokens_length1, (GDestroyNotify) g_free), NULL);
-					return NULL;
-				} else {
-					_g_free0 (range);
-					_g_free0 (pos);
-					range_tokens = (_vala_array_free (range_tokens, range_tokens_length1, (GDestroyNotify) g_free), NULL);
-					g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
-					g_clear_error (&_inner_error_);
-					return NULL;
-				}
-			}
-		}
-	} else {
-		if (_vala_strcmp0 (pos, "") != 0) {
-			_inner_error_ = g_error_new (RYGEL_HTTP_SEEK_ERROR, RYGEL_HTTP_SEEK_ERROR_INVALID_RANGE, "Invalid Range '%s'", range);
-			if (_inner_error_ != NULL) {
-				if (_inner_error_->domain == RYGEL_HTTP_SEEK_ERROR) {
-					g_propagate_error (error, _inner_error_);
-					_g_free0 (range);
-					_g_free0 (pos);
-					range_tokens = (_vala_array_free (range_tokens, range_tokens_length1, (GDestroyNotify) g_free), NULL);
-					return NULL;
-				} else {
-					_g_free0 (range);
-					_g_free0 (pos);
-					range_tokens = (_vala_array_free (range_tokens, range_tokens_length1, (GDestroyNotify) g_free), NULL);
-					g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
-					g_clear_error (&_inner_error_);
-					return NULL;
-				}
-			}
-		}
-	}
-	result = rygel_http_seek_new (GST_FORMAT_BYTES, start, stop);
-	_g_free0 (range);
-	_g_free0 (pos);
-	range_tokens = (_vala_array_free (range_tokens, range_tokens_length1, (GDestroyNotify) g_free), NULL);
-	return result;
-}
-
-
-RygelHTTPSeek* rygel_http_seek_from_time_range (SoupMessage* msg, GError** error) {
-	RygelHTTPSeek* result;
-	GError * _inner_error_;
-	char* range;
-	char* time;
-	gint range_tokens_size;
-	gint range_tokens_length1;
-	char** range_tokens;
-	gint64 start;
-	gint64 stop;
-	char* _tmp0_;
-	char** _tmp2_;
-	char** _tmp1_;
-	gboolean _tmp3_ = FALSE;
-	char* _tmp4_;
-	char* _tmp5_;
-	g_return_val_if_fail (msg != NULL, NULL);
-	_inner_error_ = NULL;
-	range = NULL;
-	time = NULL;
-	range_tokens = (range_tokens_length1 = 0, NULL);
-	start = (gint64) 0;
-	stop = (gint64) (-1);
-	range = (_tmp0_ = g_strdup (soup_message_headers_get (msg->request_headers, "TimeSeekRange.dlna.org")), _g_free0 (range), _tmp0_);
-	if (range == NULL) {
-		result = NULL;
-		_g_free0 (range);
-		_g_free0 (time);
-		range_tokens = (_vala_array_free (range_tokens, range_tokens_length1, (GDestroyNotify) g_free), NULL);
-		return result;
-	}
-	if (!g_str_has_prefix (range, "npt=")) {
-		_inner_error_ = g_error_new (RYGEL_HTTP_SEEK_ERROR, RYGEL_HTTP_SEEK_ERROR_INVALID_RANGE, "Invalid Range '%s'", range);
-		if (_inner_error_ != NULL) {
-			if (_inner_error_->domain == RYGEL_HTTP_SEEK_ERROR) {
-				g_propagate_error (error, _inner_error_);
-				_g_free0 (range);
-				_g_free0 (time);
-				range_tokens = (_vala_array_free (range_tokens, range_tokens_length1, (GDestroyNotify) g_free), NULL);
-				return NULL;
-			} else {
-				_g_free0 (range);
-				_g_free0 (time);
-				range_tokens = (_vala_array_free (range_tokens, range_tokens_length1, (GDestroyNotify) g_free), NULL);
-				g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
-				g_clear_error (&_inner_error_);
-				return NULL;
-			}
-		}
-	}
-	range_tokens = (_tmp2_ = _tmp1_ = g_strsplit (g_utf8_offset_to_pointer (range, (glong) 4), "-", 2), range_tokens = (_vala_array_free (range_tokens, range_tokens_length1, (GDestroyNotify) g_free), NULL), range_tokens_length1 = _vala_array_length (_tmp1_), range_tokens_size = range_tokens_length1, _tmp2_);
-	if (range_tokens[0] == NULL) {
-		_tmp3_ = TRUE;
-	} else {
-		_tmp3_ = range_tokens[1] == NULL;
-	}
-	if (_tmp3_) {
-		_inner_error_ = g_error_new (RYGEL_HTTP_SEEK_ERROR, RYGEL_HTTP_SEEK_ERROR_INVALID_RANGE, "Invalid Range '%s'", range);
-		if (_inner_error_ != NULL) {
-			if (_inner_error_->domain == RYGEL_HTTP_SEEK_ERROR) {
-				g_propagate_error (error, _inner_error_);
-				_g_free0 (range);
-				_g_free0 (time);
-				range_tokens = (_vala_array_free (range_tokens, range_tokens_length1, (GDestroyNotify) g_free), NULL);
-				return NULL;
-			} else {
-				_g_free0 (range);
-				_g_free0 (time);
-				range_tokens = (_vala_array_free (range_tokens, range_tokens_length1, (GDestroyNotify) g_free), NULL);
-				g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
-				g_clear_error (&_inner_error_);
-				return NULL;
-			}
-		}
-	}
-	time = (_tmp4_ = g_strdup (range_tokens[0]), _g_free0 (time), _tmp4_);
-	if (g_unichar_isdigit (g_utf8_get_char (g_utf8_offset_to_pointer (time, 0)))) {
-		start = (gint64) (g_ascii_strtod (time, NULL) * GST_SECOND);
-	} else {
-		if (_vala_strcmp0 (time, "") != 0) {
-			_inner_error_ = g_error_new (RYGEL_HTTP_SEEK_ERROR, RYGEL_HTTP_SEEK_ERROR_INVALID_RANGE, "Invalid Range '%s'", range);
-			if (_inner_error_ != NULL) {
-				if (_inner_error_->domain == RYGEL_HTTP_SEEK_ERROR) {
-					g_propagate_error (error, _inner_error_);
-					_g_free0 (range);
-					_g_free0 (time);
-					range_tokens = (_vala_array_free (range_tokens, range_tokens_length1, (GDestroyNotify) g_free), NULL);
-					return NULL;
-				} else {
-					_g_free0 (range);
-					_g_free0 (time);
-					range_tokens = (_vala_array_free (range_tokens, range_tokens_length1, (GDestroyNotify) g_free), NULL);
-					g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
-					g_clear_error (&_inner_error_);
-					return NULL;
-				}
-			}
-		}
-	}
-	time = (_tmp5_ = g_strdup (range_tokens[1]), _g_free0 (time), _tmp5_);
-	if (g_unichar_isdigit (g_utf8_get_char (g_utf8_offset_to_pointer (time, 0)))) {
-		stop = (gint64) (g_ascii_strtod (time, NULL) * GST_SECOND);
-		if (stop < start) {
-			_inner_error_ = g_error_new (RYGEL_HTTP_SEEK_ERROR, RYGEL_HTTP_SEEK_ERROR_INVALID_RANGE, "Invalid Range '%s'", range);
-			if (_inner_error_ != NULL) {
-				if (_inner_error_->domain == RYGEL_HTTP_SEEK_ERROR) {
-					g_propagate_error (error, _inner_error_);
-					_g_free0 (range);
-					_g_free0 (time);
-					range_tokens = (_vala_array_free (range_tokens, range_tokens_length1, (GDestroyNotify) g_free), NULL);
-					return NULL;
-				} else {
-					_g_free0 (range);
-					_g_free0 (time);
-					range_tokens = (_vala_array_free (range_tokens, range_tokens_length1, (GDestroyNotify) g_free), NULL);
-					g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
-					g_clear_error (&_inner_error_);
-					return NULL;
-				}
-			}
-		}
-	} else {
-		if (_vala_strcmp0 (time, "") != 0) {
-			_inner_error_ = g_error_new (RYGEL_HTTP_SEEK_ERROR, RYGEL_HTTP_SEEK_ERROR_INVALID_RANGE, "Invalid Range '%s'", range);
-			if (_inner_error_ != NULL) {
-				if (_inner_error_->domain == RYGEL_HTTP_SEEK_ERROR) {
-					g_propagate_error (error, _inner_error_);
-					_g_free0 (range);
-					_g_free0 (time);
-					range_tokens = (_vala_array_free (range_tokens, range_tokens_length1, (GDestroyNotify) g_free), NULL);
-					return NULL;
-				} else {
-					_g_free0 (range);
-					_g_free0 (time);
-					range_tokens = (_vala_array_free (range_tokens, range_tokens_length1, (GDestroyNotify) g_free), NULL);
-					g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
-					g_clear_error (&_inner_error_);
-					return NULL;
-				}
-			}
-		}
-	}
-	result = rygel_http_seek_new (GST_FORMAT_TIME, start, stop);
-	_g_free0 (range);
-	_g_free0 (time);
-	range_tokens = (_vala_array_free (range_tokens, range_tokens_length1, (GDestroyNotify) g_free), NULL);
-	return result;
-}
-
-
-static char* double_to_string (double self) {
-	char* result;
-	gint _tmp0__length1;
-	gchar* _tmp0_;
-	char* _tmp1_;
-	result = (_tmp1_ = g_strdup (g_ascii_dtostr ((_tmp0_ = g_new0 (gchar, G_ASCII_DTOSTR_BUF_SIZE), _tmp0__length1 = G_ASCII_DTOSTR_BUF_SIZE, _tmp0_), G_ASCII_DTOSTR_BUF_SIZE, self)), _tmp0_ = (g_free (_tmp0_), NULL), _tmp1_);
-	return result;
-}
-
-
-void rygel_http_seek_add_response_header (RygelHTTPSeek* self, SoupMessage* msg, gint64 length) {
-	char* header;
-	char* value;
-	double start;
-	double stop = 0.0;
-	char* _tmp6_;
-	char* _tmp5_;
-	char* _tmp4_;
-	g_return_if_fail (self != NULL);
-	g_return_if_fail (msg != NULL);
-	header = NULL;
-	value = NULL;
-	start = (double) 0;
-	if (self->priv->_format == GST_FORMAT_TIME) {
-		char* _tmp0_;
-		char* _tmp1_;
-		header = (_tmp0_ = g_strdup ("TimeSeekRange.dlna.org"), _g_free0 (header), _tmp0_);
-		value = (_tmp1_ = g_strdup ("npt="), _g_free0 (value), _tmp1_);
-		start = ((double) self->priv->_start) / GST_SECOND;
-		stop = ((double) self->priv->_stop) / GST_SECOND;
-	} else {
-		char* _tmp2_;
-		char* _tmp3_;
-		header = (_tmp2_ = g_strdup ("Content-Range"), _g_free0 (header), _tmp2_);
-		value = (_tmp3_ = g_strdup ("bytes "), _g_free0 (value), _tmp3_);
-		start = (double) self->priv->_start;
-		stop = (double) self->priv->_stop;
-	}
-	if (length > 0) {
-		stop = CLAMP (stop, start + 1, ((double) length) - 1);
-	}
-	value = (_tmp6_ = g_strconcat (value, _tmp5_ = g_strconcat (_tmp4_ = double_to_string (start), "-", NULL), NULL), _g_free0 (value), _tmp6_);
-	_g_free0 (_tmp5_);
-	_g_free0 (_tmp4_);
-	if (stop >= 0.0) {
-		char* _tmp8_;
-		char* _tmp7_;
-		value = (_tmp8_ = g_strconcat (value, _tmp7_ = double_to_string (stop), NULL), _g_free0 (value), _tmp8_);
-		_g_free0 (_tmp7_);
-	}
-	if (length > 0) {
-		char* _tmp11_;
-		char* _tmp10_;
-		char* _tmp9_;
-		value = (_tmp11_ = g_strconcat (value, _tmp10_ = g_strconcat ("/", _tmp9_ = g_strdup_printf ("%lli", length), NULL), NULL), _g_free0 (value), _tmp11_);
-		_g_free0 (_tmp10_);
-		_g_free0 (_tmp9_);
-	} else {
-		char* _tmp12_;
-		value = (_tmp12_ = g_strconcat (value, "/*", NULL), _g_free0 (value), _tmp12_);
-	}
-	soup_message_headers_append (msg->response_headers, header, value);
-	_g_free0 (header);
-	_g_free0 (value);
-}
-
-
-GstFormat rygel_http_seek_get_format (RygelHTTPSeek* self) {
-	GstFormat result;
-	g_return_val_if_fail (self != NULL, 0);
-	result = self->priv->_format;
-	return result;
-}
-
-
-static void rygel_http_seek_set_format (RygelHTTPSeek* self, GstFormat value) {
-	g_return_if_fail (self != NULL);
-	self->priv->_format = value;
-	g_object_notify ((GObject *) self, "format");
-}
-
-
-gint64 rygel_http_seek_get_start (RygelHTTPSeek* self) {
-	gint64 result;
-	g_return_val_if_fail (self != NULL, 0LL);
-	result = self->priv->_start;
-	return result;
-}
-
-
-static void rygel_http_seek_set_start (RygelHTTPSeek* self, gint64 value) {
-	g_return_if_fail (self != NULL);
-	self->priv->_start = value;
-	g_object_notify ((GObject *) self, "start");
-}
-
-
-gint64 rygel_http_seek_get_stop (RygelHTTPSeek* self) {
-	gint64 result;
-	g_return_val_if_fail (self != NULL, 0LL);
-	result = self->priv->_stop;
-	return result;
-}
-
-
-static void rygel_http_seek_set_stop (RygelHTTPSeek* self, gint64 value) {
-	g_return_if_fail (self != NULL);
-	self->priv->_stop = value;
-	g_object_notify ((GObject *) self, "stop");
-}
-
-
-gint64 rygel_http_seek_get_length (RygelHTTPSeek* self) {
-	gint64 result;
-	g_return_val_if_fail (self != NULL, 0LL);
-	result = (self->priv->_stop + 1) - self->priv->_start;
-	return result;
-}
-
-
-static void rygel_http_seek_class_init (RygelHTTPSeekClass * klass) {
-	rygel_http_seek_parent_class = g_type_class_peek_parent (klass);
-	g_type_class_add_private (klass, sizeof (RygelHTTPSeekPrivate));
-	G_OBJECT_CLASS (klass)->get_property = rygel_http_seek_get_property;
-	G_OBJECT_CLASS (klass)->set_property = rygel_http_seek_set_property;
-	G_OBJECT_CLASS (klass)->finalize = rygel_http_seek_finalize;
-	g_object_class_install_property (G_OBJECT_CLASS (klass), RYGEL_HTTP_SEEK_FORMAT, g_param_spec_enum ("format", "format", "format", GST_TYPE_FORMAT, 0, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
-	g_object_class_install_property (G_OBJECT_CLASS (klass), RYGEL_HTTP_SEEK_START, g_param_spec_int64 ("start", "start", "start", G_MININT64, G_MAXINT64, 0, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
-	g_object_class_install_property (G_OBJECT_CLASS (klass), RYGEL_HTTP_SEEK_STOP, g_param_spec_int64 ("stop", "stop", "stop", G_MININT64, G_MAXINT64, 0, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
-	g_object_class_install_property (G_OBJECT_CLASS (klass), RYGEL_HTTP_SEEK_LENGTH, g_param_spec_int64 ("length", "length", "length", G_MININT64, G_MAXINT64, 0, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
-}
-
-
-static void rygel_http_seek_instance_init (RygelHTTPSeek * self) {
-	self->priv = RYGEL_HTTP_SEEK_GET_PRIVATE (self);
-}
-
-
-static void rygel_http_seek_finalize (GObject* obj) {
-	RygelHTTPSeek * self;
-	self = RYGEL_HTTP_SEEK (obj);
-	G_OBJECT_CLASS (rygel_http_seek_parent_class)->finalize (obj);
-}
-
-
-GType rygel_http_seek_get_type (void) {
-	static GType rygel_http_seek_type_id = 0;
-	if (rygel_http_seek_type_id == 0) {
-		static const GTypeInfo g_define_type_info = { sizeof (RygelHTTPSeekClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) rygel_http_seek_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (RygelHTTPSeek), 0, (GInstanceInitFunc) rygel_http_seek_instance_init, NULL };
-		rygel_http_seek_type_id = g_type_register_static (G_TYPE_OBJECT, "RygelHTTPSeek", &g_define_type_info, 0);
-	}
-	return rygel_http_seek_type_id;
-}
-
-
-static void rygel_http_seek_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
-	RygelHTTPSeek * self;
-	self = RYGEL_HTTP_SEEK (object);
-	switch (property_id) {
-		case RYGEL_HTTP_SEEK_FORMAT:
-		g_value_set_enum (value, rygel_http_seek_get_format (self));
-		break;
-		case RYGEL_HTTP_SEEK_START:
-		g_value_set_int64 (value, rygel_http_seek_get_start (self));
-		break;
-		case RYGEL_HTTP_SEEK_STOP:
-		g_value_set_int64 (value, rygel_http_seek_get_stop (self));
-		break;
-		case RYGEL_HTTP_SEEK_LENGTH:
-		g_value_set_int64 (value, rygel_http_seek_get_length (self));
-		break;
-		default:
-		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
-		break;
-	}
-}
-
-
-static void rygel_http_seek_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
-	RygelHTTPSeek * self;
-	self = RYGEL_HTTP_SEEK (object);
-	switch (property_id) {
-		case RYGEL_HTTP_SEEK_FORMAT:
-		rygel_http_seek_set_format (self, g_value_get_enum (value));
-		break;
-		case RYGEL_HTTP_SEEK_START:
-		rygel_http_seek_set_start (self, g_value_get_int64 (value));
-		break;
-		case RYGEL_HTTP_SEEK_STOP:
-		rygel_http_seek_set_stop (self, g_value_get_int64 (value));
-		break;
-		default:
-		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
-		break;
-	}
-}
-
-
-static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
-	if ((array != NULL) && (destroy_func != NULL)) {
-		int i;
-		for (i = 0; i < array_length; i = i + 1) {
-			if (((gpointer*) array)[i] != NULL) {
-				destroy_func (((gpointer*) array)[i]);
-			}
-		}
-	}
-}
-
-
-static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
-	_vala_array_destroy (array, array_length, destroy_func);
-	g_free (array);
-}
-
-
-static gint _vala_array_length (gpointer array) {
-	int length;
-	length = 0;
-	if (array) {
-		while (((gpointer*) array)[length]) {
-			length++;
-		}
-	}
-	return length;
-}
-
-
-static int _vala_strcmp0 (const char * str1, const char * str2) {
-	if (str1 == NULL) {
-		return -(str1 != str2);
-	}
-	if (str2 == NULL) {
-		return str1 != str2;
-	}
-	return strcmp (str1, str2);
-}
-
-
-
-
--- a/src/rygel/rygel-http-seek.vala
+++ /dev/null
@@ -1,184 +0,0 @@
-/*
- * Copyright (C) 2008 Nokia Corporation.
- *
- * Author: Zeeshan Ali (Khattak) <zeeshanak@gnome.org>
- *                               <zeeshan.ali@nokia.com>
- *
- * This file is part of Rygel.
- *
- * Rygel is free software; you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * Rygel is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this program; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
- */
-
-using Gst;
-
-internal errordomain Rygel.HTTPSeekError {
-    INVALID_RANGE = Soup.KnownStatusCode.BAD_REQUEST,
-    OUT_OF_RANGE = Soup.KnownStatusCode.REQUESTED_RANGE_NOT_SATISFIABLE,
-}
-
-internal class Rygel.HTTPSeek : GLib.Object {
-    public Format format { get; private set; }
-
-    // These are either number of bytes or microseconds
-    public int64 start { get; private set; }
-    public int64 stop { get; private set; }
-
-    public int64 length {
-        get {
-            return this.stop + 1 - this.start;
-        }
-    }
-
-    public HTTPSeek (Format format,
-                     int64  start,
-                     int64  stop) {
-        this.format = format;
-        this.start = start;
-        this.stop = stop;
-    }
-
-    public static HTTPSeek? from_byte_range (Soup.Message msg)
-                                             throws HTTPSeekError {
-        string range, pos;
-        string[] range_tokens;
-        int64 start = 0, stop = -1;
-
-        range = msg.request_headers.get ("Range");
-        if (range == null) {
-            return null;
-        }
-
-        // We have a Range header. Parse.
-        if (!range.has_prefix ("bytes=")) {
-            throw new HTTPSeekError.INVALID_RANGE ("Invalid Range '%s'", range);
-        }
-
-        range_tokens = range.offset (6).split ("-", 2);
-        if (range_tokens[0] == null || range_tokens[1] == null) {
-            throw new HTTPSeekError.INVALID_RANGE ("Invalid Range '%s'", range);
-        }
-
-        // Get first byte position
-        pos = range_tokens[0];
-        if (pos[0].isdigit ()) {
-            start = pos.to_int64 ();
-        } else if (pos  != "") {
-            throw new HTTPSeekError.INVALID_RANGE ("Invalid Range '%s'", range);
-        }
-
-        // Get last byte position if specified
-        pos = range_tokens[1];
-        if (pos[0].isdigit ()) {
-            stop = pos.to_int64 ();
-            if (stop < start) {
-                throw new HTTPSeekError.INVALID_RANGE ("Invalid Range '%s'",
-                                                       range);
-            }
-        } else if (pos != "") {
-            throw new HTTPSeekError.INVALID_RANGE ("Invalid Range '%s'", range);
-        }
-
-        return new HTTPSeek (Format.BYTES, start, stop);
-    }
-
-    // FIXME: We are only accepting time range in this format:
-    //
-    // TimeSeekRange.dlna.org : npt=417.33-779.09
-    //
-    // and not
-    //
-    // TimeSeekRange.dlna.org : npt=10:19:25.7-13:23:33.6
-    public static HTTPSeek? from_time_range (Soup.Message msg)
-                                             throws HTTPSeekError {
-        string range, time;
-        string[] range_tokens;
-        int64 start = 0, stop = -1;
-
-        range = msg.request_headers.get ("TimeSeekRange.dlna.org");
-        if (range == null) {
-            return null;
-        }
-
-        if (!range.has_prefix ("npt=")) {
-            throw new HTTPSeekError.INVALID_RANGE ("Invalid Range '%s'", range);
-        }
-
-        range_tokens = range.offset (4).split ("-", 2);
-        if (range_tokens[0] == null || range_tokens[1] == null) {
-            throw new HTTPSeekError.INVALID_RANGE ("Invalid Range '%s'", range);
-        }
-
-        // Get start time
-        time = range_tokens[0];
-        if (time[0].isdigit ()) {
-            start = (int64) (time.to_double () * SECOND);
-        } else if (time != "") {
-            throw new HTTPSeekError.INVALID_RANGE ("Invalid Range '%s'", range);
-        }
-
-        // Get end time
-        time = range_tokens[1];
-        if (time[0].isdigit()) {
-            stop = (int64) (time.to_double () * SECOND);
-            if (stop < start) {
-                throw new HTTPSeekError.INVALID_RANGE ("Invalid Range '%s'",
-                                                       range);
-            }
-        } else if (time != "") {
-            throw new HTTPSeekError.INVALID_RANGE ("Invalid Range '%s'", range);
-        }
-
-        return new HTTPSeek (Format.TIME, start, stop);
-    }
-
-    public void add_response_header (Soup.Message msg, int64 length) {
-        string header;
-        string value;
-        double start = 0;
-        double stop;
-
-        if (this.format == Format.TIME) {
-            // TimeSeekRange.dlna.org: npt=START_TIME-END_TIME/DURATION
-            header = "TimeSeekRange.dlna.org";
-            value = "npt=";
-            start = (double) this.start / SECOND;
-            stop = (double) this.stop / SECOND;
-        } else {
-            // Content-Range: bytes START_BYTE-STOP_BYTE/TOTAL_LENGTH
-            header = "Content-Range";
-            value = "bytes ";
-            start = (double) this.start;
-            stop = (double) this.stop;
-        }
-
-        if (length > 0) {
-            stop = stop.clamp (start + 1, (double) length - 1);
-        }
-
-        value += start.to_string () + "-";
-
-        if (stop >= 0.0) {
-            value += stop.to_string();
-        }
-
-        if (length > 0) {
-            value += "/" + length.to_string();
-        } else {
-            value += "/*";
-        }
-
-        msg.response_headers.append (header, value);
-    }
-}
--- a/src/rygel/rygel-http-server.c
+++ /dev/null
@@ -1,769 +0,0 @@
-/* rygel-http-server.c generated by valac, the Vala compiler
- * generated from rygel-http-server.vala, do not modify */
-
-/*
- * Copyright (C) 2008, 2009 Nokia Corporation.
- *
- * Author: Zeeshan Ali (Khattak) <zeeshanak@gnome.org>
- *                               <zeeshan.ali@nokia.com>
- *
- * This file is part of Rygel.
- *
- * Rygel is free software; you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * Rygel is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this program; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
- */
-
-#include <glib.h>
-#include <glib-object.h>
-#include <stdlib.h>
-#include <string.h>
-#include <libgupnp-av/gupnp-av.h>
-#include <gio/gio.h>
-#include <libgupnp/gupnp.h>
-#include <gee.h>
-#include <libsoup/soup.h>
-#include <gst/gst.h>
-#include <libgssdp/gssdp.h>
-
-
-#define RYGEL_TYPE_TRANSCODE_MANAGER (rygel_transcode_manager_get_type ())
-#define RYGEL_TRANSCODE_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_TRANSCODE_MANAGER, RygelTranscodeManager))
-#define RYGEL_TRANSCODE_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_TRANSCODE_MANAGER, RygelTranscodeManagerClass))
-#define RYGEL_IS_TRANSCODE_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_TRANSCODE_MANAGER))
-#define RYGEL_IS_TRANSCODE_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_TRANSCODE_MANAGER))
-#define RYGEL_TRANSCODE_MANAGER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_TRANSCODE_MANAGER, RygelTranscodeManagerClass))
-
-typedef struct _RygelTranscodeManager RygelTranscodeManager;
-typedef struct _RygelTranscodeManagerClass RygelTranscodeManagerClass;
-typedef struct _RygelTranscodeManagerPrivate RygelTranscodeManagerPrivate;
-
-#define RYGEL_TYPE_MEDIA_OBJECT (rygel_media_object_get_type ())
-#define RYGEL_MEDIA_OBJECT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_MEDIA_OBJECT, RygelMediaObject))
-#define RYGEL_MEDIA_OBJECT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_MEDIA_OBJECT, RygelMediaObjectClass))
-#define RYGEL_IS_MEDIA_OBJECT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_MEDIA_OBJECT))
-#define RYGEL_IS_MEDIA_OBJECT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_MEDIA_OBJECT))
-#define RYGEL_MEDIA_OBJECT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_MEDIA_OBJECT, RygelMediaObjectClass))
-
-typedef struct _RygelMediaObject RygelMediaObject;
-typedef struct _RygelMediaObjectClass RygelMediaObjectClass;
-
-#define RYGEL_TYPE_MEDIA_ITEM (rygel_media_item_get_type ())
-#define RYGEL_MEDIA_ITEM(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_MEDIA_ITEM, RygelMediaItem))
-#define RYGEL_MEDIA_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_MEDIA_ITEM, RygelMediaItemClass))
-#define RYGEL_IS_MEDIA_ITEM(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_MEDIA_ITEM))
-#define RYGEL_IS_MEDIA_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_MEDIA_ITEM))
-#define RYGEL_MEDIA_ITEM_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_MEDIA_ITEM, RygelMediaItemClass))
-
-typedef struct _RygelMediaItem RygelMediaItem;
-typedef struct _RygelMediaItemClass RygelMediaItemClass;
-
-#define RYGEL_TYPE_STATE_MACHINE (rygel_state_machine_get_type ())
-#define RYGEL_STATE_MACHINE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_STATE_MACHINE, RygelStateMachine))
-#define RYGEL_IS_STATE_MACHINE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_STATE_MACHINE))
-#define RYGEL_STATE_MACHINE_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), RYGEL_TYPE_STATE_MACHINE, RygelStateMachineIface))
-
-typedef struct _RygelStateMachine RygelStateMachine;
-typedef struct _RygelStateMachineIface RygelStateMachineIface;
-
-#define RYGEL_TYPE_HTTP_SERVER (rygel_http_server_get_type ())
-#define RYGEL_HTTP_SERVER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_HTTP_SERVER, RygelHTTPServer))
-#define RYGEL_HTTP_SERVER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_HTTP_SERVER, RygelHTTPServerClass))
-#define RYGEL_IS_HTTP_SERVER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_HTTP_SERVER))
-#define RYGEL_IS_HTTP_SERVER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_HTTP_SERVER))
-#define RYGEL_HTTP_SERVER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_HTTP_SERVER, RygelHTTPServerClass))
-
-typedef struct _RygelHTTPServer RygelHTTPServer;
-typedef struct _RygelHTTPServerClass RygelHTTPServerClass;
-typedef struct _RygelHTTPServerPrivate RygelHTTPServerPrivate;
-
-#define RYGEL_TYPE_MEDIA_CONTAINER (rygel_media_container_get_type ())
-#define RYGEL_MEDIA_CONTAINER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_MEDIA_CONTAINER, RygelMediaContainer))
-#define RYGEL_MEDIA_CONTAINER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_MEDIA_CONTAINER, RygelMediaContainerClass))
-#define RYGEL_IS_MEDIA_CONTAINER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_MEDIA_CONTAINER))
-#define RYGEL_IS_MEDIA_CONTAINER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_MEDIA_CONTAINER))
-#define RYGEL_MEDIA_CONTAINER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_MEDIA_CONTAINER, RygelMediaContainerClass))
-
-typedef struct _RygelMediaContainer RygelMediaContainer;
-typedef struct _RygelMediaContainerClass RygelMediaContainerClass;
-
-#define RYGEL_TYPE_HTTP_REQUEST (rygel_http_request_get_type ())
-#define RYGEL_HTTP_REQUEST(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_HTTP_REQUEST, RygelHTTPRequest))
-#define RYGEL_HTTP_REQUEST_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_HTTP_REQUEST, RygelHTTPRequestClass))
-#define RYGEL_IS_HTTP_REQUEST(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_HTTP_REQUEST))
-#define RYGEL_IS_HTTP_REQUEST_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_HTTP_REQUEST))
-#define RYGEL_HTTP_REQUEST_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_HTTP_REQUEST, RygelHTTPRequestClass))
-
-typedef struct _RygelHTTPRequest RygelHTTPRequest;
-typedef struct _RygelHTTPRequestClass RygelHTTPRequestClass;
-#define _g_free0(var) (var = (g_free (var), NULL))
-#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
-
-#define RYGEL_TYPE_CONTENT_DIRECTORY (rygel_content_directory_get_type ())
-#define RYGEL_CONTENT_DIRECTORY(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_CONTENT_DIRECTORY, RygelContentDirectory))
-#define RYGEL_CONTENT_DIRECTORY_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_CONTENT_DIRECTORY, RygelContentDirectoryClass))
-#define RYGEL_IS_CONTENT_DIRECTORY(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_CONTENT_DIRECTORY))
-#define RYGEL_IS_CONTENT_DIRECTORY_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_CONTENT_DIRECTORY))
-#define RYGEL_CONTENT_DIRECTORY_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_CONTENT_DIRECTORY, RygelContentDirectoryClass))
-
-typedef struct _RygelContentDirectory RygelContentDirectory;
-typedef struct _RygelContentDirectoryClass RygelContentDirectoryClass;
-typedef struct _RygelContentDirectoryPrivate RygelContentDirectoryPrivate;
-typedef struct _RygelMediaObjectPrivate RygelMediaObjectPrivate;
-typedef struct _RygelMediaItemPrivate RygelMediaItemPrivate;
-
-#define RYGEL_TYPE_ICON_INFO (rygel_icon_info_get_type ())
-#define RYGEL_ICON_INFO(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_ICON_INFO, RygelIconInfo))
-#define RYGEL_ICON_INFO_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_ICON_INFO, RygelIconInfoClass))
-#define RYGEL_IS_ICON_INFO(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_ICON_INFO))
-#define RYGEL_IS_ICON_INFO_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_ICON_INFO))
-#define RYGEL_ICON_INFO_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_ICON_INFO, RygelIconInfoClass))
-
-typedef struct _RygelIconInfo RygelIconInfo;
-typedef struct _RygelIconInfoClass RygelIconInfoClass;
-
-#define RYGEL_TYPE_THUMBNAIL (rygel_thumbnail_get_type ())
-#define RYGEL_THUMBNAIL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_THUMBNAIL, RygelThumbnail))
-#define RYGEL_THUMBNAIL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_THUMBNAIL, RygelThumbnailClass))
-#define RYGEL_IS_THUMBNAIL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_THUMBNAIL))
-#define RYGEL_IS_THUMBNAIL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_THUMBNAIL))
-#define RYGEL_THUMBNAIL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_THUMBNAIL, RygelThumbnailClass))
-
-typedef struct _RygelThumbnail RygelThumbnail;
-typedef struct _RygelThumbnailClass RygelThumbnailClass;
-typedef struct _RygelIconInfoPrivate RygelIconInfoPrivate;
-typedef struct _RygelThumbnailPrivate RygelThumbnailPrivate;
-#define _rygel_icon_info_unref0(var) ((var == NULL) ? NULL : (var = (rygel_icon_info_unref (var), NULL)))
-typedef struct _RygelHTTPRequestPrivate RygelHTTPRequestPrivate;
-
-#define RYGEL_TYPE_HTTP_SEEK (rygel_http_seek_get_type ())
-#define RYGEL_HTTP_SEEK(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_HTTP_SEEK, RygelHTTPSeek))
-#define RYGEL_HTTP_SEEK_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_HTTP_SEEK, RygelHTTPSeekClass))
-#define RYGEL_IS_HTTP_SEEK(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_HTTP_SEEK))
-#define RYGEL_IS_HTTP_SEEK_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_HTTP_SEEK))
-#define RYGEL_HTTP_SEEK_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_HTTP_SEEK, RygelHTTPSeekClass))
-
-typedef struct _RygelHTTPSeek RygelHTTPSeek;
-typedef struct _RygelHTTPSeekClass RygelHTTPSeekClass;
-
-struct _RygelTranscodeManager {
-	GObject parent_instance;
-	RygelTranscodeManagerPrivate * priv;
-};
-
-struct _RygelTranscodeManagerClass {
-	GObjectClass parent_class;
-	char* (*create_uri_for_item) (RygelTranscodeManager* self, RygelMediaItem* item, gint thumbnail_index, const char* transcode_target, char** protocol);
-	void (*add_resources) (RygelTranscodeManager* self, GUPnPDIDLLiteItem* didl_item, RygelMediaItem* item, GError** error);
-	char* (*get_protocol) (RygelTranscodeManager* self);
-	char* (*get_protocol_info) (RygelTranscodeManager* self);
-};
-
-struct _RygelStateMachineIface {
-	GTypeInterface parent_iface;
-	void (*run) (RygelStateMachine* self);
-	GCancellable* (*get_cancellable) (RygelStateMachine* self);
-	void (*set_cancellable) (RygelStateMachine* self, GCancellable* value);
-};
-
-struct _RygelHTTPServer {
-	RygelTranscodeManager parent_instance;
-	RygelHTTPServerPrivate * priv;
-	RygelMediaContainer* root_container;
-	GUPnPContext* context;
-};
-
-struct _RygelHTTPServerClass {
-	RygelTranscodeManagerClass parent_class;
-};
-
-struct _RygelHTTPServerPrivate {
-	char* path_root;
-	GeeArrayList* requests;
-	GCancellable* _cancellable;
-};
-
-struct _RygelContentDirectory {
-	GUPnPService parent_instance;
-	RygelContentDirectoryPrivate * priv;
-	char* feature_list;
-	char* search_caps;
-	char* sort_caps;
-	RygelHTTPServer* http_server;
-	RygelMediaContainer* root_container;
-	GCancellable* cancellable;
-	guint32 system_update_id;
-};
-
-struct _RygelContentDirectoryClass {
-	GUPnPServiceClass parent_class;
-	RygelMediaContainer* (*create_root_container) (RygelContentDirectory* self);
-	void (*browse_cb) (RygelContentDirectory* self, RygelContentDirectory* content_dir, GUPnPServiceAction* action);
-};
-
-struct _RygelMediaObject {
-	GObject parent_instance;
-	RygelMediaObjectPrivate * priv;
-	char* id;
-	char* title;
-	guint64 modified;
-	GeeArrayList* uris;
-	RygelMediaContainer* parent;
-	RygelMediaContainer* parent_ref;
-};
-
-struct _RygelMediaObjectClass {
-	GObjectClass parent_class;
-};
-
-struct _RygelMediaItem {
-	RygelMediaObject parent_instance;
-	RygelMediaItemPrivate * priv;
-	char* author;
-	char* album;
-	char* date;
-	char* upnp_class;
-	char* mime_type;
-	char* dlna_profile;
-	glong size;
-	glong duration;
-	gint bitrate;
-	gint sample_freq;
-	gint bits_per_sample;
-	gint n_audio_channels;
-	gint track_number;
-	gint width;
-	gint height;
-	gint pixel_width;
-	gint pixel_height;
-	gint color_depth;
-	GeeArrayList* thumbnails;
-};
-
-struct _RygelMediaItemClass {
-	RygelMediaObjectClass parent_class;
-	GstElement* (*create_stream_source) (RygelMediaItem* self);
-	gboolean (*should_stream) (RygelMediaItem* self);
-};
-
-struct _RygelIconInfo {
-	GTypeInstance parent_instance;
-	volatile int ref_count;
-	RygelIconInfoPrivate * priv;
-	char* mime_type;
-	char* path;
-	glong size;
-	gint width;
-	gint height;
-	gint depth;
-};
-
-struct _RygelIconInfoClass {
-	GTypeClass parent_class;
-	void (*finalize) (RygelIconInfo *self);
-};
-
-struct _RygelThumbnail {
-	RygelIconInfo parent_instance;
-	RygelThumbnailPrivate * priv;
-	char* uri;
-	char* dlna_profile;
-};
-
-struct _RygelThumbnailClass {
-	RygelIconInfoClass parent_class;
-};
-
-struct _RygelHTTPRequest {
-	GObject parent_instance;
-	RygelHTTPRequestPrivate * priv;
-	RygelHTTPServer* http_server;
-	SoupServer* server;
-	SoupMessage* msg;
-	RygelMediaItem* item;
-	RygelThumbnail* thumbnail;
-	RygelHTTPSeek* byte_range;
-	RygelHTTPSeek* time_range;
-};
-
-struct _RygelHTTPRequestClass {
-	GObjectClass parent_class;
-};
-
-
-static gpointer rygel_http_server_parent_class = NULL;
-static RygelStateMachineIface* rygel_http_server_rygel_state_machine_parent_iface = NULL;
-
-GType rygel_transcode_manager_get_type (void);
-GType rygel_media_object_get_type (void);
-GType rygel_media_item_get_type (void);
-GType rygel_state_machine_get_type (void);
-GType rygel_http_server_get_type (void);
-GType rygel_media_container_get_type (void);
-GType rygel_http_request_get_type (void);
-#define RYGEL_HTTP_SERVER_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), RYGEL_TYPE_HTTP_SERVER, RygelHTTPServerPrivate))
-enum  {
-	RYGEL_HTTP_SERVER_DUMMY_PROPERTY,
-	RYGEL_HTTP_SERVER_CANCELLABLE
-};
-#define RYGEL_HTTP_SERVER_SERVER_PATH_PREFIX "/RygelHTTPServer"
-RygelTranscodeManager* rygel_transcode_manager_construct (GType object_type, GError** error);
-GType rygel_content_directory_get_type (void);
-void rygel_state_machine_set_cancellable (RygelStateMachine* self, GCancellable* value);
-RygelHTTPServer* rygel_http_server_new (RygelContentDirectory* content_dir, const char* name, GError** error);
-RygelHTTPServer* rygel_http_server_construct (GType object_type, RygelContentDirectory* content_dir, const char* name, GError** error);
-static void rygel_http_server_server_handler (RygelHTTPServer* self, SoupServer* server, SoupMessage* msg, const char* server_path, GHashTable* query, SoupClientContext* soup_client);
-static void _rygel_http_server_server_handler_soup_server_callback (SoupServer* server, SoupMessage* msg, const char* path, GHashTable* query, SoupClientContext* client, gpointer self);
-GCancellable* rygel_state_machine_get_cancellable (RygelStateMachine* self);
-static void rygel_http_server_on_cancelled (RygelHTTPServer* self, GCancellable* cancellable);
-static void _rygel_http_server_on_cancelled_g_cancellable_cancelled (GCancellable* _sender, gpointer self);
-static void rygel_http_server_real_run (RygelStateMachine* base);
-static gboolean rygel_http_server_http_uri_present (RygelHTTPServer* self, RygelMediaItem* item);
-char* rygel_transcode_manager_create_uri_for_item (RygelTranscodeManager* self, RygelMediaItem* item, gint thumbnail_index, const char* transcode_target, char** protocol);
-GUPnPDIDLLiteResource* rygel_media_item_add_resource (RygelMediaItem* self, GUPnPDIDLLiteItem* didl_item, const char* uri, const char* protocol, GError** error);
-void rygel_transcode_manager_add_resources (RygelTranscodeManager* self, GUPnPDIDLLiteItem* didl_item, RygelMediaItem* item, GError** error);
-gpointer rygel_icon_info_ref (gpointer instance);
-void rygel_icon_info_unref (gpointer instance);
-GParamSpec* rygel_param_spec_icon_info (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
-void rygel_value_set_icon_info (GValue* value, gpointer v_object);
-gpointer rygel_value_get_icon_info (const GValue* value);
-GType rygel_icon_info_get_type (void);
-GType rygel_thumbnail_get_type (void);
-static gboolean rygel_http_server_is_http_uri (RygelHTTPServer* self, const char* uri);
-GUPnPDIDLLiteResource* rygel_thumbnail_add_resource (RygelThumbnail* self, GUPnPDIDLLiteItem* didl_item, const char* protocol);
-static void rygel_http_server_real_add_resources (RygelTranscodeManager* base, GUPnPDIDLLiteItem* didl_item, RygelMediaItem* item, GError** error);
-static char* rygel_http_server_create_uri_for_path (RygelHTTPServer* self, const char* path);
-static char* rygel_http_server_real_create_uri_for_item (RygelTranscodeManager* base, RygelMediaItem* item, gint thumbnail_index, const char* transcode_target, char** protocol);
-static char* rygel_http_server_real_get_protocol (RygelTranscodeManager* base);
-char* rygel_transcode_manager_get_protocol (RygelTranscodeManager* self);
-char* rygel_transcode_manager_get_protocol_info (RygelTranscodeManager* self);
-static char* rygel_http_server_real_get_protocol_info (RygelTranscodeManager* base);
-GType rygel_http_seek_get_type (void);
-static void rygel_http_server_on_request_completed (RygelHTTPServer* self, RygelHTTPRequest* request);
-static void _lambda1_ (const char* name, const char* value, RygelHTTPServer* self);
-static void __lambda1__soup_message_headers_foreach_func (const char* name, const char* value, gpointer self);
-RygelHTTPRequest* rygel_http_request_new (RygelHTTPServer* http_server, SoupServer* server, SoupMessage* msg, GHashTable* query);
-RygelHTTPRequest* rygel_http_request_construct (GType object_type, RygelHTTPServer* http_server, SoupServer* server, SoupMessage* msg, GHashTable* query);
-static void _rygel_http_server_on_request_completed_rygel_state_machine_completed (RygelHTTPRequest* _sender, gpointer self);
-void rygel_state_machine_run (RygelStateMachine* self);
-static void rygel_http_server_finalize (GObject* obj);
-static void rygel_http_server_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
-static void rygel_http_server_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);
-static int _vala_strcmp0 (const char * str1, const char * str2);
-
-
-
-static gpointer _g_object_ref0 (gpointer self) {
-	return self ? g_object_ref (self) : NULL;
-}
-
-
-RygelHTTPServer* rygel_http_server_construct (GType object_type, RygelContentDirectory* content_dir, const char* name, GError** error) {
-	RygelHTTPServer * self;
-	RygelMediaContainer* _tmp0_;
-	GUPnPContext* _tmp1_;
-	GeeArrayList* _tmp2_;
-	char* _tmp3_;
-	g_return_val_if_fail (content_dir != NULL, NULL);
-	g_return_val_if_fail (name != NULL, NULL);
-	self = (RygelHTTPServer*) rygel_transcode_manager_construct (object_type, error);
-	self->root_container = (_tmp0_ = _g_object_ref0 (content_dir->root_container), _g_object_unref0 (self->root_container), _tmp0_);
-	self->context = (_tmp1_ = _g_object_ref0 (gupnp_service_info_get_context ((GUPnPServiceInfo*) content_dir)), _g_object_unref0 (self->context), _tmp1_);
-	rygel_state_machine_set_cancellable ((RygelStateMachine*) self, content_dir->cancellable);
-	self->priv->requests = (_tmp2_ = gee_array_list_new (RYGEL_TYPE_HTTP_REQUEST, (GBoxedCopyFunc) g_object_ref, g_object_unref, g_direct_equal), _g_object_unref0 (self->priv->requests), _tmp2_);
-	self->priv->path_root = (_tmp3_ = g_strconcat (RYGEL_HTTP_SERVER_SERVER_PATH_PREFIX "/", name, NULL), _g_free0 (self->priv->path_root), _tmp3_);
-	return self;
-}
-
-
-RygelHTTPServer* rygel_http_server_new (RygelContentDirectory* content_dir, const char* name, GError** error) {
-	return rygel_http_server_construct (RYGEL_TYPE_HTTP_SERVER, content_dir, name, error);
-}
-
-
-static void _rygel_http_server_server_handler_soup_server_callback (SoupServer* server, SoupMessage* msg, const char* path, GHashTable* query, SoupClientContext* client, gpointer self) {
-	rygel_http_server_server_handler (self, server, msg, path, query, client);
-}
-
-
-static void _rygel_http_server_on_cancelled_g_cancellable_cancelled (GCancellable* _sender, gpointer self) {
-	rygel_http_server_on_cancelled (self, _sender);
-}
-
-
-static void rygel_http_server_real_run (RygelStateMachine* base) {
-	RygelHTTPServer * self;
-	self = (RygelHTTPServer*) base;
-	soup_server_add_handler (gupnp_context_get_server (self->context), self->priv->path_root, _rygel_http_server_server_handler_soup_server_callback, g_object_ref (self), g_object_unref);
-	if (rygel_state_machine_get_cancellable ((RygelStateMachine*) self) != NULL) {
-		g_signal_connect_object (rygel_state_machine_get_cancellable ((RygelStateMachine*) self), "cancelled", (GCallback) _rygel_http_server_on_cancelled_g_cancellable_cancelled, self, 0);
-	}
-}
-
-
-static void rygel_http_server_real_add_resources (RygelTranscodeManager* base, GUPnPDIDLLiteItem* didl_item, RygelMediaItem* item, GError** error) {
-	RygelHTTPServer * self;
-	GError * _inner_error_;
-	self = (RygelHTTPServer*) base;
-	g_return_if_fail (didl_item != NULL);
-	g_return_if_fail (item != NULL);
-	_inner_error_ = NULL;
-	if (!rygel_http_server_http_uri_present (self, item)) {
-		char* protocol;
-		char* _tmp2_;
-		char* _tmp1_;
-		char* _tmp0_ = NULL;
-		char* uri;
-		GUPnPDIDLLiteResource* _tmp3_;
-		protocol = NULL;
-		uri = (_tmp1_ = rygel_transcode_manager_create_uri_for_item ((RygelTranscodeManager*) self, item, -1, NULL, &_tmp0_), protocol = (_tmp2_ = _tmp0_, _g_free0 (protocol), _tmp2_), _tmp1_);
-		_tmp3_ = rygel_media_item_add_resource (item, didl_item, uri, protocol, &_inner_error_);
-		if (_inner_error_ != NULL) {
-			g_propagate_error (error, _inner_error_);
-			_g_free0 (protocol);
-			_g_free0 (uri);
-			return;
-		}
-		_g_object_unref0 (_tmp3_);
-		_g_free0 (protocol);
-		_g_free0 (uri);
-	}
-	RYGEL_TRANSCODE_MANAGER_CLASS (rygel_http_server_parent_class)->add_resources (RYGEL_TRANSCODE_MANAGER (self), didl_item, item, &_inner_error_);
-	if (_inner_error_ != NULL) {
-		g_propagate_error (error, _inner_error_);
-		return;
-	}
-	{
-		GeeIterator* _thumbnail_it;
-		_thumbnail_it = gee_abstract_collection_iterator ((GeeAbstractCollection*) item->thumbnails);
-		while (TRUE) {
-			RygelThumbnail* thumbnail;
-			if (!gee_iterator_next (_thumbnail_it)) {
-				break;
-			}
-			thumbnail = (RygelThumbnail*) gee_iterator_get (_thumbnail_it);
-			if (!rygel_http_server_is_http_uri (self, thumbnail->uri)) {
-				char* uri;
-				gint index;
-				char* protocol;
-				char* _tmp7_;
-				char* _tmp6_;
-				char* _tmp5_;
-				char* _tmp4_ = NULL;
-				GUPnPDIDLLiteResource* _tmp8_;
-				char* _tmp9_;
-				uri = g_strdup (thumbnail->uri);
-				index = gee_abstract_list_index_of ((GeeAbstractList*) item->thumbnails, thumbnail);
-				protocol = NULL;
-				thumbnail->uri = (_tmp7_ = (_tmp5_ = rygel_transcode_manager_create_uri_for_item ((RygelTranscodeManager*) self, item, index, NULL, &_tmp4_), protocol = (_tmp6_ = _tmp4_, _g_free0 (protocol), _tmp6_), _tmp5_), _g_free0 (thumbnail->uri), _tmp7_);
-				_tmp8_ = rygel_thumbnail_add_resource (thumbnail, didl_item, protocol);
-				_g_object_unref0 (_tmp8_);
-				thumbnail->uri = (_tmp9_ = g_strdup (uri), _g_free0 (thumbnail->uri), _tmp9_);
-				_g_free0 (uri);
-				_g_free0 (protocol);
-			}
-			_rygel_icon_info_unref0 (thumbnail);
-		}
-		_g_object_unref0 (_thumbnail_it);
-	}
-}
-
-
-static gboolean rygel_http_server_http_uri_present (RygelHTTPServer* self, RygelMediaItem* item) {
-	gboolean result;
-	gboolean present;
-	g_return_val_if_fail (self != NULL, FALSE);
-	g_return_val_if_fail (item != NULL, FALSE);
-	present = FALSE;
-	{
-		GeeIterator* _uri_it;
-		_uri_it = gee_abstract_collection_iterator ((GeeAbstractCollection*) ((RygelMediaObject*) item)->uris);
-		while (TRUE) {
-			char* uri;
-			if (!gee_iterator_next (_uri_it)) {
-				break;
-			}
-			uri = (char*) gee_iterator_get (_uri_it);
-			if (rygel_http_server_is_http_uri (self, uri)) {
-				present = TRUE;
-				_g_free0 (uri);
-				break;
-			}
-			_g_free0 (uri);
-		}
-		_g_object_unref0 (_uri_it);
-	}
-	result = present;
-	return result;
-}
-
-
-static gboolean rygel_http_server_is_http_uri (RygelHTTPServer* self, const char* uri) {
-	gboolean result;
-	char* _tmp0_;
-	gboolean _tmp1_;
-	g_return_val_if_fail (self != NULL, FALSE);
-	g_return_val_if_fail (uri != NULL, FALSE);
-	result = (_tmp1_ = _vala_strcmp0 (_tmp0_ = g_uri_parse_scheme (uri), "http") == 0, _g_free0 (_tmp0_), _tmp1_);
-	return result;
-}
-
-
-static void rygel_http_server_on_cancelled (RygelHTTPServer* self, GCancellable* cancellable) {
-	g_return_if_fail (self != NULL);
-	g_return_if_fail (cancellable != NULL);
-	g_cancellable_cancel (rygel_state_machine_get_cancellable ((RygelStateMachine*) self));
-	soup_server_remove_handler (gupnp_context_get_server (self->context), self->priv->path_root);
-	g_signal_emit_by_name ((RygelStateMachine*) self, "completed");
-}
-
-
-static char* rygel_http_server_create_uri_for_path (RygelHTTPServer* self, const char* path) {
-	char* result;
-	g_return_val_if_fail (self != NULL, NULL);
-	g_return_val_if_fail (path != NULL, NULL);
-	result = g_strdup_printf ("http://%s:%u%s%s", gssdp_client_get_host_ip ((GSSDPClient*) self->context), gupnp_context_get_port (self->context), self->priv->path_root, path);
-	return result;
-}
-
-
-static char* rygel_http_server_real_create_uri_for_item (RygelTranscodeManager* base, RygelMediaItem* item, gint thumbnail_index, const char* transcode_target, char** protocol) {
-	RygelHTTPServer * self;
-	char* result;
-	char* escaped;
-	char* query;
-	char* _tmp6_;
-	self = (RygelHTTPServer*) base;
-	g_return_val_if_fail (item != NULL, NULL);
-	if (protocol != NULL) {
-		*protocol = NULL;
-	}
-	escaped = g_uri_escape_string (((RygelMediaObject*) item)->id, "", TRUE);
-	query = g_strconcat ("?itemid=", escaped, NULL);
-	if (thumbnail_index >= 0) {
-		char* _tmp2_;
-		char* _tmp1_;
-		char* _tmp0_;
-		query = (_tmp2_ = g_strconcat (query, _tmp1_ = g_strconcat ("&thumbnail=", _tmp0_ = g_strdup_printf ("%i", thumbnail_index), NULL), NULL), _g_free0 (query), _tmp2_);
-		_g_free0 (_tmp1_);
-		_g_free0 (_tmp0_);
-	}
-	if (transcode_target != NULL) {
-		char* _tmp3_;
-		char* _tmp5_;
-		char* _tmp4_;
-		escaped = (_tmp3_ = g_uri_escape_string (transcode_target, "", TRUE), _g_free0 (escaped), _tmp3_);
-		query = (_tmp5_ = g_strconcat (query, _tmp4_ = g_strconcat ("&transcode=", escaped, NULL), NULL), _g_free0 (query), _tmp5_);
-		_g_free0 (_tmp4_);
-	}
-	*protocol = (_tmp6_ = g_strdup ("http-get"), _g_free0 (*protocol), _tmp6_);
-	result = rygel_http_server_create_uri_for_path (self, query);
-	_g_free0 (escaped);
-	_g_free0 (query);
-	return result;
-}
-
-
-static char* rygel_http_server_real_get_protocol (RygelTranscodeManager* base) {
-	RygelHTTPServer * self;
-	char* result;
-	self = (RygelHTTPServer*) base;
-	result = g_strdup ("http-get");
-	return result;
-}
-
-
-static char* rygel_http_server_real_get_protocol_info (RygelTranscodeManager* base) {
-	RygelHTTPServer * self;
-	char* result;
-	char* _tmp0_;
-	char* _tmp1_;
-	char* protocol_info;
-	char* base_info;
-	self = (RygelHTTPServer*) base;
-	protocol_info = (_tmp1_ = g_strconcat (_tmp0_ = rygel_transcode_manager_get_protocol ((RygelTranscodeManager*) self), ":*:*:*", NULL), _g_free0 (_tmp0_), _tmp1_);
-	base_info = RYGEL_TRANSCODE_MANAGER_CLASS (rygel_http_server_parent_class)->get_protocol_info (RYGEL_TRANSCODE_MANAGER (self));
-	if (_vala_strcmp0 (base_info, "") != 0) {
-		char* _tmp3_;
-		char* _tmp2_;
-		protocol_info = (_tmp3_ = g_strconcat (protocol_info, _tmp2_ = g_strconcat (",", base_info, NULL), NULL), _g_free0 (protocol_info), _tmp3_);
-		_g_free0 (_tmp2_);
-	}
-	result = protocol_info;
-	_g_free0 (base_info);
-	return result;
-}
-
-
-static void rygel_http_server_on_request_completed (RygelHTTPServer* self, RygelHTTPRequest* request) {
-	char* _tmp2_;
-	char* _tmp1_;
-	char* _tmp0_ = NULL;
-	g_return_if_fail (self != NULL);
-	g_return_if_fail (request != NULL);
-	g_debug ("rygel-http-server.vala:164: HTTP %s request for URI '%s' handled.", _tmp1_ = (g_object_get (request->msg, "method", &_tmp0_, NULL), _tmp0_), _tmp2_ = soup_uri_to_string (soup_message_get_uri (request->msg), FALSE));
-	_g_free0 (_tmp2_);
-	_g_free0 (_tmp1_);
-	gee_abstract_collection_remove ((GeeAbstractCollection*) self->priv->requests, request);
-}
-
-
-static void _lambda1_ (const char* name, const char* value, RygelHTTPServer* self) {
-	g_return_if_fail (name != NULL);
-	g_return_if_fail (value != NULL);
-	g_debug ("rygel-http-server.vala:181: %s : %s", name, value);
-}
-
-
-static void __lambda1__soup_message_headers_foreach_func (const char* name, const char* value, gpointer self) {
-	_lambda1_ (name, value, self);
-}
-
-
-static void _rygel_http_server_on_request_completed_rygel_state_machine_completed (RygelHTTPRequest* _sender, gpointer self) {
-	rygel_http_server_on_request_completed (self, _sender);
-}
-
-
-static void rygel_http_server_server_handler (RygelHTTPServer* self, SoupServer* server, SoupMessage* msg, const char* server_path, GHashTable* query, SoupClientContext* soup_client) {
-	char* _tmp2_;
-	char* _tmp1_;
-	char* _tmp0_ = NULL;
-	RygelHTTPRequest* request;
-	g_return_if_fail (self != NULL);
-	g_return_if_fail (server != NULL);
-	g_return_if_fail (msg != NULL);
-	g_return_if_fail (server_path != NULL);
-	g_return_if_fail (soup_client != NULL);
-	g_debug ("rygel-http-server.vala:177: HTTP %s request for URI '%s'. Headers:", _tmp1_ = (g_object_get (msg, "method", &_tmp0_, NULL), _tmp0_), _tmp2_ = soup_uri_to_string (soup_message_get_uri (msg), FALSE));
-	_g_free0 (_tmp2_);
-	_g_free0 (_tmp1_);
-	soup_message_headers_foreach (msg->request_headers, __lambda1__soup_message_headers_foreach_func, self);
-	request = rygel_http_request_new (self, server, msg, query);
-	g_signal_connect_object ((RygelStateMachine*) request, "completed", (GCallback) _rygel_http_server_on_request_completed_rygel_state_machine_completed, self, 0);
-	gee_abstract_collection_add ((GeeAbstractCollection*) self->priv->requests, request);
-	rygel_state_machine_run ((RygelStateMachine*) request);
-	_g_object_unref0 (request);
-}
-
-
-static GCancellable* rygel_http_server_real_get_cancellable (RygelStateMachine* base) {
-	GCancellable* result;
-	RygelHTTPServer* self;
-	self = (RygelHTTPServer*) base;
-	result = self->priv->_cancellable;
-	return result;
-}
-
-
-static void rygel_http_server_real_set_cancellable (RygelStateMachine* base, GCancellable* value) {
-	RygelHTTPServer* self;
-	GCancellable* _tmp0_;
-	self = (RygelHTTPServer*) base;
-	self->priv->_cancellable = (_tmp0_ = _g_object_ref0 (value), _g_object_unref0 (self->priv->_cancellable), _tmp0_);
-	g_object_notify ((GObject *) self, "cancellable");
-}
-
-
-static void rygel_http_server_class_init (RygelHTTPServerClass * klass) {
-	rygel_http_server_parent_class = g_type_class_peek_parent (klass);
-	g_type_class_add_private (klass, sizeof (RygelHTTPServerPrivate));
-	RYGEL_TRANSCODE_MANAGER_CLASS (klass)->add_resources = rygel_http_server_real_add_resources;
-	RYGEL_TRANSCODE_MANAGER_CLASS (klass)->create_uri_for_item = rygel_http_server_real_create_uri_for_item;
-	RYGEL_TRANSCODE_MANAGER_CLASS (klass)->get_protocol = rygel_http_server_real_get_protocol;
-	RYGEL_TRANSCODE_MANAGER_CLASS (klass)->get_protocol_info = rygel_http_server_real_get_protocol_info;
-	G_OBJECT_CLASS (klass)->get_property = rygel_http_server_get_property;
-	G_OBJECT_CLASS (klass)->set_property = rygel_http_server_set_property;
-	G_OBJECT_CLASS (klass)->finalize = rygel_http_server_finalize;
-	g_object_class_override_property (G_OBJECT_CLASS (klass), RYGEL_HTTP_SERVER_CANCELLABLE, "cancellable");
-}
-
-
-static void rygel_http_server_rygel_state_machine_interface_init (RygelStateMachineIface * iface) {
-	rygel_http_server_rygel_state_machine_parent_iface = g_type_interface_peek_parent (iface);
-	iface->run = rygel_http_server_real_run;
-	iface->get_cancellable = rygel_http_server_real_get_cancellable;
-	iface->set_cancellable = rygel_http_server_real_set_cancellable;
-}
-
-
-static void rygel_http_server_instance_init (RygelHTTPServer * self) {
-	self->priv = RYGEL_HTTP_SERVER_GET_PRIVATE (self);
-}
-
-
-static void rygel_http_server_finalize (GObject* obj) {
-	RygelHTTPServer * self;
-	self = RYGEL_HTTP_SERVER (obj);
-	_g_free0 (self->priv->path_root);
-	_g_object_unref0 (self->root_container);
-	_g_object_unref0 (self->context);
-	_g_object_unref0 (self->priv->requests);
-	_g_object_unref0 (self->priv->_cancellable);
-	G_OBJECT_CLASS (rygel_http_server_parent_class)->finalize (obj);
-}
-
-
-GType rygel_http_server_get_type (void) {
-	static GType rygel_http_server_type_id = 0;
-	if (rygel_http_server_type_id == 0) {
-		static const GTypeInfo g_define_type_info = { sizeof (RygelHTTPServerClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) rygel_http_server_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (RygelHTTPServer), 0, (GInstanceInitFunc) rygel_http_server_instance_init, NULL };
-		static const GInterfaceInfo rygel_state_machine_info = { (GInterfaceInitFunc) rygel_http_server_rygel_state_machine_interface_init, (GInterfaceFinalizeFunc) NULL, NULL};
-		rygel_http_server_type_id = g_type_register_static (RYGEL_TYPE_TRANSCODE_MANAGER, "RygelHTTPServer", &g_define_type_info, 0);
-		g_type_add_interface_static (rygel_http_server_type_id, RYGEL_TYPE_STATE_MACHINE, &rygel_state_machine_info);
-	}
-	return rygel_http_server_type_id;
-}
-
-
-static void rygel_http_server_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
-	RygelHTTPServer * self;
-	self = RYGEL_HTTP_SERVER (object);
-	switch (property_id) {
-		case RYGEL_HTTP_SERVER_CANCELLABLE:
-		g_value_set_object (value, rygel_state_machine_get_cancellable ((RygelStateMachine*) self));
-		break;
-		default:
-		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
-		break;
-	}
-}
-
-
-static void rygel_http_server_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
-	RygelHTTPServer * self;
-	self = RYGEL_HTTP_SERVER (object);
-	switch (property_id) {
-		case RYGEL_HTTP_SERVER_CANCELLABLE:
-		rygel_state_machine_set_cancellable ((RygelStateMachine*) self, g_value_get_object (value));
-		break;
-		default:
-		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
-		break;
-	}
-}
-
-
-static int _vala_strcmp0 (const char * str1, const char * str2) {
-	if (str1 == NULL) {
-		return -(str1 != str2);
-	}
-	if (str2 == NULL) {
-		return str1 != str2;
-	}
-	return strcmp (str1, str2);
-}
-
-
-
-
--- a/src/rygel/rygel-http-transcode-handler.c
+++ /dev/null
@@ -1,513 +0,0 @@
-/* rygel-http-transcode-handler.c generated by valac, the Vala compiler
- * generated from rygel-http-transcode-handler.vala, do not modify */
-
-/*
- * Copyright (C) 2009 Nokia Corporation.
- *
- * Author: Zeeshan Ali (Khattak) <zeeshanak@gnome.org>
- *                               <zeeshan.ali@nokia.com>
- *
- * This file is part of Rygel.
- *
- * Rygel is free software; you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * Rygel is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this program; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
- */
-
-#include <glib.h>
-#include <glib-object.h>
-#include <libsoup/soup.h>
-#include <libgupnp-av/gupnp-av.h>
-#include <gio/gio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <gee.h>
-#include <gst/gst.h>
-
-
-#define RYGEL_TYPE_HTTP_REQUEST_HANDLER (rygel_http_request_handler_get_type ())
-#define RYGEL_HTTP_REQUEST_HANDLER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_HTTP_REQUEST_HANDLER, RygelHTTPRequestHandler))
-#define RYGEL_HTTP_REQUEST_HANDLER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_HTTP_REQUEST_HANDLER, RygelHTTPRequestHandlerClass))
-#define RYGEL_IS_HTTP_REQUEST_HANDLER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_HTTP_REQUEST_HANDLER))
-#define RYGEL_IS_HTTP_REQUEST_HANDLER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_HTTP_REQUEST_HANDLER))
-#define RYGEL_HTTP_REQUEST_HANDLER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_HTTP_REQUEST_HANDLER, RygelHTTPRequestHandlerClass))
-
-typedef struct _RygelHTTPRequestHandler RygelHTTPRequestHandler;
-typedef struct _RygelHTTPRequestHandlerClass RygelHTTPRequestHandlerClass;
-typedef struct _RygelHTTPRequestHandlerPrivate RygelHTTPRequestHandlerPrivate;
-
-#define RYGEL_TYPE_HTTP_REQUEST (rygel_http_request_get_type ())
-#define RYGEL_HTTP_REQUEST(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_HTTP_REQUEST, RygelHTTPRequest))
-#define RYGEL_HTTP_REQUEST_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_HTTP_REQUEST, RygelHTTPRequestClass))
-#define RYGEL_IS_HTTP_REQUEST(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_HTTP_REQUEST))
-#define RYGEL_IS_HTTP_REQUEST_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_HTTP_REQUEST))
-#define RYGEL_HTTP_REQUEST_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_HTTP_REQUEST, RygelHTTPRequestClass))
-
-typedef struct _RygelHTTPRequest RygelHTTPRequest;
-typedef struct _RygelHTTPRequestClass RygelHTTPRequestClass;
-
-#define RYGEL_TYPE_HTTP_RESPONSE (rygel_http_response_get_type ())
-#define RYGEL_HTTP_RESPONSE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_HTTP_RESPONSE, RygelHTTPResponse))
-#define RYGEL_HTTP_RESPONSE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_HTTP_RESPONSE, RygelHTTPResponseClass))
-#define RYGEL_IS_HTTP_RESPONSE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_HTTP_RESPONSE))
-#define RYGEL_IS_HTTP_RESPONSE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_HTTP_RESPONSE))
-#define RYGEL_HTTP_RESPONSE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_HTTP_RESPONSE, RygelHTTPResponseClass))
-
-typedef struct _RygelHTTPResponse RygelHTTPResponse;
-typedef struct _RygelHTTPResponseClass RygelHTTPResponseClass;
-
-#define RYGEL_TYPE_HTTP_TRANSCODE_HANDLER (rygel_http_transcode_handler_get_type ())
-#define RYGEL_HTTP_TRANSCODE_HANDLER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_HTTP_TRANSCODE_HANDLER, RygelHTTPTranscodeHandler))
-#define RYGEL_HTTP_TRANSCODE_HANDLER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_HTTP_TRANSCODE_HANDLER, RygelHTTPTranscodeHandlerClass))
-#define RYGEL_IS_HTTP_TRANSCODE_HANDLER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_HTTP_TRANSCODE_HANDLER))
-#define RYGEL_IS_HTTP_TRANSCODE_HANDLER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_HTTP_TRANSCODE_HANDLER))
-#define RYGEL_HTTP_TRANSCODE_HANDLER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_HTTP_TRANSCODE_HANDLER, RygelHTTPTranscodeHandlerClass))
-
-typedef struct _RygelHTTPTranscodeHandler RygelHTTPTranscodeHandler;
-typedef struct _RygelHTTPTranscodeHandlerClass RygelHTTPTranscodeHandlerClass;
-typedef struct _RygelHTTPTranscodeHandlerPrivate RygelHTTPTranscodeHandlerPrivate;
-
-#define RYGEL_TYPE_TRANSCODER (rygel_transcoder_get_type ())
-#define RYGEL_TRANSCODER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_TRANSCODER, RygelTranscoder))
-#define RYGEL_TRANSCODER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_TRANSCODER, RygelTranscoderClass))
-#define RYGEL_IS_TRANSCODER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_TRANSCODER))
-#define RYGEL_IS_TRANSCODER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_TRANSCODER))
-#define RYGEL_TRANSCODER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_TRANSCODER, RygelTranscoderClass))
-
-typedef struct _RygelTranscoder RygelTranscoder;
-typedef struct _RygelTranscoderClass RygelTranscoderClass;
-#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
-
-#define RYGEL_TYPE_STATE_MACHINE (rygel_state_machine_get_type ())
-#define RYGEL_STATE_MACHINE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_STATE_MACHINE, RygelStateMachine))
-#define RYGEL_IS_STATE_MACHINE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_STATE_MACHINE))
-#define RYGEL_STATE_MACHINE_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), RYGEL_TYPE_STATE_MACHINE, RygelStateMachineIface))
-
-typedef struct _RygelStateMachine RygelStateMachine;
-typedef struct _RygelStateMachineIface RygelStateMachineIface;
-typedef struct _RygelHTTPRequestPrivate RygelHTTPRequestPrivate;
-
-#define RYGEL_TYPE_TRANSCODE_MANAGER (rygel_transcode_manager_get_type ())
-#define RYGEL_TRANSCODE_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_TRANSCODE_MANAGER, RygelTranscodeManager))
-#define RYGEL_TRANSCODE_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_TRANSCODE_MANAGER, RygelTranscodeManagerClass))
-#define RYGEL_IS_TRANSCODE_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_TRANSCODE_MANAGER))
-#define RYGEL_IS_TRANSCODE_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_TRANSCODE_MANAGER))
-#define RYGEL_TRANSCODE_MANAGER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_TRANSCODE_MANAGER, RygelTranscodeManagerClass))
-
-typedef struct _RygelTranscodeManager RygelTranscodeManager;
-typedef struct _RygelTranscodeManagerClass RygelTranscodeManagerClass;
-
-#define RYGEL_TYPE_HTTP_SERVER (rygel_http_server_get_type ())
-#define RYGEL_HTTP_SERVER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_HTTP_SERVER, RygelHTTPServer))
-#define RYGEL_HTTP_SERVER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_HTTP_SERVER, RygelHTTPServerClass))
-#define RYGEL_IS_HTTP_SERVER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_HTTP_SERVER))
-#define RYGEL_IS_HTTP_SERVER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_HTTP_SERVER))
-#define RYGEL_HTTP_SERVER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_HTTP_SERVER, RygelHTTPServerClass))
-
-typedef struct _RygelHTTPServer RygelHTTPServer;
-typedef struct _RygelHTTPServerClass RygelHTTPServerClass;
-
-#define RYGEL_TYPE_MEDIA_OBJECT (rygel_media_object_get_type ())
-#define RYGEL_MEDIA_OBJECT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_MEDIA_OBJECT, RygelMediaObject))
-#define RYGEL_MEDIA_OBJECT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_MEDIA_OBJECT, RygelMediaObjectClass))
-#define RYGEL_IS_MEDIA_OBJECT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_MEDIA_OBJECT))
-#define RYGEL_IS_MEDIA_OBJECT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_MEDIA_OBJECT))
-#define RYGEL_MEDIA_OBJECT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_MEDIA_OBJECT, RygelMediaObjectClass))
-
-typedef struct _RygelMediaObject RygelMediaObject;
-typedef struct _RygelMediaObjectClass RygelMediaObjectClass;
-
-#define RYGEL_TYPE_MEDIA_ITEM (rygel_media_item_get_type ())
-#define RYGEL_MEDIA_ITEM(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_MEDIA_ITEM, RygelMediaItem))
-#define RYGEL_MEDIA_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_MEDIA_ITEM, RygelMediaItemClass))
-#define RYGEL_IS_MEDIA_ITEM(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_MEDIA_ITEM))
-#define RYGEL_IS_MEDIA_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_MEDIA_ITEM))
-#define RYGEL_MEDIA_ITEM_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_MEDIA_ITEM, RygelMediaItemClass))
-
-typedef struct _RygelMediaItem RygelMediaItem;
-typedef struct _RygelMediaItemClass RygelMediaItemClass;
-
-#define RYGEL_TYPE_ICON_INFO (rygel_icon_info_get_type ())
-#define RYGEL_ICON_INFO(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_ICON_INFO, RygelIconInfo))
-#define RYGEL_ICON_INFO_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_ICON_INFO, RygelIconInfoClass))
-#define RYGEL_IS_ICON_INFO(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_ICON_INFO))
-#define RYGEL_IS_ICON_INFO_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_ICON_INFO))
-#define RYGEL_ICON_INFO_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_ICON_INFO, RygelIconInfoClass))
-
-typedef struct _RygelIconInfo RygelIconInfo;
-typedef struct _RygelIconInfoClass RygelIconInfoClass;
-
-#define RYGEL_TYPE_THUMBNAIL (rygel_thumbnail_get_type ())
-#define RYGEL_THUMBNAIL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_THUMBNAIL, RygelThumbnail))
-#define RYGEL_THUMBNAIL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_THUMBNAIL, RygelThumbnailClass))
-#define RYGEL_IS_THUMBNAIL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_THUMBNAIL))
-#define RYGEL_IS_THUMBNAIL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_THUMBNAIL))
-#define RYGEL_THUMBNAIL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_THUMBNAIL, RygelThumbnailClass))
-
-typedef struct _RygelThumbnail RygelThumbnail;
-typedef struct _RygelThumbnailClass RygelThumbnailClass;
-
-#define RYGEL_TYPE_HTTP_SEEK (rygel_http_seek_get_type ())
-#define RYGEL_HTTP_SEEK(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_HTTP_SEEK, RygelHTTPSeek))
-#define RYGEL_HTTP_SEEK_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_HTTP_SEEK, RygelHTTPSeekClass))
-#define RYGEL_IS_HTTP_SEEK(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_HTTP_SEEK))
-#define RYGEL_IS_HTTP_SEEK_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_HTTP_SEEK))
-#define RYGEL_HTTP_SEEK_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_HTTP_SEEK, RygelHTTPSeekClass))
-
-typedef struct _RygelHTTPSeek RygelHTTPSeek;
-typedef struct _RygelHTTPSeekClass RygelHTTPSeekClass;
-typedef struct _RygelMediaObjectPrivate RygelMediaObjectPrivate;
-
-#define RYGEL_TYPE_MEDIA_CONTAINER (rygel_media_container_get_type ())
-#define RYGEL_MEDIA_CONTAINER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_MEDIA_CONTAINER, RygelMediaContainer))
-#define RYGEL_MEDIA_CONTAINER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_MEDIA_CONTAINER, RygelMediaContainerClass))
-#define RYGEL_IS_MEDIA_CONTAINER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_MEDIA_CONTAINER))
-#define RYGEL_IS_MEDIA_CONTAINER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_MEDIA_CONTAINER))
-#define RYGEL_MEDIA_CONTAINER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_MEDIA_CONTAINER, RygelMediaContainerClass))
-
-typedef struct _RygelMediaContainer RygelMediaContainer;
-typedef struct _RygelMediaContainerClass RygelMediaContainerClass;
-typedef struct _RygelMediaItemPrivate RygelMediaItemPrivate;
-#define _gst_object_unref0(var) ((var == NULL) ? NULL : (var = (gst_object_unref (var), NULL)))
-
-#define RYGEL_TYPE_LIVE_RESPONSE (rygel_live_response_get_type ())
-#define RYGEL_LIVE_RESPONSE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_LIVE_RESPONSE, RygelLiveResponse))
-#define RYGEL_LIVE_RESPONSE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_LIVE_RESPONSE, RygelLiveResponseClass))
-#define RYGEL_IS_LIVE_RESPONSE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_LIVE_RESPONSE))
-#define RYGEL_IS_LIVE_RESPONSE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_LIVE_RESPONSE))
-#define RYGEL_LIVE_RESPONSE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_LIVE_RESPONSE, RygelLiveResponseClass))
-
-typedef struct _RygelLiveResponse RygelLiveResponse;
-typedef struct _RygelLiveResponseClass RygelLiveResponseClass;
-
-typedef enum  {
-	RYGEL_HTTP_REQUEST_ERROR_UNACCEPTABLE = SOUP_STATUS_NOT_ACCEPTABLE,
-	RYGEL_HTTP_REQUEST_ERROR_BAD_REQUEST = SOUP_STATUS_BAD_REQUEST,
-	RYGEL_HTTP_REQUEST_ERROR_NOT_FOUND = SOUP_STATUS_NOT_FOUND
-} RygelHTTPRequestError;
-#define RYGEL_HTTP_REQUEST_ERROR rygel_http_request_error_quark ()
-struct _RygelHTTPRequestHandler {
-	GObject parent_instance;
-	RygelHTTPRequestHandlerPrivate * priv;
-};
-
-struct _RygelHTTPRequestHandlerClass {
-	GObjectClass parent_class;
-	void (*add_response_headers) (RygelHTTPRequestHandler* self, RygelHTTPRequest* request, GError** error);
-	RygelHTTPResponse* (*render_body) (RygelHTTPRequestHandler* self, RygelHTTPRequest* request, GError** error);
-	GUPnPDIDLLiteResource* (*add_resource) (RygelHTTPRequestHandler* self, GUPnPDIDLLiteItem* didl_item, RygelHTTPRequest* request, GError** error);
-};
-
-struct _RygelHTTPTranscodeHandler {
-	RygelHTTPRequestHandler parent_instance;
-	RygelHTTPTranscodeHandlerPrivate * priv;
-};
-
-struct _RygelHTTPTranscodeHandlerClass {
-	RygelHTTPRequestHandlerClass parent_class;
-};
-
-struct _RygelHTTPTranscodeHandlerPrivate {
-	RygelTranscoder* transcoder;
-};
-
-struct _RygelStateMachineIface {
-	GTypeInterface parent_iface;
-	void (*run) (RygelStateMachine* self);
-	GCancellable* (*get_cancellable) (RygelStateMachine* self);
-	void (*set_cancellable) (RygelStateMachine* self, GCancellable* value);
-};
-
-struct _RygelHTTPRequest {
-	GObject parent_instance;
-	RygelHTTPRequestPrivate * priv;
-	RygelHTTPServer* http_server;
-	SoupServer* server;
-	SoupMessage* msg;
-	RygelMediaItem* item;
-	RygelThumbnail* thumbnail;
-	RygelHTTPSeek* byte_range;
-	RygelHTTPSeek* time_range;
-};
-
-struct _RygelHTTPRequestClass {
-	GObjectClass parent_class;
-};
-
-struct _RygelMediaObject {
-	GObject parent_instance;
-	RygelMediaObjectPrivate * priv;
-	char* id;
-	char* title;
-	guint64 modified;
-	GeeArrayList* uris;
-	RygelMediaContainer* parent;
-	RygelMediaContainer* parent_ref;
-};
-
-struct _RygelMediaObjectClass {
-	GObjectClass parent_class;
-};
-
-struct _RygelMediaItem {
-	RygelMediaObject parent_instance;
-	RygelMediaItemPrivate * priv;
-	char* author;
-	char* album;
-	char* date;
-	char* upnp_class;
-	char* mime_type;
-	char* dlna_profile;
-	glong size;
-	glong duration;
-	gint bitrate;
-	gint sample_freq;
-	gint bits_per_sample;
-	gint n_audio_channels;
-	gint track_number;
-	gint width;
-	gint height;
-	gint pixel_width;
-	gint pixel_height;
-	gint color_depth;
-	GeeArrayList* thumbnails;
-};
-
-struct _RygelMediaItemClass {
-	RygelMediaObjectClass parent_class;
-	GstElement* (*create_stream_source) (RygelMediaItem* self);
-	gboolean (*should_stream) (RygelMediaItem* self);
-};
-
-
-static gpointer rygel_http_transcode_handler_parent_class = NULL;
-
-GType rygel_http_request_handler_get_type (void);
-GType rygel_http_request_get_type (void);
-GQuark rygel_http_request_error_quark (void);
-GType rygel_http_response_get_type (void);
-GType rygel_http_transcode_handler_get_type (void);
-GType rygel_transcoder_get_type (void);
-#define RYGEL_HTTP_TRANSCODE_HANDLER_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), RYGEL_TYPE_HTTP_TRANSCODE_HANDLER, RygelHTTPTranscodeHandlerPrivate))
-enum  {
-	RYGEL_HTTP_TRANSCODE_HANDLER_DUMMY_PROPERTY
-};
-RygelHTTPRequestHandler* rygel_http_request_handler_construct (GType object_type);
-void rygel_http_request_handler_set_cancellable (RygelHTTPRequestHandler* self, GCancellable* value);
-RygelHTTPTranscodeHandler* rygel_http_transcode_handler_new (RygelTranscoder* transcoder, GCancellable* cancellable);
-RygelHTTPTranscodeHandler* rygel_http_transcode_handler_construct (GType object_type, RygelTranscoder* transcoder, GCancellable* cancellable);
-GType rygel_state_machine_get_type (void);
-GType rygel_transcode_manager_get_type (void);
-GType rygel_http_server_get_type (void);
-GType rygel_media_object_get_type (void);
-GType rygel_media_item_get_type (void);
-gpointer rygel_icon_info_ref (gpointer instance);
-void rygel_icon_info_unref (gpointer instance);
-GParamSpec* rygel_param_spec_icon_info (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
-void rygel_value_set_icon_info (GValue* value, gpointer v_object);
-gpointer rygel_value_get_icon_info (const GValue* value);
-GType rygel_icon_info_get_type (void);
-GType rygel_thumbnail_get_type (void);
-GType rygel_http_seek_get_type (void);
-const char* rygel_transcoder_get_mime_type (RygelTranscoder* self);
-void rygel_http_seek_add_response_header (RygelHTTPSeek* self, SoupMessage* msg, gint64 length);
-GType rygel_media_container_get_type (void);
-void rygel_http_request_handler_add_response_headers (RygelHTTPRequestHandler* self, RygelHTTPRequest* request, GError** error);
-static void rygel_http_transcode_handler_real_add_response_headers (RygelHTTPRequestHandler* base, RygelHTTPRequest* request, GError** error);
-GstElement* rygel_media_item_create_stream_source (RygelMediaItem* self);
-GstElement* rygel_transcoder_create_source (RygelTranscoder* self, RygelMediaItem* item, GstElement* src, GError** error);
-GCancellable* rygel_http_request_handler_get_cancellable (RygelHTTPRequestHandler* self);
-RygelLiveResponse* rygel_live_response_new (SoupServer* server, SoupMessage* msg, const char* name, GstElement* src, RygelHTTPSeek* time_range, GCancellable* cancellable, GError** error);
-RygelLiveResponse* rygel_live_response_construct (GType object_type, SoupServer* server, SoupMessage* msg, const char* name, GstElement* src, RygelHTTPSeek* time_range, GCancellable* cancellable, GError** error);
-GType rygel_live_response_get_type (void);
-static RygelHTTPResponse* rygel_http_transcode_handler_real_render_body (RygelHTTPRequestHandler* base, RygelHTTPRequest* request, GError** error);
-GUPnPDIDLLiteResource* rygel_transcoder_add_resource (RygelTranscoder* self, GUPnPDIDLLiteItem* didl_item, RygelMediaItem* item, RygelTranscodeManager* manager, GError** error);
-static GUPnPDIDLLiteResource* rygel_http_transcode_handler_real_add_resource (RygelHTTPRequestHandler* base, GUPnPDIDLLiteItem* didl_item, RygelHTTPRequest* request, GError** error);
-static void rygel_http_transcode_handler_finalize (GObject* obj);
-
-
-
-static gpointer _g_object_ref0 (gpointer self) {
-	return self ? g_object_ref (self) : NULL;
-}
-
-
-RygelHTTPTranscodeHandler* rygel_http_transcode_handler_construct (GType object_type, RygelTranscoder* transcoder, GCancellable* cancellable) {
-	RygelHTTPTranscodeHandler * self;
-	RygelTranscoder* _tmp0_;
-	g_return_val_if_fail (transcoder != NULL, NULL);
-	self = (RygelHTTPTranscodeHandler*) rygel_http_request_handler_construct (object_type);
-	self->priv->transcoder = (_tmp0_ = _g_object_ref0 (transcoder), _g_object_unref0 (self->priv->transcoder), _tmp0_);
-	rygel_http_request_handler_set_cancellable ((RygelHTTPRequestHandler*) self, cancellable);
-	return self;
-}
-
-
-RygelHTTPTranscodeHandler* rygel_http_transcode_handler_new (RygelTranscoder* transcoder, GCancellable* cancellable) {
-	return rygel_http_transcode_handler_construct (RYGEL_TYPE_HTTP_TRANSCODE_HANDLER, transcoder, cancellable);
-}
-
-
-static void rygel_http_transcode_handler_real_add_response_headers (RygelHTTPRequestHandler* base, RygelHTTPRequest* request, GError** error) {
-	RygelHTTPTranscodeHandler * self;
-	GError * _inner_error_;
-	self = (RygelHTTPTranscodeHandler*) base;
-	g_return_if_fail (request != NULL);
-	_inner_error_ = NULL;
-	soup_message_headers_append (request->msg->response_headers, "Content-Type", rygel_transcoder_get_mime_type (self->priv->transcoder));
-	if (request->time_range != NULL) {
-		rygel_http_seek_add_response_header (request->time_range, request->msg, (gint64) request->item->duration);
-	}
-	RYGEL_HTTP_REQUEST_HANDLER_CLASS (rygel_http_transcode_handler_parent_class)->add_response_headers (RYGEL_HTTP_REQUEST_HANDLER (self), request, &_inner_error_);
-	if (_inner_error_ != NULL) {
-		if (_inner_error_->domain == RYGEL_HTTP_REQUEST_ERROR) {
-			g_propagate_error (error, _inner_error_);
-			return;
-		} else {
-			g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
-			g_clear_error (&_inner_error_);
-			return;
-		}
-	}
-}
-
-
-static RygelHTTPResponse* rygel_http_transcode_handler_real_render_body (RygelHTTPRequestHandler* base, RygelHTTPRequest* request, GError** error) {
-	RygelHTTPTranscodeHandler * self;
-	RygelHTTPResponse* result;
-	GError * _inner_error_;
-	RygelMediaItem* item;
-	GstElement* src;
-	GstElement* _tmp0_;
-	GstElement* _tmp1_;
-	RygelLiveResponse* _tmp2_;
-	self = (RygelHTTPTranscodeHandler*) base;
-	g_return_val_if_fail (request != NULL, NULL);
-	_inner_error_ = NULL;
-	item = _g_object_ref0 (request->item);
-	src = rygel_media_item_create_stream_source (item);
-	if (src == NULL) {
-		_inner_error_ = g_error_new_literal (RYGEL_HTTP_REQUEST_ERROR, RYGEL_HTTP_REQUEST_ERROR_NOT_FOUND, "Not found");
-		if (_inner_error_ != NULL) {
-			if (_inner_error_->domain == RYGEL_HTTP_REQUEST_ERROR) {
-				g_propagate_error (error, _inner_error_);
-				_g_object_unref0 (item);
-				_gst_object_unref0 (src);
-				return NULL;
-			} else {
-				_g_object_unref0 (item);
-				_gst_object_unref0 (src);
-				g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
-				g_clear_error (&_inner_error_);
-				return NULL;
-			}
-		}
-	}
-	_tmp0_ = rygel_transcoder_create_source (self->priv->transcoder, item, src, &_inner_error_);
-	if (_inner_error_ != NULL) {
-		if (_inner_error_->domain == RYGEL_HTTP_REQUEST_ERROR) {
-			g_propagate_error (error, _inner_error_);
-			_g_object_unref0 (item);
-			_gst_object_unref0 (src);
-			return NULL;
-		} else {
-			_g_object_unref0 (item);
-			_gst_object_unref0 (src);
-			g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
-			g_clear_error (&_inner_error_);
-			return NULL;
-		}
-	}
-	src = (_tmp1_ = _tmp0_, _gst_object_unref0 (src), _tmp1_);
-	_tmp2_ = rygel_live_response_new (request->server, request->msg, "RygelLiveResponse", src, request->time_range, rygel_http_request_handler_get_cancellable ((RygelHTTPRequestHandler*) self), &_inner_error_);
-	if (_inner_error_ != NULL) {
-		if (_inner_error_->domain == RYGEL_HTTP_REQUEST_ERROR) {
-			g_propagate_error (error, _inner_error_);
-			_g_object_unref0 (item);
-			_gst_object_unref0 (src);
-			return NULL;
-		} else {
-			_g_object_unref0 (item);
-			_gst_object_unref0 (src);
-			g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
-			g_clear_error (&_inner_error_);
-			return NULL;
-		}
-	}
-	result = (RygelHTTPResponse*) _tmp2_;
-	_g_object_unref0 (item);
-	_gst_object_unref0 (src);
-	return result;
-}
-
-
-static GUPnPDIDLLiteResource* rygel_http_transcode_handler_real_add_resource (RygelHTTPRequestHandler* base, GUPnPDIDLLiteItem* didl_item, RygelHTTPRequest* request, GError** error) {
-	RygelHTTPTranscodeHandler * self;
-	GUPnPDIDLLiteResource* result;
-	GError * _inner_error_;
-	GUPnPDIDLLiteResource* _tmp0_;
-	self = (RygelHTTPTranscodeHandler*) base;
-	g_return_val_if_fail (didl_item != NULL, NULL);
-	g_return_val_if_fail (request != NULL, NULL);
-	_inner_error_ = NULL;
-	_tmp0_ = rygel_transcoder_add_resource (self->priv->transcoder, didl_item, request->item, (RygelTranscodeManager*) request->http_server, &_inner_error_);
-	if (_inner_error_ != NULL) {
-		if (_inner_error_->domain == RYGEL_HTTP_REQUEST_ERROR) {
-			g_propagate_error (error, _inner_error_);
-			return NULL;
-		} else {
-			g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
-			g_clear_error (&_inner_error_);
-			return NULL;
-		}
-	}
-	result = _tmp0_;
-	return result;
-}
-
-
-static void rygel_http_transcode_handler_class_init (RygelHTTPTranscodeHandlerClass * klass) {
-	rygel_http_transcode_handler_parent_class = g_type_class_peek_parent (klass);
-	g_type_class_add_private (klass, sizeof (RygelHTTPTranscodeHandlerPrivate));
-	RYGEL_HTTP_REQUEST_HANDLER_CLASS (klass)->add_response_headers = rygel_http_transcode_handler_real_add_response_headers;
-	RYGEL_HTTP_REQUEST_HANDLER_CLASS (klass)->render_body = rygel_http_transcode_handler_real_render_body;
-	RYGEL_HTTP_REQUEST_HANDLER_CLASS (klass)->add_resource = rygel_http_transcode_handler_real_add_resource;
-	G_OBJECT_CLASS (klass)->finalize = rygel_http_transcode_handler_finalize;
-}
-
-
-static void rygel_http_transcode_handler_instance_init (RygelHTTPTranscodeHandler * self) {
-	self->priv = RYGEL_HTTP_TRANSCODE_HANDLER_GET_PRIVATE (self);
-}
-
-
-static void rygel_http_transcode_handler_finalize (GObject* obj) {
-	RygelHTTPTranscodeHandler * self;
-	self = RYGEL_HTTP_TRANSCODE_HANDLER (obj);
-	_g_object_unref0 (self->priv->transcoder);
-	G_OBJECT_CLASS (rygel_http_transcode_handler_parent_class)->finalize (obj);
-}
-
-
-GType rygel_http_transcode_handler_get_type (void) {
-	static GType rygel_http_transcode_handler_type_id = 0;
-	if (rygel_http_transcode_handler_type_id == 0) {
-		static const GTypeInfo g_define_type_info = { sizeof (RygelHTTPTranscodeHandlerClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) rygel_http_transcode_handler_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (RygelHTTPTranscodeHandler), 0, (GInstanceInitFunc) rygel_http_transcode_handler_instance_init, NULL };
-		rygel_http_transcode_handler_type_id = g_type_register_static (RYGEL_TYPE_HTTP_REQUEST_HANDLER, "RygelHTTPTranscodeHandler", &g_define_type_info, 0);
-	}
-	return rygel_http_transcode_handler_type_id;
-}
-
-
-
-
--- a/src/rygel/rygel-http-transcode-handler.vala
+++ /dev/null
@@ -1,78 +0,0 @@
-/*
- * Copyright (C) 2009 Nokia Corporation.
- *
- * Author: Zeeshan Ali (Khattak) <zeeshanak@gnome.org>
- *                               <zeeshan.ali@nokia.com>
- *
- * This file is part of Rygel.
- *
- * Rygel is free software; you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * Rygel is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this program; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
- */
-
-using Gst;
-using GUPnP;
-
-/**
- * The handler for HTTP transcoding requests.
- */
-internal class Rygel.HTTPTranscodeHandler : HTTPRequestHandler {
-    private Transcoder transcoder;
-
-    public HTTPTranscodeHandler (Transcoder   transcoder,
-                                 Cancellable? cancellable) {
-        this.transcoder = transcoder;
-        this.cancellable = cancellable;
-    }
-
-    public override void add_response_headers (HTTPRequest request)
-                                               throws HTTPRequestError {
-        request.msg.response_headers.append ("Content-Type",
-                                             this.transcoder.mime_type);
-        if (request.time_range != null) {
-            request.time_range.add_response_header (request.msg,
-                                                    request.item.duration);
-        }
-
-        // Chain-up
-        base.add_response_headers (request);
-    }
-
-    public override HTTPResponse render_body (HTTPRequest request)
-                                              throws HTTPRequestError {
-        var item = request.item;
-        var src = item.create_stream_source ();
-        if (src == null) {
-            throw new HTTPRequestError.NOT_FOUND ("Not found");
-        }
-
-        src = this.transcoder.create_source (item, src);
-
-        return new LiveResponse (request.server,
-                                 request.msg,
-                                 "RygelLiveResponse",
-                                 src,
-                                 request.time_range,
-                                 this.cancellable);
-    }
-
-    protected override DIDLLiteResource add_resource (DIDLLiteItem didl_item,
-                                                      HTTPRequest  request)
-                                                      throws HTTPRequestError {
-        return this.transcoder.add_resource (didl_item,
-                                             request.item,
-                                             request.http_server);
-    }
-}
-
--- a/src/rygel/rygel-icon-info.c
+++ /dev/null
@@ -1,250 +0,0 @@
-/* rygel-icon-info.c generated by valac, the Vala compiler
- * generated from rygel-icon-info.vala, do not modify */
-
-/*
- * Copyright (C) 2008 Nokia Corporation.
- *
- * Author: Zeeshan Ali (Khattak) <zeeshanak@gnome.org>
- *                               <zeeshan.ali@nokia.com>
- *
- * This file is part of Rygel.
- *
- * Rygel is free software; you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * Rygel is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this program; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
- */
-
-#include <glib.h>
-#include <glib-object.h>
-#include <stdlib.h>
-#include <string.h>
-#include <gobject/gvaluecollector.h>
-
-
-#define RYGEL_TYPE_ICON_INFO (rygel_icon_info_get_type ())
-#define RYGEL_ICON_INFO(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_ICON_INFO, RygelIconInfo))
-#define RYGEL_ICON_INFO_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_ICON_INFO, RygelIconInfoClass))
-#define RYGEL_IS_ICON_INFO(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_ICON_INFO))
-#define RYGEL_IS_ICON_INFO_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_ICON_INFO))
-#define RYGEL_ICON_INFO_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_ICON_INFO, RygelIconInfoClass))
-
-typedef struct _RygelIconInfo RygelIconInfo;
-typedef struct _RygelIconInfoClass RygelIconInfoClass;
-typedef struct _RygelIconInfoPrivate RygelIconInfoPrivate;
-#define _g_free0(var) (var = (g_free (var), NULL))
-typedef struct _RygelParamSpecIconInfo RygelParamSpecIconInfo;
-
-struct _RygelIconInfo {
-	GTypeInstance parent_instance;
-	volatile int ref_count;
-	RygelIconInfoPrivate * priv;
-	char* mime_type;
-	char* path;
-	glong size;
-	gint width;
-	gint height;
-	gint depth;
-};
-
-struct _RygelIconInfoClass {
-	GTypeClass parent_class;
-	void (*finalize) (RygelIconInfo *self);
-};
-
-struct _RygelParamSpecIconInfo {
-	GParamSpec parent_instance;
-};
-
-
-static gpointer rygel_icon_info_parent_class = NULL;
-
-gpointer rygel_icon_info_ref (gpointer instance);
-void rygel_icon_info_unref (gpointer instance);
-GParamSpec* rygel_param_spec_icon_info (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
-void rygel_value_set_icon_info (GValue* value, gpointer v_object);
-gpointer rygel_value_get_icon_info (const GValue* value);
-GType rygel_icon_info_get_type (void);
-enum  {
-	RYGEL_ICON_INFO_DUMMY_PROPERTY
-};
-RygelIconInfo* rygel_icon_info_new (const char* mime_type);
-RygelIconInfo* rygel_icon_info_construct (GType object_type, const char* mime_type);
-static void rygel_icon_info_finalize (RygelIconInfo* obj);
-
-
-
-RygelIconInfo* rygel_icon_info_construct (GType object_type, const char* mime_type) {
-	RygelIconInfo* self;
-	char* _tmp0_;
-	char* _tmp1_;
-	g_return_val_if_fail (mime_type != NULL, NULL);
-	self = (RygelIconInfo*) g_type_create_instance (object_type);
-	self->mime_type = (_tmp0_ = g_strdup (mime_type), _g_free0 (self->mime_type), _tmp0_);
-	self->path = (_tmp1_ = g_strdup (self->path), _g_free0 (self->path), _tmp1_);
-	return self;
-}
-
-
-RygelIconInfo* rygel_icon_info_new (const char* mime_type) {
-	return rygel_icon_info_construct (RYGEL_TYPE_ICON_INFO, mime_type);
-}
-
-
-static void rygel_value_icon_info_init (GValue* value) {
-	value->data[0].v_pointer = NULL;
-}
-
-
-static void rygel_value_icon_info_free_value (GValue* value) {
-	if (value->data[0].v_pointer) {
-		rygel_icon_info_unref (value->data[0].v_pointer);
-	}
-}
-
-
-static void rygel_value_icon_info_copy_value (const GValue* src_value, GValue* dest_value) {
-	if (src_value->data[0].v_pointer) {
-		dest_value->data[0].v_pointer = rygel_icon_info_ref (src_value->data[0].v_pointer);
-	} else {
-		dest_value->data[0].v_pointer = NULL;
-	}
-}
-
-
-static gpointer rygel_value_icon_info_peek_pointer (const GValue* value) {
-	return value->data[0].v_pointer;
-}
-
-
-static gchar* rygel_value_icon_info_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
-	if (collect_values[0].v_pointer) {
-		RygelIconInfo* object;
-		object = collect_values[0].v_pointer;
-		if (object->parent_instance.g_class == NULL) {
-			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
-		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
-			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
-		}
-		value->data[0].v_pointer = rygel_icon_info_ref (object);
-	} else {
-		value->data[0].v_pointer = NULL;
-	}
-	return NULL;
-}
-
-
-static gchar* rygel_value_icon_info_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
-	RygelIconInfo** object_p;
-	object_p = collect_values[0].v_pointer;
-	if (!object_p) {
-		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
-	}
-	if (!value->data[0].v_pointer) {
-		*object_p = NULL;
-	} else if (collect_flags && G_VALUE_NOCOPY_CONTENTS) {
-		*object_p = value->data[0].v_pointer;
-	} else {
-		*object_p = rygel_icon_info_ref (value->data[0].v_pointer);
-	}
-	return NULL;
-}
-
-
-GParamSpec* rygel_param_spec_icon_info (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
-	RygelParamSpecIconInfo* spec;
-	g_return_val_if_fail (g_type_is_a (object_type, RYGEL_TYPE_ICON_INFO), NULL);
-	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
-	G_PARAM_SPEC (spec)->value_type = object_type;
-	return G_PARAM_SPEC (spec);
-}
-
-
-gpointer rygel_value_get_icon_info (const GValue* value) {
-	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, RYGEL_TYPE_ICON_INFO), NULL);
-	return value->data[0].v_pointer;
-}
-
-
-void rygel_value_set_icon_info (GValue* value, gpointer v_object) {
-	RygelIconInfo* old;
-	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, RYGEL_TYPE_ICON_INFO));
-	old = value->data[0].v_pointer;
-	if (v_object) {
-		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, RYGEL_TYPE_ICON_INFO));
-		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
-		value->data[0].v_pointer = v_object;
-		rygel_icon_info_ref (value->data[0].v_pointer);
-	} else {
-		value->data[0].v_pointer = NULL;
-	}
-	if (old) {
-		rygel_icon_info_unref (old);
-	}
-}
-
-
-static void rygel_icon_info_class_init (RygelIconInfoClass * klass) {
-	rygel_icon_info_parent_class = g_type_class_peek_parent (klass);
-	RYGEL_ICON_INFO_CLASS (klass)->finalize = rygel_icon_info_finalize;
-}
-
-
-static void rygel_icon_info_instance_init (RygelIconInfo * self) {
-	self->size = (glong) (-1);
-	self->width = -1;
-	self->height = -1;
-	self->depth = -1;
-	self->ref_count = 1;
-}
-
-
-static void rygel_icon_info_finalize (RygelIconInfo* obj) {
-	RygelIconInfo * self;
-	self = RYGEL_ICON_INFO (obj);
-	_g_free0 (self->mime_type);
-	_g_free0 (self->path);
-}
-
-
-GType rygel_icon_info_get_type (void) {
-	static GType rygel_icon_info_type_id = 0;
-	if (rygel_icon_info_type_id == 0) {
-		static const GTypeValueTable g_define_type_value_table = { rygel_value_icon_info_init, rygel_value_icon_info_free_value, rygel_value_icon_info_copy_value, rygel_value_icon_info_peek_pointer, "p", rygel_value_icon_info_collect_value, "p", rygel_value_icon_info_lcopy_value };
-		static const GTypeInfo g_define_type_info = { sizeof (RygelIconInfoClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) rygel_icon_info_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (RygelIconInfo), 0, (GInstanceInitFunc) rygel_icon_info_instance_init, &g_define_type_value_table };
-		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
-		rygel_icon_info_type_id = g_type_register_fundamental (g_type_fundamental_next (), "RygelIconInfo", &g_define_type_info, &g_define_type_fundamental_info, 0);
-	}
-	return rygel_icon_info_type_id;
-}
-
-
-gpointer rygel_icon_info_ref (gpointer instance) {
-	RygelIconInfo* self;
-	self = instance;
-	g_atomic_int_inc (&self->ref_count);
-	return instance;
-}
-
-
-void rygel_icon_info_unref (gpointer instance) {
-	RygelIconInfo* self;
-	self = instance;
-	if (g_atomic_int_dec_and_test (&self->ref_count)) {
-		RYGEL_ICON_INFO_GET_CLASS (self)->finalize (self);
-		g_type_free_instance ((GTypeInstance *) self);
-	}
-}
-
-
-
-
--- a/src/rygel/rygel-l16-transcoder-bin.c
+++ /dev/null
@@ -1,237 +0,0 @@
-/* rygel-l16-transcoder-bin.c generated by valac, the Vala compiler
- * generated from rygel-l16-transcoder-bin.vala, do not modify */
-
-/*
- * Copyright (C) 2009 Nokia Corporation.
- *
- * Author: Zeeshan Ali (Khattak) <zeeshanak@gnome.org>
- *                               <zeeshan.ali@nokia.com>
- *
- * This file is part of Rygel.
- *
- * Rygel is free software; you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * Rygel is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this program; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
- */
-
-#include <glib.h>
-#include <glib-object.h>
-#include <gst/gst.h>
-#include <stdlib.h>
-#include <string.h>
-
-
-#define RYGEL_TYPE_L16_TRANSCODER_BIN (rygel_l16_transcoder_bin_get_type ())
-#define RYGEL_L16_TRANSCODER_BIN(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_L16_TRANSCODER_BIN, RygelL16TranscoderBin))
-#define RYGEL_L16_TRANSCODER_BIN_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_L16_TRANSCODER_BIN, RygelL16TranscoderBinClass))
-#define RYGEL_IS_L16_TRANSCODER_BIN(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_L16_TRANSCODER_BIN))
-#define RYGEL_IS_L16_TRANSCODER_BIN_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_L16_TRANSCODER_BIN))
-#define RYGEL_L16_TRANSCODER_BIN_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_L16_TRANSCODER_BIN, RygelL16TranscoderBinClass))
-
-typedef struct _RygelL16TranscoderBin RygelL16TranscoderBin;
-typedef struct _RygelL16TranscoderBinClass RygelL16TranscoderBinClass;
-typedef struct _RygelL16TranscoderBinPrivate RygelL16TranscoderBinPrivate;
-#define _gst_object_unref0(var) ((var == NULL) ? NULL : (var = (gst_object_unref (var), NULL)))
-
-#define RYGEL_TYPE_TRANSCODER (rygel_transcoder_get_type ())
-#define RYGEL_TRANSCODER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_TRANSCODER, RygelTranscoder))
-#define RYGEL_TRANSCODER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_TRANSCODER, RygelTranscoderClass))
-#define RYGEL_IS_TRANSCODER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_TRANSCODER))
-#define RYGEL_IS_TRANSCODER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_TRANSCODER))
-#define RYGEL_TRANSCODER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_TRANSCODER, RygelTranscoderClass))
-
-typedef struct _RygelTranscoder RygelTranscoder;
-typedef struct _RygelTranscoderClass RygelTranscoderClass;
-
-#define RYGEL_TYPE_L16_TRANSCODER (rygel_l16_transcoder_get_type ())
-#define RYGEL_L16_TRANSCODER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_L16_TRANSCODER, RygelL16Transcoder))
-#define RYGEL_L16_TRANSCODER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_L16_TRANSCODER, RygelL16TranscoderClass))
-#define RYGEL_IS_L16_TRANSCODER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_L16_TRANSCODER))
-#define RYGEL_IS_L16_TRANSCODER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_L16_TRANSCODER))
-#define RYGEL_L16_TRANSCODER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_L16_TRANSCODER, RygelL16TranscoderClass))
-
-typedef struct _RygelL16Transcoder RygelL16Transcoder;
-typedef struct _RygelL16TranscoderClass RygelL16TranscoderClass;
-
-#define RYGEL_TYPE_MEDIA_OBJECT (rygel_media_object_get_type ())
-#define RYGEL_MEDIA_OBJECT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_MEDIA_OBJECT, RygelMediaObject))
-#define RYGEL_MEDIA_OBJECT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_MEDIA_OBJECT, RygelMediaObjectClass))
-#define RYGEL_IS_MEDIA_OBJECT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_MEDIA_OBJECT))
-#define RYGEL_IS_MEDIA_OBJECT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_MEDIA_OBJECT))
-#define RYGEL_MEDIA_OBJECT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_MEDIA_OBJECT, RygelMediaObjectClass))
-
-typedef struct _RygelMediaObject RygelMediaObject;
-typedef struct _RygelMediaObjectClass RygelMediaObjectClass;
-
-#define RYGEL_TYPE_MEDIA_ITEM (rygel_media_item_get_type ())
-#define RYGEL_MEDIA_ITEM(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_MEDIA_ITEM, RygelMediaItem))
-#define RYGEL_MEDIA_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_MEDIA_ITEM, RygelMediaItemClass))
-#define RYGEL_IS_MEDIA_ITEM(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_MEDIA_ITEM))
-#define RYGEL_IS_MEDIA_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_MEDIA_ITEM))
-#define RYGEL_MEDIA_ITEM_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_MEDIA_ITEM, RygelMediaItemClass))
-
-typedef struct _RygelMediaItem RygelMediaItem;
-typedef struct _RygelMediaItemClass RygelMediaItemClass;
-#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
-
-struct _RygelL16TranscoderBin {
-	GstBin parent_instance;
-	RygelL16TranscoderBinPrivate * priv;
-};
-
-struct _RygelL16TranscoderBinClass {
-	GstBinClass parent_class;
-};
-
-struct _RygelL16TranscoderBinPrivate {
-	GstElement* audio_enc;
-};
-
-typedef enum  {
-	RYGEL_LIVE_RESPONSE_ERROR_MISSING_PLUGIN,
-	RYGEL_LIVE_RESPONSE_ERROR_LINK
-} RygelLiveResponseError;
-#define RYGEL_LIVE_RESPONSE_ERROR rygel_live_response_error_quark ()
-
-static gpointer rygel_l16_transcoder_bin_parent_class = NULL;
-
-GType rygel_l16_transcoder_bin_get_type (void);
-#define RYGEL_L16_TRANSCODER_BIN_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), RYGEL_TYPE_L16_TRANSCODER_BIN, RygelL16TranscoderBinPrivate))
-enum  {
-	RYGEL_L16_TRANSCODER_BIN_DUMMY_PROPERTY
-};
-#define RYGEL_L16_TRANSCODER_BIN_DECODEBIN "decodebin2"
-#define RYGEL_L16_TRANSCODER_BIN_AUDIO_SRC_PAD "audio-src-pad"
-#define RYGEL_L16_TRANSCODER_BIN_AUDIO_SINK_PAD "audio-sink-pad"
-GstElement* rygel_gst_utils_create_element (const char* factoryname, const char* name, GError** error);
-GType rygel_transcoder_get_type (void);
-GType rygel_l16_transcoder_get_type (void);
-GType rygel_media_object_get_type (void);
-GType rygel_media_item_get_type (void);
-GstElement* rygel_l16_transcoder_create_encoder (RygelL16Transcoder* self, RygelMediaItem* item, const char* src_pad_name, const char* sink_pad_name, GError** error);
-static void rygel_l16_transcoder_bin_decodebin_pad_added (RygelL16TranscoderBin* self, GstElement* decodebin, GstPad* new_pad);
-static void _rygel_l16_transcoder_bin_decodebin_pad_added_gst_element_pad_added (GstElement* _sender, GstPad* pad, gpointer self);
-RygelL16TranscoderBin* rygel_l16_transcoder_bin_new (RygelMediaItem* item, GstElement* src, RygelL16Transcoder* transcoder, GError** error);
-RygelL16TranscoderBin* rygel_l16_transcoder_bin_construct (GType object_type, RygelMediaItem* item, GstElement* src, RygelL16Transcoder* transcoder, GError** error);
-void rygel_gst_utils_post_error (GstElement* dest, GError* _error_);
-GQuark rygel_live_response_error_quark (void);
-static void rygel_l16_transcoder_bin_finalize (GObject* obj);
-
-
-
-static gpointer _gst_object_ref0 (gpointer self) {
-	return self ? gst_object_ref (self) : NULL;
-}
-
-
-static void _rygel_l16_transcoder_bin_decodebin_pad_added_gst_element_pad_added (GstElement* _sender, GstPad* pad, gpointer self) {
-	rygel_l16_transcoder_bin_decodebin_pad_added (self, _sender, pad);
-}
-
-
-RygelL16TranscoderBin* rygel_l16_transcoder_bin_construct (GType object_type, RygelMediaItem* item, GstElement* src, RygelL16Transcoder* transcoder, GError** error) {
-	GError * _inner_error_;
-	RygelL16TranscoderBin * self;
-	GstElement* decodebin;
-	GstElement* _tmp0_;
-	GstElement* _tmp1_;
-	GstPad* src_pad;
-	GstGhostPad* ghost;
-	g_return_val_if_fail (item != NULL, NULL);
-	g_return_val_if_fail (src != NULL, NULL);
-	g_return_val_if_fail (transcoder != NULL, NULL);
-	_inner_error_ = NULL;
-	self = g_object_newv (object_type, 0, NULL);
-	decodebin = rygel_gst_utils_create_element (RYGEL_L16_TRANSCODER_BIN_DECODEBIN, RYGEL_L16_TRANSCODER_BIN_DECODEBIN, &_inner_error_);
-	if (_inner_error_ != NULL) {
-		g_propagate_error (error, _inner_error_);
-		return;
-	}
-	_tmp0_ = rygel_l16_transcoder_create_encoder (transcoder, item, RYGEL_L16_TRANSCODER_BIN_AUDIO_SRC_PAD, RYGEL_L16_TRANSCODER_BIN_AUDIO_SINK_PAD, &_inner_error_);
-	if (_inner_error_ != NULL) {
-		g_propagate_error (error, _inner_error_);
-		_gst_object_unref0 (decodebin);
-		return;
-	}
-	self->priv->audio_enc = (_tmp1_ = _tmp0_, _gst_object_unref0 (self->priv->audio_enc), _tmp1_);
-	gst_bin_add_many ((GstBin*) self, _gst_object_ref0 (src), _gst_object_ref0 (decodebin), _gst_object_ref0 (self->priv->audio_enc), NULL);
-	gst_element_link (src, decodebin);
-	src_pad = gst_element_get_static_pad (self->priv->audio_enc, RYGEL_L16_TRANSCODER_BIN_AUDIO_SRC_PAD);
-	ghost = (GstGhostPad*) gst_ghost_pad_new (NULL, src_pad);
-	gst_element_add_pad ((GstElement*) self, _gst_object_ref0 ((GstPad*) ghost));
-	g_signal_connect_object (decodebin, "pad-added", (GCallback) _rygel_l16_transcoder_bin_decodebin_pad_added_gst_element_pad_added, self, 0);
-	_gst_object_unref0 (decodebin);
-	_gst_object_unref0 (src_pad);
-	_gst_object_unref0 (ghost);
-	return self;
-}
-
-
-RygelL16TranscoderBin* rygel_l16_transcoder_bin_new (RygelMediaItem* item, GstElement* src, RygelL16Transcoder* transcoder, GError** error) {
-	return rygel_l16_transcoder_bin_construct (RYGEL_TYPE_L16_TRANSCODER_BIN, item, src, transcoder, error);
-}
-
-
-static void rygel_l16_transcoder_bin_decodebin_pad_added (RygelL16TranscoderBin* self, GstElement* decodebin, GstPad* new_pad) {
-	GstPad* enc_pad;
-	g_return_if_fail (self != NULL);
-	g_return_if_fail (decodebin != NULL);
-	g_return_if_fail (new_pad != NULL);
-	enc_pad = _gst_object_ref0 (gst_element_get_pad (self->priv->audio_enc, RYGEL_L16_TRANSCODER_BIN_AUDIO_SINK_PAD));
-	if (!gst_pad_can_link (new_pad, enc_pad)) {
-		_gst_object_unref0 (enc_pad);
-		return;
-	}
-	if (gst_pad_link (new_pad, enc_pad) != GST_PAD_LINK_OK) {
-		GError* _tmp0_;
-		rygel_gst_utils_post_error ((GstElement*) self, _tmp0_ = g_error_new (RYGEL_LIVE_RESPONSE_ERROR, RYGEL_LIVE_RESPONSE_ERROR_LINK, "Failed to link pad %s to %s", gst_object_get_name ((GstObject*) new_pad), gst_object_get_name ((GstObject*) enc_pad)));
-		_g_error_free0 (_tmp0_);
-		_gst_object_unref0 (enc_pad);
-		return;
-	}
-	_gst_object_unref0 (enc_pad);
-}
-
-
-static void rygel_l16_transcoder_bin_class_init (RygelL16TranscoderBinClass * klass) {
-	rygel_l16_transcoder_bin_parent_class = g_type_class_peek_parent (klass);
-	g_type_class_add_private (klass, sizeof (RygelL16TranscoderBinPrivate));
-	G_OBJECT_CLASS (klass)->finalize = rygel_l16_transcoder_bin_finalize;
-}
-
-
-static void rygel_l16_transcoder_bin_instance_init (RygelL16TranscoderBin * self) {
-	self->priv = RYGEL_L16_TRANSCODER_BIN_GET_PRIVATE (self);
-}
-
-
-static void rygel_l16_transcoder_bin_finalize (GObject* obj) {
-	RygelL16TranscoderBin * self;
-	self = RYGEL_L16_TRANSCODER_BIN (obj);
-	_gst_object_unref0 (self->priv->audio_enc);
-	G_OBJECT_CLASS (rygel_l16_transcoder_bin_parent_class)->finalize (obj);
-}
-
-
-GType rygel_l16_transcoder_bin_get_type (void) {
-	static GType rygel_l16_transcoder_bin_type_id = 0;
-	if (rygel_l16_transcoder_bin_type_id == 0) {
-		static const GTypeInfo g_define_type_info = { sizeof (RygelL16TranscoderBinClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) rygel_l16_transcoder_bin_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (RygelL16TranscoderBin), 0, (GInstanceInitFunc) rygel_l16_transcoder_bin_instance_init, NULL };
-		rygel_l16_transcoder_bin_type_id = g_type_register_static (GST_TYPE_BIN, "RygelL16TranscoderBin", &g_define_type_info, 0);
-	}
-	return rygel_l16_transcoder_bin_type_id;
-}
-
-
-
-
--- a/src/rygel/rygel-l16-transcoder-bin.vala
+++ /dev/null
@@ -1,72 +0,0 @@
-/*
- * Copyright (C) 2009 Nokia Corporation.
- *
- * Author: Zeeshan Ali (Khattak) <zeeshanak@gnome.org>
- *                               <zeeshan.ali@nokia.com>
- *
- * This file is part of Rygel.
- *
- * Rygel is free software; you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * Rygel is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this program; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
- */
-
-using Gst;
-
-/**
- * A Gst.Bin derivative that implements transcoding of any type of media (using
- * decodebin2) to linear PCM audio.
- */
-internal class Rygel.L16TranscoderBin : Gst.Bin {
-    private const string DECODEBIN = "decodebin2";
-
-    private const string AUDIO_SRC_PAD = "audio-src-pad";
-    private const string AUDIO_SINK_PAD = "audio-sink-pad";
-
-    private dynamic Element audio_enc;
-
-    public L16TranscoderBin (MediaItem     item,
-                             Element       src,
-                             L16Transcoder transcoder) throws Error {
-        Element decodebin = GstUtils.create_element (DECODEBIN, DECODEBIN);
-
-        this.audio_enc = transcoder.create_encoder (item,
-                                                    AUDIO_SRC_PAD,
-                                                    AUDIO_SINK_PAD);
-
-        this.add_many (src, decodebin, this.audio_enc);
-        src.link (decodebin);
-
-        var src_pad = this.audio_enc.get_static_pad (AUDIO_SRC_PAD);
-        var ghost = new GhostPad (null, src_pad);
-        this.add_pad (ghost);
-
-        decodebin.pad_added += this.decodebin_pad_added;
-    }
-
-    private void decodebin_pad_added (Element decodebin, Pad new_pad) {
-        Pad enc_pad = this.audio_enc.get_pad (AUDIO_SINK_PAD);
-        if (!new_pad.can_link (enc_pad)) {
-            return;
-        }
-
-        if (new_pad.link (enc_pad) != PadLinkReturn.OK) {
-            GstUtils.post_error (this,
-                                 new LiveResponseError.LINK (
-                                                "Failed to link pad %s to %s",
-                                                new_pad.name,
-                                                enc_pad.name));
-            return;
-        }
-    }
-}
--- a/src/rygel/rygel-l16-transcoder.c
+++ /dev/null
@@ -1,490 +0,0 @@
-/* rygel-l16-transcoder.c generated by valac, the Vala compiler
- * generated from rygel-l16-transcoder.vala, do not modify */
-
-/*
- * Copyright (C) 2009 Nokia Corporation.
- *
- * Author: Zeeshan Ali (Khattak) <zeeshanak@gnome.org>
- *                               <zeeshan.ali@nokia.com>
- *
- * This file is part of Rygel.
- *
- * Rygel is free software; you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * Rygel is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this program; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
- */
-
-#include <glib.h>
-#include <glib-object.h>
-#include <gst/gst.h>
-#include <libgupnp-av/gupnp-av.h>
-#include <stdlib.h>
-#include <string.h>
-#include <gee.h>
-
-
-#define TYPE_ENDIANNESS (endianness_get_type ())
-
-#define RYGEL_TYPE_TRANSCODER (rygel_transcoder_get_type ())
-#define RYGEL_TRANSCODER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_TRANSCODER, RygelTranscoder))
-#define RYGEL_TRANSCODER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_TRANSCODER, RygelTranscoderClass))
-#define RYGEL_IS_TRANSCODER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_TRANSCODER))
-#define RYGEL_IS_TRANSCODER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_TRANSCODER))
-#define RYGEL_TRANSCODER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_TRANSCODER, RygelTranscoderClass))
-
-typedef struct _RygelTranscoder RygelTranscoder;
-typedef struct _RygelTranscoderClass RygelTranscoderClass;
-typedef struct _RygelTranscoderPrivate RygelTranscoderPrivate;
-
-#define RYGEL_TYPE_MEDIA_OBJECT (rygel_media_object_get_type ())
-#define RYGEL_MEDIA_OBJECT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_MEDIA_OBJECT, RygelMediaObject))
-#define RYGEL_MEDIA_OBJECT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_MEDIA_OBJECT, RygelMediaObjectClass))
-#define RYGEL_IS_MEDIA_OBJECT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_MEDIA_OBJECT))
-#define RYGEL_IS_MEDIA_OBJECT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_MEDIA_OBJECT))
-#define RYGEL_MEDIA_OBJECT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_MEDIA_OBJECT, RygelMediaObjectClass))
-
-typedef struct _RygelMediaObject RygelMediaObject;
-typedef struct _RygelMediaObjectClass RygelMediaObjectClass;
-
-#define RYGEL_TYPE_MEDIA_ITEM (rygel_media_item_get_type ())
-#define RYGEL_MEDIA_ITEM(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_MEDIA_ITEM, RygelMediaItem))
-#define RYGEL_MEDIA_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_MEDIA_ITEM, RygelMediaItemClass))
-#define RYGEL_IS_MEDIA_ITEM(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_MEDIA_ITEM))
-#define RYGEL_IS_MEDIA_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_MEDIA_ITEM))
-#define RYGEL_MEDIA_ITEM_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_MEDIA_ITEM, RygelMediaItemClass))
-
-typedef struct _RygelMediaItem RygelMediaItem;
-typedef struct _RygelMediaItemClass RygelMediaItemClass;
-
-#define RYGEL_TYPE_TRANSCODE_MANAGER (rygel_transcode_manager_get_type ())
-#define RYGEL_TRANSCODE_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_TRANSCODE_MANAGER, RygelTranscodeManager))
-#define RYGEL_TRANSCODE_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_TRANSCODE_MANAGER, RygelTranscodeManagerClass))
-#define RYGEL_IS_TRANSCODE_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_TRANSCODE_MANAGER))
-#define RYGEL_IS_TRANSCODE_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_TRANSCODE_MANAGER))
-#define RYGEL_TRANSCODE_MANAGER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_TRANSCODE_MANAGER, RygelTranscodeManagerClass))
-
-typedef struct _RygelTranscodeManager RygelTranscodeManager;
-typedef struct _RygelTranscodeManagerClass RygelTranscodeManagerClass;
-
-#define RYGEL_TYPE_L16_TRANSCODER (rygel_l16_transcoder_get_type ())
-#define RYGEL_L16_TRANSCODER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_L16_TRANSCODER, RygelL16Transcoder))
-#define RYGEL_L16_TRANSCODER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_L16_TRANSCODER, RygelL16TranscoderClass))
-#define RYGEL_IS_L16_TRANSCODER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_L16_TRANSCODER))
-#define RYGEL_IS_L16_TRANSCODER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_L16_TRANSCODER))
-#define RYGEL_L16_TRANSCODER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_L16_TRANSCODER, RygelL16TranscoderClass))
-
-typedef struct _RygelL16Transcoder RygelL16Transcoder;
-typedef struct _RygelL16TranscoderClass RygelL16TranscoderClass;
-typedef struct _RygelL16TranscoderPrivate RygelL16TranscoderPrivate;
-#define _g_free0(var) (var = (g_free (var), NULL))
-
-#define RYGEL_TYPE_L16_TRANSCODER_BIN (rygel_l16_transcoder_bin_get_type ())
-#define RYGEL_L16_TRANSCODER_BIN(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_L16_TRANSCODER_BIN, RygelL16TranscoderBin))
-#define RYGEL_L16_TRANSCODER_BIN_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_L16_TRANSCODER_BIN, RygelL16TranscoderBinClass))
-#define RYGEL_IS_L16_TRANSCODER_BIN(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_L16_TRANSCODER_BIN))
-#define RYGEL_IS_L16_TRANSCODER_BIN_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_L16_TRANSCODER_BIN))
-#define RYGEL_L16_TRANSCODER_BIN_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_L16_TRANSCODER_BIN, RygelL16TranscoderBinClass))
-
-typedef struct _RygelL16TranscoderBin RygelL16TranscoderBin;
-typedef struct _RygelL16TranscoderBinClass RygelL16TranscoderBinClass;
-#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
-typedef struct _RygelMediaObjectPrivate RygelMediaObjectPrivate;
-
-#define RYGEL_TYPE_MEDIA_CONTAINER (rygel_media_container_get_type ())
-#define RYGEL_MEDIA_CONTAINER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_MEDIA_CONTAINER, RygelMediaContainer))
-#define RYGEL_MEDIA_CONTAINER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_MEDIA_CONTAINER, RygelMediaContainerClass))
-#define RYGEL_IS_MEDIA_CONTAINER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_MEDIA_CONTAINER))
-#define RYGEL_IS_MEDIA_CONTAINER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_MEDIA_CONTAINER))
-#define RYGEL_MEDIA_CONTAINER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_MEDIA_CONTAINER, RygelMediaContainerClass))
-
-typedef struct _RygelMediaContainer RygelMediaContainer;
-typedef struct _RygelMediaContainerClass RygelMediaContainerClass;
-typedef struct _RygelMediaItemPrivate RygelMediaItemPrivate;
-
-#define RYGEL_TYPE_ICON_INFO (rygel_icon_info_get_type ())
-#define RYGEL_ICON_INFO(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_ICON_INFO, RygelIconInfo))
-#define RYGEL_ICON_INFO_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_ICON_INFO, RygelIconInfoClass))
-#define RYGEL_IS_ICON_INFO(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_ICON_INFO))
-#define RYGEL_IS_ICON_INFO_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_ICON_INFO))
-#define RYGEL_ICON_INFO_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_ICON_INFO, RygelIconInfoClass))
-
-typedef struct _RygelIconInfo RygelIconInfo;
-typedef struct _RygelIconInfoClass RygelIconInfoClass;
-
-#define RYGEL_TYPE_THUMBNAIL (rygel_thumbnail_get_type ())
-#define RYGEL_THUMBNAIL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_THUMBNAIL, RygelThumbnail))
-#define RYGEL_THUMBNAIL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_THUMBNAIL, RygelThumbnailClass))
-#define RYGEL_IS_THUMBNAIL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_THUMBNAIL))
-#define RYGEL_IS_THUMBNAIL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_THUMBNAIL))
-#define RYGEL_THUMBNAIL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_THUMBNAIL, RygelThumbnailClass))
-
-typedef struct _RygelThumbnail RygelThumbnail;
-typedef struct _RygelThumbnailClass RygelThumbnailClass;
-#define _gst_object_unref0(var) ((var == NULL) ? NULL : (var = (gst_object_unref (var), NULL)))
-#define _gst_caps_unref0(var) ((var == NULL) ? NULL : (var = (gst_caps_unref (var), NULL)))
-
-typedef enum  {
-	ENDIANNESS_LITTLE = G_LITTLE_ENDIAN,
-	ENDIANNESS_BIG = G_BIG_ENDIAN
-} Endianness;
-
-struct _RygelTranscoder {
-	GObject parent_instance;
-	RygelTranscoderPrivate * priv;
-};
-
-struct _RygelTranscoderClass {
-	GObjectClass parent_class;
-	GstElement* (*create_source) (RygelTranscoder* self, RygelMediaItem* item, GstElement* src, GError** error);
-	GUPnPDIDLLiteResource* (*add_resource) (RygelTranscoder* self, GUPnPDIDLLiteItem* didl_item, RygelMediaItem* item, RygelTranscodeManager* manager, GError** error);
-	guint (*get_distance) (RygelTranscoder* self, RygelMediaItem* item);
-};
-
-struct _RygelL16Transcoder {
-	RygelTranscoder parent_instance;
-	RygelL16TranscoderPrivate * priv;
-};
-
-struct _RygelL16TranscoderClass {
-	RygelTranscoderClass parent_class;
-};
-
-struct _RygelL16TranscoderPrivate {
-	Endianness endianness;
-};
-
-struct _RygelMediaObject {
-	GObject parent_instance;
-	RygelMediaObjectPrivate * priv;
-	char* id;
-	char* title;
-	guint64 modified;
-	GeeArrayList* uris;
-	RygelMediaContainer* parent;
-	RygelMediaContainer* parent_ref;
-};
-
-struct _RygelMediaObjectClass {
-	GObjectClass parent_class;
-};
-
-struct _RygelMediaItem {
-	RygelMediaObject parent_instance;
-	RygelMediaItemPrivate * priv;
-	char* author;
-	char* album;
-	char* date;
-	char* upnp_class;
-	char* mime_type;
-	char* dlna_profile;
-	glong size;
-	glong duration;
-	gint bitrate;
-	gint sample_freq;
-	gint bits_per_sample;
-	gint n_audio_channels;
-	gint track_number;
-	gint width;
-	gint height;
-	gint pixel_width;
-	gint pixel_height;
-	gint color_depth;
-	GeeArrayList* thumbnails;
-};
-
-struct _RygelMediaItemClass {
-	RygelMediaObjectClass parent_class;
-	GstElement* (*create_stream_source) (RygelMediaItem* self);
-	gboolean (*should_stream) (RygelMediaItem* self);
-};
-
-
-static gpointer rygel_l16_transcoder_parent_class = NULL;
-
-GType endianness_get_type (void);
-GType rygel_transcoder_get_type (void);
-GType rygel_media_object_get_type (void);
-GType rygel_media_item_get_type (void);
-GType rygel_transcode_manager_get_type (void);
-GType rygel_l16_transcoder_get_type (void);
-#define RYGEL_L16_TRANSCODER_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), RYGEL_TYPE_L16_TRANSCODER, RygelL16TranscoderPrivate))
-enum  {
-	RYGEL_L16_TRANSCODER_DUMMY_PROPERTY
-};
-#define RYGEL_L16_TRANSCODER_CHANNELS 2
-#define RYGEL_L16_TRANSCODER_FREQUENCY 44100
-#define RYGEL_L16_TRANSCODER_WIDTH 16
-#define RYGEL_L16_TRANSCODER_DEPTH 16
-#define RYGEL_L16_TRANSCODER_SIGNED TRUE
-#define RYGEL_L16_TRANSCODER_AUDIO_CONVERT "audioconvert"
-#define RYGEL_L16_TRANSCODER_AUDIO_RESAMPLE "audioresample"
-#define RYGEL_L16_TRANSCODER_AUDIO_RATE "audiorate"
-#define RYGEL_L16_TRANSCODER_CAPS_FILTER "capsfilter"
-#define RYGEL_MEDIA_ITEM_AUDIO_CLASS "object.item.audioItem"
-RygelTranscoder* rygel_transcoder_construct (GType object_type, const char* mime_type, const char* dlna_profile, const char* upnp_class);
-RygelL16Transcoder* rygel_l16_transcoder_new (Endianness endianness);
-RygelL16Transcoder* rygel_l16_transcoder_construct (GType object_type, Endianness endianness);
-RygelL16TranscoderBin* rygel_l16_transcoder_bin_new (RygelMediaItem* item, GstElement* src, RygelL16Transcoder* transcoder, GError** error);
-RygelL16TranscoderBin* rygel_l16_transcoder_bin_construct (GType object_type, RygelMediaItem* item, GstElement* src, RygelL16Transcoder* transcoder, GError** error);
-GType rygel_l16_transcoder_bin_get_type (void);
-static GstElement* rygel_l16_transcoder_real_create_source (RygelTranscoder* base, RygelMediaItem* item, GstElement* src, GError** error);
-GUPnPDIDLLiteResource* rygel_transcoder_add_resource (RygelTranscoder* self, GUPnPDIDLLiteItem* didl_item, RygelMediaItem* item, RygelTranscodeManager* manager, GError** error);
-static GUPnPDIDLLiteResource* rygel_l16_transcoder_real_add_resource (RygelTranscoder* base, GUPnPDIDLLiteItem* didl_item, RygelMediaItem* item, RygelTranscodeManager* manager, GError** error);
-GType rygel_media_container_get_type (void);
-gpointer rygel_icon_info_ref (gpointer instance);
-void rygel_icon_info_unref (gpointer instance);
-GParamSpec* rygel_param_spec_icon_info (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
-void rygel_value_set_icon_info (GValue* value, gpointer v_object);
-gpointer rygel_value_get_icon_info (const GValue* value);
-GType rygel_icon_info_get_type (void);
-GType rygel_thumbnail_get_type (void);
-#define RYGEL_MEDIA_ITEM_IMAGE_CLASS "object.item.imageItem"
-static guint rygel_l16_transcoder_real_get_distance (RygelTranscoder* base, RygelMediaItem* item);
-GstElement* rygel_gst_utils_create_element (const char* factoryname, const char* name, GError** error);
-static inline void _dynamic_set_caps5 (GstElement* obj, GstCaps* value);
-GstElement* rygel_l16_transcoder_create_encoder (RygelL16Transcoder* self, RygelMediaItem* item, const char* src_pad_name, const char* sink_pad_name, GError** error);
-static void rygel_l16_transcoder_finalize (GObject* obj);
-
-
-
-
-GType endianness_get_type (void) {
-	static GType endianness_type_id = 0;
-	if (G_UNLIKELY (endianness_type_id == 0)) {
-		static const GEnumValue values[] = {{ENDIANNESS_LITTLE, "ENDIANNESS_LITTLE", "little"}, {ENDIANNESS_BIG, "ENDIANNESS_BIG", "big"}, {0, NULL, NULL}};
-		endianness_type_id = g_enum_register_static ("Endianness", values);
-	}
-	return endianness_type_id;
-}
-
-
-RygelL16Transcoder* rygel_l16_transcoder_construct (GType object_type, Endianness endianness) {
-	RygelL16Transcoder * self;
-	char* _tmp6_;
-	char* _tmp5_;
-	char* _tmp4_;
-	char* _tmp3_;
-	char* _tmp2_;
-	char* _tmp1_;
-	char* _tmp0_;
-	char* _tmp7_;
-	char* mime_type;
-	mime_type = (_tmp7_ = g_strconcat (_tmp5_ = g_strconcat (_tmp4_ = g_strconcat (_tmp2_ = g_strconcat (_tmp1_ = g_strconcat ("audio/L", _tmp0_ = g_strdup_printf ("%i", RYGEL_L16_TRANSCODER_WIDTH), NULL), ";rate=", NULL), _tmp3_ = g_strdup_printf ("%i", RYGEL_L16_TRANSCODER_FREQUENCY), NULL), ";channels=", NULL), _tmp6_ = g_strdup_printf ("%i", RYGEL_L16_TRANSCODER_CHANNELS), NULL), _g_free0 (_tmp6_), _g_free0 (_tmp5_), _g_free0 (_tmp4_), _g_free0 (_tmp3_), _g_free0 (_tmp2_), _g_free0 (_tmp1_), _g_free0 (_tmp0_), _tmp7_);
-	self = (RygelL16Transcoder*) rygel_transcoder_construct (object_type, mime_type, "LPCM", RYGEL_MEDIA_ITEM_AUDIO_CLASS);
-	self->priv->endianness = endianness;
-	_g_free0 (mime_type);
-	return self;
-}
-
-
-RygelL16Transcoder* rygel_l16_transcoder_new (Endianness endianness) {
-	return rygel_l16_transcoder_construct (RYGEL_TYPE_L16_TRANSCODER, endianness);
-}
-
-
-static GstElement* rygel_l16_transcoder_real_create_source (RygelTranscoder* base, RygelMediaItem* item, GstElement* src, GError** error) {
-	RygelL16Transcoder * self;
-	GstElement* result;
-	GError * _inner_error_;
-	RygelL16TranscoderBin* _tmp0_;
-	self = (RygelL16Transcoder*) base;
-	g_return_val_if_fail (item != NULL, NULL);
-	g_return_val_if_fail (src != NULL, NULL);
-	_inner_error_ = NULL;
-	_tmp0_ = rygel_l16_transcoder_bin_new (item, src, self, &_inner_error_);
-	if (_inner_error_ != NULL) {
-		g_propagate_error (error, _inner_error_);
-		return NULL;
-	}
-	result = (GstElement*) _tmp0_;
-	return result;
-}
-
-
-static GUPnPDIDLLiteResource* rygel_l16_transcoder_real_add_resource (RygelTranscoder* base, GUPnPDIDLLiteItem* didl_item, RygelMediaItem* item, RygelTranscodeManager* manager, GError** error) {
-	RygelL16Transcoder * self;
-	GUPnPDIDLLiteResource* result;
-	GError * _inner_error_;
-	GUPnPDIDLLiteResource* resource;
-	self = (RygelL16Transcoder*) base;
-	g_return_val_if_fail (didl_item != NULL, NULL);
-	g_return_val_if_fail (item != NULL, NULL);
-	g_return_val_if_fail (manager != NULL, NULL);
-	_inner_error_ = NULL;
-	resource = RYGEL_TRANSCODER_CLASS (rygel_l16_transcoder_parent_class)->add_resource (RYGEL_TRANSCODER (self), didl_item, item, manager, &_inner_error_);
-	if (_inner_error_ != NULL) {
-		g_propagate_error (error, _inner_error_);
-		return NULL;
-	}
-	if (resource == NULL) {
-		result = NULL;
-		_g_object_unref0 (resource);
-		return result;
-	}
-	gupnp_didl_lite_resource_set_sample_freq (resource, RYGEL_L16_TRANSCODER_FREQUENCY);
-	gupnp_didl_lite_resource_set_audio_channels (resource, RYGEL_L16_TRANSCODER_CHANNELS);
-	gupnp_didl_lite_resource_set_bits_per_sample (resource, RYGEL_L16_TRANSCODER_WIDTH);
-	gupnp_didl_lite_resource_set_bitrate (resource, ((RYGEL_L16_TRANSCODER_FREQUENCY * RYGEL_L16_TRANSCODER_CHANNELS) * RYGEL_L16_TRANSCODER_WIDTH) / 8);
-	result = resource;
-	return result;
-}
-
-
-static guint rygel_l16_transcoder_real_get_distance (RygelTranscoder* base, RygelMediaItem* item) {
-	RygelL16Transcoder * self;
-	guint result;
-	guint distance = 0U;
-	self = (RygelL16Transcoder*) base;
-	g_return_val_if_fail (item != NULL, 0U);
-	if (g_str_has_prefix (item->upnp_class, RYGEL_MEDIA_ITEM_IMAGE_CLASS)) {
-		result = G_MAXUINT;
-		return result;
-	}
-	if (g_str_has_prefix (item->upnp_class, RYGEL_MEDIA_ITEM_AUDIO_CLASS)) {
-		distance = 0;
-		if (item->sample_freq > 0) {
-			distance = distance + ((guint) abs (item->sample_freq - RYGEL_L16_TRANSCODER_FREQUENCY));
-		}
-		if (item->n_audio_channels > 0) {
-			distance = distance + ((guint) abs (item->n_audio_channels - RYGEL_L16_TRANSCODER_CHANNELS));
-		}
-		if (item->bits_per_sample > 0) {
-			distance = distance + ((guint) abs (item->bits_per_sample - RYGEL_L16_TRANSCODER_WIDTH));
-		}
-	} else {
-		distance = G_MAXUINT / 2;
-	}
-	result = distance;
-	return result;
-}
-
-
-static gpointer _gst_object_ref0 (gpointer self) {
-	return self ? gst_object_ref (self) : NULL;
-}
-
-
-static inline void _dynamic_set_caps5 (GstElement* obj, GstCaps* value) {
-	g_object_set (obj, "caps", value, NULL);
-}
-
-
-GstElement* rygel_l16_transcoder_create_encoder (RygelL16Transcoder* self, RygelMediaItem* item, const char* src_pad_name, const char* sink_pad_name, GError** error) {
-	GstElement* result;
-	GError * _inner_error_;
-	GstElement* convert1;
-	GstElement* resample;
-	GstElement* audiorate;
-	GstElement* convert2;
-	GstElement* capsfilter;
-	GstBin* bin;
-	GstCaps* _tmp0_;
-	GstPad* pad;
-	GstGhostPad* ghost;
-	GstPad* _tmp1_;
-	GstGhostPad* _tmp2_;
-	g_return_val_if_fail (self != NULL, NULL);
-	g_return_val_if_fail (item != NULL, NULL);
-	_inner_error_ = NULL;
-	convert1 = rygel_gst_utils_create_element (RYGEL_L16_TRANSCODER_AUDIO_CONVERT, NULL, &_inner_error_);
-	if (_inner_error_ != NULL) {
-		g_propagate_error (error, _inner_error_);
-		return NULL;
-	}
-	resample = rygel_gst_utils_create_element (RYGEL_L16_TRANSCODER_AUDIO_RESAMPLE, RYGEL_L16_TRANSCODER_AUDIO_RESAMPLE, &_inner_error_);
-	if (_inner_error_ != NULL) {
-		g_propagate_error (error, _inner_error_);
-		_gst_object_unref0 (convert1);
-		return NULL;
-	}
-	audiorate = rygel_gst_utils_create_element (RYGEL_L16_TRANSCODER_AUDIO_RATE, NULL, &_inner_error_);
-	if (_inner_error_ != NULL) {
-		g_propagate_error (error, _inner_error_);
-		_gst_object_unref0 (convert1);
-		_gst_object_unref0 (resample);
-		return NULL;
-	}
-	convert2 = rygel_gst_utils_create_element (RYGEL_L16_TRANSCODER_AUDIO_CONVERT, NULL, &_inner_error_);
-	if (_inner_error_ != NULL) {
-		g_propagate_error (error, _inner_error_);
-		_gst_object_unref0 (convert1);
-		_gst_object_unref0 (resample);
-		_gst_object_unref0 (audiorate);
-		return NULL;
-	}
-	capsfilter = rygel_gst_utils_create_element (RYGEL_L16_TRANSCODER_CAPS_FILTER, RYGEL_L16_TRANSCODER_CAPS_FILTER, &_inner_error_);
-	if (_inner_error_ != NULL) {
-		g_propagate_error (error, _inner_error_);
-		_gst_object_unref0 (convert1);
-		_gst_object_unref0 (resample);
-		_gst_object_unref0 (audiorate);
-		_gst_object_unref0 (convert2);
-		return NULL;
-	}
-	bin = (GstBin*) gst_bin_new ("l16-encoder-bin");
-	gst_bin_add_many (bin, _gst_object_ref0 (convert1), _gst_object_ref0 (resample), _gst_object_ref0 (audiorate), _gst_object_ref0 (convert2), _gst_object_ref0 (capsfilter), NULL);
-	_dynamic_set_caps5 (capsfilter, _tmp0_ = gst_caps_new_simple ("audio/x-raw-int", "channels", G_TYPE_INT, RYGEL_L16_TRANSCODER_CHANNELS, "rate", G_TYPE_INT, RYGEL_L16_TRANSCODER_FREQUENCY, "width", G_TYPE_INT, RYGEL_L16_TRANSCODER_WIDTH, "depth", G_TYPE_INT, RYGEL_L16_TRANSCODER_DEPTH, "signed", G_TYPE_BOOLEAN, RYGEL_L16_TRANSCODER_SIGNED, "endianness", G_TYPE_INT, self->priv->endianness, NULL));
-	_gst_caps_unref0 (_tmp0_);
-	gst_element_link_many (convert1, resample, audiorate, convert2, capsfilter, NULL);
-	pad = gst_element_get_static_pad (convert1, "sink");
-	ghost = (GstGhostPad*) gst_ghost_pad_new (sink_pad_name, pad);
-	gst_element_add_pad ((GstElement*) bin, _gst_object_ref0 ((GstPad*) ghost));
-	pad = (_tmp1_ = gst_element_get_static_pad (capsfilter, "src"), _gst_object_unref0 (pad), _tmp1_);
-	ghost = (_tmp2_ = (GstGhostPad*) gst_ghost_pad_new (src_pad_name, pad), _gst_object_unref0 (ghost), _tmp2_);
-	gst_element_add_pad ((GstElement*) bin, _gst_object_ref0 ((GstPad*) ghost));
-	result = (GstElement*) bin;
-	_gst_object_unref0 (convert1);
-	_gst_object_unref0 (resample);
-	_gst_object_unref0 (audiorate);
-	_gst_object_unref0 (convert2);
-	_gst_object_unref0 (capsfilter);
-	_gst_object_unref0 (pad);
-	_gst_object_unref0 (ghost);
-	return result;
-}
-
-
-static void rygel_l16_transcoder_class_init (RygelL16TranscoderClass * klass) {
-	rygel_l16_transcoder_parent_class = g_type_class_peek_parent (klass);
-	g_type_class_add_private (klass, sizeof (RygelL16TranscoderPrivate));
-	RYGEL_TRANSCODER_CLASS (klass)->create_source = rygel_l16_transcoder_real_create_source;
-	RYGEL_TRANSCODER_CLASS (klass)->add_resource = rygel_l16_transcoder_real_add_resource;
-	RYGEL_TRANSCODER_CLASS (klass)->get_distance = rygel_l16_transcoder_real_get_distance;
-	G_OBJECT_CLASS (klass)->finalize = rygel_l16_transcoder_finalize;
-}
-
-
-static void rygel_l16_transcoder_instance_init (RygelL16Transcoder * self) {
-	self->priv = RYGEL_L16_TRANSCODER_GET_PRIVATE (self);
-}
-
-
-static void rygel_l16_transcoder_finalize (GObject* obj) {
-	RygelL16Transcoder * self;
-	self = RYGEL_L16_TRANSCODER (obj);
-	G_OBJECT_CLASS (rygel_l16_transcoder_parent_class)->finalize (obj);
-}
-
-
-GType rygel_l16_transcoder_get_type (void) {
-	static GType rygel_l16_transcoder_type_id = 0;
-	if (rygel_l16_transcoder_type_id == 0) {
-		static const GTypeInfo g_define_type_info = { sizeof (RygelL16TranscoderClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) rygel_l16_transcoder_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (RygelL16Transcoder), 0, (GInstanceInitFunc) rygel_l16_transcoder_instance_init, NULL };
-		rygel_l16_transcoder_type_id = g_type_register_static (RYGEL_TYPE_TRANSCODER, "RygelL16Transcoder", &g_define_type_info, 0);
-	}
-	return rygel_l16_transcoder_type_id;
-}
-
-
-
-
--- a/src/rygel/rygel-l16-transcoder.vala
+++ /dev/null
@@ -1,152 +0,0 @@
-/*
- * Copyright (C) 2009 Nokia Corporation.
- *
- * Author: Zeeshan Ali (Khattak) <zeeshanak@gnome.org>
- *                               <zeeshan.ali@nokia.com>
- *
- * This file is part of Rygel.
- *
- * Rygel is free software; you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * Rygel is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this program; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
- */
-using Gst;
-using GUPnP;
-using Gee;
-
-internal enum Endianness {
-    LITTLE = ByteOrder.LITTLE_ENDIAN,
-    BIG = ByteOrder.BIG_ENDIAN
-}
-
-/**
- * Transcoder for linear PCM audio (LPCM). This element uses L16TrancoderBin for
- * actual transcoding.
- */
-internal class Rygel.L16Transcoder : Rygel.Transcoder {
-    private const int CHANNELS = 2;
-    private const int FREQUENCY = 44100;
-    private const int WIDTH = 16;
-    private const int DEPTH = 16;
-    private const bool SIGNED = true;
-
-    private Endianness endianness;
-
-    private const string AUDIO_CONVERT = "audioconvert";
-    private const string AUDIO_RESAMPLE = "audioresample";
-    private const string AUDIO_RATE = "audiorate";
-    private const string CAPS_FILTER = "capsfilter";
-
-    public L16Transcoder (Endianness endianness) {
-        var mime_type = "audio/L" + L16Transcoder.WIDTH.to_string () +
-                        ";rate=" + L16Transcoder.FREQUENCY.to_string () +
-                        ";channels=" + L16Transcoder.CHANNELS.to_string ();
-
-        base (mime_type, "LPCM", MediaItem.AUDIO_CLASS);
-
-        this.endianness = endianness;
-    }
-
-    public override Element create_source (MediaItem item,
-                                           Element   src)
-                                           throws Error {
-        return new L16TranscoderBin (item, src, this);
-    }
-
-    public override DIDLLiteResource? add_resource (DIDLLiteItem     didl_item,
-                                                    MediaItem        item,
-                                                    TranscodeManager manager)
-                                                    throws Error {
-        var resource = base.add_resource (didl_item, item, manager);
-        if (resource == null)
-            return null;
-
-        resource.sample_freq = L16Transcoder.FREQUENCY;
-        resource.audio_channels = L16Transcoder.CHANNELS;
-        resource.bits_per_sample = L16Transcoder.WIDTH;
-        // Set bitrate in bytes/second
-        resource.bitrate = L16Transcoder.FREQUENCY *
-                           L16Transcoder.CHANNELS *
-                           L16Transcoder.WIDTH / 8;
-
-        return resource;
-    }
-
-    public override uint get_distance (MediaItem item) {
-        if (item.upnp_class.has_prefix (MediaItem.IMAGE_CLASS)) {
-            return uint.MAX;
-        }
-
-        uint distance;
-
-        if (item.upnp_class.has_prefix (MediaItem.AUDIO_CLASS)) {
-            distance = uint.MIN;
-
-            if (item.sample_freq > 0) {
-                distance += (item.sample_freq - FREQUENCY).abs ();
-            }
-
-            if (item.n_audio_channels > 0) {
-                distance += (item.n_audio_channels - CHANNELS).abs ();
-            }
-
-            if (item.bits_per_sample > 0) {
-                distance += (item.bits_per_sample - WIDTH).abs ();
-            }
-        } else {
-            distance = uint.MAX / 2;
-        }
-
-        return distance;
-    }
-
-    public Element create_encoder (MediaItem item,
-                                   string?   src_pad_name,
-                                   string?   sink_pad_name)
-                                   throws Error {
-        dynamic Element convert1 = GstUtils.create_element (AUDIO_CONVERT,
-                                                            null);
-        dynamic Element resample = GstUtils.create_element (AUDIO_RESAMPLE,
-                                                            AUDIO_RESAMPLE);
-        dynamic Element audiorate = GstUtils.create_element (AUDIO_RATE, null);
-        dynamic Element convert2 = GstUtils.create_element (AUDIO_CONVERT,
-                                                            null);
-        dynamic Element capsfilter = GstUtils.create_element (CAPS_FILTER,
-                                                              CAPS_FILTER);
-
-        var bin = new Bin ("l16-encoder-bin");
-        bin.add_many (convert1, resample, audiorate, convert2, capsfilter);
-
-        capsfilter.caps = new Caps.simple (
-                                    "audio/x-raw-int",
-                                    "channels", typeof (int), CHANNELS,
-                                    "rate",  typeof (int), FREQUENCY,
-                                    "width", typeof (int), WIDTH,
-                                    "depth", typeof (int), DEPTH,
-                                    "signed", typeof (bool), SIGNED,
-                                    "endianness", typeof (int),
-                                    this.endianness);
-
-        convert1.link_many (resample, audiorate, convert2, capsfilter);
-
-        var pad = convert1.get_static_pad ("sink");
-        var ghost = new GhostPad (sink_pad_name, pad);
-        bin.add_pad (ghost);
-
-        pad = capsfilter.get_static_pad ("src");
-        ghost = new GhostPad (src_pad_name, pad);
-        bin.add_pad (ghost);
-
-        return bin;
-    }
-}
--- a/src/rygel/rygel-live-response.c
+++ /dev/null
@@ -1,699 +0,0 @@
-/* rygel-live-response.c generated by valac, the Vala compiler
- * generated from rygel-live-response.vala, do not modify */
-
-/*
- * Copyright (C) 2008 Zeeshan Ali (Khattak) <zeeshanak@gnome.org>.
- * Copyright (C) 2008 Nokia Corporation.
- *
- * Author: Zeeshan Ali (Khattak) <zeeshanak@gnome.org>
- *                               <zeeshan.ali@nokia.com>
- *
- * This file is part of Rygel.
- *
- * Rygel is free software; you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * Rygel is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this program; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
- */
-
-#include <glib.h>
-#include <glib-object.h>
-#include <gio/gio.h>
-#include <libsoup/soup.h>
-#include <gst/gst.h>
-#include <stdlib.h>
-#include <string.h>
-
-
-#define RYGEL_TYPE_STATE_MACHINE (rygel_state_machine_get_type ())
-#define RYGEL_STATE_MACHINE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_STATE_MACHINE, RygelStateMachine))
-#define RYGEL_IS_STATE_MACHINE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_STATE_MACHINE))
-#define RYGEL_STATE_MACHINE_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), RYGEL_TYPE_STATE_MACHINE, RygelStateMachineIface))
-
-typedef struct _RygelStateMachine RygelStateMachine;
-typedef struct _RygelStateMachineIface RygelStateMachineIface;
-
-#define RYGEL_TYPE_HTTP_RESPONSE (rygel_http_response_get_type ())
-#define RYGEL_HTTP_RESPONSE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_HTTP_RESPONSE, RygelHTTPResponse))
-#define RYGEL_HTTP_RESPONSE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_HTTP_RESPONSE, RygelHTTPResponseClass))
-#define RYGEL_IS_HTTP_RESPONSE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_HTTP_RESPONSE))
-#define RYGEL_IS_HTTP_RESPONSE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_HTTP_RESPONSE))
-#define RYGEL_HTTP_RESPONSE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_HTTP_RESPONSE, RygelHTTPResponseClass))
-
-typedef struct _RygelHTTPResponse RygelHTTPResponse;
-typedef struct _RygelHTTPResponseClass RygelHTTPResponseClass;
-typedef struct _RygelHTTPResponsePrivate RygelHTTPResponsePrivate;
-
-#define RYGEL_TYPE_LIVE_RESPONSE (rygel_live_response_get_type ())
-#define RYGEL_LIVE_RESPONSE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_LIVE_RESPONSE, RygelLiveResponse))
-#define RYGEL_LIVE_RESPONSE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_LIVE_RESPONSE, RygelLiveResponseClass))
-#define RYGEL_IS_LIVE_RESPONSE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_LIVE_RESPONSE))
-#define RYGEL_IS_LIVE_RESPONSE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_LIVE_RESPONSE))
-#define RYGEL_LIVE_RESPONSE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_LIVE_RESPONSE, RygelLiveResponseClass))
-
-typedef struct _RygelLiveResponse RygelLiveResponse;
-typedef struct _RygelLiveResponseClass RygelLiveResponseClass;
-typedef struct _RygelLiveResponsePrivate RygelLiveResponsePrivate;
-
-#define RYGEL_TYPE_HTTP_SEEK (rygel_http_seek_get_type ())
-#define RYGEL_HTTP_SEEK(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_HTTP_SEEK, RygelHTTPSeek))
-#define RYGEL_HTTP_SEEK_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_HTTP_SEEK, RygelHTTPSeekClass))
-#define RYGEL_IS_HTTP_SEEK(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_HTTP_SEEK))
-#define RYGEL_IS_HTTP_SEEK_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_HTTP_SEEK))
-#define RYGEL_HTTP_SEEK_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_HTTP_SEEK, RygelHTTPSeekClass))
-
-typedef struct _RygelHTTPSeek RygelHTTPSeek;
-typedef struct _RygelHTTPSeekClass RygelHTTPSeekClass;
-#define _gst_object_unref0(var) ((var == NULL) ? NULL : (var = (gst_object_unref (var), NULL)))
-#define _g_async_queue_unref0(var) ((var == NULL) ? NULL : (var = (g_async_queue_unref (var), NULL)))
-#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
-#define _gst_buffer_unref0(var) ((var == NULL) ? NULL : (var = (gst_buffer_unref (var), NULL)))
-#define _gst_caps_unref0(var) ((var == NULL) ? NULL : (var = (gst_caps_unref (var), NULL)))
-#define _gst_structure_free0(var) ((var == NULL) ? NULL : (var = (gst_structure_free (var), NULL)))
-#define __g_list_free_gst_object_unref0(var) ((var == NULL) ? NULL : (var = (_g_list_free_gst_object_unref (var), NULL)))
-#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
-#define _g_free0(var) (var = (g_free (var), NULL))
-
-typedef enum  {
-	RYGEL_LIVE_RESPONSE_ERROR_MISSING_PLUGIN,
-	RYGEL_LIVE_RESPONSE_ERROR_LINK
-} RygelLiveResponseError;
-#define RYGEL_LIVE_RESPONSE_ERROR rygel_live_response_error_quark ()
-struct _RygelStateMachineIface {
-	GTypeInterface parent_iface;
-	void (*run) (RygelStateMachine* self);
-	GCancellable* (*get_cancellable) (RygelStateMachine* self);
-	void (*set_cancellable) (RygelStateMachine* self, GCancellable* value);
-};
-
-struct _RygelHTTPResponse {
-	GObject parent_instance;
-	RygelHTTPResponsePrivate * priv;
-	SoupMessage* msg;
-};
-
-struct _RygelHTTPResponseClass {
-	GObjectClass parent_class;
-	void (*run) (RygelHTTPResponse* self);
-	void (*end) (RygelHTTPResponse* self, gboolean aborted, guint status);
-};
-
-struct _RygelLiveResponse {
-	RygelHTTPResponse parent_instance;
-	RygelLiveResponsePrivate * priv;
-};
-
-struct _RygelLiveResponseClass {
-	RygelHTTPResponseClass parent_class;
-};
-
-struct _RygelLiveResponsePrivate {
-	GstPipeline* pipeline;
-	GAsyncQueue* buffers;
-	RygelHTTPSeek* time_range;
-};
-
-
-static gpointer rygel_live_response_parent_class = NULL;
-
-GQuark rygel_live_response_error_quark (void);
-GType rygel_state_machine_get_type (void);
-GType rygel_http_response_get_type (void);
-GType rygel_live_response_get_type (void);
-GType rygel_http_seek_get_type (void);
-#define RYGEL_LIVE_RESPONSE_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), RYGEL_TYPE_LIVE_RESPONSE, RygelLiveResponsePrivate))
-enum  {
-	RYGEL_LIVE_RESPONSE_DUMMY_PROPERTY
-};
-#define RYGEL_LIVE_RESPONSE_SINK_NAME "fakesink"
-RygelHTTPResponse* rygel_http_response_construct (GType object_type, SoupServer* server, SoupMessage* msg, gboolean partial, GCancellable* cancellable);
-static void rygel_live_response_prepare_pipeline (RygelLiveResponse* self, const char* name, GstElement* src, GError** error);
-RygelLiveResponse* rygel_live_response_new (SoupServer* server, SoupMessage* msg, const char* name, GstElement* src, RygelHTTPSeek* time_range, GCancellable* cancellable, GError** error);
-RygelLiveResponse* rygel_live_response_construct (GType object_type, SoupServer* server, SoupMessage* msg, const char* name, GstElement* src, RygelHTTPSeek* time_range, GCancellable* cancellable, GError** error);
-void rygel_http_response_run (RygelHTTPResponse* self);
-gint64 rygel_http_seek_get_start (RygelHTTPSeek* self);
-static void rygel_live_response_real_run (RygelHTTPResponse* base);
-void rygel_http_response_end (RygelHTTPResponse* self, gboolean aborted, guint status);
-static void rygel_live_response_real_end (RygelHTTPResponse* base, gboolean aborted, guint status);
-static inline void _dynamic_set_signal_handoffs0 (GstElement* obj, gboolean value);
-static void rygel_live_response_on_new_buffer (RygelLiveResponse* self, GstElement* sink, GstBuffer* buffer, GstPad* pad);
-static void _rygel_live_response_on_new_buffer_dynamic_handoff0_ (GstElement* _sender, GstBuffer* buffer, GstPad* pad, gpointer self);
-void _dynamic_handoff1_connect (gpointer obj, const char * signal_name, GCallback handler, gpointer data);
-static void rygel_live_response_src_pad_added (RygelLiveResponse* self, GstElement* src, GstPad* src_pad);
-static void _rygel_live_response_src_pad_added_gst_element_pad_added (GstElement* _sender, GstPad* pad, gpointer self);
-static gboolean rygel_live_response_bus_handler (RygelLiveResponse* self, GstBus* bus, GstMessage* message);
-static gboolean _rygel_live_response_bus_handler_gst_bus_func (GstBus* bus, GstMessage* message, gpointer self);
-static GstElement* rygel_live_response_get_rtp_depayloader (RygelLiveResponse* self, GstCaps* caps);
-static gboolean rygel_live_response_need_rtp_depayloader (RygelLiveResponse* self, GstCaps* caps);
-static gboolean rygel_live_response_rtp_depay_filter (RygelLiveResponse* self, GstPluginFeature* feature);
-static gboolean _rygel_live_response_rtp_depay_filter_gst_plugin_feature_filter (GstPluginFeature* feature, gpointer self);
-static GstElement* rygel_live_response_get_best_depay (RygelLiveResponse* self, GList* features, GstCaps* caps);
-static void _g_list_free_gst_object_unref (GList* self);
-static gint rygel_live_response_compare_factories (void* a, void* b);
-static gint _rygel_live_response_compare_factories_gcompare_func (void* a, void* b);
-static gboolean rygel_live_response_idle_handler (RygelLiveResponse* self);
-static gboolean _rygel_live_response_idle_handler_gsource_func (gpointer self);
-void rygel_http_response_push_data (RygelHTTPResponse* self, void* data, gsize length);
-static gboolean rygel_live_response_seek (RygelLiveResponse* self);
-gint64 rygel_http_seek_get_stop (RygelHTTPSeek* self);
-static void rygel_live_response_finalize (GObject* obj);
-static int _vala_strcmp0 (const char * str1, const char * str2);
-
-
-static void g_cclosure_user_marshal_VOID__POINTER_OBJECT (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data);
-
-GQuark rygel_live_response_error_quark (void) {
-	return g_quark_from_static_string ("rygel_live_response_error-quark");
-}
-
-
-static gpointer _g_object_ref0 (gpointer self) {
-	return self ? g_object_ref (self) : NULL;
-}
-
-
-RygelLiveResponse* rygel_live_response_construct (GType object_type, SoupServer* server, SoupMessage* msg, const char* name, GstElement* src, RygelHTTPSeek* time_range, GCancellable* cancellable, GError** error) {
-	GError * _inner_error_;
-	RygelLiveResponse * self;
-	GAsyncQueue* _tmp0_;
-	RygelHTTPSeek* _tmp1_;
-	g_return_val_if_fail (server != NULL, NULL);
-	g_return_val_if_fail (msg != NULL, NULL);
-	g_return_val_if_fail (name != NULL, NULL);
-	g_return_val_if_fail (src != NULL, NULL);
-	_inner_error_ = NULL;
-	self = (RygelLiveResponse*) rygel_http_response_construct (object_type, server, msg, FALSE, cancellable);
-	soup_message_headers_set_encoding (((RygelHTTPResponse*) self)->msg->response_headers, SOUP_ENCODING_EOF);
-	self->priv->buffers = (_tmp0_ = g_async_queue_new (), _g_async_queue_unref0 (self->priv->buffers), _tmp0_);
-	rygel_live_response_prepare_pipeline (self, name, src, &_inner_error_);
-	if (_inner_error_ != NULL) {
-		g_propagate_error (error, _inner_error_);
-		return;
-	}
-	self->priv->time_range = (_tmp1_ = _g_object_ref0 (time_range), _g_object_unref0 (self->priv->time_range), _tmp1_);
-	return self;
-}
-
-
-RygelLiveResponse* rygel_live_response_new (SoupServer* server, SoupMessage* msg, const char* name, GstElement* src, RygelHTTPSeek* time_range, GCancellable* cancellable, GError** error) {
-	return rygel_live_response_construct (RYGEL_TYPE_LIVE_RESPONSE, server, msg, name, src, time_range, cancellable, error);
-}
-
-
-static void rygel_live_response_real_run (RygelHTTPResponse* base) {
-	RygelLiveResponse * self;
-	gboolean _tmp0_ = FALSE;
-	self = (RygelLiveResponse*) base;
-	RYGEL_HTTP_RESPONSE_CLASS (rygel_live_response_parent_class)->run (RYGEL_HTTP_RESPONSE (self));
-	if (self->priv->time_range != NULL) {
-		_tmp0_ = rygel_http_seek_get_start (self->priv->time_range) > 0;
-	} else {
-		_tmp0_ = FALSE;
-	}
-	if (_tmp0_) {
-		gst_element_set_state ((GstElement*) self->priv->pipeline, GST_STATE_PAUSED);
-	} else {
-		gst_element_set_state ((GstElement*) self->priv->pipeline, GST_STATE_PLAYING);
-	}
-}
-
-
-static void rygel_live_response_real_end (RygelHTTPResponse* base, gboolean aborted, guint status) {
-	RygelLiveResponse * self;
-	GstBuffer* buffer;
-	self = (RygelLiveResponse*) base;
-	gst_element_set_state ((GstElement*) self->priv->pipeline, GST_STATE_NULL);
-	buffer = NULL;
-	{
-		gboolean _tmp0_;
-		_tmp0_ = TRUE;
-		while (TRUE) {
-			GstBuffer* _tmp1_;
-			if (!_tmp0_) {
-				if (!(buffer != NULL)) {
-					break;
-				}
-			}
-			_tmp0_ = FALSE;
-			buffer = (_tmp1_ = (GstBuffer*) g_async_queue_try_pop (self->priv->buffers), _gst_buffer_unref0 (buffer), _tmp1_);
-		}
-	}
-	if (!aborted) {
-		soup_message_body_complete (((RygelHTTPResponse*) self)->msg->response_body);
-	}
-	RYGEL_HTTP_RESPONSE_CLASS (rygel_live_response_parent_class)->end (RYGEL_HTTP_RESPONSE (self), aborted, status);
-	_gst_buffer_unref0 (buffer);
-}
-
-
-static inline void _dynamic_set_signal_handoffs0 (GstElement* obj, gboolean value) {
-	g_object_set (obj, "signal-handoffs", value, NULL);
-}
-
-
-static void _rygel_live_response_on_new_buffer_dynamic_handoff0_ (GstElement* _sender, GstBuffer* buffer, GstPad* pad, gpointer self) {
-	rygel_live_response_on_new_buffer (self, _sender, buffer, pad);
-}
-
-
-void _dynamic_handoff1_connect (gpointer obj, const char * signal_name, GCallback handler, gpointer data) {
-	g_signal_connect_object (obj, signal_name, handler, data, 0);
-}
-
-
-static gpointer _gst_object_ref0 (gpointer self) {
-	return self ? gst_object_ref (self) : NULL;
-}
-
-
-static void _rygel_live_response_src_pad_added_gst_element_pad_added (GstElement* _sender, GstPad* pad, gpointer self) {
-	rygel_live_response_src_pad_added (self, _sender, pad);
-}
-
-
-static gboolean _rygel_live_response_bus_handler_gst_bus_func (GstBus* bus, GstMessage* message, gpointer self) {
-	return rygel_live_response_bus_handler (self, bus, message);
-}
-
-
-static void rygel_live_response_prepare_pipeline (RygelLiveResponse* self, const char* name, GstElement* src, GError** error) {
-	GError * _inner_error_;
-	GstElement* sink;
-	GstPipeline* _tmp0_;
-	GstBus* bus;
-	g_return_if_fail (self != NULL);
-	g_return_if_fail (name != NULL);
-	g_return_if_fail (src != NULL);
-	_inner_error_ = NULL;
-	sink = gst_element_factory_make ("fakesink", RYGEL_LIVE_RESPONSE_SINK_NAME);
-	if (sink == NULL) {
-		_inner_error_ = g_error_new_literal (RYGEL_LIVE_RESPONSE_ERROR, RYGEL_LIVE_RESPONSE_ERROR_MISSING_PLUGIN, "Required plugin 'fakesink' missing");
-		if (_inner_error_ != NULL) {
-			g_propagate_error (error, _inner_error_);
-			_gst_object_unref0 (sink);
-			return;
-		}
-	}
-	_dynamic_set_signal_handoffs0 (sink, TRUE);
-	_dynamic_handoff1_connect (sink, "handoff", (GCallback) _rygel_live_response_on_new_buffer_dynamic_handoff0_, self);
-	self->priv->pipeline = (_tmp0_ = (GstPipeline*) gst_pipeline_new (name), _gst_object_unref0 (self->priv->pipeline), _tmp0_);
-	g_assert (self->priv->pipeline != NULL);
-	gst_bin_add_many ((GstBin*) self->priv->pipeline, _gst_object_ref0 (src), _gst_object_ref0 (sink), NULL);
-	if (src->numpads == 0) {
-		g_signal_connect_object (src, "pad-added", (GCallback) _rygel_live_response_src_pad_added_gst_element_pad_added, self, 0);
-	} else {
-		if (!gst_element_link (src, sink)) {
-			_inner_error_ = g_error_new (RYGEL_LIVE_RESPONSE_ERROR, RYGEL_LIVE_RESPONSE_ERROR_LINK, "Failed to link %s to %s", gst_object_get_name ((GstObject*) src), gst_object_get_name ((GstObject*) sink));
-			if (_inner_error_ != NULL) {
-				g_propagate_error (error, _inner_error_);
-				_gst_object_unref0 (sink);
-				return;
-			}
-		}
-	}
-	bus = gst_pipeline_get_bus (self->priv->pipeline);
-	gst_bus_add_watch (bus, _rygel_live_response_bus_handler_gst_bus_func, self);
-	_gst_object_unref0 (sink);
-	_gst_object_unref0 (bus);
-}
-
-
-static void rygel_live_response_src_pad_added (RygelLiveResponse* self, GstElement* src, GstPad* src_pad) {
-	GstCaps* caps;
-	GstElement* sink;
-	GstPad* sink_pad;
-	GstElement* depay;
-	g_return_if_fail (self != NULL);
-	g_return_if_fail (src != NULL);
-	g_return_if_fail (src_pad != NULL);
-	caps = gst_pad_get_caps (src_pad);
-	sink = gst_bin_get_by_name ((GstBin*) self->priv->pipeline, RYGEL_LIVE_RESPONSE_SINK_NAME);
-	sink_pad = NULL;
-	depay = rygel_live_response_get_rtp_depayloader (self, caps);
-	if (depay != NULL) {
-		GstPad* _tmp0_;
-		gst_bin_add ((GstBin*) self->priv->pipeline, _gst_object_ref0 (depay));
-		if (!gst_element_link (depay, sink)) {
-			g_critical ("rygel-live-response.vala:130: Failed to link %s to %s", gst_object_get_name ((GstObject*) depay), gst_object_get_name ((GstObject*) sink));
-			rygel_http_response_end ((RygelHTTPResponse*) self, FALSE, (guint) SOUP_STATUS_NONE);
-			_gst_caps_unref0 (caps);
-			_gst_object_unref0 (sink);
-			_gst_object_unref0 (sink_pad);
-			_gst_object_unref0 (depay);
-			return;
-		}
-		sink_pad = (_tmp0_ = _gst_object_ref0 (gst_element_get_compatible_pad (depay, src_pad, caps)), _gst_object_unref0 (sink_pad), _tmp0_);
-	} else {
-		GstPad* _tmp1_;
-		sink_pad = (_tmp1_ = _gst_object_ref0 (gst_element_get_compatible_pad (sink, src_pad, caps)), _gst_object_unref0 (sink_pad), _tmp1_);
-	}
-	if (gst_pad_link (src_pad, sink_pad) != GST_PAD_LINK_OK) {
-		g_critical ("rygel-live-response.vala:143: Failed to link pad %s to %s", gst_object_get_name ((GstObject*) src_pad), gst_object_get_name ((GstObject*) sink_pad));
-		rygel_http_response_end ((RygelHTTPResponse*) self, FALSE, (guint) SOUP_STATUS_NONE);
-		_gst_caps_unref0 (caps);
-		_gst_object_unref0 (sink);
-		_gst_object_unref0 (sink_pad);
-		_gst_object_unref0 (depay);
-		return;
-	}
-	if (depay != NULL) {
-		gst_element_sync_state_with_parent (depay);
-	}
-	_gst_caps_unref0 (caps);
-	_gst_object_unref0 (sink);
-	_gst_object_unref0 (sink_pad);
-	_gst_object_unref0 (depay);
-}
-
-
-static gpointer _gst_structure_copy0 (gpointer self) {
-	return self ? gst_structure_copy (self) : NULL;
-}
-
-
-static gboolean rygel_live_response_need_rtp_depayloader (RygelLiveResponse* self, GstCaps* caps) {
-	gboolean result;
-	GstStructure* structure;
-	g_return_val_if_fail (self != NULL, FALSE);
-	g_return_val_if_fail (caps != NULL, FALSE);
-	structure = _gst_structure_copy0 (gst_caps_get_structure (caps, (guint) 0));
-	result = _vala_strcmp0 (gst_structure_get_name (structure), "application/x-rtp") == 0;
-	_gst_structure_free0 (structure);
-	return result;
-}
-
-
-static gboolean _rygel_live_response_rtp_depay_filter_gst_plugin_feature_filter (GstPluginFeature* feature, gpointer self) {
-	return rygel_live_response_rtp_depay_filter (self, feature);
-}
-
-
-static void _g_list_free_gst_object_unref (GList* self) {
-	g_list_foreach (self, (GFunc) gst_object_unref, NULL);
-	g_list_free (self);
-}
-
-
-static GstElement* rygel_live_response_get_rtp_depayloader (RygelLiveResponse* self, GstCaps* caps) {
-	GstElement* result;
-	GstRegistry* registry;
-	GList* features;
-	g_return_val_if_fail (self != NULL, NULL);
-	g_return_val_if_fail (caps != NULL, NULL);
-	if (!rygel_live_response_need_rtp_depayloader (self, caps)) {
-		result = NULL;
-		return result;
-	}
-	registry = gst_registry_get_default ();
-	features = gst_registry_feature_filter (registry, _rygel_live_response_rtp_depay_filter_gst_plugin_feature_filter, FALSE, self);
-	result = rygel_live_response_get_best_depay (self, features, caps);
-	__g_list_free_gst_object_unref0 (features);
-	return result;
-}
-
-
-static gint _rygel_live_response_compare_factories_gcompare_func (void* a, void* b) {
-	return rygel_live_response_compare_factories (a, b);
-}
-
-
-static GstElement* rygel_live_response_get_best_depay (RygelLiveResponse* self, GList* features, GstCaps* caps) {
-	GstElement* result;
-	GList* relevant_factories;
-	GstElementFactory* factory;
-	g_return_val_if_fail (self != NULL, NULL);
-	g_return_val_if_fail (caps != NULL, NULL);
-	relevant_factories = NULL;
-	{
-		GList* feature_collection;
-		GList* feature_it;
-		feature_collection = features;
-		for (feature_it = feature_collection; feature_it != NULL; feature_it = feature_it->next) {
-			GstPluginFeature* feature;
-			feature = _gst_object_ref0 ((GstPluginFeature*) feature_it->data);
-			{
-				GstElementFactory* factory;
-				factory = _gst_object_ref0 (GST_ELEMENT_FACTORY (feature));
-				if (gst_element_factory_can_sink_caps (factory, caps)) {
-					relevant_factories = g_list_append (relevant_factories, _gst_object_ref0 (factory));
-				}
-				_gst_object_unref0 (feature);
-				_gst_object_unref0 (factory);
-			}
-		}
-	}
-	if (g_list_length (relevant_factories) == 0) {
-		result = NULL;
-		__g_list_free_gst_object_unref0 (relevant_factories);
-		return result;
-	}
-	relevant_factories = g_list_sort (relevant_factories, _rygel_live_response_compare_factories_gcompare_func);
-	factory = _gst_object_ref0 ((GstElementFactory*) relevant_factories->data);
-	result = gst_element_factory_make (gst_plugin_feature_get_name ((GstPluginFeature*) factory), NULL);
-	__g_list_free_gst_object_unref0 (relevant_factories);
-	_gst_object_unref0 (factory);
-	return result;
-}
-
-
-static gboolean string_contains (const char* self, const char* needle) {
-	gboolean result;
-	g_return_val_if_fail (self != NULL, FALSE);
-	g_return_val_if_fail (needle != NULL, FALSE);
-	result = strstr (self, needle) != NULL;
-	return result;
-}
-
-
-static gboolean rygel_live_response_rtp_depay_filter (RygelLiveResponse* self, GstPluginFeature* feature) {
-	gboolean result;
-	GstElementFactory* factory;
-	g_return_val_if_fail (self != NULL, FALSE);
-	g_return_val_if_fail (feature != NULL, FALSE);
-	if (!g_type_is_a (G_TYPE_FROM_INSTANCE ((GObject*) feature), GST_TYPE_ELEMENT_FACTORY)) {
-		result = FALSE;
-		return result;
-	}
-	factory = _gst_object_ref0 (GST_ELEMENT_FACTORY (feature));
-	result = string_contains (gst_element_factory_get_klass (factory), "Depayloader");
-	_gst_object_unref0 (factory);
-	return result;
-}
-
-
-static gint rygel_live_response_compare_factories (void* a, void* b) {
-	gint result;
-	GstElementFactory* factory_a;
-	GstElementFactory* factory_b;
-	factory_a = _gst_object_ref0 (GST_ELEMENT_FACTORY (a));
-	factory_b = _gst_object_ref0 (GST_ELEMENT_FACTORY (b));
-	result = (gint) (gst_plugin_feature_get_rank ((GstPluginFeature*) factory_b) - gst_plugin_feature_get_rank ((GstPluginFeature*) factory_a));
-	_gst_object_unref0 (factory_a);
-	_gst_object_unref0 (factory_b);
-	return result;
-}
-
-
-static gpointer _gst_buffer_ref0 (gpointer self) {
-	return self ? gst_buffer_ref (self) : NULL;
-}
-
-
-static gboolean _rygel_live_response_idle_handler_gsource_func (gpointer self) {
-	return rygel_live_response_idle_handler (self);
-}
-
-
-static void rygel_live_response_on_new_buffer (RygelLiveResponse* self, GstElement* sink, GstBuffer* buffer, GstPad* pad) {
-	g_return_if_fail (self != NULL);
-	g_return_if_fail (sink != NULL);
-	g_return_if_fail (buffer != NULL);
-	g_return_if_fail (pad != NULL);
-	g_async_queue_push (self->priv->buffers, _gst_buffer_ref0 (buffer));
-	g_idle_add_full (G_PRIORITY_HIGH_IDLE, _rygel_live_response_idle_handler_gsource_func, g_object_ref (self), g_object_unref);
-}
-
-
-static gboolean rygel_live_response_idle_handler (RygelLiveResponse* self) {
-	gboolean result;
-	GstBuffer* buffer;
-	g_return_val_if_fail (self != NULL, FALSE);
-	buffer = (GstBuffer*) g_async_queue_try_pop (self->priv->buffers);
-	if (buffer != NULL) {
-		rygel_http_response_push_data ((RygelHTTPResponse*) self, buffer->data, (gsize) buffer->size);
-	}
-	result = FALSE;
-	_gst_buffer_unref0 (buffer);
-	return result;
-}
-
-
-static gboolean rygel_live_response_bus_handler (RygelLiveResponse* self, GstBus* bus, GstMessage* message) {
-	gboolean result;
-	gboolean ret;
-	g_return_val_if_fail (self != NULL, FALSE);
-	g_return_val_if_fail (bus != NULL, FALSE);
-	g_return_val_if_fail (message != NULL, FALSE);
-	ret = TRUE;
-	if (message->type == GST_MESSAGE_EOS) {
-		ret = FALSE;
-	} else {
-		if (message->type == GST_MESSAGE_STATE_CHANGED) {
-			gboolean _tmp0_ = FALSE;
-			if (message->src != GST_OBJECT (self->priv->pipeline)) {
-				result = TRUE;
-				return result;
-			}
-			if (self->priv->time_range != NULL) {
-				_tmp0_ = rygel_http_seek_get_start (self->priv->time_range) > 0;
-			} else {
-				_tmp0_ = FALSE;
-			}
-			if (_tmp0_) {
-				GstState old_state = 0;
-				GstState new_state = 0;
-				gboolean _tmp1_ = FALSE;
-				gst_message_parse_state_changed (message, &old_state, &new_state, NULL);
-				if (old_state == GST_STATE_READY) {
-					_tmp1_ = new_state == GST_STATE_PAUSED;
-				} else {
-					_tmp1_ = FALSE;
-				}
-				if (_tmp1_) {
-					if (rygel_live_response_seek (self)) {
-						gst_element_set_state ((GstElement*) self->priv->pipeline, GST_STATE_PLAYING);
-					}
-				}
-			}
-		} else {
-			GError* err;
-			char* err_msg;
-			err = NULL;
-			err_msg = NULL;
-			if (message->type == GST_MESSAGE_ERROR) {
-				char* _tmp5_;
-				char* _tmp4_ = NULL;
-				GError* _tmp3_;
-				GError* _tmp2_ = NULL;
-				(gst_message_parse_error (message, &_tmp2_, &_tmp4_), err = (_tmp3_ = _tmp2_, _g_error_free0 (err), _tmp3_));
-				err_msg = (_tmp5_ = _tmp4_, _g_free0 (err_msg), _tmp5_);
-				g_critical ("rygel-live-response.vala:262: Error from pipeline %s:%s", gst_object_get_name ((GstObject*) self->priv->pipeline), err_msg);
-				ret = FALSE;
-			} else {
-				if (message->type == GST_MESSAGE_WARNING) {
-					char* _tmp9_;
-					char* _tmp8_ = NULL;
-					GError* _tmp7_;
-					GError* _tmp6_ = NULL;
-					(gst_message_parse_warning (message, &_tmp6_, &_tmp8_), err = (_tmp7_ = _tmp6_, _g_error_free0 (err), _tmp7_));
-					err_msg = (_tmp9_ = _tmp8_, _g_free0 (err_msg), _tmp9_);
-					g_warning ("rygel-live-response.vala:269: Warning from pipeline %s:%s", gst_object_get_name ((GstObject*) self->priv->pipeline), err_msg);
-				}
-			}
-			_g_error_free0 (err);
-			_g_free0 (err_msg);
-		}
-	}
-	if (!ret) {
-		rygel_http_response_end ((RygelHTTPResponse*) self, FALSE, (guint) SOUP_STATUS_NONE);
-	}
-	result = ret;
-	return result;
-}
-
-
-static gboolean rygel_live_response_seek (RygelLiveResponse* self) {
-	gboolean result;
-	GstSeekType stop_type = 0;
-	g_return_val_if_fail (self != NULL, FALSE);
-	if (rygel_http_seek_get_stop (self->priv->time_range) > 0) {
-		stop_type = GST_SEEK_TYPE_SET;
-	} else {
-		stop_type = GST_SEEK_TYPE_NONE;
-	}
-	if (!gst_element_seek ((GstElement*) self->priv->pipeline, 1.0, GST_FORMAT_TIME, GST_SEEK_FLAG_FLUSH, GST_SEEK_TYPE_SET, rygel_http_seek_get_start (self->priv->time_range), stop_type, rygel_http_seek_get_stop (self->priv->time_range))) {
-		g_warning ("rygel-live-response.vala:298: Failed to seek to offset %lld", rygel_http_seek_get_start (self->priv->time_range));
-		rygel_http_response_end ((RygelHTTPResponse*) self, FALSE, (guint) SOUP_STATUS_REQUESTED_RANGE_NOT_SATISFIABLE);
-		result = FALSE;
-		return result;
-	}
-	result = TRUE;
-	return result;
-}
-
-
-static void rygel_live_response_class_init (RygelLiveResponseClass * klass) {
-	rygel_live_response_parent_class = g_type_class_peek_parent (klass);
-	g_type_class_add_private (klass, sizeof (RygelLiveResponsePrivate));
-	RYGEL_HTTP_RESPONSE_CLASS (klass)->run = rygel_live_response_real_run;
-	RYGEL_HTTP_RESPONSE_CLASS (klass)->end = rygel_live_response_real_end;
-	G_OBJECT_CLASS (klass)->finalize = rygel_live_response_finalize;
-}
-
-
-static void rygel_live_response_instance_init (RygelLiveResponse * self) {
-	self->priv = RYGEL_LIVE_RESPONSE_GET_PRIVATE (self);
-}
-
-
-static void rygel_live_response_finalize (GObject* obj) {
-	RygelLiveResponse * self;
-	self = RYGEL_LIVE_RESPONSE (obj);
-	_gst_object_unref0 (self->priv->pipeline);
-	_g_async_queue_unref0 (self->priv->buffers);
-	_g_object_unref0 (self->priv->time_range);
-	G_OBJECT_CLASS (rygel_live_response_parent_class)->finalize (obj);
-}
-
-
-GType rygel_live_response_get_type (void) {
-	static GType rygel_live_response_type_id = 0;
-	if (rygel_live_response_type_id == 0) {
-		static const GTypeInfo g_define_type_info = { sizeof (RygelLiveResponseClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) rygel_live_response_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (RygelLiveResponse), 0, (GInstanceInitFunc) rygel_live_response_instance_init, NULL };
-		rygel_live_response_type_id = g_type_register_static (RYGEL_TYPE_HTTP_RESPONSE, "RygelLiveResponse", &g_define_type_info, 0);
-	}
-	return rygel_live_response_type_id;
-}
-
-
-static int _vala_strcmp0 (const char * str1, const char * str2) {
-	if (str1 == NULL) {
-		return -(str1 != str2);
-	}
-	if (str2 == NULL) {
-		return str1 != str2;
-	}
-	return strcmp (str1, str2);
-}
-
-
-
-static void g_cclosure_user_marshal_VOID__POINTER_OBJECT (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data) {
-	typedef void (*GMarshalFunc_VOID__POINTER_OBJECT) (gpointer data1, gpointer arg_1, gpointer arg_2, gpointer data2);
-	register GMarshalFunc_VOID__POINTER_OBJECT callback;
-	register GCClosure * cc;
-	register gpointer data1, data2;
-	cc = (GCClosure *) closure;
-	g_return_if_fail (n_param_values == 3);
-	if (G_CCLOSURE_SWAP_DATA (closure)) {
-		data1 = closure->data;
-		data2 = param_values->data[0].v_pointer;
-	} else {
-		data1 = param_values->data[0].v_pointer;
-		data2 = closure->data;
-	}
-	callback = (GMarshalFunc_VOID__POINTER_OBJECT) (marshal_data ? marshal_data : cc->callback);
-	callback (data1, gst_value_get_mini_object (param_values + 1), g_value_get_object (param_values + 2), data2);
-}
-
-
-
--- a/src/rygel/rygel-live-response.vala
+++ /dev/null
@@ -1,309 +0,0 @@
-/*
- * Copyright (C) 2008 Zeeshan Ali (Khattak) <zeeshanak@gnome.org>.
- * Copyright (C) 2008 Nokia Corporation.
- *
- * Author: Zeeshan Ali (Khattak) <zeeshanak@gnome.org>
- *                               <zeeshan.ali@nokia.com>
- *
- * This file is part of Rygel.
- *
- * Rygel is free software; you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * Rygel is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this program; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
- */
-
-using GUPnP;
-using Gee;
-using Gst;
-
-internal errordomain Rygel.LiveResponseError {
-    MISSING_PLUGIN,
-    LINK
-}
-
-internal class Rygel.LiveResponse : Rygel.HTTPResponse {
-    private const string SINK_NAME = "fakesink";
-
-    private Pipeline pipeline;
-
-    private AsyncQueue<Buffer> buffers;
-
-    private HTTPSeek time_range;
-
-    public LiveResponse (Soup.Server  server,
-                         Soup.Message msg,
-                         string       name,
-                         Element      src,
-                         HTTPSeek?    time_range,
-                         Cancellable? cancellable) throws Error {
-        base (server, msg, false, cancellable);
-
-        this.msg.response_headers.set_encoding (Soup.Encoding.EOF);
-
-        this.buffers = new AsyncQueue<Buffer> ();
-
-        this.prepare_pipeline (name, src);
-        this.time_range = time_range;
-    }
-
-    public override void run () {
-        base.run ();
-
-        // Only bother attempting to seek if the offset is greater than zero.
-        if (this.time_range != null && this.time_range.start > 0) {
-            this.pipeline.set_state (State.PAUSED);
-        } else {
-            this.pipeline.set_state (State.PLAYING);
-        }
-    }
-
-    public override void end (bool aborted, uint status) {
-        this.pipeline.set_state (State.NULL);
-        // Flush the queue of buffers
-        Buffer buffer = null;
-        do {
-            buffer = this.buffers.try_pop ();
-        } while (buffer != null);
-
-        if (!aborted) {
-            this.msg.response_body.complete ();
-        }
-
-        base.end (aborted, status);
-    }
-
-    private void prepare_pipeline (string name,
-                                   Element src) throws Error {
-        dynamic Element sink = ElementFactory.make ("fakesink", SINK_NAME);
-
-        if (sink == null) {
-            throw new LiveResponseError.MISSING_PLUGIN (
-                                    "Required plugin 'fakesink' missing");
-        }
-
-        sink.signal_handoffs = true;
-        sink.handoff += this.on_new_buffer;
-
-        this.pipeline = new Pipeline (name);
-        assert (this.pipeline != null);
-
-        this.pipeline.add_many (src, sink);
-
-        if (src.numpads == 0) {
-            // Seems source uses dynamic pads, link when pad available
-            src.pad_added += this.src_pad_added;
-        } else {
-            // static pads? easy!
-            if (!src.link (sink)) {
-                throw new LiveResponseError.LINK ("Failed to link %s to %s",
-                                                  src.name,
-                                                  sink.name);
-            }
-        }
-
-        // Bus handler
-        var bus = this.pipeline.get_bus ();
-        bus.add_watch (bus_handler);
-    }
-
-    private void src_pad_added (Element src,
-                                Pad     src_pad) {
-        var caps = src_pad.get_caps ();
-
-        var sink = this.pipeline.get_by_name (SINK_NAME);
-        Pad sink_pad;
-
-        dynamic Element depay = this.get_rtp_depayloader (caps);
-        if (depay != null) {
-            this.pipeline.add (depay);
-            if (!depay.link (sink)) {
-                critical ("Failed to link %s to %s",
-                          depay.name,
-                          sink.name);
-                this.end (false, Soup.KnownStatusCode.NONE);
-                return;
-            }
-
-            sink_pad = depay.get_compatible_pad (src_pad, caps);
-        } else {
-            sink_pad = sink.get_compatible_pad (src_pad, caps);
-        }
-
-        if (src_pad.link (sink_pad) != PadLinkReturn.OK) {
-            critical ("Failed to link pad %s to %s",
-                      src_pad.name,
-                      sink_pad.name);
-            this.end (false, Soup.KnownStatusCode.NONE);
-            return;
-        }
-
-        if (depay != null) {
-            depay.sync_state_with_parent ();
-        }
-    }
-
-    private bool need_rtp_depayloader (Caps caps) {
-        var structure = caps.get_structure (0);
-        return structure.get_name () == "application/x-rtp";
-    }
-
-    private dynamic Element? get_rtp_depayloader (Caps caps) {
-        if (!need_rtp_depayloader (caps)) {
-            return null;
-        }
-
-        unowned Registry registry = Registry.get_default ();
-        var features = registry.feature_filter (this.rtp_depay_filter, false);
-
-        return get_best_depay (features, caps);
-    }
-
-    private dynamic Element? get_best_depay (GLib.List<PluginFeature> features,
-                                             Caps                     caps) {
-        var relevant_factories = new GLib.List<ElementFactory> ();
-
-        // First construct a list of relevant factories
-        foreach (PluginFeature feature in features) {
-            var factory = (ElementFactory) feature;
-            if (factory.can_sink_caps (caps)) {
-               relevant_factories.append (factory);
-            }
-        }
-
-        if (relevant_factories.length () == 0) {
-            // No relevant factory available, hence no depayloader
-            return null;
-        }
-
-        // Then sort the list through their ranks
-        relevant_factories.sort (this.compare_factories);
-
-        // create an element of the top ranking factory and return it
-        var factory = relevant_factories.data;
-
-        return ElementFactory.make (factory.get_name (), null);
-    }
-
-    private bool rtp_depay_filter (PluginFeature feature) {
-        if (!feature.get_type ().is_a (typeof (ElementFactory))) {
-            return false;
-        }
-
-        var factory = (ElementFactory) feature;
-
-        return factory.get_klass ().contains ("Depayloader");
-    }
-
-    private static int compare_factories (void *a, void *b) {
-        ElementFactory factory_a = (ElementFactory) a;
-        ElementFactory factory_b = (ElementFactory) b;
-
-        return (int) (factory_b.get_rank () - factory_a.get_rank ());
-    }
-
-    private void on_new_buffer (Element sink,
-                                Buffer  buffer,
-                                Pad     pad) {
-        this.buffers.push (buffer);
-        Idle.add_full (Priority.HIGH_IDLE, this.idle_handler);
-    }
-
-    private bool idle_handler () {
-        var buffer = this.buffers.try_pop ();
-
-        if (buffer != null) {
-            this.push_data (buffer.data, buffer.size);
-        }
-
-        return false;
-    }
-
-    private bool bus_handler (Gst.Bus     bus,
-                              Gst.Message message) {
-        bool ret = true;
-
-        if (message.type == MessageType.EOS) {
-            ret = false;
-        } else if (message.type == MessageType.STATE_CHANGED) {
-            if (message.src != this.pipeline) {
-                return true;
-            }
-
-            if (this.time_range != null && this.time_range.start > 0) {
-                State old_state;
-                State new_state;
-
-                message.parse_state_changed (out old_state,
-                                             out new_state,
-                                             null);
-
-                if (old_state == State.READY && new_state == State.PAUSED) {
-                    if (this.seek ()) {
-                        this.pipeline.set_state (State.PLAYING);
-                    }
-                }
-            }
-        } else {
-            GLib.Error err;
-            string err_msg;
-
-            if (message.type == MessageType.ERROR) {
-                message.parse_error (out err, out err_msg);
-                critical ("Error from pipeline %s:%s",
-                          this.pipeline.name,
-                          err_msg);
-
-                ret = false;
-            } else if (message.type == MessageType.WARNING) {
-                message.parse_warning (out err, out err_msg);
-                warning ("Warning from pipeline %s:%s",
-                         this.pipeline.name,
-                         err_msg);
-            }
-        }
-
-        if (!ret) {
-            this.end (false, Soup.KnownStatusCode.NONE);
-        }
-
-        return ret;
-    }
-
-    private bool seek () {
-        Gst.SeekType stop_type;
-
-        if (this.time_range.stop > 0) {
-            stop_type = Gst.SeekType.SET;
-        } else {
-            stop_type = Gst.SeekType.NONE;
-        }
-
-        if (!this.pipeline.seek (1.0,
-                                 Format.TIME,
-                                 SeekFlags.FLUSH,
-                                 Gst.SeekType.SET,
-                                 this.time_range.start,
-                                 stop_type,
-                                 this.time_range.stop)) {
-            warning ("Failed to seek to offset %lld", this.time_range.start);
-
-            this.end (false,
-                      Soup.KnownStatusCode.REQUESTED_RANGE_NOT_SATISFIABLE);
-
-            return false;
-        }
-
-        return true;
-    }
-}
-
--- a/src/rygel/rygel-log-handler.c
+++ /dev/null
@@ -1,268 +0,0 @@
-/* rygel-log-handler.c generated by valac, the Vala compiler
- * generated from rygel-log-handler.vala, do not modify */
-
-/*
- * Copyright (C) 2008 Nokia Corporation.
- *
- * Author: Zeeshan Ali (Khattak) <zeeshanak@gnome.org>
- *                               <zeeshan.ali@nokia.com>
- *
- * This file is part of Rygel.
- *
- * Rygel is free software; you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * Rygel is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this program; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
- */
-
-#include <glib.h>
-#include <glib-object.h>
-#include <stdlib.h>
-#include <string.h>
-#include <gee.h>
-
-
-#define RYGEL_TYPE_LOG_LEVEL (rygel_log_level_get_type ())
-
-#define RYGEL_TYPE_LOG_HANDLER (rygel_log_handler_get_type ())
-#define RYGEL_LOG_HANDLER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_LOG_HANDLER, RygelLogHandler))
-#define RYGEL_LOG_HANDLER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_LOG_HANDLER, RygelLogHandlerClass))
-#define RYGEL_IS_LOG_HANDLER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_LOG_HANDLER))
-#define RYGEL_IS_LOG_HANDLER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_LOG_HANDLER))
-#define RYGEL_LOG_HANDLER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_LOG_HANDLER, RygelLogHandlerClass))
-
-typedef struct _RygelLogHandler RygelLogHandler;
-typedef struct _RygelLogHandlerClass RygelLogHandlerClass;
-typedef struct _RygelLogHandlerPrivate RygelLogHandlerPrivate;
-#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
-
-#define RYGEL_TYPE_META_CONFIG (rygel_meta_config_get_type ())
-#define RYGEL_META_CONFIG(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_META_CONFIG, RygelMetaConfig))
-#define RYGEL_META_CONFIG_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_META_CONFIG, RygelMetaConfigClass))
-#define RYGEL_IS_META_CONFIG(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_META_CONFIG))
-#define RYGEL_IS_META_CONFIG_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_META_CONFIG))
-#define RYGEL_META_CONFIG_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_META_CONFIG, RygelMetaConfigClass))
-
-typedef struct _RygelMetaConfig RygelMetaConfig;
-typedef struct _RygelMetaConfigClass RygelMetaConfigClass;
-
-#define RYGEL_TYPE_CONFIGURATION (rygel_configuration_get_type ())
-#define RYGEL_CONFIGURATION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_CONFIGURATION, RygelConfiguration))
-#define RYGEL_IS_CONFIGURATION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_CONFIGURATION))
-#define RYGEL_CONFIGURATION_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), RYGEL_TYPE_CONFIGURATION, RygelConfigurationIface))
-
-typedef struct _RygelConfiguration RygelConfiguration;
-typedef struct _RygelConfigurationIface RygelConfigurationIface;
-
-typedef enum  {
-	RYGEL_LOG_LEVEL_INVALID = 0,
-	RYGEL_LOG_LEVEL_CRITICAL = 1,
-	RYGEL_LOG_LEVEL_ERROR = 2,
-	RYGEL_LOG_LEVEL_WARNING = 3,
-	RYGEL_LOG_LEVEL_INFO = 4,
-	RYGEL_LOG_LEVEL_DEFAULT = 4,
-	RYGEL_LOG_LEVEL_DEBUG = 5
-} RygelLogLevel;
-
-struct _RygelLogHandler {
-	GObject parent_instance;
-	RygelLogHandlerPrivate * priv;
-	GLogLevelFlags levels;
-};
-
-struct _RygelLogHandlerClass {
-	GObjectClass parent_class;
-};
-
-struct _RygelConfigurationIface {
-	GTypeInterface parent_iface;
-	gboolean (*get_upnp_enabled) (RygelConfiguration* self, GError** error);
-	char* (*get_interface) (RygelConfiguration* self, GError** error);
-	gint (*get_port) (RygelConfiguration* self, GError** error);
-	gboolean (*get_transcoding) (RygelConfiguration* self, GError** error);
-	gboolean (*get_mp3_transcoder) (RygelConfiguration* self, GError** error);
-	gboolean (*get_mp2ts_transcoder) (RygelConfiguration* self, GError** error);
-	gboolean (*get_lpcm_transcoder) (RygelConfiguration* self, GError** error);
-	RygelLogLevel (*get_log_level) (RygelConfiguration* self, GError** error);
-	gboolean (*get_enabled) (RygelConfiguration* self, const char* section, GError** error);
-	char* (*get_title) (RygelConfiguration* self, const char* section, GError** error);
-	char* (*get_string) (RygelConfiguration* self, const char* section, const char* key, GError** error);
-	GeeArrayList* (*get_string_list) (RygelConfiguration* self, const char* section, const char* key, GError** error);
-	gint (*get_int) (RygelConfiguration* self, const char* section, const char* key, gint min, gint max, GError** error);
-	GeeArrayList* (*get_int_list) (RygelConfiguration* self, const char* section, const char* key, GError** error);
-	gboolean (*get_bool) (RygelConfiguration* self, const char* section, const char* key, GError** error);
-};
-
-
-static RygelLogHandler* rygel_log_handler_log_handler;
-static RygelLogHandler* rygel_log_handler_log_handler = NULL;
-static gpointer rygel_log_handler_parent_class = NULL;
-
-GType rygel_log_level_get_type (void);
-GType rygel_log_handler_get_type (void);
-enum  {
-	RYGEL_LOG_HANDLER_DUMMY_PROPERTY
-};
-#define RYGEL_LOG_HANDLER_DEFAULT_LEVELS ((((G_LOG_LEVEL_WARNING | G_LOG_LEVEL_CRITICAL) | G_LOG_LEVEL_ERROR) | G_LOG_LEVEL_MESSAGE) | G_LOG_LEVEL_INFO)
-static RygelLogHandler* rygel_log_handler_new (void);
-static RygelLogHandler* rygel_log_handler_construct (GType object_type);
-RygelLogHandler* rygel_log_handler_get_default (void);
-static void rygel_log_handler_log_func (RygelLogHandler* self, const char* log_domain, GLogLevelFlags log_levels, const char* message);
-static void _rygel_log_handler_log_func_glog_func (const char* log_domain, GLogLevelFlags log_levels, const char* message, gpointer self);
-GType rygel_meta_config_get_type (void);
-RygelMetaConfig* rygel_meta_config_get_default (void);
-GType rygel_configuration_get_type (void);
-RygelLogLevel rygel_configuration_get_log_level (RygelConfiguration* self, GError** error);
-static GLogLevelFlags rygel_log_handler_log_level_to_flags (RygelLogHandler* self, RygelLogLevel level);
-static void rygel_log_handler_finalize (GObject* obj);
-
-
-
-
-GType rygel_log_level_get_type (void) {
-	static GType rygel_log_level_type_id = 0;
-	if (G_UNLIKELY (rygel_log_level_type_id == 0)) {
-		static const GEnumValue values[] = {{RYGEL_LOG_LEVEL_INVALID, "RYGEL_LOG_LEVEL_INVALID", "invalid"}, {RYGEL_LOG_LEVEL_CRITICAL, "RYGEL_LOG_LEVEL_CRITICAL", "critical"}, {RYGEL_LOG_LEVEL_ERROR, "RYGEL_LOG_LEVEL_ERROR", "error"}, {RYGEL_LOG_LEVEL_WARNING, "RYGEL_LOG_LEVEL_WARNING", "warning"}, {RYGEL_LOG_LEVEL_INFO, "RYGEL_LOG_LEVEL_INFO", "info"}, {RYGEL_LOG_LEVEL_DEFAULT, "RYGEL_LOG_LEVEL_DEFAULT", "default"}, {RYGEL_LOG_LEVEL_DEBUG, "RYGEL_LOG_LEVEL_DEBUG", "debug"}, {0, NULL, NULL}};
-		rygel_log_level_type_id = g_enum_register_static ("RygelLogLevel", values);
-	}
-	return rygel_log_level_type_id;
-}
-
-
-static gpointer _g_object_ref0 (gpointer self) {
-	return self ? g_object_ref (self) : NULL;
-}
-
-
-RygelLogHandler* rygel_log_handler_get_default (void) {
-	RygelLogHandler* result;
-	if (rygel_log_handler_log_handler == NULL) {
-		RygelLogHandler* _tmp0_;
-		rygel_log_handler_log_handler = (_tmp0_ = rygel_log_handler_new (), _g_object_unref0 (rygel_log_handler_log_handler), _tmp0_);
-	}
-	result = _g_object_ref0 (rygel_log_handler_log_handler);
-	return result;
-}
-
-
-static void _rygel_log_handler_log_func_glog_func (const char* log_domain, GLogLevelFlags log_levels, const char* message, gpointer self) {
-	rygel_log_handler_log_func (self, log_domain, log_levels, message);
-}
-
-
-static RygelLogHandler* rygel_log_handler_construct (GType object_type) {
-	GError * _inner_error_;
-	RygelLogHandler * self;
-	RygelMetaConfig* config;
-	RygelLogLevel _tmp0_;
-	_inner_error_ = NULL;
-	self = (RygelLogHandler*) g_object_new (object_type, NULL);
-	g_log_set_default_handler (_rygel_log_handler_log_func_glog_func, self);
-	config = rygel_meta_config_get_default ();
-	_tmp0_ = rygel_configuration_get_log_level ((RygelConfiguration*) config, &_inner_error_);
-	if (_inner_error_ != NULL) {
-		_g_object_unref0 (config);
-		g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
-		g_clear_error (&_inner_error_);
-		return NULL;
-	}
-	self->levels = rygel_log_handler_log_level_to_flags (self, _tmp0_);
-	_g_object_unref0 (config);
-	return self;
-}
-
-
-static RygelLogHandler* rygel_log_handler_new (void) {
-	return rygel_log_handler_construct (RYGEL_TYPE_LOG_HANDLER);
-}
-
-
-static void rygel_log_handler_log_func (RygelLogHandler* self, const char* log_domain, GLogLevelFlags log_levels, const char* message) {
-	g_return_if_fail (self != NULL);
-	g_return_if_fail (message != NULL);
-	if ((self->levels & log_levels) == log_levels) {
-		g_log_default_handler (log_domain, log_levels, message, NULL);
-	}
-}
-
-
-static GLogLevelFlags rygel_log_handler_log_level_to_flags (RygelLogHandler* self, RygelLogLevel level) {
-	GLogLevelFlags result;
-	GLogLevelFlags flags;
-	g_return_val_if_fail (self != NULL, 0);
-	flags = RYGEL_LOG_HANDLER_DEFAULT_LEVELS;
-	switch (level) {
-		case RYGEL_LOG_LEVEL_CRITICAL:
-		{
-			flags = G_LOG_LEVEL_CRITICAL;
-			break;
-		}
-		case RYGEL_LOG_LEVEL_ERROR:
-		{
-			flags = G_LOG_LEVEL_CRITICAL | G_LOG_LEVEL_ERROR;
-			break;
-		}
-		case RYGEL_LOG_LEVEL_WARNING:
-		{
-			flags = (G_LOG_LEVEL_WARNING | G_LOG_LEVEL_CRITICAL) | G_LOG_LEVEL_ERROR;
-			break;
-		}
-		case RYGEL_LOG_LEVEL_INFO:
-		{
-			flags = (((G_LOG_LEVEL_WARNING | G_LOG_LEVEL_CRITICAL) | G_LOG_LEVEL_ERROR) | G_LOG_LEVEL_MESSAGE) | G_LOG_LEVEL_INFO;
-			break;
-		}
-		case RYGEL_LOG_LEVEL_DEBUG:
-		{
-			flags = ((((G_LOG_LEVEL_WARNING | G_LOG_LEVEL_CRITICAL) | G_LOG_LEVEL_ERROR) | G_LOG_LEVEL_MESSAGE) | G_LOG_LEVEL_INFO) | G_LOG_LEVEL_DEBUG;
-			break;
-		}
-		default:
-		{
-			flags = RYGEL_LOG_HANDLER_DEFAULT_LEVELS;
-			break;
-		}
-	}
-	result = flags;
-	return result;
-}
-
-
-static void rygel_log_handler_class_init (RygelLogHandlerClass * klass) {
-	rygel_log_handler_parent_class = g_type_class_peek_parent (klass);
-	G_OBJECT_CLASS (klass)->finalize = rygel_log_handler_finalize;
-}
-
-
-static void rygel_log_handler_instance_init (RygelLogHandler * self) {
-}
-
-
-static void rygel_log_handler_finalize (GObject* obj) {
-	RygelLogHandler * self;
-	self = RYGEL_LOG_HANDLER (obj);
-	G_OBJECT_CLASS (rygel_log_handler_parent_class)->finalize (obj);
-}
-
-
-GType rygel_log_handler_get_type (void) {
-	static GType rygel_log_handler_type_id = 0;
-	if (rygel_log_handler_type_id == 0) {
-		static const GTypeInfo g_define_type_info = { sizeof (RygelLogHandlerClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) rygel_log_handler_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (RygelLogHandler), 0, (GInstanceInitFunc) rygel_log_handler_instance_init, NULL };
-		rygel_log_handler_type_id = g_type_register_static (G_TYPE_OBJECT, "RygelLogHandler", &g_define_type_info, 0);
-	}
-	return rygel_log_handler_type_id;
-}
-
-
-
-
--- a/src/rygel/rygel-main.c
+++ /dev/null
@@ -1,885 +0,0 @@
-/* rygel-main.c generated by valac, the Vala compiler
- * generated from rygel-main.vala, do not modify */
-
-/*
- * Copyright (C) 2008 Nokia Corporation.
- * Copyright (C) 2008 Zeeshan Ali (Khattak) <zeeshanak@gnome.org>.
- *
- * Author: Zeeshan Ali (Khattak) <zeeshanak@gnome.org>
- *
- * This file is part of Rygel.
- *
- * Rygel is free software; you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * Rygel is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this program; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
- */
-
-#include <glib.h>
-#include <glib-object.h>
-#include <libgupnp/gupnp.h>
-#include <gee.h>
-#include <stdlib.h>
-#include <string.h>
-#include <glib/gi18n-lib.h>
-#include <cstuff.h>
-#include <libgssdp/gssdp.h>
-#include <gst/gst.h>
-#include <dbus/dbus-glib-lowlevel.h>
-#include <dbus/dbus-glib.h>
-
-
-#define RYGEL_TYPE_MAIN (rygel_main_get_type ())
-#define RYGEL_MAIN(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_MAIN, RygelMain))
-#define RYGEL_MAIN_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_MAIN, RygelMainClass))
-#define RYGEL_IS_MAIN(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_MAIN))
-#define RYGEL_IS_MAIN_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_MAIN))
-#define RYGEL_MAIN_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_MAIN, RygelMainClass))
-
-typedef struct _RygelMain RygelMain;
-typedef struct _RygelMainClass RygelMainClass;
-typedef struct _RygelMainPrivate RygelMainPrivate;
-
-#define RYGEL_TYPE_PLUGIN_LOADER (rygel_plugin_loader_get_type ())
-#define RYGEL_PLUGIN_LOADER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_PLUGIN_LOADER, RygelPluginLoader))
-#define RYGEL_PLUGIN_LOADER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_PLUGIN_LOADER, RygelPluginLoaderClass))
-#define RYGEL_IS_PLUGIN_LOADER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_PLUGIN_LOADER))
-#define RYGEL_IS_PLUGIN_LOADER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_PLUGIN_LOADER))
-#define RYGEL_PLUGIN_LOADER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_PLUGIN_LOADER, RygelPluginLoaderClass))
-
-typedef struct _RygelPluginLoader RygelPluginLoader;
-typedef struct _RygelPluginLoaderClass RygelPluginLoaderClass;
-
-#define RYGEL_TYPE_ROOT_DEVICE_FACTORY (rygel_root_device_factory_get_type ())
-#define RYGEL_ROOT_DEVICE_FACTORY(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_ROOT_DEVICE_FACTORY, RygelRootDeviceFactory))
-#define RYGEL_ROOT_DEVICE_FACTORY_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_ROOT_DEVICE_FACTORY, RygelRootDeviceFactoryClass))
-#define RYGEL_IS_ROOT_DEVICE_FACTORY(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_ROOT_DEVICE_FACTORY))
-#define RYGEL_IS_ROOT_DEVICE_FACTORY_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_ROOT_DEVICE_FACTORY))
-#define RYGEL_ROOT_DEVICE_FACTORY_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_ROOT_DEVICE_FACTORY, RygelRootDeviceFactoryClass))
-
-typedef struct _RygelRootDeviceFactory RygelRootDeviceFactory;
-typedef struct _RygelRootDeviceFactoryClass RygelRootDeviceFactoryClass;
-
-#define RYGEL_TYPE_ROOT_DEVICE (rygel_root_device_get_type ())
-#define RYGEL_ROOT_DEVICE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_ROOT_DEVICE, RygelRootDevice))
-#define RYGEL_ROOT_DEVICE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_ROOT_DEVICE, RygelRootDeviceClass))
-#define RYGEL_IS_ROOT_DEVICE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_ROOT_DEVICE))
-#define RYGEL_IS_ROOT_DEVICE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_ROOT_DEVICE))
-#define RYGEL_ROOT_DEVICE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_ROOT_DEVICE, RygelRootDeviceClass))
-
-typedef struct _RygelRootDevice RygelRootDevice;
-typedef struct _RygelRootDeviceClass RygelRootDeviceClass;
-
-#define RYGEL_TYPE_CONFIGURATION (rygel_configuration_get_type ())
-#define RYGEL_CONFIGURATION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_CONFIGURATION, RygelConfiguration))
-#define RYGEL_IS_CONFIGURATION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_CONFIGURATION))
-#define RYGEL_CONFIGURATION_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), RYGEL_TYPE_CONFIGURATION, RygelConfigurationIface))
-
-typedef struct _RygelConfiguration RygelConfiguration;
-typedef struct _RygelConfigurationIface RygelConfigurationIface;
-
-#define RYGEL_TYPE_LOG_LEVEL (rygel_log_level_get_type ())
-
-#define RYGEL_TYPE_LOG_HANDLER (rygel_log_handler_get_type ())
-#define RYGEL_LOG_HANDLER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_LOG_HANDLER, RygelLogHandler))
-#define RYGEL_LOG_HANDLER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_LOG_HANDLER, RygelLogHandlerClass))
-#define RYGEL_IS_LOG_HANDLER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_LOG_HANDLER))
-#define RYGEL_IS_LOG_HANDLER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_LOG_HANDLER))
-#define RYGEL_LOG_HANDLER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_LOG_HANDLER, RygelLogHandlerClass))
-
-typedef struct _RygelLogHandler RygelLogHandler;
-typedef struct _RygelLogHandlerClass RygelLogHandlerClass;
-#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
-#define _g_main_loop_unref0(var) ((var == NULL) ? NULL : (var = (g_main_loop_unref (var), NULL)))
-
-#define RYGEL_TYPE_META_CONFIG (rygel_meta_config_get_type ())
-#define RYGEL_META_CONFIG(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_META_CONFIG, RygelMetaConfig))
-#define RYGEL_META_CONFIG_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_META_CONFIG, RygelMetaConfigClass))
-#define RYGEL_IS_META_CONFIG(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_META_CONFIG))
-#define RYGEL_IS_META_CONFIG_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_META_CONFIG))
-#define RYGEL_META_CONFIG_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_META_CONFIG, RygelMetaConfigClass))
-
-typedef struct _RygelMetaConfig RygelMetaConfig;
-typedef struct _RygelMetaConfigClass RygelMetaConfigClass;
-
-#define RYGEL_TYPE_PLUGIN (rygel_plugin_get_type ())
-#define RYGEL_PLUGIN(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_PLUGIN, RygelPlugin))
-#define RYGEL_PLUGIN_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_PLUGIN, RygelPluginClass))
-#define RYGEL_IS_PLUGIN(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_PLUGIN))
-#define RYGEL_IS_PLUGIN_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_PLUGIN))
-#define RYGEL_PLUGIN_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_PLUGIN, RygelPluginClass))
-
-typedef struct _RygelPlugin RygelPlugin;
-typedef struct _RygelPluginClass RygelPluginClass;
-#define _rygel_root_device_factory_unref0(var) ((var == NULL) ? NULL : (var = (rygel_root_device_factory_unref (var), NULL)))
-#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
-#define _g_free0(var) (var = (g_free (var), NULL))
-typedef struct _RygelRootDeviceFactoryPrivate RygelRootDeviceFactoryPrivate;
-typedef struct _RygelPluginPrivate RygelPluginPrivate;
-
-#define RYGEL_TYPE_RESOURCE_INFO (rygel_resource_info_get_type ())
-#define RYGEL_RESOURCE_INFO(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_RESOURCE_INFO, RygelResourceInfo))
-#define RYGEL_RESOURCE_INFO_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_RESOURCE_INFO, RygelResourceInfoClass))
-#define RYGEL_IS_RESOURCE_INFO(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_RESOURCE_INFO))
-#define RYGEL_IS_RESOURCE_INFO_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_RESOURCE_INFO))
-#define RYGEL_RESOURCE_INFO_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_RESOURCE_INFO, RygelResourceInfoClass))
-
-typedef struct _RygelResourceInfo RygelResourceInfo;
-typedef struct _RygelResourceInfoClass RygelResourceInfoClass;
-
-#define RYGEL_TYPE_ICON_INFO (rygel_icon_info_get_type ())
-#define RYGEL_ICON_INFO(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_ICON_INFO, RygelIconInfo))
-#define RYGEL_ICON_INFO_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_ICON_INFO, RygelIconInfoClass))
-#define RYGEL_IS_ICON_INFO(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_ICON_INFO))
-#define RYGEL_IS_ICON_INFO_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_ICON_INFO))
-#define RYGEL_ICON_INFO_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_ICON_INFO, RygelIconInfoClass))
-
-typedef struct _RygelIconInfo RygelIconInfo;
-typedef struct _RygelIconInfoClass RygelIconInfoClass;
-
-#define RYGEL_TYPE_DBUS_SERVICE (rygel_dbus_service_get_type ())
-#define RYGEL_DBUS_SERVICE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_DBUS_SERVICE, RygelDBusService))
-#define RYGEL_DBUS_SERVICE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_DBUS_SERVICE, RygelDBusServiceClass))
-#define RYGEL_IS_DBUS_SERVICE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_DBUS_SERVICE))
-#define RYGEL_IS_DBUS_SERVICE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_DBUS_SERVICE))
-#define RYGEL_DBUS_SERVICE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_DBUS_SERVICE, RygelDBusServiceClass))
-
-typedef struct _RygelDBusService RygelDBusService;
-typedef struct _RygelDBusServiceClass RygelDBusServiceClass;
-
-struct _RygelMain {
-	GObject parent_instance;
-	RygelMainPrivate * priv;
-};
-
-struct _RygelMainClass {
-	GObjectClass parent_class;
-};
-
-typedef enum  {
-	RYGEL_LOG_LEVEL_INVALID = 0,
-	RYGEL_LOG_LEVEL_CRITICAL = 1,
-	RYGEL_LOG_LEVEL_ERROR = 2,
-	RYGEL_LOG_LEVEL_WARNING = 3,
-	RYGEL_LOG_LEVEL_INFO = 4,
-	RYGEL_LOG_LEVEL_DEFAULT = 4,
-	RYGEL_LOG_LEVEL_DEBUG = 5
-} RygelLogLevel;
-
-struct _RygelConfigurationIface {
-	GTypeInterface parent_iface;
-	gboolean (*get_upnp_enabled) (RygelConfiguration* self, GError** error);
-	char* (*get_interface) (RygelConfiguration* self, GError** error);
-	gint (*get_port) (RygelConfiguration* self, GError** error);
-	gboolean (*get_transcoding) (RygelConfiguration* self, GError** error);
-	gboolean (*get_mp3_transcoder) (RygelConfiguration* self, GError** error);
-	gboolean (*get_mp2ts_transcoder) (RygelConfiguration* self, GError** error);
-	gboolean (*get_lpcm_transcoder) (RygelConfiguration* self, GError** error);
-	RygelLogLevel (*get_log_level) (RygelConfiguration* self, GError** error);
-	gboolean (*get_enabled) (RygelConfiguration* self, const char* section, GError** error);
-	char* (*get_title) (RygelConfiguration* self, const char* section, GError** error);
-	char* (*get_string) (RygelConfiguration* self, const char* section, const char* key, GError** error);
-	GeeArrayList* (*get_string_list) (RygelConfiguration* self, const char* section, const char* key, GError** error);
-	gint (*get_int) (RygelConfiguration* self, const char* section, const char* key, gint min, gint max, GError** error);
-	GeeArrayList* (*get_int_list) (RygelConfiguration* self, const char* section, const char* key, GError** error);
-	gboolean (*get_bool) (RygelConfiguration* self, const char* section, const char* key, GError** error);
-};
-
-struct _RygelMainPrivate {
-	RygelPluginLoader* plugin_loader;
-	GUPnPContextManager* context_manager;
-	GeeArrayList* factories;
-	GeeArrayList* root_devices;
-	RygelConfiguration* config;
-	RygelLogHandler* log_handler;
-	GMainLoop* main_loop;
-	gint exit_code;
-};
-
-struct _RygelRootDeviceFactory {
-	GTypeInstance parent_instance;
-	volatile int ref_count;
-	RygelRootDeviceFactoryPrivate * priv;
-	GUPnPContext* context;
-};
-
-struct _RygelRootDeviceFactoryClass {
-	GTypeClass parent_class;
-	void (*finalize) (RygelRootDeviceFactory *self);
-};
-
-struct _RygelPlugin {
-	GUPnPResourceFactory parent_instance;
-	RygelPluginPrivate * priv;
-	char* name;
-	char* title;
-	char* desc_path;
-	GeeArrayList* resource_infos;
-	GeeArrayList* icon_infos;
-};
-
-struct _RygelPluginClass {
-	GUPnPResourceFactoryClass parent_class;
-};
-
-typedef enum  {
-	RYGEL_CMDLINE_CONFIG_ERROR_VERSION_ONLY
-} RygelCmdlineConfigError;
-#define RYGEL_CMDLINE_CONFIG_ERROR rygel_cmdline_config_error_quark ()
-
-static gpointer rygel_main_parent_class = NULL;
-
-GType rygel_main_get_type (void);
-GType rygel_plugin_loader_get_type (void);
-gpointer rygel_root_device_factory_ref (gpointer instance);
-void rygel_root_device_factory_unref (gpointer instance);
-GParamSpec* rygel_param_spec_root_device_factory (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
-void rygel_value_set_root_device_factory (GValue* value, gpointer v_object);
-gpointer rygel_value_get_root_device_factory (const GValue* value);
-GType rygel_root_device_factory_get_type (void);
-GType rygel_root_device_get_type (void);
-GType rygel_log_level_get_type (void);
-GType rygel_configuration_get_type (void);
-GType rygel_log_handler_get_type (void);
-#define RYGEL_MAIN_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), RYGEL_TYPE_MAIN, RygelMainPrivate))
-enum  {
-	RYGEL_MAIN_DUMMY_PROPERTY
-};
-RygelLogHandler* rygel_log_handler_get_default (void);
-GType rygel_meta_config_get_type (void);
-RygelMetaConfig* rygel_meta_config_get_default (void);
-RygelPluginLoader* rygel_plugin_loader_new (void);
-RygelPluginLoader* rygel_plugin_loader_construct (GType object_type);
-static GUPnPContextManager* rygel_main_create_context_manager (RygelMain* self);
-GType rygel_plugin_get_type (void);
-static void rygel_main_on_plugin_loaded (RygelMain* self, RygelPluginLoader* plugin_loader, RygelPlugin* plugin);
-static void _rygel_main_on_plugin_loaded_rygel_plugin_loader_plugin_available (RygelPluginLoader* _sender, RygelPlugin* plugin, gpointer self);
-static void rygel_main_application_exit_cb (RygelMain* self);
-static void _rygel_main_application_exit_cb_cstuff_utils_application_exit_cb (gpointer self);
-static RygelMain* rygel_main_new (GError** error);
-static RygelMain* rygel_main_construct (GType object_type, GError** error);
-void rygel_main_exit (RygelMain* self, gint exit_code);
-void rygel_plugin_loader_load_plugins (RygelPluginLoader* self);
-static gint rygel_main_run (RygelMain* self);
-static void rygel_main_create_device (RygelMain* self, RygelPlugin* plugin, RygelRootDeviceFactory* factory);
-gint rygel_configuration_get_port (RygelConfiguration* self, GError** error);
-static void rygel_main_on_context_available (RygelMain* self, GUPnPContextManager* manager, GUPnPContext* context);
-static void _rygel_main_on_context_available_gupnp_context_manager_context_available (GUPnPContextManager* _sender, GUPnPContext* p0, gpointer self);
-static void rygel_main_on_context_unavailable (RygelMain* self, GUPnPContextManager* manager, GUPnPContext* context);
-static void _rygel_main_on_context_unavailable_gupnp_context_manager_context_unavailable (GUPnPContextManager* _sender, GUPnPContext* p0, gpointer self);
-char* rygel_configuration_get_interface (RygelConfiguration* self, GError** error);
-RygelRootDeviceFactory* rygel_root_device_factory_new (GUPnPContext* context, GError** error);
-RygelRootDeviceFactory* rygel_root_device_factory_construct (GType object_type, GUPnPContext* context, GError** error);
-GeeCollection* rygel_plugin_loader_list_plugins (RygelPluginLoader* self);
-RygelRootDevice* rygel_root_device_factory_create (RygelRootDeviceFactory* self, RygelPlugin* plugin, GError** error);
-gboolean rygel_plugin_get_available (RygelPlugin* self);
-static void rygel_main_on_plugin_notify (RygelMain* self, RygelPlugin* plugin, GParamSpec* spec);
-static void _rygel_main_on_plugin_notify_g_object_notify (RygelPlugin* _sender, GParamSpec* pspec, gpointer self);
-gpointer rygel_resource_info_ref (gpointer instance);
-void rygel_resource_info_unref (gpointer instance);
-GParamSpec* rygel_param_spec_resource_info (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
-void rygel_value_set_resource_info (GValue* value, gpointer v_object);
-gpointer rygel_value_get_resource_info (const GValue* value);
-GType rygel_resource_info_get_type (void);
-gpointer rygel_icon_info_ref (gpointer instance);
-void rygel_icon_info_unref (gpointer instance);
-GParamSpec* rygel_param_spec_icon_info (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
-void rygel_value_set_icon_info (GValue* value, gpointer v_object);
-gpointer rygel_value_get_icon_info (const GValue* value);
-GType rygel_icon_info_get_type (void);
-GType rygel_dbus_service_get_type (void);
-GQuark rygel_cmdline_config_error_quark (void);
-void rygel_cmdline_config_parse_args (char*** args, int* args_length1, GError** error);
-RygelDBusService* rygel_dbus_service_new (RygelMain* main, GError** error);
-RygelDBusService* rygel_dbus_service_construct (GType object_type, RygelMain* main, GError** error);
-static gint rygel_main_main (char** args, int args_length1);
-static void rygel_main_finalize (GObject* obj);
-static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
-static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);
-static int _vala_strcmp0 (const char * str1, const char * str2);
-
-
-
-static void _rygel_main_on_plugin_loaded_rygel_plugin_loader_plugin_available (RygelPluginLoader* _sender, RygelPlugin* plugin, gpointer self) {
-	rygel_main_on_plugin_loaded (self, _sender, plugin);
-}
-
-
-static void _rygel_main_application_exit_cb_cstuff_utils_application_exit_cb (gpointer self) {
-	rygel_main_application_exit_cb (self);
-}
-
-
-static RygelMain* rygel_main_construct (GType object_type, GError** error) {
-	RygelMain * self;
-	RygelLogHandler* _tmp0_;
-	RygelConfiguration* _tmp1_;
-	RygelPluginLoader* _tmp2_;
-	GeeArrayList* _tmp3_;
-	GeeArrayList* _tmp4_;
-	GUPnPContextManager* _tmp5_;
-	GMainLoop* _tmp6_;
-	self = (RygelMain*) g_object_new (object_type, NULL);
-	g_set_application_name (_ (PACKAGE_NAME));
-	self->priv->log_handler = (_tmp0_ = rygel_log_handler_get_default (), _g_object_unref0 (self->priv->log_handler), _tmp0_);
-	self->priv->config = (_tmp1_ = (RygelConfiguration*) rygel_meta_config_get_default (), _g_object_unref0 (self->priv->config), _tmp1_);
-	self->priv->plugin_loader = (_tmp2_ = rygel_plugin_loader_new (), _g_object_unref0 (self->priv->plugin_loader), _tmp2_);
-	self->priv->root_devices = (_tmp3_ = gee_array_list_new (RYGEL_TYPE_ROOT_DEVICE, (GBoxedCopyFunc) g_object_ref, g_object_unref, g_direct_equal), _g_object_unref0 (self->priv->root_devices), _tmp3_);
-	self->priv->factories = (_tmp4_ = gee_array_list_new (RYGEL_TYPE_ROOT_DEVICE_FACTORY, (GBoxedCopyFunc) rygel_root_device_factory_ref, rygel_root_device_factory_unref, g_direct_equal), _g_object_unref0 (self->priv->factories), _tmp4_);
-	self->priv->context_manager = (_tmp5_ = rygel_main_create_context_manager (self), _g_object_unref0 (self->priv->context_manager), _tmp5_);
-	self->priv->main_loop = (_tmp6_ = g_main_loop_new (NULL, FALSE), _g_main_loop_unref0 (self->priv->main_loop), _tmp6_);
-	self->priv->exit_code = 0;
-	g_signal_connect_object (self->priv->plugin_loader, "plugin-available", (GCallback) _rygel_main_on_plugin_loaded_rygel_plugin_loader_plugin_available, self, 0);
-	on_application_exit (_rygel_main_application_exit_cb_cstuff_utils_application_exit_cb, self);
-	return self;
-}
-
-
-static RygelMain* rygel_main_new (GError** error) {
-	return rygel_main_construct (RYGEL_TYPE_MAIN, error);
-}
-
-
-void rygel_main_exit (RygelMain* self, gint exit_code) {
-	g_return_if_fail (self != NULL);
-	self->priv->exit_code = exit_code;
-	g_main_loop_quit (self->priv->main_loop);
-}
-
-
-static gint rygel_main_run (RygelMain* self) {
-	gint result;
-	g_return_val_if_fail (self != NULL, 0);
-	rygel_plugin_loader_load_plugins (self->priv->plugin_loader);
-	g_main_loop_run (self->priv->main_loop);
-	result = self->priv->exit_code;
-	return result;
-}
-
-
-static void rygel_main_application_exit_cb (RygelMain* self) {
-	g_return_if_fail (self != NULL);
-	rygel_main_exit (self, 0);
-}
-
-
-static void rygel_main_on_plugin_loaded (RygelMain* self, RygelPluginLoader* plugin_loader, RygelPlugin* plugin) {
-	GeeArrayList* factories;
-	g_return_if_fail (self != NULL);
-	g_return_if_fail (plugin_loader != NULL);
-	g_return_if_fail (plugin != NULL);
-	factories = gee_array_list_new (RYGEL_TYPE_ROOT_DEVICE_FACTORY, (GBoxedCopyFunc) rygel_root_device_factory_ref, rygel_root_device_factory_unref, g_direct_equal);
-	{
-		GeeIterator* _factory_it;
-		_factory_it = gee_abstract_collection_iterator ((GeeAbstractCollection*) self->priv->factories);
-		while (TRUE) {
-			RygelRootDeviceFactory* factory;
-			if (!gee_iterator_next (_factory_it)) {
-				break;
-			}
-			factory = (RygelRootDeviceFactory*) gee_iterator_get (_factory_it);
-			gee_abstract_collection_add ((GeeAbstractCollection*) factories, factory);
-			_rygel_root_device_factory_unref0 (factory);
-		}
-		_g_object_unref0 (_factory_it);
-	}
-	{
-		GeeIterator* _factory_it;
-		_factory_it = gee_abstract_collection_iterator ((GeeAbstractCollection*) factories);
-		while (TRUE) {
-			RygelRootDeviceFactory* factory;
-			if (!gee_iterator_next (_factory_it)) {
-				break;
-			}
-			factory = (RygelRootDeviceFactory*) gee_iterator_get (_factory_it);
-			rygel_main_create_device (self, plugin, factory);
-			_rygel_root_device_factory_unref0 (factory);
-		}
-		_g_object_unref0 (_factory_it);
-	}
-	_g_object_unref0 (factories);
-}
-
-
-static void _rygel_main_on_context_available_gupnp_context_manager_context_available (GUPnPContextManager* _sender, GUPnPContext* p0, gpointer self) {
-	rygel_main_on_context_available (self, _sender, p0);
-}
-
-
-static void _rygel_main_on_context_unavailable_gupnp_context_manager_context_unavailable (GUPnPContextManager* _sender, GUPnPContext* p0, gpointer self) {
-	rygel_main_on_context_unavailable (self, _sender, p0);
-}
-
-
-static GUPnPContextManager* rygel_main_create_context_manager (RygelMain* self) {
-	GUPnPContextManager* result;
-	GError * _inner_error_;
-	gint port;
-	GUPnPContextManager* manager;
-	g_return_val_if_fail (self != NULL, NULL);
-	_inner_error_ = NULL;
-	port = 0;
-	{
-		gint _tmp0_;
-		_tmp0_ = rygel_configuration_get_port (self->priv->config, &_inner_error_);
-		if (_inner_error_ != NULL) {
-			goto __catch50_g_error;
-			goto __finally50;
-		}
-		port = _tmp0_;
-	}
-	goto __finally50;
-	__catch50_g_error:
-	{
-		GError * err;
-		err = _inner_error_;
-		_inner_error_ = NULL;
-		{
-			_g_error_free0 (err);
-		}
-	}
-	__finally50:
-	if (_inner_error_ != NULL) {
-		g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
-		g_clear_error (&_inner_error_);
-		return NULL;
-	}
-	manager = gupnp_context_manager_new (NULL, (guint) port);
-	g_signal_connect_object (manager, "context-available", (GCallback) _rygel_main_on_context_available_gupnp_context_manager_context_available, self, 0);
-	g_signal_connect_object (manager, "context-unavailable", (GCallback) _rygel_main_on_context_unavailable_gupnp_context_manager_context_unavailable, self, 0);
-	result = manager;
-	return result;
-}
-
-
-static void rygel_main_on_context_available (RygelMain* self, GUPnPContextManager* manager, GUPnPContext* context) {
-	GError * _inner_error_;
-	char* iface;
-	gboolean _tmp2_ = FALSE;
-	g_return_if_fail (self != NULL);
-	g_return_if_fail (manager != NULL);
-	g_return_if_fail (context != NULL);
-	_inner_error_ = NULL;
-	iface = NULL;
-	g_debug ("rygel-main.vala:110: new network context %s (%s) available.", gssdp_client_get_interface ((GSSDPClient*) context), gssdp_client_get_host_ip ((GSSDPClient*) context));
-	{
-		char* _tmp0_;
-		char* _tmp1_;
-		_tmp0_ = rygel_configuration_get_interface (self->priv->config, &_inner_error_);
-		if (_inner_error_ != NULL) {
-			goto __catch51_g_error;
-			goto __finally51;
-		}
-		iface = (_tmp1_ = _tmp0_, _g_free0 (iface), _tmp1_);
-	}
-	goto __finally51;
-	__catch51_g_error:
-	{
-		GError * err;
-		err = _inner_error_;
-		_inner_error_ = NULL;
-		{
-			_g_error_free0 (err);
-		}
-	}
-	__finally51:
-	if (_inner_error_ != NULL) {
-		_g_free0 (iface);
-		g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
-		g_clear_error (&_inner_error_);
-		return;
-	}
-	if (iface == NULL) {
-		_tmp2_ = TRUE;
-	} else {
-		_tmp2_ = _vala_strcmp0 (iface, gssdp_client_get_interface ((GSSDPClient*) context)) == 0;
-	}
-	if (_tmp2_) {
-		RygelRootDeviceFactory* factory;
-		GeeArrayList* plugins;
-		factory = rygel_root_device_factory_new (context, &_inner_error_);
-		if (_inner_error_ != NULL) {
-			_g_free0 (iface);
-			g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
-			g_clear_error (&_inner_error_);
-			return;
-		}
-		gee_abstract_collection_add ((GeeAbstractCollection*) self->priv->factories, factory);
-		plugins = gee_array_list_new (RYGEL_TYPE_PLUGIN, (GBoxedCopyFunc) g_object_ref, g_object_unref, g_direct_equal);
-		{
-			GeeCollection* _tmp3_;
-			GeeIterator* _tmp4_;
-			GeeIterator* _plugin_it;
-			_plugin_it = (_tmp4_ = gee_iterable_iterator ((GeeIterable*) (_tmp3_ = rygel_plugin_loader_list_plugins (self->priv->plugin_loader))), _g_object_unref0 (_tmp3_), _tmp4_);
-			while (TRUE) {
-				RygelPlugin* plugin;
-				if (!gee_iterator_next (_plugin_it)) {
-					break;
-				}
-				plugin = (RygelPlugin*) gee_iterator_get (_plugin_it);
-				gee_abstract_collection_add ((GeeAbstractCollection*) plugins, plugin);
-				_g_object_unref0 (plugin);
-			}
-			_g_object_unref0 (_plugin_it);
-		}
-		{
-			GeeIterator* _plugin_it;
-			_plugin_it = gee_abstract_collection_iterator ((GeeAbstractCollection*) plugins);
-			while (TRUE) {
-				RygelPlugin* plugin;
-				if (!gee_iterator_next (_plugin_it)) {
-					break;
-				}
-				plugin = (RygelPlugin*) gee_iterator_get (_plugin_it);
-				rygel_main_create_device (self, plugin, factory);
-				_g_object_unref0 (plugin);
-			}
-			_g_object_unref0 (_plugin_it);
-		}
-		_rygel_root_device_factory_unref0 (factory);
-		_g_object_unref0 (plugins);
-	} else {
-		g_debug ("rygel-main.vala:132: Ignoring network context %s (%s).", gssdp_client_get_interface ((GSSDPClient*) context), gssdp_client_get_host_ip ((GSSDPClient*) context));
-	}
-	_g_free0 (iface);
-}
-
-
-static void rygel_main_on_context_unavailable (RygelMain* self, GUPnPContextManager* manager, GUPnPContext* context) {
-	GeeArrayList* factory_list;
-	GeeArrayList* device_list;
-	g_return_if_fail (self != NULL);
-	g_return_if_fail (manager != NULL);
-	g_return_if_fail (context != NULL);
-	g_debug ("rygel-main.vala:140: Network context %s (%s) now unavailable.", gssdp_client_get_interface ((GSSDPClient*) context), gssdp_client_get_host_ip ((GSSDPClient*) context));
-	factory_list = gee_array_list_new (RYGEL_TYPE_ROOT_DEVICE_FACTORY, (GBoxedCopyFunc) rygel_root_device_factory_ref, rygel_root_device_factory_unref, g_direct_equal);
-	{
-		GeeIterator* _factory_it;
-		_factory_it = gee_abstract_collection_iterator ((GeeAbstractCollection*) self->priv->factories);
-		while (TRUE) {
-			RygelRootDeviceFactory* factory;
-			if (!gee_iterator_next (_factory_it)) {
-				break;
-			}
-			factory = (RygelRootDeviceFactory*) gee_iterator_get (_factory_it);
-			if (context == factory->context) {
-				gee_abstract_collection_add ((GeeAbstractCollection*) factory_list, factory);
-			}
-			_rygel_root_device_factory_unref0 (factory);
-		}
-		_g_object_unref0 (_factory_it);
-	}
-	{
-		GeeIterator* _factory_it;
-		_factory_it = gee_abstract_collection_iterator ((GeeAbstractCollection*) factory_list);
-		while (TRUE) {
-			RygelRootDeviceFactory* factory;
-			if (!gee_iterator_next (_factory_it)) {
-				break;
-			}
-			factory = (RygelRootDeviceFactory*) gee_iterator_get (_factory_it);
-			gee_abstract_collection_remove ((GeeAbstractCollection*) self->priv->factories, factory);
-			_rygel_root_device_factory_unref0 (factory);
-		}
-		_g_object_unref0 (_factory_it);
-	}
-	device_list = gee_array_list_new (RYGEL_TYPE_ROOT_DEVICE, (GBoxedCopyFunc) g_object_ref, g_object_unref, g_direct_equal);
-	{
-		GeeIterator* _device_it;
-		_device_it = gee_abstract_collection_iterator ((GeeAbstractCollection*) self->priv->root_devices);
-		while (TRUE) {
-			RygelRootDevice* device;
-			if (!gee_iterator_next (_device_it)) {
-				break;
-			}
-			device = (RygelRootDevice*) gee_iterator_get (_device_it);
-			if (context == gupnp_device_info_get_context ((GUPnPDeviceInfo*) device)) {
-				gee_abstract_collection_add ((GeeAbstractCollection*) device_list, device);
-			}
-			_g_object_unref0 (device);
-		}
-		_g_object_unref0 (_device_it);
-	}
-	{
-		GeeIterator* _device_it;
-		_device_it = gee_abstract_collection_iterator ((GeeAbstractCollection*) device_list);
-		while (TRUE) {
-			RygelRootDevice* device;
-			if (!gee_iterator_next (_device_it)) {
-				break;
-			}
-			device = (RygelRootDevice*) gee_iterator_get (_device_it);
-			gee_abstract_collection_remove ((GeeAbstractCollection*) self->priv->root_devices, device);
-			_g_object_unref0 (device);
-		}
-		_g_object_unref0 (_device_it);
-	}
-	_g_object_unref0 (factory_list);
-	_g_object_unref0 (device_list);
-}
-
-
-static void _rygel_main_on_plugin_notify_g_object_notify (RygelPlugin* _sender, GParamSpec* pspec, gpointer self) {
-	rygel_main_on_plugin_notify (self, _sender, pspec);
-}
-
-
-static void rygel_main_create_device (RygelMain* self, RygelPlugin* plugin, RygelRootDeviceFactory* factory) {
-	GError * _inner_error_;
-	g_return_if_fail (self != NULL);
-	g_return_if_fail (plugin != NULL);
-	g_return_if_fail (factory != NULL);
-	_inner_error_ = NULL;
-	{
-		RygelRootDevice* device;
-		device = rygel_root_device_factory_create (factory, plugin, &_inner_error_);
-		if (_inner_error_ != NULL) {
-			goto __catch52_g_error;
-			goto __finally52;
-		}
-		gupnp_root_device_set_available ((GUPnPRootDevice*) device, rygel_plugin_get_available (plugin));
-		gee_abstract_collection_add ((GeeAbstractCollection*) self->priv->root_devices, device);
-		g_signal_connect_object ((GObject*) plugin, "notify::available", (GCallback) _rygel_main_on_plugin_notify_g_object_notify, self, 0);
-		_g_object_unref0 (device);
-	}
-	goto __finally52;
-	__catch52_g_error:
-	{
-		GError * _error_;
-		_error_ = _inner_error_;
-		_inner_error_ = NULL;
-		{
-			g_warning ("rygel-main.vala:178: Failed to create RootDevice for %s. Reason: %s\n", plugin->name, _error_->message);
-			_g_error_free0 (_error_);
-		}
-	}
-	__finally52:
-	if (_inner_error_ != NULL) {
-		g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
-		g_clear_error (&_inner_error_);
-		return;
-	}
-}
-
-
-static void rygel_main_on_plugin_notify (RygelMain* self, RygelPlugin* plugin, GParamSpec* spec) {
-	g_return_if_fail (self != NULL);
-	g_return_if_fail (plugin != NULL);
-	g_return_if_fail (spec != NULL);
-	{
-		GeeIterator* _device_it;
-		_device_it = gee_abstract_collection_iterator ((GeeAbstractCollection*) self->priv->root_devices);
-		while (TRUE) {
-			RygelRootDevice* device;
-			if (!gee_iterator_next (_device_it)) {
-				break;
-			}
-			device = (RygelRootDevice*) gee_iterator_get (_device_it);
-			if (gupnp_device_info_get_resource_factory ((GUPnPDeviceInfo*) device) == GUPNP_RESOURCE_FACTORY (plugin)) {
-				gupnp_root_device_set_available ((GUPnPRootDevice*) device, rygel_plugin_get_available (plugin));
-			}
-			_g_object_unref0 (device);
-		}
-		_g_object_unref0 (_device_it);
-	}
-}
-
-
-static gint rygel_main_main (char** args, int args_length1) {
-	gint result;
-	GError * _inner_error_;
-	RygelMain* main;
-	RygelDBusService* service;
-	gint exit_code;
-	_inner_error_ = NULL;
-	main = NULL;
-	service = NULL;
-	{
-		char** _tmp0_;
-		gint dummy_args_size;
-		gint dummy_args_length1;
-		char** dummy_args;
-		RygelMain* _tmp1_;
-		RygelMain* _tmp2_;
-		RygelDBusService* _tmp3_;
-		RygelDBusService* _tmp4_;
-		rygel_cmdline_config_parse_args (&args, &args_length1, &_inner_error_);
-		if (_inner_error_ != NULL) {
-			if (_inner_error_->domain == DBUS_GERROR) {
-				goto __catch53_dbus_gerror;
-			}
-			if (g_error_matches (_inner_error_, RYGEL_CMDLINE_CONFIG_ERROR, RYGEL_CMDLINE_CONFIG_ERROR_VERSION_ONLY)) {
-				goto __catch53_rygel_cmdline_config_error_version_only;
-			}
-			goto __catch53_g_error;
-			goto __finally53;
-		}
-		dummy_args = (_tmp0_ = g_new0 (char*, 0 + 1), dummy_args_length1 = 0, dummy_args_size = dummy_args_length1, _tmp0_);
-		gst_init (&dummy_args_length1, &dummy_args);
-		_tmp1_ = rygel_main_new (&_inner_error_);
-		if (_inner_error_ != NULL) {
-			dummy_args = (_vala_array_free (dummy_args, dummy_args_length1, (GDestroyNotify) g_free), NULL);
-			if (_inner_error_->domain == DBUS_GERROR) {
-				goto __catch53_dbus_gerror;
-			}
-			if (g_error_matches (_inner_error_, RYGEL_CMDLINE_CONFIG_ERROR, RYGEL_CMDLINE_CONFIG_ERROR_VERSION_ONLY)) {
-				goto __catch53_rygel_cmdline_config_error_version_only;
-			}
-			goto __catch53_g_error;
-			goto __finally53;
-		}
-		main = (_tmp2_ = _tmp1_, _g_object_unref0 (main), _tmp2_);
-		_tmp3_ = rygel_dbus_service_new (main, &_inner_error_);
-		if (_inner_error_ != NULL) {
-			dummy_args = (_vala_array_free (dummy_args, dummy_args_length1, (GDestroyNotify) g_free), NULL);
-			if (_inner_error_->domain == DBUS_GERROR) {
-				goto __catch53_dbus_gerror;
-			}
-			if (g_error_matches (_inner_error_, RYGEL_CMDLINE_CONFIG_ERROR, RYGEL_CMDLINE_CONFIG_ERROR_VERSION_ONLY)) {
-				goto __catch53_rygel_cmdline_config_error_version_only;
-			}
-			goto __catch53_g_error;
-			goto __finally53;
-		}
-		service = (_tmp4_ = _tmp3_, _g_object_unref0 (service), _tmp4_);
-		dummy_args = (_vala_array_free (dummy_args, dummy_args_length1, (GDestroyNotify) g_free), NULL);
-	}
-	goto __finally53;
-	__catch53_dbus_gerror:
-	{
-		GError * err;
-		err = _inner_error_;
-		_inner_error_ = NULL;
-		{
-			g_warning ("rygel-main.vala:208: Failed to start D-Bus service: %s", err->message);
-			_g_error_free0 (err);
-		}
-	}
-	goto __finally53;
-	__catch53_rygel_cmdline_config_error_version_only:
-	{
-		GError * err;
-		err = _inner_error_;
-		_inner_error_ = NULL;
-		{
-			result = 0;
-			_g_error_free0 (err);
-			_g_object_unref0 (main);
-			_g_object_unref0 (service);
-			return result;
-		}
-	}
-	goto __finally53;
-	__catch53_g_error:
-	{
-		GError * err;
-		err = _inner_error_;
-		_inner_error_ = NULL;
-		{
-			g_error ("rygel-main.vala:212: %s", err->message);
-			result = -1;
-			_g_error_free0 (err);
-			_g_object_unref0 (main);
-			_g_object_unref0 (service);
-			return result;
-		}
-	}
-	__finally53:
-	if (_inner_error_ != NULL) {
-		_g_object_unref0 (main);
-		_g_object_unref0 (service);
-		g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
-		g_clear_error (&_inner_error_);
-		return 0;
-	}
-	exit_code = rygel_main_run (main);
-	result = exit_code;
-	_g_object_unref0 (main);
-	_g_object_unref0 (service);
-	return result;
-}
-
-
-int main (int argc, char ** argv) {
-	g_thread_init (NULL);
-	g_type_init ();
-	return rygel_main_main (argv, argc);
-}
-
-
-static void rygel_main_class_init (RygelMainClass * klass) {
-	rygel_main_parent_class = g_type_class_peek_parent (klass);
-	g_type_class_add_private (klass, sizeof (RygelMainPrivate));
-	G_OBJECT_CLASS (klass)->finalize = rygel_main_finalize;
-}
-
-
-static void rygel_main_instance_init (RygelMain * self) {
-	self->priv = RYGEL_MAIN_GET_PRIVATE (self);
-}
-
-
-static void rygel_main_finalize (GObject* obj) {
-	RygelMain * self;
-	self = RYGEL_MAIN (obj);
-	_g_object_unref0 (self->priv->plugin_loader);
-	_g_object_unref0 (self->priv->context_manager);
-	_g_object_unref0 (self->priv->factories);
-	_g_object_unref0 (self->priv->root_devices);
-	_g_object_unref0 (self->priv->config);
-	_g_object_unref0 (self->priv->log_handler);
-	_g_main_loop_unref0 (self->priv->main_loop);
-	G_OBJECT_CLASS (rygel_main_parent_class)->finalize (obj);
-}
-
-
-GType rygel_main_get_type (void) {
-	static GType rygel_main_type_id = 0;
-	if (rygel_main_type_id == 0) {
-		static const GTypeInfo g_define_type_info = { sizeof (RygelMainClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) rygel_main_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (RygelMain), 0, (GInstanceInitFunc) rygel_main_instance_init, NULL };
-		rygel_main_type_id = g_type_register_static (G_TYPE_OBJECT, "RygelMain", &g_define_type_info, 0);
-	}
-	return rygel_main_type_id;
-}
-
-
-static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
-	if ((array != NULL) && (destroy_func != NULL)) {
-		int i;
-		for (i = 0; i < array_length; i = i + 1) {
-			if (((gpointer*) array)[i] != NULL) {
-				destroy_func (((gpointer*) array)[i]);
-			}
-		}
-	}
-}
-
-
-static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
-	_vala_array_destroy (array, array_length, destroy_func);
-	g_free (array);
-}
-
-
-static int _vala_strcmp0 (const char * str1, const char * str2) {
-	if (str1 == NULL) {
-		return -(str1 != str2);
-	}
-	if (str2 == NULL) {
-		return str1 != str2;
-	}
-	return strcmp (str1, str2);
-}
-
-
-
-
--- a/src/rygel/rygel-media-container.c
+++ /dev/null
@@ -1,241 +0,0 @@
-/* rygel-media-container.c generated by valac, the Vala compiler
- * generated from rygel-media-container.vala, do not modify */
-
-/*
- * Copyright (C) 2008 Zeeshan Ali <zeenix@gmail.com>.
- *
- * Author: Zeeshan Ali <zeenix@gmail.com>
- *
- * This file is part of Rygel.
- *
- * Rygel is free software; you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * Rygel is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this program; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
- */
-
-#include <glib.h>
-#include <glib-object.h>
-#include <stdlib.h>
-#include <string.h>
-#include <gee.h>
-#include <gio/gio.h>
-
-
-#define RYGEL_TYPE_MEDIA_OBJECT (rygel_media_object_get_type ())
-#define RYGEL_MEDIA_OBJECT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_MEDIA_OBJECT, RygelMediaObject))
-#define RYGEL_MEDIA_OBJECT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_MEDIA_OBJECT, RygelMediaObjectClass))
-#define RYGEL_IS_MEDIA_OBJECT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_MEDIA_OBJECT))
-#define RYGEL_IS_MEDIA_OBJECT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_MEDIA_OBJECT))
-#define RYGEL_MEDIA_OBJECT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_MEDIA_OBJECT, RygelMediaObjectClass))
-
-typedef struct _RygelMediaObject RygelMediaObject;
-typedef struct _RygelMediaObjectClass RygelMediaObjectClass;
-typedef struct _RygelMediaObjectPrivate RygelMediaObjectPrivate;
-
-#define RYGEL_TYPE_MEDIA_CONTAINER (rygel_media_container_get_type ())
-#define RYGEL_MEDIA_CONTAINER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_MEDIA_CONTAINER, RygelMediaContainer))
-#define RYGEL_MEDIA_CONTAINER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_MEDIA_CONTAINER, RygelMediaContainerClass))
-#define RYGEL_IS_MEDIA_CONTAINER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_MEDIA_CONTAINER))
-#define RYGEL_IS_MEDIA_CONTAINER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_MEDIA_CONTAINER))
-#define RYGEL_MEDIA_CONTAINER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_MEDIA_CONTAINER, RygelMediaContainerClass))
-
-typedef struct _RygelMediaContainer RygelMediaContainer;
-typedef struct _RygelMediaContainerClass RygelMediaContainerClass;
-typedef struct _RygelMediaContainerPrivate RygelMediaContainerPrivate;
-#define _g_free0(var) (var = (g_free (var), NULL))
-
-struct _RygelMediaObject {
-	GObject parent_instance;
-	RygelMediaObjectPrivate * priv;
-	char* id;
-	char* title;
-	guint64 modified;
-	GeeArrayList* uris;
-	RygelMediaContainer* parent;
-	RygelMediaContainer* parent_ref;
-};
-
-struct _RygelMediaObjectClass {
-	GObjectClass parent_class;
-};
-
-struct _RygelMediaContainer {
-	RygelMediaObject parent_instance;
-	RygelMediaContainerPrivate * priv;
-	guint child_count;
-	guint32 update_id;
-};
-
-struct _RygelMediaContainerClass {
-	RygelMediaObjectClass parent_class;
-	void (*get_children) (RygelMediaContainer* self, guint offset, guint max_count, GCancellable* cancellable, GAsyncReadyCallback callback, void* callback_target);
-	GeeList* (*get_children_finish) (RygelMediaContainer* self, GAsyncResult* res, GError** error);
-	void (*find_object) (RygelMediaContainer* self, const char* id, GCancellable* cancellable, GAsyncReadyCallback callback, void* callback_target);
-	RygelMediaObject* (*find_object_finish) (RygelMediaContainer* self, GAsyncResult* res, GError** error);
-};
-
-
-static gpointer rygel_media_container_parent_class = NULL;
-
-GType rygel_media_object_get_type (void);
-GType rygel_media_container_get_type (void);
-enum  {
-	RYGEL_MEDIA_CONTAINER_DUMMY_PROPERTY
-};
-RygelMediaObject* rygel_media_object_construct (GType object_type);
-static void rygel_media_container_on_container_updated (RygelMediaContainer* self, RygelMediaContainer* container, RygelMediaContainer* updated_container);
-static void _rygel_media_container_on_container_updated_rygel_media_container_container_updated (RygelMediaContainer* _sender, RygelMediaContainer* container, gpointer self);
-RygelMediaContainer* rygel_media_container_construct (GType object_type, const char* id, RygelMediaContainer* parent, const char* title, guint child_count);
-RygelMediaContainer* rygel_media_container_construct_root (GType object_type, const char* title, guint child_count);
-void rygel_media_container_get_children (RygelMediaContainer* self, guint offset, guint max_count, GCancellable* cancellable, GAsyncReadyCallback callback, void* callback_target);
-static void rygel_media_container_real_get_children (RygelMediaContainer* self, guint offset, guint max_count, GCancellable* cancellable, GAsyncReadyCallback callback, void* callback_target);
-GeeList* rygel_media_container_get_children_finish (RygelMediaContainer* self, GAsyncResult* res, GError** error);
-static GeeList* rygel_media_container_real_get_children_finish (RygelMediaContainer* self, GAsyncResult* res, GError** error);
-void rygel_media_container_find_object (RygelMediaContainer* self, const char* id, GCancellable* cancellable, GAsyncReadyCallback callback, void* callback_target);
-static void rygel_media_container_real_find_object (RygelMediaContainer* self, const char* id, GCancellable* cancellable, GAsyncReadyCallback callback, void* callback_target);
-RygelMediaObject* rygel_media_container_find_object_finish (RygelMediaContainer* self, GAsyncResult* res, GError** error);
-static RygelMediaObject* rygel_media_container_real_find_object_finish (RygelMediaContainer* self, GAsyncResult* res, GError** error);
-void rygel_media_container_updated (RygelMediaContainer* self);
-static void rygel_media_container_finalize (GObject* obj);
-
-
-
-static void _rygel_media_container_on_container_updated_rygel_media_container_container_updated (RygelMediaContainer* _sender, RygelMediaContainer* container, gpointer self) {
-	rygel_media_container_on_container_updated (self, _sender, container);
-}
-
-
-RygelMediaContainer* rygel_media_container_construct (GType object_type, const char* id, RygelMediaContainer* parent, const char* title, guint child_count) {
-	RygelMediaContainer * self;
-	char* _tmp0_;
-	char* _tmp1_;
-	g_return_val_if_fail (id != NULL, NULL);
-	g_return_val_if_fail (title != NULL, NULL);
-	self = (RygelMediaContainer*) rygel_media_object_construct (object_type);
-	((RygelMediaObject*) self)->id = (_tmp0_ = g_strdup (id), _g_free0 (((RygelMediaObject*) self)->id), _tmp0_);
-	((RygelMediaObject*) self)->parent = parent;
-	((RygelMediaObject*) self)->title = (_tmp1_ = g_strdup (title), _g_free0 (((RygelMediaObject*) self)->title), _tmp1_);
-	self->child_count = child_count;
-	self->update_id = (guint32) 0;
-	g_signal_connect_object (self, "container-updated", (GCallback) _rygel_media_container_on_container_updated_rygel_media_container_container_updated, self, 0);
-	return self;
-}
-
-
-RygelMediaContainer* rygel_media_container_construct_root (GType object_type, const char* title, guint child_count) {
-	RygelMediaContainer * self;
-	g_return_val_if_fail (title != NULL, NULL);
-	self = (RygelMediaContainer*) rygel_media_container_construct (object_type, "0", NULL, title, child_count);
-	return self;
-}
-
-
-static void rygel_media_container_real_get_children (RygelMediaContainer* self, guint offset, guint max_count, GCancellable* cancellable, GAsyncReadyCallback callback, void* callback_target) {
-	g_return_if_fail (self != NULL);
-	g_critical ("Type `%s' does not implement abstract method `rygel_media_container_get_children'", g_type_name (G_TYPE_FROM_INSTANCE (self)));
-	return;
-}
-
-
-void rygel_media_container_get_children (RygelMediaContainer* self, guint offset, guint max_count, GCancellable* cancellable, GAsyncReadyCallback callback, void* callback_target) {
-	RYGEL_MEDIA_CONTAINER_GET_CLASS (self)->get_children (self, offset, max_count, cancellable, callback, callback_target);
-}
-
-
-static GeeList* rygel_media_container_real_get_children_finish (RygelMediaContainer* self, GAsyncResult* res, GError** error) {
-	g_return_val_if_fail (self != NULL, NULL);
-	g_critical ("Type `%s' does not implement abstract method `rygel_media_container_get_children_finish'", g_type_name (G_TYPE_FROM_INSTANCE (self)));
-	return NULL;
-}
-
-
-GeeList* rygel_media_container_get_children_finish (RygelMediaContainer* self, GAsyncResult* res, GError** error) {
-	return RYGEL_MEDIA_CONTAINER_GET_CLASS (self)->get_children_finish (self, res, error);
-}
-
-
-static void rygel_media_container_real_find_object (RygelMediaContainer* self, const char* id, GCancellable* cancellable, GAsyncReadyCallback callback, void* callback_target) {
-	g_return_if_fail (self != NULL);
-	g_critical ("Type `%s' does not implement abstract method `rygel_media_container_find_object'", g_type_name (G_TYPE_FROM_INSTANCE (self)));
-	return;
-}
-
-
-void rygel_media_container_find_object (RygelMediaContainer* self, const char* id, GCancellable* cancellable, GAsyncReadyCallback callback, void* callback_target) {
-	RYGEL_MEDIA_CONTAINER_GET_CLASS (self)->find_object (self, id, cancellable, callback, callback_target);
-}
-
-
-static RygelMediaObject* rygel_media_container_real_find_object_finish (RygelMediaContainer* self, GAsyncResult* res, GError** error) {
-	g_return_val_if_fail (self != NULL, NULL);
-	g_critical ("Type `%s' does not implement abstract method `rygel_media_container_find_object_finish'", g_type_name (G_TYPE_FROM_INSTANCE (self)));
-	return NULL;
-}
-
-
-RygelMediaObject* rygel_media_container_find_object_finish (RygelMediaContainer* self, GAsyncResult* res, GError** error) {
-	return RYGEL_MEDIA_CONTAINER_GET_CLASS (self)->find_object_finish (self, res, error);
-}
-
-
-void rygel_media_container_updated (RygelMediaContainer* self) {
-	g_return_if_fail (self != NULL);
-	self->update_id++;
-	g_signal_emit_by_name (self, "container-updated", self);
-}
-
-
-static void rygel_media_container_on_container_updated (RygelMediaContainer* self, RygelMediaContainer* container, RygelMediaContainer* updated_container) {
-	g_return_if_fail (self != NULL);
-	g_return_if_fail (container != NULL);
-	g_return_if_fail (updated_container != NULL);
-	if (((RygelMediaObject*) self)->parent != NULL) {
-		g_signal_emit_by_name (((RygelMediaObject*) self)->parent, "container-updated", updated_container);
-	}
-}
-
-
-static void rygel_media_container_class_init (RygelMediaContainerClass * klass) {
-	rygel_media_container_parent_class = g_type_class_peek_parent (klass);
-	RYGEL_MEDIA_CONTAINER_CLASS (klass)->get_children = rygel_media_container_real_get_children;
-	RYGEL_MEDIA_CONTAINER_CLASS (klass)->get_children_finish = rygel_media_container_real_get_children_finish;
-	RYGEL_MEDIA_CONTAINER_CLASS (klass)->find_object = rygel_media_container_real_find_object;
-	RYGEL_MEDIA_CONTAINER_CLASS (klass)->find_object_finish = rygel_media_container_real_find_object_finish;
-	G_OBJECT_CLASS (klass)->finalize = rygel_media_container_finalize;
-	g_signal_new ("container_updated", RYGEL_TYPE_MEDIA_CONTAINER, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__OBJECT, G_TYPE_NONE, 1, RYGEL_TYPE_MEDIA_CONTAINER);
-}
-
-
-static void rygel_media_container_instance_init (RygelMediaContainer * self) {
-}
-
-
-static void rygel_media_container_finalize (GObject* obj) {
-	RygelMediaContainer * self;
-	self = RYGEL_MEDIA_CONTAINER (obj);
-	G_OBJECT_CLASS (rygel_media_container_parent_class)->finalize (obj);
-}
-
-
-GType rygel_media_container_get_type (void) {
-	static GType rygel_media_container_type_id = 0;
-	if (rygel_media_container_type_id == 0) {
-		static const GTypeInfo g_define_type_info = { sizeof (RygelMediaContainerClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) rygel_media_container_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (RygelMediaContainer), 0, (GInstanceInitFunc) rygel_media_container_instance_init, NULL };
-		rygel_media_container_type_id = g_type_register_static (RYGEL_TYPE_MEDIA_OBJECT, "RygelMediaContainer", &g_define_type_info, G_TYPE_FLAG_ABSTRACT);
-	}
-	return rygel_media_container_type_id;
-}
-
-
-
-
--- a/src/rygel/rygel-media-db-container.c
+++ /dev/null
@@ -1,364 +0,0 @@
-/* rygel-media-db-container.c generated by valac, the Vala compiler
- * generated from rygel-media-db-container.vala, do not modify */
-
-/*
- * Copyright (C) 2009 Jens Georg <mail@jensge.org>.
- *
- * Author: Jens Georg <mail@jensge.org>
- *
- * This file is part of Rygel.
- *
- * Rygel is free software; you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * Rygel is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this program; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
- */
-
-#include <glib.h>
-#include <glib-object.h>
-#include <stdlib.h>
-#include <string.h>
-#include <gee.h>
-#include <gio/gio.h>
-
-
-#define RYGEL_TYPE_MEDIA_OBJECT (rygel_media_object_get_type ())
-#define RYGEL_MEDIA_OBJECT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_MEDIA_OBJECT, RygelMediaObject))
-#define RYGEL_MEDIA_OBJECT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_MEDIA_OBJECT, RygelMediaObjectClass))
-#define RYGEL_IS_MEDIA_OBJECT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_MEDIA_OBJECT))
-#define RYGEL_IS_MEDIA_OBJECT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_MEDIA_OBJECT))
-#define RYGEL_MEDIA_OBJECT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_MEDIA_OBJECT, RygelMediaObjectClass))
-
-typedef struct _RygelMediaObject RygelMediaObject;
-typedef struct _RygelMediaObjectClass RygelMediaObjectClass;
-typedef struct _RygelMediaObjectPrivate RygelMediaObjectPrivate;
-
-#define RYGEL_TYPE_MEDIA_CONTAINER (rygel_media_container_get_type ())
-#define RYGEL_MEDIA_CONTAINER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_MEDIA_CONTAINER, RygelMediaContainer))
-#define RYGEL_MEDIA_CONTAINER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_MEDIA_CONTAINER, RygelMediaContainerClass))
-#define RYGEL_IS_MEDIA_CONTAINER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_MEDIA_CONTAINER))
-#define RYGEL_IS_MEDIA_CONTAINER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_MEDIA_CONTAINER))
-#define RYGEL_MEDIA_CONTAINER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_MEDIA_CONTAINER, RygelMediaContainerClass))
-
-typedef struct _RygelMediaContainer RygelMediaContainer;
-typedef struct _RygelMediaContainerClass RygelMediaContainerClass;
-typedef struct _RygelMediaContainerPrivate RygelMediaContainerPrivate;
-
-#define RYGEL_TYPE_MEDIA_DB_CONTAINER (rygel_media_db_container_get_type ())
-#define RYGEL_MEDIA_DB_CONTAINER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_MEDIA_DB_CONTAINER, RygelMediaDBContainer))
-#define RYGEL_MEDIA_DB_CONTAINER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_MEDIA_DB_CONTAINER, RygelMediaDBContainerClass))
-#define RYGEL_IS_MEDIA_DB_CONTAINER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_MEDIA_DB_CONTAINER))
-#define RYGEL_IS_MEDIA_DB_CONTAINER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_MEDIA_DB_CONTAINER))
-#define RYGEL_MEDIA_DB_CONTAINER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_MEDIA_DB_CONTAINER, RygelMediaDBContainerClass))
-
-typedef struct _RygelMediaDBContainer RygelMediaDBContainer;
-typedef struct _RygelMediaDBContainerClass RygelMediaDBContainerClass;
-typedef struct _RygelMediaDBContainerPrivate RygelMediaDBContainerPrivate;
-
-#define RYGEL_TYPE_MEDIA_DB (rygel_media_db_get_type ())
-#define RYGEL_MEDIA_DB(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_MEDIA_DB, RygelMediaDB))
-#define RYGEL_MEDIA_DB_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_MEDIA_DB, RygelMediaDBClass))
-#define RYGEL_IS_MEDIA_DB(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_MEDIA_DB))
-#define RYGEL_IS_MEDIA_DB_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_MEDIA_DB))
-#define RYGEL_MEDIA_DB_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_MEDIA_DB, RygelMediaDBClass))
-
-typedef struct _RygelMediaDB RygelMediaDB;
-typedef struct _RygelMediaDBClass RygelMediaDBClass;
-#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
-#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
-
-#define RYGEL_TYPE_SIMPLE_ASYNC_RESULT (rygel_simple_async_result_get_type ())
-#define RYGEL_SIMPLE_ASYNC_RESULT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_SIMPLE_ASYNC_RESULT, RygelSimpleAsyncResult))
-#define RYGEL_SIMPLE_ASYNC_RESULT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_SIMPLE_ASYNC_RESULT, RygelSimpleAsyncResultClass))
-#define RYGEL_IS_SIMPLE_ASYNC_RESULT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_SIMPLE_ASYNC_RESULT))
-#define RYGEL_IS_SIMPLE_ASYNC_RESULT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_SIMPLE_ASYNC_RESULT))
-#define RYGEL_SIMPLE_ASYNC_RESULT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_SIMPLE_ASYNC_RESULT, RygelSimpleAsyncResultClass))
-
-typedef struct _RygelSimpleAsyncResult RygelSimpleAsyncResult;
-typedef struct _RygelSimpleAsyncResultClass RygelSimpleAsyncResultClass;
-typedef struct _RygelSimpleAsyncResultPrivate RygelSimpleAsyncResultPrivate;
-
-struct _RygelMediaObject {
-	GObject parent_instance;
-	RygelMediaObjectPrivate * priv;
-	char* id;
-	char* title;
-	guint64 modified;
-	GeeArrayList* uris;
-	RygelMediaContainer* parent;
-	RygelMediaContainer* parent_ref;
-};
-
-struct _RygelMediaObjectClass {
-	GObjectClass parent_class;
-};
-
-struct _RygelMediaContainer {
-	RygelMediaObject parent_instance;
-	RygelMediaContainerPrivate * priv;
-	guint child_count;
-	guint32 update_id;
-};
-
-struct _RygelMediaContainerClass {
-	RygelMediaObjectClass parent_class;
-	void (*get_children) (RygelMediaContainer* self, guint offset, guint max_count, GCancellable* cancellable, GAsyncReadyCallback callback, void* callback_target);
-	GeeList* (*get_children_finish) (RygelMediaContainer* self, GAsyncResult* res, GError** error);
-	void (*find_object) (RygelMediaContainer* self, const char* id, GCancellable* cancellable, GAsyncReadyCallback callback, void* callback_target);
-	RygelMediaObject* (*find_object_finish) (RygelMediaContainer* self, GAsyncResult* res, GError** error);
-};
-
-struct _RygelMediaDBContainer {
-	RygelMediaContainer parent_instance;
-	RygelMediaDBContainerPrivate * priv;
-	RygelMediaDB* media_db;
-};
-
-struct _RygelMediaDBContainerClass {
-	RygelMediaContainerClass parent_class;
-};
-
-typedef enum  {
-	RYGEL_MEDIA_DB_ERROR_SQLITE_ERROR,
-	RYGEL_MEDIA_DB_ERROR_GENERAL_ERROR,
-	RYGEL_MEDIA_DB_ERROR_INVALID_TYPE
-} RygelMediaDBError;
-#define RYGEL_MEDIA_DB_ERROR rygel_media_db_error_quark ()
-struct _RygelSimpleAsyncResult {
-	GObject parent_instance;
-	RygelSimpleAsyncResultPrivate * priv;
-	GObject* source_object;
-	GAsyncReadyCallback callback;
-	gpointer callback_target;
-	GDestroyNotify callback_target_destroy_notify;
-	gpointer data;
-	GError* error;
-};
-
-struct _RygelSimpleAsyncResultClass {
-	GObjectClass parent_class;
-};
-
-
-static gpointer rygel_media_db_container_parent_class = NULL;
-
-GType rygel_media_object_get_type (void);
-GType rygel_media_container_get_type (void);
-GType rygel_media_db_container_get_type (void);
-GType rygel_media_db_get_type (void);
-enum  {
-	RYGEL_MEDIA_DB_CONTAINER_DUMMY_PROPERTY
-};
-GQuark rygel_media_db_error_quark (void);
-gint rygel_media_db_get_child_count (RygelMediaDB* self, const char* container_id, GError** error);
-RygelMediaContainer* rygel_media_container_construct (GType object_type, const char* id, RygelMediaContainer* parent, const char* title, guint child_count);
-static void rygel_media_db_container_on_db_container_updated (RygelMediaDBContainer* self, RygelMediaContainer* container, RygelMediaContainer* container_updated);
-static void _rygel_media_db_container_on_db_container_updated_rygel_media_container_container_updated (RygelMediaContainer* _sender, RygelMediaContainer* container, gpointer self);
-RygelMediaDBContainer* rygel_media_db_container_new (RygelMediaDB* media_db, const char* id, const char* title);
-RygelMediaDBContainer* rygel_media_db_container_construct (GType object_type, RygelMediaDB* media_db, const char* id, const char* title);
-RygelSimpleAsyncResult* rygel_simple_async_result_new (GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GObject* source_object, GAsyncReadyCallback callback, void* callback_target);
-RygelSimpleAsyncResult* rygel_simple_async_result_construct (GType object_type, GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GObject* source_object, GAsyncReadyCallback callback, void* callback_target);
-GType rygel_simple_async_result_get_type (void);
-GeeArrayList* rygel_media_db_get_children (RygelMediaDB* self, const char* container_id, glong offset, glong max_count);
-void rygel_simple_async_result_complete_in_idle (RygelSimpleAsyncResult* self);
-static void rygel_media_db_container_real_get_children (RygelMediaContainer* base, guint offset, guint max_count, GCancellable* cancellable, GAsyncReadyCallback callback, void* callback_target);
-static GeeList* rygel_media_db_container_real_get_children_finish (RygelMediaContainer* base, GAsyncResult* res, GError** error);
-RygelMediaObject* rygel_media_db_get_object (RygelMediaDB* self, const char* object_id, GError** error);
-static void rygel_media_db_container_real_find_object (RygelMediaContainer* base, const char* id, GCancellable* cancellable, GAsyncReadyCallback callback, void* callback_target);
-static RygelMediaObject* rygel_media_db_container_real_find_object_finish (RygelMediaContainer* base, GAsyncResult* res, GError** error);
-static void rygel_media_db_container_finalize (GObject* obj);
-
-
-
-static gpointer _g_object_ref0 (gpointer self) {
-	return self ? g_object_ref (self) : NULL;
-}
-
-
-static void _rygel_media_db_container_on_db_container_updated_rygel_media_container_container_updated (RygelMediaContainer* _sender, RygelMediaContainer* container, gpointer self) {
-	rygel_media_db_container_on_db_container_updated (self, _sender, container);
-}
-
-
-RygelMediaDBContainer* rygel_media_db_container_construct (GType object_type, RygelMediaDB* media_db, const char* id, const char* title) {
-	GError * _inner_error_;
-	RygelMediaDBContainer * self;
-	gint count = 0;
-	RygelMediaDB* _tmp1_;
-	g_return_val_if_fail (media_db != NULL, NULL);
-	g_return_val_if_fail (id != NULL, NULL);
-	g_return_val_if_fail (title != NULL, NULL);
-	_inner_error_ = NULL;
-	{
-		gint _tmp0_;
-		_tmp0_ = rygel_media_db_get_child_count (media_db, id, &_inner_error_);
-		if (_inner_error_ != NULL) {
-			if (_inner_error_->domain == RYGEL_MEDIA_DB_ERROR) {
-				goto __catch46_rygel_media_db_error;
-			}
-			goto __finally46;
-		}
-		count = _tmp0_;
-	}
-	goto __finally46;
-	__catch46_rygel_media_db_error:
-	{
-		GError * e;
-		e = _inner_error_;
-		_inner_error_ = NULL;
-		{
-			g_debug ("rygel-media-db-container.vala:31: Could not get child count from database: %s", e->message);
-			count = 0;
-			_g_error_free0 (e);
-		}
-	}
-	__finally46:
-	if (_inner_error_ != NULL) {
-		g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
-		g_clear_error (&_inner_error_);
-		return NULL;
-	}
-	self = (RygelMediaDBContainer*) rygel_media_container_construct (object_type, id, NULL, title, (guint) count);
-	self->media_db = (_tmp1_ = _g_object_ref0 (media_db), _g_object_unref0 (self->media_db), _tmp1_);
-	g_signal_connect_object ((RygelMediaContainer*) self, "container-updated", (GCallback) _rygel_media_db_container_on_db_container_updated_rygel_media_container_container_updated, self, 0);
-	return self;
-}
-
-
-RygelMediaDBContainer* rygel_media_db_container_new (RygelMediaDB* media_db, const char* id, const char* title) {
-	return rygel_media_db_container_construct (RYGEL_TYPE_MEDIA_DB_CONTAINER, media_db, id, title);
-}
-
-
-static void rygel_media_db_container_on_db_container_updated (RygelMediaDBContainer* self, RygelMediaContainer* container, RygelMediaContainer* container_updated) {
-	GError * _inner_error_;
-	gint _tmp0_;
-	g_return_if_fail (self != NULL);
-	g_return_if_fail (container != NULL);
-	g_return_if_fail (container_updated != NULL);
-	_inner_error_ = NULL;
-	_tmp0_ = rygel_media_db_get_child_count (self->media_db, ((RygelMediaObject*) self)->id, &_inner_error_);
-	if (_inner_error_ != NULL) {
-		g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
-		g_clear_error (&_inner_error_);
-		return;
-	}
-	((RygelMediaContainer*) self)->child_count = (guint) _tmp0_;
-}
-
-
-static void rygel_media_db_container_real_get_children (RygelMediaContainer* base, guint offset, guint max_count, GCancellable* cancellable, GAsyncReadyCallback callback, void* callback_target) {
-	RygelMediaDBContainer * self;
-	RygelSimpleAsyncResult* res;
-	GeeArrayList* _tmp0_;
-	self = (RygelMediaDBContainer*) base;
-	res = rygel_simple_async_result_new (GEE_TYPE_ARRAY_LIST, (GBoxedCopyFunc) g_object_ref, g_object_unref, (GObject*) self, callback, callback_target);
-	res->data = (_tmp0_ = rygel_media_db_get_children (self->media_db, ((RygelMediaObject*) self)->id, (glong) offset, (glong) max_count), _g_object_unref0 (res->data), _tmp0_);
-	rygel_simple_async_result_complete_in_idle (res);
-	_g_object_unref0 (res);
-}
-
-
-static GeeList* rygel_media_db_container_real_get_children_finish (RygelMediaContainer* base, GAsyncResult* res, GError** error) {
-	RygelMediaDBContainer * self;
-	GeeList* result;
-	RygelSimpleAsyncResult* _result_;
-	self = (RygelMediaDBContainer*) base;
-	g_return_val_if_fail (res != NULL, NULL);
-	_result_ = _g_object_ref0 (RYGEL_SIMPLE_ASYNC_RESULT (res));
-	{
-		GeeIterator* _obj_it;
-		_obj_it = gee_abstract_collection_iterator ((GeeAbstractCollection*) ((GeeArrayList*) _result_->data));
-		while (TRUE) {
-			RygelMediaObject* obj;
-			if (!gee_iterator_next (_obj_it)) {
-				break;
-			}
-			obj = (RygelMediaObject*) gee_iterator_get (_obj_it);
-			obj->parent = (RygelMediaContainer*) self;
-			_g_object_unref0 (obj);
-		}
-		_g_object_unref0 (_obj_it);
-	}
-	result = _g_object_ref0 ((GeeList*) ((GeeArrayList*) _result_->data));
-	_g_object_unref0 (_result_);
-	return result;
-}
-
-
-static void rygel_media_db_container_real_find_object (RygelMediaContainer* base, const char* id, GCancellable* cancellable, GAsyncReadyCallback callback, void* callback_target) {
-	RygelMediaDBContainer * self;
-	GError * _inner_error_;
-	RygelSimpleAsyncResult* res;
-	RygelMediaObject* _tmp0_;
-	RygelMediaObject* _tmp1_;
-	self = (RygelMediaDBContainer*) base;
-	g_return_if_fail (id != NULL);
-	_inner_error_ = NULL;
-	res = rygel_simple_async_result_new (RYGEL_TYPE_MEDIA_OBJECT, (GBoxedCopyFunc) g_object_ref, g_object_unref, (GObject*) self, callback, callback_target);
-	_tmp0_ = rygel_media_db_get_object (self->media_db, id, &_inner_error_);
-	if (_inner_error_ != NULL) {
-		_g_object_unref0 (res);
-		g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
-		g_clear_error (&_inner_error_);
-		return;
-	}
-	res->data = (_tmp1_ = _tmp0_, _g_object_unref0 (res->data), _tmp1_);
-	rygel_simple_async_result_complete_in_idle (res);
-	_g_object_unref0 (res);
-}
-
-
-static RygelMediaObject* rygel_media_db_container_real_find_object_finish (RygelMediaContainer* base, GAsyncResult* res, GError** error) {
-	RygelMediaDBContainer * self;
-	RygelMediaObject* result;
-	self = (RygelMediaDBContainer*) base;
-	g_return_val_if_fail (res != NULL, NULL);
-	result = _g_object_ref0 ((RygelMediaObject*) RYGEL_SIMPLE_ASYNC_RESULT (res)->data);
-	return result;
-}
-
-
-static void rygel_media_db_container_class_init (RygelMediaDBContainerClass * klass) {
-	rygel_media_db_container_parent_class = g_type_class_peek_parent (klass);
-	RYGEL_MEDIA_CONTAINER_CLASS (klass)->get_children = rygel_media_db_container_real_get_children;
-	RYGEL_MEDIA_CONTAINER_CLASS (klass)->get_children_finish = rygel_media_db_container_real_get_children_finish;
-	RYGEL_MEDIA_CONTAINER_CLASS (klass)->find_object = rygel_media_db_container_real_find_object;
-	RYGEL_MEDIA_CONTAINER_CLASS (klass)->find_object_finish = rygel_media_db_container_real_find_object_finish;
-	G_OBJECT_CLASS (klass)->finalize = rygel_media_db_container_finalize;
-}
-
-
-static void rygel_media_db_container_instance_init (RygelMediaDBContainer * self) {
-}
-
-
-static void rygel_media_db_container_finalize (GObject* obj) {
-	RygelMediaDBContainer * self;
-	self = RYGEL_MEDIA_DB_CONTAINER (obj);
-	_g_object_unref0 (self->media_db);
-	G_OBJECT_CLASS (rygel_media_db_container_parent_class)->finalize (obj);
-}
-
-
-GType rygel_media_db_container_get_type (void) {
-	static GType rygel_media_db_container_type_id = 0;
-	if (rygel_media_db_container_type_id == 0) {
-		static const GTypeInfo g_define_type_info = { sizeof (RygelMediaDBContainerClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) rygel_media_db_container_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (RygelMediaDBContainer), 0, (GInstanceInitFunc) rygel_media_db_container_instance_init, NULL };
-		rygel_media_db_container_type_id = g_type_register_static (RYGEL_TYPE_MEDIA_CONTAINER, "RygelMediaDBContainer", &g_define_type_info, 0);
-	}
-	return rygel_media_db_container_type_id;
-}
-
-
-
-
--- a/src/rygel/rygel-media-db-object-factory.c
+++ /dev/null
@@ -1,197 +0,0 @@
-/* rygel-media-db-object-factory.c generated by valac, the Vala compiler
- * generated from rygel-media-db-object-factory.vala, do not modify */
-
-/*
- * Copyright (C) 2009 Jens Georg <mail@jensge.org>.
- *
- * Author: Jens Georg <mail@jensge.org>
- *
- * This file is part of Rygel.
- *
- * Rygel is free software; you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * Rygel is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this program; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
- */
-
-#include <glib.h>
-#include <glib-object.h>
-#include <stdlib.h>
-#include <string.h>
-
-
-#define RYGEL_TYPE_MEDIA_DB_OBJECT_FACTORY (rygel_media_db_object_factory_get_type ())
-#define RYGEL_MEDIA_DB_OBJECT_FACTORY(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_MEDIA_DB_OBJECT_FACTORY, RygelMediaDBObjectFactory))
-#define RYGEL_MEDIA_DB_OBJECT_FACTORY_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_MEDIA_DB_OBJECT_FACTORY, RygelMediaDBObjectFactoryClass))
-#define RYGEL_IS_MEDIA_DB_OBJECT_FACTORY(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_MEDIA_DB_OBJECT_FACTORY))
-#define RYGEL_IS_MEDIA_DB_OBJECT_FACTORY_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_MEDIA_DB_OBJECT_FACTORY))
-#define RYGEL_MEDIA_DB_OBJECT_FACTORY_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_MEDIA_DB_OBJECT_FACTORY, RygelMediaDBObjectFactoryClass))
-
-typedef struct _RygelMediaDBObjectFactory RygelMediaDBObjectFactory;
-typedef struct _RygelMediaDBObjectFactoryClass RygelMediaDBObjectFactoryClass;
-typedef struct _RygelMediaDBObjectFactoryPrivate RygelMediaDBObjectFactoryPrivate;
-
-#define RYGEL_TYPE_MEDIA_DB (rygel_media_db_get_type ())
-#define RYGEL_MEDIA_DB(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_MEDIA_DB, RygelMediaDB))
-#define RYGEL_MEDIA_DB_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_MEDIA_DB, RygelMediaDBClass))
-#define RYGEL_IS_MEDIA_DB(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_MEDIA_DB))
-#define RYGEL_IS_MEDIA_DB_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_MEDIA_DB))
-#define RYGEL_MEDIA_DB_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_MEDIA_DB, RygelMediaDBClass))
-
-typedef struct _RygelMediaDB RygelMediaDB;
-typedef struct _RygelMediaDBClass RygelMediaDBClass;
-
-#define RYGEL_TYPE_MEDIA_OBJECT (rygel_media_object_get_type ())
-#define RYGEL_MEDIA_OBJECT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_MEDIA_OBJECT, RygelMediaObject))
-#define RYGEL_MEDIA_OBJECT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_MEDIA_OBJECT, RygelMediaObjectClass))
-#define RYGEL_IS_MEDIA_OBJECT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_MEDIA_OBJECT))
-#define RYGEL_IS_MEDIA_OBJECT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_MEDIA_OBJECT))
-#define RYGEL_MEDIA_OBJECT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_MEDIA_OBJECT, RygelMediaObjectClass))
-
-typedef struct _RygelMediaObject RygelMediaObject;
-typedef struct _RygelMediaObjectClass RygelMediaObjectClass;
-
-#define RYGEL_TYPE_MEDIA_CONTAINER (rygel_media_container_get_type ())
-#define RYGEL_MEDIA_CONTAINER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_MEDIA_CONTAINER, RygelMediaContainer))
-#define RYGEL_MEDIA_CONTAINER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_MEDIA_CONTAINER, RygelMediaContainerClass))
-#define RYGEL_IS_MEDIA_CONTAINER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_MEDIA_CONTAINER))
-#define RYGEL_IS_MEDIA_CONTAINER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_MEDIA_CONTAINER))
-#define RYGEL_MEDIA_CONTAINER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_MEDIA_CONTAINER, RygelMediaContainerClass))
-
-typedef struct _RygelMediaContainer RygelMediaContainer;
-typedef struct _RygelMediaContainerClass RygelMediaContainerClass;
-
-#define RYGEL_TYPE_MEDIA_ITEM (rygel_media_item_get_type ())
-#define RYGEL_MEDIA_ITEM(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_MEDIA_ITEM, RygelMediaItem))
-#define RYGEL_MEDIA_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_MEDIA_ITEM, RygelMediaItemClass))
-#define RYGEL_IS_MEDIA_ITEM(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_MEDIA_ITEM))
-#define RYGEL_IS_MEDIA_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_MEDIA_ITEM))
-#define RYGEL_MEDIA_ITEM_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_MEDIA_ITEM, RygelMediaItemClass))
-
-typedef struct _RygelMediaItem RygelMediaItem;
-typedef struct _RygelMediaItemClass RygelMediaItemClass;
-
-#define RYGEL_TYPE_MEDIA_DB_CONTAINER (rygel_media_db_container_get_type ())
-#define RYGEL_MEDIA_DB_CONTAINER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_MEDIA_DB_CONTAINER, RygelMediaDBContainer))
-#define RYGEL_MEDIA_DB_CONTAINER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_MEDIA_DB_CONTAINER, RygelMediaDBContainerClass))
-#define RYGEL_IS_MEDIA_DB_CONTAINER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_MEDIA_DB_CONTAINER))
-#define RYGEL_IS_MEDIA_DB_CONTAINER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_MEDIA_DB_CONTAINER))
-#define RYGEL_MEDIA_DB_CONTAINER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_MEDIA_DB_CONTAINER, RygelMediaDBContainerClass))
-
-typedef struct _RygelMediaDBContainer RygelMediaDBContainer;
-typedef struct _RygelMediaDBContainerClass RygelMediaDBContainerClass;
-
-struct _RygelMediaDBObjectFactory {
-	GObject parent_instance;
-	RygelMediaDBObjectFactoryPrivate * priv;
-};
-
-struct _RygelMediaDBObjectFactoryClass {
-	GObjectClass parent_class;
-	RygelMediaContainer* (*get_container) (RygelMediaDBObjectFactory* self, RygelMediaDB* media_db, const char* id, const char* title, guint child_count);
-	RygelMediaItem* (*get_item) (RygelMediaDBObjectFactory* self, RygelMediaDB* media_db, RygelMediaContainer* parent, const char* id, const char* title, const char* upnp_class);
-};
-
-
-static gpointer rygel_media_db_object_factory_parent_class = NULL;
-
-GType rygel_media_db_object_factory_get_type (void);
-GType rygel_media_db_get_type (void);
-GType rygel_media_object_get_type (void);
-GType rygel_media_container_get_type (void);
-GType rygel_media_item_get_type (void);
-enum  {
-	RYGEL_MEDIA_DB_OBJECT_FACTORY_DUMMY_PROPERTY
-};
-RygelMediaDBContainer* rygel_media_db_container_new (RygelMediaDB* media_db, const char* id, const char* title);
-RygelMediaDBContainer* rygel_media_db_container_construct (GType object_type, RygelMediaDB* media_db, const char* id, const char* title);
-GType rygel_media_db_container_get_type (void);
-RygelMediaContainer* rygel_media_db_object_factory_get_container (RygelMediaDBObjectFactory* self, RygelMediaDB* media_db, const char* id, const char* title, guint child_count);
-static RygelMediaContainer* rygel_media_db_object_factory_real_get_container (RygelMediaDBObjectFactory* self, RygelMediaDB* media_db, const char* id, const char* title, guint child_count);
-RygelMediaItem* rygel_media_item_new (const char* id, RygelMediaContainer* parent, const char* title, const char* upnp_class);
-RygelMediaItem* rygel_media_item_construct (GType object_type, const char* id, RygelMediaContainer* parent, const char* title, const char* upnp_class);
-RygelMediaItem* rygel_media_db_object_factory_get_item (RygelMediaDBObjectFactory* self, RygelMediaDB* media_db, RygelMediaContainer* parent, const char* id, const char* title, const char* upnp_class);
-static RygelMediaItem* rygel_media_db_object_factory_real_get_item (RygelMediaDBObjectFactory* self, RygelMediaDB* media_db, RygelMediaContainer* parent, const char* id, const char* title, const char* upnp_class);
-RygelMediaDBObjectFactory* rygel_media_db_object_factory_new (void);
-RygelMediaDBObjectFactory* rygel_media_db_object_factory_construct (GType object_type);
-
-
-
-static RygelMediaContainer* rygel_media_db_object_factory_real_get_container (RygelMediaDBObjectFactory* self, RygelMediaDB* media_db, const char* id, const char* title, guint child_count) {
-	RygelMediaContainer* result;
-	g_return_val_if_fail (self != NULL, NULL);
-	g_return_val_if_fail (media_db != NULL, NULL);
-	g_return_val_if_fail (id != NULL, NULL);
-	g_return_val_if_fail (title != NULL, NULL);
-	result = (RygelMediaContainer*) rygel_media_db_container_new (media_db, id, title);
-	return result;
-}
-
-
-RygelMediaContainer* rygel_media_db_object_factory_get_container (RygelMediaDBObjectFactory* self, RygelMediaDB* media_db, const char* id, const char* title, guint child_count) {
-	return RYGEL_MEDIA_DB_OBJECT_FACTORY_GET_CLASS (self)->get_container (self, media_db, id, title, child_count);
-}
-
-
-static RygelMediaItem* rygel_media_db_object_factory_real_get_item (RygelMediaDBObjectFactory* self, RygelMediaDB* media_db, RygelMediaContainer* parent, const char* id, const char* title, const char* upnp_class) {
-	RygelMediaItem* result;
-	g_return_val_if_fail (self != NULL, NULL);
-	g_return_val_if_fail (media_db != NULL, NULL);
-	g_return_val_if_fail (parent != NULL, NULL);
-	g_return_val_if_fail (id != NULL, NULL);
-	g_return_val_if_fail (title != NULL, NULL);
-	g_return_val_if_fail (upnp_class != NULL, NULL);
-	result = rygel_media_item_new (id, parent, title, upnp_class);
-	return result;
-}
-
-
-RygelMediaItem* rygel_media_db_object_factory_get_item (RygelMediaDBObjectFactory* self, RygelMediaDB* media_db, RygelMediaContainer* parent, const char* id, const char* title, const char* upnp_class) {
-	return RYGEL_MEDIA_DB_OBJECT_FACTORY_GET_CLASS (self)->get_item (self, media_db, parent, id, title, upnp_class);
-}
-
-
-RygelMediaDBObjectFactory* rygel_media_db_object_factory_construct (GType object_type) {
-	RygelMediaDBObjectFactory * self;
-	self = (RygelMediaDBObjectFactory*) g_object_new (object_type, NULL);
-	return self;
-}
-
-
-RygelMediaDBObjectFactory* rygel_media_db_object_factory_new (void) {
-	return rygel_media_db_object_factory_construct (RYGEL_TYPE_MEDIA_DB_OBJECT_FACTORY);
-}
-
-
-static void rygel_media_db_object_factory_class_init (RygelMediaDBObjectFactoryClass * klass) {
-	rygel_media_db_object_factory_parent_class = g_type_class_peek_parent (klass);
-	RYGEL_MEDIA_DB_OBJECT_FACTORY_CLASS (klass)->get_container = rygel_media_db_object_factory_real_get_container;
-	RYGEL_MEDIA_DB_OBJECT_FACTORY_CLASS (klass)->get_item = rygel_media_db_object_factory_real_get_item;
-}
-
-
-static void rygel_media_db_object_factory_instance_init (RygelMediaDBObjectFactory * self) {
-}
-
-
-GType rygel_media_db_object_factory_get_type (void) {
-	static GType rygel_media_db_object_factory_type_id = 0;
-	if (rygel_media_db_object_factory_type_id == 0) {
-		static const GTypeInfo g_define_type_info = { sizeof (RygelMediaDBObjectFactoryClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) rygel_media_db_object_factory_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (RygelMediaDBObjectFactory), 0, (GInstanceInitFunc) rygel_media_db_object_factory_instance_init, NULL };
-		rygel_media_db_object_factory_type_id = g_type_register_static (G_TYPE_OBJECT, "RygelMediaDBObjectFactory", &g_define_type_info, 0);
-	}
-	return rygel_media_db_object_factory_type_id;
-}
-
-
-
-
--- a/src/rygel/rygel-media-db.c
+++ /dev/null
@@ -1,1975 +0,0 @@
-/* rygel-media-db.c generated by valac, the Vala compiler
- * generated from rygel-media-db.vala, do not modify */
-
-/*
- * Copyright (C) 2009 Jens Georg <mail@jensge.org>.
- *
- * Author: Jens Georg <mail@jensge.org>
- *
- * This file is part of Rygel.
- *
- * Rygel is free software; you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * Rygel is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this program; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
- */
-
-#include <glib.h>
-#include <glib-object.h>
-#include <sqlite3.h>
-#include <stdlib.h>
-#include <string.h>
-#include <gee.h>
-#include <gst/gst.h>
-
-
-#define RYGEL_TYPE_MEDIA_DB_OBJECT_TYPE (rygel_media_db_object_type_get_type ())
-
-#define RYGEL_TYPE_MEDIA_DB (rygel_media_db_get_type ())
-#define RYGEL_MEDIA_DB(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_MEDIA_DB, RygelMediaDB))
-#define RYGEL_MEDIA_DB_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_MEDIA_DB, RygelMediaDBClass))
-#define RYGEL_IS_MEDIA_DB(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_MEDIA_DB))
-#define RYGEL_IS_MEDIA_DB_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_MEDIA_DB))
-#define RYGEL_MEDIA_DB_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_MEDIA_DB, RygelMediaDBClass))
-
-typedef struct _RygelMediaDB RygelMediaDB;
-typedef struct _RygelMediaDBClass RygelMediaDBClass;
-typedef struct _RygelMediaDBPrivate RygelMediaDBPrivate;
-
-#define RYGEL_TYPE_MEDIA_DB_OBJECT_FACTORY (rygel_media_db_object_factory_get_type ())
-#define RYGEL_MEDIA_DB_OBJECT_FACTORY(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_MEDIA_DB_OBJECT_FACTORY, RygelMediaDBObjectFactory))
-#define RYGEL_MEDIA_DB_OBJECT_FACTORY_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_MEDIA_DB_OBJECT_FACTORY, RygelMediaDBObjectFactoryClass))
-#define RYGEL_IS_MEDIA_DB_OBJECT_FACTORY(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_MEDIA_DB_OBJECT_FACTORY))
-#define RYGEL_IS_MEDIA_DB_OBJECT_FACTORY_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_MEDIA_DB_OBJECT_FACTORY))
-#define RYGEL_MEDIA_DB_OBJECT_FACTORY_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_MEDIA_DB_OBJECT_FACTORY, RygelMediaDBObjectFactoryClass))
-
-typedef struct _RygelMediaDBObjectFactory RygelMediaDBObjectFactory;
-typedef struct _RygelMediaDBObjectFactoryClass RygelMediaDBObjectFactoryClass;
-#define _sqlite3_close0(var) ((var == NULL) ? NULL : (var = (sqlite3_close (var), NULL)))
-#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
-#define _g_free0(var) (var = (g_free (var), NULL))
-#define _sqlite3_finalize0(var) ((var == NULL) ? NULL : (var = (sqlite3_finalize (var), NULL)))
-
-#define RYGEL_TYPE_MEDIA_OBJECT (rygel_media_object_get_type ())
-#define RYGEL_MEDIA_OBJECT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_MEDIA_OBJECT, RygelMediaObject))
-#define RYGEL_MEDIA_OBJECT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_MEDIA_OBJECT, RygelMediaObjectClass))
-#define RYGEL_IS_MEDIA_OBJECT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_MEDIA_OBJECT))
-#define RYGEL_IS_MEDIA_OBJECT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_MEDIA_OBJECT))
-#define RYGEL_MEDIA_OBJECT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_MEDIA_OBJECT, RygelMediaObjectClass))
-
-typedef struct _RygelMediaObject RygelMediaObject;
-typedef struct _RygelMediaObjectClass RygelMediaObjectClass;
-typedef struct _RygelMediaObjectPrivate RygelMediaObjectPrivate;
-
-#define RYGEL_TYPE_MEDIA_CONTAINER (rygel_media_container_get_type ())
-#define RYGEL_MEDIA_CONTAINER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_MEDIA_CONTAINER, RygelMediaContainer))
-#define RYGEL_MEDIA_CONTAINER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_MEDIA_CONTAINER, RygelMediaContainerClass))
-#define RYGEL_IS_MEDIA_CONTAINER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_MEDIA_CONTAINER))
-#define RYGEL_IS_MEDIA_CONTAINER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_MEDIA_CONTAINER))
-#define RYGEL_MEDIA_CONTAINER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_MEDIA_CONTAINER, RygelMediaContainerClass))
-
-typedef struct _RygelMediaContainer RygelMediaContainer;
-typedef struct _RygelMediaContainerClass RygelMediaContainerClass;
-
-#define RYGEL_TYPE_MEDIA_ITEM (rygel_media_item_get_type ())
-#define RYGEL_MEDIA_ITEM(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_MEDIA_ITEM, RygelMediaItem))
-#define RYGEL_MEDIA_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_MEDIA_ITEM, RygelMediaItemClass))
-#define RYGEL_IS_MEDIA_ITEM(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_MEDIA_ITEM))
-#define RYGEL_IS_MEDIA_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_MEDIA_ITEM))
-#define RYGEL_MEDIA_ITEM_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_MEDIA_ITEM, RygelMediaItemClass))
-
-typedef struct _RygelMediaItem RygelMediaItem;
-typedef struct _RygelMediaItemClass RygelMediaItemClass;
-#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
-typedef struct _RygelMediaItemPrivate RygelMediaItemPrivate;
-
-#define RYGEL_TYPE_ICON_INFO (rygel_icon_info_get_type ())
-#define RYGEL_ICON_INFO(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_ICON_INFO, RygelIconInfo))
-#define RYGEL_ICON_INFO_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_ICON_INFO, RygelIconInfoClass))
-#define RYGEL_IS_ICON_INFO(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_ICON_INFO))
-#define RYGEL_IS_ICON_INFO_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_ICON_INFO))
-#define RYGEL_ICON_INFO_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_ICON_INFO, RygelIconInfoClass))
-
-typedef struct _RygelIconInfo RygelIconInfo;
-typedef struct _RygelIconInfoClass RygelIconInfoClass;
-
-#define RYGEL_TYPE_THUMBNAIL (rygel_thumbnail_get_type ())
-#define RYGEL_THUMBNAIL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_THUMBNAIL, RygelThumbnail))
-#define RYGEL_THUMBNAIL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_THUMBNAIL, RygelThumbnailClass))
-#define RYGEL_IS_THUMBNAIL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_THUMBNAIL))
-#define RYGEL_IS_THUMBNAIL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_THUMBNAIL))
-#define RYGEL_THUMBNAIL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_THUMBNAIL, RygelThumbnailClass))
-
-typedef struct _RygelThumbnail RygelThumbnail;
-typedef struct _RygelThumbnailClass RygelThumbnailClass;
-
-typedef enum  {
-	RYGEL_MEDIA_DB_ERROR_SQLITE_ERROR,
-	RYGEL_MEDIA_DB_ERROR_GENERAL_ERROR,
-	RYGEL_MEDIA_DB_ERROR_INVALID_TYPE
-} RygelMediaDBError;
-#define RYGEL_MEDIA_DB_ERROR rygel_media_db_error_quark ()
-typedef enum  {
-	RYGEL_MEDIA_DB_OBJECT_TYPE_CONTAINER,
-	RYGEL_MEDIA_DB_OBJECT_TYPE_ITEM
-} RygelMediaDBObjectType;
-
-struct _RygelMediaDB {
-	GObject parent_instance;
-	RygelMediaDBPrivate * priv;
-};
-
-struct _RygelMediaDBClass {
-	GObjectClass parent_class;
-};
-
-struct _RygelMediaDBPrivate {
-	sqlite3* db;
-	RygelMediaDBObjectFactory* factory;
-};
-
-struct _RygelMediaObject {
-	GObject parent_instance;
-	RygelMediaObjectPrivate * priv;
-	char* id;
-	char* title;
-	guint64 modified;
-	GeeArrayList* uris;
-	RygelMediaContainer* parent;
-	RygelMediaContainer* parent_ref;
-};
-
-struct _RygelMediaObjectClass {
-	GObjectClass parent_class;
-};
-
-struct _RygelMediaItem {
-	RygelMediaObject parent_instance;
-	RygelMediaItemPrivate * priv;
-	char* author;
-	char* album;
-	char* date;
-	char* upnp_class;
-	char* mime_type;
-	char* dlna_profile;
-	glong size;
-	glong duration;
-	gint bitrate;
-	gint sample_freq;
-	gint bits_per_sample;
-	gint n_audio_channels;
-	gint track_number;
-	gint width;
-	gint height;
-	gint pixel_width;
-	gint pixel_height;
-	gint color_depth;
-	GeeArrayList* thumbnails;
-};
-
-struct _RygelMediaItemClass {
-	RygelMediaObjectClass parent_class;
-	GstElement* (*create_stream_source) (RygelMediaItem* self);
-	gboolean (*should_stream) (RygelMediaItem* self);
-};
-
-
-static gpointer rygel_media_db_parent_class = NULL;
-
-GQuark rygel_media_db_error_quark (void);
-GType rygel_media_db_object_type_get_type (void);
-GType rygel_media_db_get_type (void);
-GType rygel_media_db_object_factory_get_type (void);
-#define RYGEL_MEDIA_DB_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), RYGEL_TYPE_MEDIA_DB, RygelMediaDBPrivate))
-enum  {
-	RYGEL_MEDIA_DB_DUMMY_PROPERTY
-};
-#define RYGEL_MEDIA_DB_schema_version "4"
-#define RYGEL_MEDIA_DB_SCHEMA_STRING "CREATE TABLE Schema_Info (version TEXT NOT NULL); " "CREATE TABLE Object_Type (id INTEGER PRIMARY KEY, " "desc TEXT NOT NULL);" "CREATE TABLE Meta_Data (id INTEGER PRIMARY KEY AUTOINCREMENT, " "size INTEGER NOT NULL, " "mime_type TEXT NOT NULL, " "duration INTEGER, " "width INTEGER, " "height INTEGER, " "class TEXT NOT NULL, " "author TEXT, " "album TEXT, " "date TEXT, " "bitrate INTEGER, " "sample_freq INTEGER, " "bits_per_sample INTEGER, " "channels INTEGER, " "track INTEGER, " "color_depth INTEGER, " "object_fk TEXT UNIQUE CONSTRAINT " "object_fk_id REFERENCES Object(upnp_id) " "ON DELETE CASCADE);" "CREATE TABLE Object (parent TEXT CONSTRAINT parent_fk_id " "REFERENCES Object(upnp_id), " "upnp_id TEXT PRIMARY KEY, " "type_fk INTEGER CONSTRAINT type_fk_id " "REFERENCES Object_Type(id), " "title TEXT NOT NULL, " "timestamp INTEGER NOT NULL);" "CREATE TABLE Uri (object_fk TEXT " "CONSTRAINT object_fk_id REFERENCES Object(upnp_id) " "ON DELETE CASCADE, " "uri TEXT NOT NULL);" "INSERT INTO Object_Type (id, desc) VALUES (0, 'Container'); " "INSERT INTO Object_Type (id, desc) VALUES (1, 'Item'); " "INSERT INTO Schema_Info (version) VALUES ('" RYGEL_MEDIA_DB_schema_version "'); "
-#define RYGEL_MEDIA_DB_CREATE_TRIGGER_STRING "CREATE TRIGGER trgr_delete_children " "BEFORE DELETE ON Object " "FOR EACH ROW BEGIN " "UPDATE Object SET parent = NULL " "WHERE Object.parent = OLD.upnp_id;" "END;" "CREATE TRIGGER trgr_delete_metadata " "BEFORE DELETE ON Object " "FOR EACH ROW BEGIN " "DELETE FROM Meta_Data WHERE Meta_Data.object_fk = OLD.upnp_id; " "END;" "CREATE TRIGGER trgr_delete_uris " "BEFORE DELETE ON Object " "FOR EACH ROW BEGIN " "DELETE FROM Uri WHERE Uri.object_fk = OLD.upnp_id;" "END;"
-#define RYGEL_MEDIA_DB_INSERT_META_DATA_STRING "INSERT INTO Meta_Data " "(size, mime_type, width, height, class, " "author, album, date, bitrate, " "sample_freq, bits_per_sample, channels, " "track, color_depth, duration, object_fk) VALUES " "(?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)"
-#define RYGEL_MEDIA_DB_UPDATE_META_DATA_STRING "UPDATE Meta_Data SET " "size = ?, mime_type = ?, width = ?, height = ?, class = ?, " "author = ?, album = ?, date = ?, bitrate = ?, " "sample_freq = ?, bits_per_sample = ?, channels = ?, " "track = ?, color_depth = ?, duration = ? " "WHERE object_fk = ?"
-#define RYGEL_MEDIA_DB_INSERT_OBJECT_STRING "INSERT INTO Object (upnp_id, title, type_fk, parent, timestamp) " "VALUES (?,?,?,?,?)"
-#define RYGEL_MEDIA_DB_UPDATE_OBJECT_STRING "UPDATE Object SET title = ?, timestamp = ? WHERE upnp_id = ?"
-#define RYGEL_MEDIA_DB_INSERT_URI_STRING "INSERT INTO Uri (object_fk, uri) VALUES (?,?)"
-#define RYGEL_MEDIA_DB_DELETE_URI_STRING "DELETE FROM Uri WHERE object_fk = ?"
-#define RYGEL_MEDIA_DB_GET_OBJECT_STRING "SELECT type_fk, title, Meta_Data.size, Meta_Data.mime_type, " "Meta_Data.width, Meta_Data.height, " "Meta_Data.class, Meta_Data.author, Meta_Data.album, " "Meta_Data.date, Meta_Data.bitrate, Meta_Data.sample_freq, " "Meta_Data.bits_per_sample, Meta_Data.channels, " "Meta_Data.track, Meta_Data.color_depth, Meta_Data.duration, " "Object.parent " "FROM Object LEFT OUTER JOIN Meta_Data " "ON Object.upnp_id = Meta_Data.object_fk WHERE Object.upnp_id = ?"
-#define RYGEL_MEDIA_DB_GET_CHILDREN_STRING "SELECT type_fk, title, Meta_Data.size, Meta_Data.mime_type, " "Meta_Data.width, Meta_Data.height, " "Meta_Data.class, Meta_Data.author, Meta_Data.album, " "Meta_Data.date, Meta_Data.bitrate, Meta_Data.sample_freq, " "Meta_Data.bits_per_sample, Meta_Data.channels, " "Meta_Data.track, Meta_Data.color_depth, Meta_Data.duration, " "upnp_id, Object.parent, Object.timestamp " "FROM Object LEFT OUTER JOIN Meta_Data " "ON Object.upnp_id = Meta_Data.object_fk " "WHERE Object.parent = ? " "ORDER BY type_fk ASC, " "Meta_Data.class ASC, " "Meta_Data.track ASC, " "title ASC " "LIMIT ?,?"
-#define RYGEL_MEDIA_DB_URI_GET_STRING "SELECT uri FROM Uri WHERE Uri.object_fk = ?"
-#define RYGEL_MEDIA_DB_CHILDREN_COUNT_STRING "SELECT COUNT(upnp_id) FROM Object WHERE Object.parent = ?"
-#define RYGEL_MEDIA_DB_OBJECT_EXISTS_STRING "SELECT COUNT(upnp_id), timestamp FROM Object WHERE Object.upnp_id = ?"
-#define RYGEL_MEDIA_DB_OBJECT_DELETE_STRING "DELETE FROM Object WHERE Object.upnp_id = ?"
-#define RYGEL_MEDIA_DB_SWEEPER_STRING "DELETE FROM Object WHERE parent IS NULL AND Object.upnp_id != '0'"
-#define RYGEL_MEDIA_DB_GET_CHILD_ID_STRING "SELECT upnp_id FROM OBJECT WHERE parent = ?"
-#define RYGEL_MEDIA_DB_UPDATE_V3_V4_STRING_1 "ALTER TABLE Meta_Data ADD object_fk TEXT"
-#define RYGEL_MEDIA_DB_UPDATE_V3_V4_STRING_2 "UPDATE Meta_Data SET object_fk = " "(SELECT upnp_id FROM Object WHERE metadata_fk = Meta_Data.id)"
-#define RYGEL_MEDIA_DB_UPDATE_V3_V4_STRING_3 "ALTER TABLE Object ADD timestamp INTEGER"
-#define RYGEL_MEDIA_DB_UPDATE_V3_V4_STRING_4 "UPDATE Object SET timestamp = 0"
-static void rygel_media_db_update_v3_v4 (RygelMediaDB* self);
-static gboolean rygel_media_db_create_schema (RygelMediaDB* self);
-static void rygel_media_db_open_db (RygelMediaDB* self, const char* name);
-static RygelMediaDB* rygel_media_db_new (const char* name, RygelMediaDBObjectFactory* factory);
-static RygelMediaDB* rygel_media_db_construct (GType object_type, const char* name, RygelMediaDBObjectFactory* factory);
-RygelMediaDBObjectFactory* rygel_media_db_object_factory_new (void);
-RygelMediaDBObjectFactory* rygel_media_db_object_factory_construct (GType object_type);
-RygelMediaDB* rygel_media_db_create (const char* name, GError** error);
-RygelMediaDB* rygel_media_db_create_with_factory (const char* name, RygelMediaDBObjectFactory* factory, GError** error);
-static gboolean rygel_media_db_sweeper (RygelMediaDB* self);
-static gboolean _rygel_media_db_sweeper_gsource_func (gpointer self);
-void rygel_media_db_remove_by_id (RygelMediaDB* self, const char* id, GError** error);
-GType rygel_media_object_get_type (void);
-GType rygel_media_container_get_type (void);
-GType rygel_media_item_get_type (void);
-void rygel_media_db_remove_object (RygelMediaDB* self, RygelMediaObject* obj, GError** error);
-void rygel_media_db_save_item (RygelMediaDB* self, RygelMediaItem* item, GError** error);
-void rygel_media_db_save_container (RygelMediaDB* self, RygelMediaContainer* container, GError** error);
-void rygel_media_db_save_object (RygelMediaDB* self, RygelMediaObject* obj, GError** error);
-static void rygel_media_db_create_object (RygelMediaDB* self, RygelMediaObject* item, GError** error);
-static void rygel_media_db_save_uris (RygelMediaDB* self, RygelMediaObject* obj, GError** error);
-static void rygel_media_db_save_metadata (RygelMediaDB* self, RygelMediaItem* item, const char* sql, GError** error);
-static void rygel_media_db_remove_uris (RygelMediaDB* self, RygelMediaObject* obj, GError** error);
-static void rygel_media_db_update_object_internal (RygelMediaDB* self, RygelMediaObject* obj, GError** error);
-void rygel_media_db_update_object (RygelMediaDB* self, RygelMediaObject* obj, GError** error);
-gpointer rygel_icon_info_ref (gpointer instance);
-void rygel_icon_info_unref (gpointer instance);
-GParamSpec* rygel_param_spec_icon_info (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
-void rygel_value_set_icon_info (GValue* value, gpointer v_object);
-gpointer rygel_value_get_icon_info (const GValue* value);
-GType rygel_icon_info_get_type (void);
-GType rygel_thumbnail_get_type (void);
-void rygel_media_item_add_uri (RygelMediaItem* self, const char* uri, RygelThumbnail* thumbnail);
-static void rygel_media_db_add_uris (RygelMediaDB* self, RygelMediaObject* obj, GError** error);
-RygelMediaContainer* rygel_media_db_object_factory_get_container (RygelMediaDBObjectFactory* self, RygelMediaDB* media_db, const char* id, const char* title, guint child_count);
-RygelMediaItem* rygel_media_db_object_factory_get_item (RygelMediaDBObjectFactory* self, RygelMediaDB* media_db, RygelMediaContainer* parent, const char* id, const char* title, const char* upnp_class);
-static void rygel_media_db_fill_item (RygelMediaDB* self, sqlite3_stmt* statement, RygelMediaItem* item);
-static RygelMediaObject* rygel_media_db_get_object_from_statement (RygelMediaDB* self, RygelMediaContainer* parent, const char* object_id, sqlite3_stmt* statement);
-RygelMediaObject* rygel_media_db_get_object (RygelMediaDB* self, const char* object_id, GError** error);
-RygelMediaItem* rygel_media_db_get_item (RygelMediaDB* self, const char* item_id, GError** error);
-RygelMediaContainer* rygel_media_db_get_container (RygelMediaDB* self, const char* container_id, GError** error);
-GeeArrayList* rygel_media_db_get_child_ids (RygelMediaDB* self, const char* container_id, GError** error);
-gint rygel_media_db_get_child_count (RygelMediaDB* self, const char* container_id, GError** error);
-gboolean rygel_media_db_exists (RygelMediaDB* self, const char* object_id, gint64* timestamp, GError** error);
-GeeArrayList* rygel_media_db_get_children (RygelMediaDB* self, const char* container_id, glong offset, glong max_count);
-static void rygel_media_db_finalize (GObject* obj);
-static int _vala_strcmp0 (const char * str1, const char * str2);
-
-
-
-GQuark rygel_media_db_error_quark (void) {
-	return g_quark_from_static_string ("rygel_media_db_error-quark");
-}
-
-
-
-GType rygel_media_db_object_type_get_type (void) {
-	static GType rygel_media_db_object_type_type_id = 0;
-	if (G_UNLIKELY (rygel_media_db_object_type_type_id == 0)) {
-		static const GEnumValue values[] = {{RYGEL_MEDIA_DB_OBJECT_TYPE_CONTAINER, "RYGEL_MEDIA_DB_OBJECT_TYPE_CONTAINER", "container"}, {RYGEL_MEDIA_DB_OBJECT_TYPE_ITEM, "RYGEL_MEDIA_DB_OBJECT_TYPE_ITEM", "item"}, {0, NULL, NULL}};
-		rygel_media_db_object_type_type_id = g_enum_register_static ("RygelMediaDBObjectType", values);
-	}
-	return rygel_media_db_object_type_type_id;
-}
-
-
-static void rygel_media_db_update_v3_v4 (RygelMediaDB* self) {
-	gboolean _tmp0_ = FALSE;
-	gboolean _tmp1_ = FALSE;
-	gboolean _tmp2_ = FALSE;
-	gboolean _tmp3_ = FALSE;
-	gboolean _tmp4_ = FALSE;
-	gboolean _tmp5_ = FALSE;
-	g_return_if_fail (self != NULL);
-	if (sqlite3_exec (self->priv->db, "BEGIN", NULL, NULL, NULL) == SQLITE_OK) {
-		_tmp5_ = sqlite3_exec (self->priv->db, RYGEL_MEDIA_DB_UPDATE_V3_V4_STRING_1, NULL, NULL, NULL) == SQLITE_OK;
-	} else {
-		_tmp5_ = FALSE;
-	}
-	if (_tmp5_) {
-		_tmp4_ = sqlite3_exec (self->priv->db, RYGEL_MEDIA_DB_UPDATE_V3_V4_STRING_2, NULL, NULL, NULL) == SQLITE_OK;
-	} else {
-		_tmp4_ = FALSE;
-	}
-	if (_tmp4_) {
-		_tmp3_ = sqlite3_exec (self->priv->db, RYGEL_MEDIA_DB_UPDATE_V3_V4_STRING_3, NULL, NULL, NULL) == SQLITE_OK;
-	} else {
-		_tmp3_ = FALSE;
-	}
-	if (_tmp3_) {
-		_tmp2_ = sqlite3_exec (self->priv->db, RYGEL_MEDIA_DB_UPDATE_V3_V4_STRING_4, NULL, NULL, NULL) == SQLITE_OK;
-	} else {
-		_tmp2_ = FALSE;
-	}
-	if (_tmp2_) {
-		_tmp1_ = sqlite3_exec (self->priv->db, RYGEL_MEDIA_DB_CREATE_TRIGGER_STRING, NULL, NULL, NULL) == SQLITE_OK;
-	} else {
-		_tmp1_ = FALSE;
-	}
-	if (_tmp1_) {
-		_tmp0_ = sqlite3_exec (self->priv->db, "UPDATE Schema_Info SET version = " RYGEL_MEDIA_DB_schema_version, NULL, NULL, NULL) == SQLITE_OK;
-	} else {
-		_tmp0_ = FALSE;
-	}
-	if (_tmp0_) {
-		sqlite3_exec (self->priv->db, "COMMIT", NULL, NULL, NULL);
-	} else {
-		sqlite3* _tmp6_;
-		sqlite3_exec (self->priv->db, "ROLLBACK", NULL, NULL, NULL);
-		g_warning ("rygel-media-db.vala:217: Database upgrade failed: %s", sqlite3_errmsg (self->priv->db));
-		self->priv->db = (_tmp6_ = NULL, _sqlite3_close0 (self->priv->db), _tmp6_);
-	}
-}
-
-
-static void rygel_media_db_open_db (RygelMediaDB* self, const char* name) {
-	char* dirname;
-	char* _tmp0_;
-	char* _tmp1_;
-	char* db_file;
-	sqlite3* _tmp4_;
-	gint _tmp3_;
-	sqlite3* _tmp2_ = NULL;
-	gint rc;
-	gint schema_info_size;
-	gint schema_info_length1;
-	char** schema_info;
-	gint nrows = 0;
-	gint ncolumns = 0;
-	g_return_if_fail (self != NULL);
-	g_return_if_fail (name != NULL);
-	dirname = g_build_filename (g_get_user_cache_dir (), "rygel", NULL);
-	g_mkdir_with_parents (dirname, 0750);
-	db_file = (_tmp1_ = g_build_filename (dirname, _tmp0_ = g_strdup_printf ("%s.db", name), NULL), _g_free0 (_tmp0_), _tmp1_);
-	g_debug ("rygel-media-db.vala:227: Using database file %s", db_file);
-	rc = (_tmp3_ = sqlite3_open (db_file, &_tmp2_), self->priv->db = (_tmp4_ = _tmp2_, _sqlite3_close0 (self->priv->db), _tmp4_), _tmp3_);
-	if (rc != SQLITE_OK) {
-		g_warning ("rygel-media-db.vala:230: Failed to open database: %d, %s", rc, sqlite3_errmsg (self->priv->db));
-		_g_free0 (dirname);
-		_g_free0 (db_file);
-		return;
-	}
-	schema_info = (schema_info_length1 = 0, NULL);
-	rc = sqlite3_get_table (self->priv->db, "SELECT version FROM Schema_Info;", &schema_info, &nrows, &ncolumns, NULL);
-	if (rc == SQLITE_OK) {
-		gboolean _tmp5_ = FALSE;
-		if (nrows == 1) {
-			_tmp5_ = ncolumns == 1;
-		} else {
-			_tmp5_ = FALSE;
-		}
-		if (_tmp5_) {
-			if (_vala_strcmp0 (schema_info[1], RYGEL_MEDIA_DB_schema_version) == 0) {
-				g_debug ("rygel-media-db.vala:249: Media DB schema has current version");
-			} else {
-				gint old_version;
-				gint current_version;
-				old_version = atoi (schema_info[1]);
-				current_version = atoi (RYGEL_MEDIA_DB_schema_version);
-				if (old_version < current_version) {
-					g_debug ("rygel-media-db.vala:254: Older schema detected. Upgrading...");
-					switch (old_version) {
-						case 3:
-						{
-							rygel_media_db_update_v3_v4 (self);
-							break;
-						}
-						default:
-						{
-							sqlite3* _tmp6_;
-							g_warning ("rygel-media-db.vala:260: Cannot upgrade");
-							self->priv->db = (_tmp6_ = NULL, _sqlite3_close0 (self->priv->db), _tmp6_);
-							break;
-						}
-					}
-				} else {
-					sqlite3* _tmp7_;
-					g_warning ("The version \"%d\" of the detected database" " is newer than our supported version \"%d\"", old_version, current_version);
-					self->priv->db = (_tmp7_ = NULL, _sqlite3_close0 (self->priv->db), _tmp7_);
-				}
-			}
-		} else {
-			sqlite3* _tmp8_;
-			g_warning ("rygel-media-db.vala:272: Incompatible schema... cannot proceed");
-			self->priv->db = (_tmp8_ = NULL, _sqlite3_close0 (self->priv->db), _tmp8_);
-			_g_free0 (dirname);
-			_g_free0 (db_file);
-			return;
-		}
-	} else {
-		g_debug ("rygel-media-db.vala:277: Could not find schema version; checking for empty database...");
-		rc = sqlite3_get_table (self->priv->db, "SELECT * FROM sqlite_master", &schema_info, &nrows, &ncolumns, NULL);
-		if (rc != SQLITE_OK) {
-			sqlite3* _tmp9_;
-			g_warning ("rygel-media-db.vala:284: Something weird going on: %s", sqlite3_errmsg (self->priv->db));
-			self->priv->db = (_tmp9_ = NULL, _sqlite3_close0 (self->priv->db), _tmp9_);
-			_g_free0 (dirname);
-			_g_free0 (db_file);
-			return;
-		}
-		if (nrows == 0) {
-			g_debug ("rygel-media-db.vala:291: Empty database, creating new schema version %s", RYGEL_MEDIA_DB_schema_version);
-			if (!rygel_media_db_create_schema (self)) {
-				sqlite3* _tmp10_;
-				self->priv->db = (_tmp10_ = NULL, _sqlite3_close0 (self->priv->db), _tmp10_);
-				_g_free0 (dirname);
-				_g_free0 (db_file);
-				return;
-			}
-		} else {
-			sqlite3* _tmp11_;
-			g_warning ("rygel-media-db.vala:298: Incompatible schema... cannot proceed");
-			self->priv->db = (_tmp11_ = NULL, _sqlite3_close0 (self->priv->db), _tmp11_);
-			_g_free0 (dirname);
-			_g_free0 (db_file);
-			return;
-		}
-	}
-	_g_free0 (dirname);
-	_g_free0 (db_file);
-}
-
-
-static gpointer _g_object_ref0 (gpointer self) {
-	return self ? g_object_ref (self) : NULL;
-}
-
-
-static RygelMediaDB* rygel_media_db_construct (GType object_type, const char* name, RygelMediaDBObjectFactory* factory) {
-	RygelMediaDB * self;
-	RygelMediaDBObjectFactory* _tmp0_;
-	g_return_val_if_fail (name != NULL, NULL);
-	g_return_val_if_fail (factory != NULL, NULL);
-	self = (RygelMediaDB*) g_object_new (object_type, NULL);
-	rygel_media_db_open_db (self, name);
-	self->priv->factory = (_tmp0_ = _g_object_ref0 (factory), _g_object_unref0 (self->priv->factory), _tmp0_);
-	return self;
-}
-
-
-static RygelMediaDB* rygel_media_db_new (const char* name, RygelMediaDBObjectFactory* factory) {
-	return rygel_media_db_construct (RYGEL_TYPE_MEDIA_DB, name, factory);
-}
-
-
-RygelMediaDB* rygel_media_db_create (const char* name, GError** error) {
-	RygelMediaDB* result;
-	GError * _inner_error_;
-	RygelMediaDBObjectFactory* _tmp0_;
-	RygelMediaDB* _tmp1_;
-	RygelMediaDB* instance;
-	g_return_val_if_fail (name != NULL, NULL);
-	_inner_error_ = NULL;
-	instance = (_tmp1_ = rygel_media_db_new (name, _tmp0_ = rygel_media_db_object_factory_new ()), _g_object_unref0 (_tmp0_), _tmp1_);
-	if (instance->priv->db != NULL) {
-		result = instance;
-		return result;
-	}
-	_inner_error_ = g_error_new_literal (RYGEL_MEDIA_DB_ERROR, RYGEL_MEDIA_DB_ERROR_GENERAL_ERROR, "Invalid database");
-	if (_inner_error_ != NULL) {
-		if (_inner_error_->domain == RYGEL_MEDIA_DB_ERROR) {
-			g_propagate_error (error, _inner_error_);
-			_g_object_unref0 (instance);
-			return NULL;
-		} else {
-			_g_object_unref0 (instance);
-			g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
-			g_clear_error (&_inner_error_);
-			return NULL;
-		}
-	}
-	_g_object_unref0 (instance);
-}
-
-
-RygelMediaDB* rygel_media_db_create_with_factory (const char* name, RygelMediaDBObjectFactory* factory, GError** error) {
-	RygelMediaDB* result;
-	GError * _inner_error_;
-	RygelMediaDB* instance;
-	g_return_val_if_fail (name != NULL, NULL);
-	g_return_val_if_fail (factory != NULL, NULL);
-	_inner_error_ = NULL;
-	instance = rygel_media_db_new (name, factory);
-	if (instance->priv->db != NULL) {
-		result = instance;
-		return result;
-	}
-	_inner_error_ = g_error_new_literal (RYGEL_MEDIA_DB_ERROR, RYGEL_MEDIA_DB_ERROR_GENERAL_ERROR, "Invalid database");
-	if (_inner_error_ != NULL) {
-		if (_inner_error_->domain == RYGEL_MEDIA_DB_ERROR) {
-			g_propagate_error (error, _inner_error_);
-			_g_object_unref0 (instance);
-			return NULL;
-		} else {
-			_g_object_unref0 (instance);
-			g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
-			g_clear_error (&_inner_error_);
-			return NULL;
-		}
-	}
-	_g_object_unref0 (instance);
-}
-
-
-static gboolean rygel_media_db_sweeper (RygelMediaDB* self) {
-	gboolean result;
-	gint rc;
-	g_return_val_if_fail (self != NULL, FALSE);
-	g_debug ("rygel-media-db.vala:331: Running sweeper");
-	rc = sqlite3_exec (self->priv->db, RYGEL_MEDIA_DB_SWEEPER_STRING, NULL, NULL, NULL);
-	if (rc != SQLITE_OK) {
-		g_warning ("rygel-media-db.vala:334: Failed to sweep database");
-		result = FALSE;
-		return result;
-	} else {
-		gint changes;
-		changes = sqlite3_changes (self->priv->db);
-		g_debug ("rygel-media-db.vala:341: Changes in sweeper: %d", changes);
-		result = changes != 0;
-		return result;
-	}
-}
-
-
-static gboolean _rygel_media_db_sweeper_gsource_func (gpointer self) {
-	return rygel_media_db_sweeper (self);
-}
-
-
-void rygel_media_db_remove_by_id (RygelMediaDB* self, const char* id, GError** error) {
-	GError * _inner_error_;
-	sqlite3_stmt* statement;
-	sqlite3_stmt* _tmp2_;
-	gint _tmp1_;
-	sqlite3_stmt* _tmp0_ = NULL;
-	gint rc;
-	g_return_if_fail (self != NULL);
-	g_return_if_fail (id != NULL);
-	_inner_error_ = NULL;
-	statement = NULL;
-	rc = (_tmp1_ = sqlite3_prepare_v2 (self->priv->db, "DELETE FROM Object WHERE upnp_id = ?", -1, &_tmp0_, NULL), statement = (_tmp2_ = _tmp0_, _sqlite3_finalize0 (statement), _tmp2_), _tmp1_);
-	if (rc == SQLITE_OK) {
-		gboolean _tmp3_ = FALSE;
-		if (sqlite3_bind_text (statement, 1, g_strdup (id), -1, g_free) != SQLITE_OK) {
-			_inner_error_ = g_error_new_literal (RYGEL_MEDIA_DB_ERROR, RYGEL_MEDIA_DB_ERROR_SQLITE_ERROR, sqlite3_errmsg (self->priv->db));
-			if (_inner_error_ != NULL) {
-				if (_inner_error_->domain == RYGEL_MEDIA_DB_ERROR) {
-					g_propagate_error (error, _inner_error_);
-					_sqlite3_finalize0 (statement);
-					return;
-				} else {
-					_sqlite3_finalize0 (statement);
-					g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
-					g_clear_error (&_inner_error_);
-					return;
-				}
-			}
-		}
-		rc = sqlite3_step (statement);
-		if (rc == SQLITE_DONE) {
-			_tmp3_ = TRUE;
-		} else {
-			_tmp3_ = rc == SQLITE_OK;
-		}
-		if (_tmp3_) {
-			g_signal_emit_by_name (self, "object-removed", id);
-			g_idle_add_full (G_PRIORITY_DEFAULT_IDLE, _rygel_media_db_sweeper_gsource_func, g_object_ref (self), g_object_unref);
-		}
-	} else {
-		g_warning ("rygel-media-db.vala:375: Failed to prepare delete of object %s: %s", id, sqlite3_errmsg (self->priv->db));
-		_inner_error_ = g_error_new_literal (RYGEL_MEDIA_DB_ERROR, RYGEL_MEDIA_DB_ERROR_SQLITE_ERROR, sqlite3_errmsg (self->priv->db));
-		if (_inner_error_ != NULL) {
-			if (_inner_error_->domain == RYGEL_MEDIA_DB_ERROR) {
-				g_propagate_error (error, _inner_error_);
-				_sqlite3_finalize0 (statement);
-				return;
-			} else {
-				_sqlite3_finalize0 (statement);
-				g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
-				g_clear_error (&_inner_error_);
-				return;
-			}
-		}
-	}
-	_sqlite3_finalize0 (statement);
-}
-
-
-void rygel_media_db_remove_object (RygelMediaDB* self, RygelMediaObject* obj, GError** error) {
-	GError * _inner_error_;
-	g_return_if_fail (self != NULL);
-	g_return_if_fail (obj != NULL);
-	_inner_error_ = NULL;
-	rygel_media_db_remove_by_id (self, obj->id, &_inner_error_);
-	if (_inner_error_ != NULL) {
-		if (_inner_error_->domain == RYGEL_MEDIA_DB_ERROR) {
-			g_propagate_error (error, _inner_error_);
-			return;
-		} else {
-			g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
-			g_clear_error (&_inner_error_);
-			return;
-		}
-	}
-	if (RYGEL_IS_MEDIA_ITEM (obj)) {
-		g_signal_emit_by_name (self, "item-removed", obj->id);
-	} else {
-		if (RYGEL_IS_MEDIA_CONTAINER (obj)) {
-			g_signal_emit_by_name (self, "container-removed", obj->id);
-		} else {
-			_inner_error_ = g_error_new_literal (RYGEL_MEDIA_DB_ERROR, RYGEL_MEDIA_DB_ERROR_INVALID_TYPE, "Invalid object type");
-			if (_inner_error_ != NULL) {
-				if (_inner_error_->domain == RYGEL_MEDIA_DB_ERROR) {
-					g_propagate_error (error, _inner_error_);
-					return;
-				} else {
-					g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
-					g_clear_error (&_inner_error_);
-					return;
-				}
-			}
-		}
-	}
-}
-
-
-void rygel_media_db_save_object (RygelMediaDB* self, RygelMediaObject* obj, GError** error) {
-	GError * _inner_error_;
-	g_return_if_fail (self != NULL);
-	g_return_if_fail (obj != NULL);
-	_inner_error_ = NULL;
-	if (RYGEL_IS_MEDIA_ITEM (obj)) {
-		rygel_media_db_save_item (self, RYGEL_MEDIA_ITEM (obj), &_inner_error_);
-		if (_inner_error_ != NULL) {
-			g_propagate_error (error, _inner_error_);
-			return;
-		}
-	} else {
-		if (RYGEL_IS_MEDIA_CONTAINER (obj)) {
-			rygel_media_db_save_container (self, RYGEL_MEDIA_CONTAINER (obj), &_inner_error_);
-			if (_inner_error_ != NULL) {
-				g_propagate_error (error, _inner_error_);
-				return;
-			}
-		} else {
-			_inner_error_ = g_error_new_literal (RYGEL_MEDIA_DB_ERROR, RYGEL_MEDIA_DB_ERROR_INVALID_TYPE, "Invalid object type");
-			if (_inner_error_ != NULL) {
-				g_propagate_error (error, _inner_error_);
-				return;
-			}
-		}
-	}
-}
-
-
-static gpointer _g_error_copy0 (gpointer self) {
-	return self ? g_error_copy (self) : NULL;
-}
-
-
-void rygel_media_db_save_container (RygelMediaDB* self, RygelMediaContainer* container, GError** error) {
-	GError * _inner_error_;
-	gint rc;
-	g_return_if_fail (self != NULL);
-	g_return_if_fail (container != NULL);
-	_inner_error_ = NULL;
-	rc = sqlite3_exec (self->priv->db, "BEGIN", NULL, NULL, NULL);
-	{
-		rygel_media_db_create_object (self, (RygelMediaObject*) container, &_inner_error_);
-		if (_inner_error_ != NULL) {
-			goto __catch39_g_error;
-			goto __finally39;
-		}
-		rygel_media_db_save_uris (self, (RygelMediaObject*) container, &_inner_error_);
-		if (_inner_error_ != NULL) {
-			goto __catch39_g_error;
-			goto __finally39;
-		}
-		rc = sqlite3_exec (self->priv->db, "COMMIT", NULL, NULL, NULL);
-		if (rc == SQLITE_OK) {
-			g_signal_emit_by_name (self, "object-added", ((RygelMediaObject*) container)->id);
-			g_signal_emit_by_name (self, "container-added", ((RygelMediaObject*) container)->id);
-		}
-	}
-	goto __finally39;
-	__catch39_g_error:
-	{
-		GError * _error_;
-		_error_ = _inner_error_;
-		_inner_error_ = NULL;
-		{
-			rc = sqlite3_exec (self->priv->db, "ROLLBACK", NULL, NULL, NULL);
-			_inner_error_ = _g_error_copy0 (_error_);
-			if (_inner_error_ != NULL) {
-				_g_error_free0 (_error_);
-				goto __finally39;
-			}
-			_g_error_free0 (_error_);
-		}
-	}
-	__finally39:
-	if (_inner_error_ != NULL) {
-		g_propagate_error (error, _inner_error_);
-		return;
-	}
-}
-
-
-void rygel_media_db_save_item (RygelMediaDB* self, RygelMediaItem* item, GError** error) {
-	GError * _inner_error_;
-	gint rc;
-	g_return_if_fail (self != NULL);
-	g_return_if_fail (item != NULL);
-	_inner_error_ = NULL;
-	rc = sqlite3_exec (self->priv->db, "BEGIN;", NULL, NULL, NULL);
-	{
-		rygel_media_db_save_metadata (self, item, RYGEL_MEDIA_DB_INSERT_META_DATA_STRING, &_inner_error_);
-		if (_inner_error_ != NULL) {
-			goto __catch40_g_error;
-			goto __finally40;
-		}
-		rygel_media_db_create_object (self, (RygelMediaObject*) item, &_inner_error_);
-		if (_inner_error_ != NULL) {
-			goto __catch40_g_error;
-			goto __finally40;
-		}
-		rygel_media_db_save_uris (self, (RygelMediaObject*) item, &_inner_error_);
-		if (_inner_error_ != NULL) {
-			goto __catch40_g_error;
-			goto __finally40;
-		}
-		rc = sqlite3_exec (self->priv->db, "COMMIT;", NULL, NULL, NULL);
-		if (rc == SQLITE_OK) {
-			g_signal_emit_by_name (self, "object-added", ((RygelMediaObject*) item)->id);
-			g_signal_emit_by_name (self, "item-added", ((RygelMediaObject*) item)->id);
-		}
-	}
-	goto __finally40;
-	__catch40_g_error:
-	{
-		GError * _error_;
-		_error_ = _inner_error_;
-		_inner_error_ = NULL;
-		{
-			g_warning ("rygel-media-db.vala:431: Failed to add item with id %s: %s", ((RygelMediaObject*) item)->id, _error_->message);
-			rc = sqlite3_exec (self->priv->db, "ROLLBACK;", NULL, NULL, NULL);
-			_inner_error_ = _g_error_copy0 (_error_);
-			if (_inner_error_ != NULL) {
-				_g_error_free0 (_error_);
-				goto __finally40;
-			}
-			_g_error_free0 (_error_);
-		}
-	}
-	__finally40:
-	if (_inner_error_ != NULL) {
-		g_propagate_error (error, _inner_error_);
-		return;
-	}
-}
-
-
-void rygel_media_db_update_object (RygelMediaDB* self, RygelMediaObject* obj, GError** error) {
-	GError * _inner_error_;
-	gint rc;
-	g_return_if_fail (self != NULL);
-	g_return_if_fail (obj != NULL);
-	_inner_error_ = NULL;
-	rc = sqlite3_exec (self->priv->db, "BEGIN", NULL, NULL, NULL);
-	{
-		rygel_media_db_remove_uris (self, obj, &_inner_error_);
-		if (_inner_error_ != NULL) {
-			goto __catch41_g_error;
-			goto __finally41;
-		}
-		if (RYGEL_IS_MEDIA_ITEM (obj)) {
-			rygel_media_db_save_metadata (self, RYGEL_MEDIA_ITEM (obj), RYGEL_MEDIA_DB_UPDATE_META_DATA_STRING, &_inner_error_);
-			if (_inner_error_ != NULL) {
-				goto __catch41_g_error;
-				goto __finally41;
-			}
-		}
-		rygel_media_db_update_object_internal (self, obj, &_inner_error_);
-		if (_inner_error_ != NULL) {
-			goto __catch41_g_error;
-			goto __finally41;
-		}
-		rygel_media_db_save_uris (self, obj, &_inner_error_);
-		if (_inner_error_ != NULL) {
-			goto __catch41_g_error;
-			goto __finally41;
-		}
-		rc = sqlite3_exec (self->priv->db, "COMMIT", NULL, NULL, NULL);
-		if (rc == SQLITE_OK) {
-			g_signal_emit_by_name (self, "object-updated", obj->id);
-			if (RYGEL_IS_MEDIA_ITEM (obj)) {
-				g_signal_emit_by_name (self, "item-updated", obj->id);
-			} else {
-				if (RYGEL_IS_MEDIA_CONTAINER (obj)) {
-					g_signal_emit_by_name (self, "container-updated", obj->id);
-				}
-			}
-		}
-	}
-	goto __finally41;
-	__catch41_g_error:
-	{
-		GError * _error_;
-		_error_ = _inner_error_;
-		_inner_error_ = NULL;
-		{
-			g_warning ("rygel-media-db.vala:458: Failed to add item with id %s: %s", obj->id, _error_->message);
-			rc = sqlite3_exec (self->priv->db, "ROLLBACK", NULL, NULL, NULL);
-			_inner_error_ = _g_error_copy0 (_error_);
-			if (_inner_error_ != NULL) {
-				_g_error_free0 (_error_);
-				goto __finally41;
-			}
-			_g_error_free0 (_error_);
-		}
-	}
-	__finally41:
-	if (_inner_error_ != NULL) {
-		g_propagate_error (error, _inner_error_);
-		return;
-	}
-}
-
-
-static void rygel_media_db_update_object_internal (RygelMediaDB* self, RygelMediaObject* obj, GError** error) {
-	GError * _inner_error_;
-	sqlite3_stmt* statement;
-	sqlite3_stmt* _tmp2_;
-	gint _tmp1_;
-	sqlite3_stmt* _tmp0_ = NULL;
-	gint rc;
-	g_return_if_fail (self != NULL);
-	g_return_if_fail (obj != NULL);
-	_inner_error_ = NULL;
-	statement = NULL;
-	rc = (_tmp1_ = sqlite3_prepare_v2 (self->priv->db, RYGEL_MEDIA_DB_UPDATE_OBJECT_STRING, -1, &_tmp0_, NULL), statement = (_tmp2_ = _tmp0_, _sqlite3_finalize0 (statement), _tmp2_), _tmp1_);
-	if (rc == SQLITE_OK) {
-		gboolean _tmp3_ = FALSE;
-		gboolean _tmp4_ = FALSE;
-		gboolean _tmp5_ = FALSE;
-		if (sqlite3_bind_text (statement, 1, g_strdup (obj->title), -1, g_free) != SQLITE_OK) {
-			_tmp4_ = TRUE;
-		} else {
-			_tmp4_ = sqlite3_bind_int64 (statement, 2, (gint64) obj->modified) != SQLITE_OK;
-		}
-		if (_tmp4_) {
-			_tmp3_ = TRUE;
-		} else {
-			_tmp3_ = sqlite3_bind_text (statement, 3, g_strdup (obj->id), -1, g_free) != SQLITE_OK;
-		}
-		if (_tmp3_) {
-			_inner_error_ = g_error_new_literal (RYGEL_MEDIA_DB_ERROR, RYGEL_MEDIA_DB_ERROR_SQLITE_ERROR, sqlite3_errmsg (self->priv->db));
-			if (_inner_error_ != NULL) {
-				g_propagate_error (error, _inner_error_);
-				_sqlite3_finalize0 (statement);
-				return;
-			}
-		}
-		rc = sqlite3_step (statement);
-		if (rc != SQLITE_DONE) {
-			_tmp5_ = rc != SQLITE_OK;
-		} else {
-			_tmp5_ = FALSE;
-		}
-		if (_tmp5_) {
-			_inner_error_ = g_error_new_literal (RYGEL_MEDIA_DB_ERROR, RYGEL_MEDIA_DB_ERROR_SQLITE_ERROR, sqlite3_errmsg (self->priv->db));
-			if (_inner_error_ != NULL) {
-				g_propagate_error (error, _inner_error_);
-				_sqlite3_finalize0 (statement);
-				return;
-			}
-		}
-	} else {
-		_inner_error_ = g_error_new_literal (RYGEL_MEDIA_DB_ERROR, RYGEL_MEDIA_DB_ERROR_SQLITE_ERROR, sqlite3_errmsg (self->priv->db));
-		if (_inner_error_ != NULL) {
-			g_propagate_error (error, _inner_error_);
-			_sqlite3_finalize0 (statement);
-			return;
-		}
-	}
-	_sqlite3_finalize0 (statement);
-}
-
-
-static void rygel_media_db_remove_uris (RygelMediaDB* self, RygelMediaObject* obj, GError** error) {
-	GError * _inner_error_;
-	sqlite3_stmt* statement;
-	sqlite3_stmt* _tmp2_;
-	gint _tmp1_;
-	sqlite3_stmt* _tmp0_ = NULL;
-	gint rc;
-	g_return_if_fail (self != NULL);
-	g_return_if_fail (obj != NULL);
-	_inner_error_ = NULL;
-	statement = NULL;
-	rc = (_tmp1_ = sqlite3_prepare_v2 (self->priv->db, RYGEL_MEDIA_DB_DELETE_URI_STRING, -1, &_tmp0_, NULL), statement = (_tmp2_ = _tmp0_, _sqlite3_finalize0 (statement), _tmp2_), _tmp1_);
-	if (rc == SQLITE_OK) {
-		gboolean _tmp3_ = FALSE;
-		if (sqlite3_bind_text (statement, 1, g_strdup (obj->id), -1, g_free) != SQLITE_OK) {
-			_inner_error_ = g_error_new_literal (RYGEL_MEDIA_DB_ERROR, RYGEL_MEDIA_DB_ERROR_SQLITE_ERROR, sqlite3_errmsg (self->priv->db));
-			if (_inner_error_ != NULL) {
-				g_propagate_error (error, _inner_error_);
-				_sqlite3_finalize0 (statement);
-				return;
-			}
-		}
-		rc = sqlite3_step (statement);
-		if (rc != SQLITE_DONE) {
-			_tmp3_ = rc != SQLITE_OK;
-		} else {
-			_tmp3_ = FALSE;
-		}
-		if (_tmp3_) {
-			_inner_error_ = g_error_new_literal (RYGEL_MEDIA_DB_ERROR, RYGEL_MEDIA_DB_ERROR_SQLITE_ERROR, sqlite3_errmsg (self->priv->db));
-			if (_inner_error_ != NULL) {
-				g_propagate_error (error, _inner_error_);
-				_sqlite3_finalize0 (statement);
-				return;
-			}
-		}
-	} else {
-		_inner_error_ = g_error_new_literal (RYGEL_MEDIA_DB_ERROR, RYGEL_MEDIA_DB_ERROR_SQLITE_ERROR, sqlite3_errmsg (self->priv->db));
-		if (_inner_error_ != NULL) {
-			g_propagate_error (error, _inner_error_);
-			_sqlite3_finalize0 (statement);
-			return;
-		}
-	}
-	_sqlite3_finalize0 (statement);
-}
-
-
-static void rygel_media_db_save_metadata (RygelMediaDB* self, RygelMediaItem* item, const char* sql, GError** error) {
-	GError * _inner_error_;
-	sqlite3_stmt* statement;
-	sqlite3_stmt* _tmp2_;
-	gint _tmp1_;
-	sqlite3_stmt* _tmp0_ = NULL;
-	gint rc;
-	g_return_if_fail (self != NULL);
-	g_return_if_fail (item != NULL);
-	g_return_if_fail (sql != NULL);
-	_inner_error_ = NULL;
-	statement = NULL;
-	rc = (_tmp1_ = sqlite3_prepare_v2 (self->priv->db, sql, -1, &_tmp0_, NULL), statement = (_tmp2_ = _tmp0_, _sqlite3_finalize0 (statement), _tmp2_), _tmp1_);
-	if (rc == SQLITE_OK) {
-		gboolean _tmp3_ = FALSE;
-		gboolean _tmp4_ = FALSE;
-		gboolean _tmp5_ = FALSE;
-		gboolean _tmp6_ = FALSE;
-		gboolean _tmp7_ = FALSE;
-		gboolean _tmp8_ = FALSE;
-		gboolean _tmp9_ = FALSE;
-		gboolean _tmp10_ = FALSE;
-		gboolean _tmp11_ = FALSE;
-		gboolean _tmp12_ = FALSE;
-		gboolean _tmp13_ = FALSE;
-		gboolean _tmp14_ = FALSE;
-		gboolean _tmp15_ = FALSE;
-		gboolean _tmp16_ = FALSE;
-		gboolean _tmp17_ = FALSE;
-		gboolean _tmp18_ = FALSE;
-		if (sqlite3_bind_int64 (statement, 1, (gint64) item->size) != SQLITE_OK) {
-			_tmp17_ = TRUE;
-		} else {
-			_tmp17_ = sqlite3_bind_text (statement, 2, g_strdup (item->mime_type), -1, g_free) != SQLITE_OK;
-		}
-		if (_tmp17_) {
-			_tmp16_ = TRUE;
-		} else {
-			_tmp16_ = sqlite3_bind_int (statement, 3, item->width) != SQLITE_OK;
-		}
-		if (_tmp16_) {
-			_tmp15_ = TRUE;
-		} else {
-			_tmp15_ = sqlite3_bind_int (statement, 4, item->height) != SQLITE_OK;
-		}
-		if (_tmp15_) {
-			_tmp14_ = TRUE;
-		} else {
-			_tmp14_ = sqlite3_bind_text (statement, 5, g_strdup (item->upnp_class), -1, g_free) != SQLITE_OK;
-		}
-		if (_tmp14_) {
-			_tmp13_ = TRUE;
-		} else {
-			_tmp13_ = sqlite3_bind_text (statement, 6, g_strdup (item->author), -1, g_free) != SQLITE_OK;
-		}
-		if (_tmp13_) {
-			_tmp12_ = TRUE;
-		} else {
-			_tmp12_ = sqlite3_bind_text (statement, 7, g_strdup (item->album), -1, g_free) != SQLITE_OK;
-		}
-		if (_tmp12_) {
-			_tmp11_ = TRUE;
-		} else {
-			_tmp11_ = sqlite3_bind_text (statement, 8, g_strdup (item->date), -1, g_free) != SQLITE_OK;
-		}
-		if (_tmp11_) {
-			_tmp10_ = TRUE;
-		} else {
-			_tmp10_ = sqlite3_bind_int (statement, 9, item->bitrate) != SQLITE_OK;
-		}
-		if (_tmp10_) {
-			_tmp9_ = TRUE;
-		} else {
-			_tmp9_ = sqlite3_bind_int (statement, 10, item->sample_freq) != SQLITE_OK;
-		}
-		if (_tmp9_) {
-			_tmp8_ = TRUE;
-		} else {
-			_tmp8_ = sqlite3_bind_int (statement, 11, item->bits_per_sample) != SQLITE_OK;
-		}
-		if (_tmp8_) {
-			_tmp7_ = TRUE;
-		} else {
-			_tmp7_ = sqlite3_bind_int (statement, 12, item->n_audio_channels) != SQLITE_OK;
-		}
-		if (_tmp7_) {
-			_tmp6_ = TRUE;
-		} else {
-			_tmp6_ = sqlite3_bind_int (statement, 13, item->track_number) != SQLITE_OK;
-		}
-		if (_tmp6_) {
-			_tmp5_ = TRUE;
-		} else {
-			_tmp5_ = sqlite3_bind_int (statement, 14, item->color_depth) != SQLITE_OK;
-		}
-		if (_tmp5_) {
-			_tmp4_ = TRUE;
-		} else {
-			_tmp4_ = sqlite3_bind_int64 (statement, 15, (gint64) item->duration) != SQLITE_OK;
-		}
-		if (_tmp4_) {
-			_tmp3_ = TRUE;
-		} else {
-			_tmp3_ = sqlite3_bind_text (statement, 16, g_strdup (((RygelMediaObject*) item)->id), -1, g_free) != SQLITE_OK;
-		}
-		if (_tmp3_) {
-			_inner_error_ = g_error_new_literal (RYGEL_MEDIA_DB_ERROR, RYGEL_MEDIA_DB_ERROR_SQLITE_ERROR, sqlite3_errmsg (self->priv->db));
-			if (_inner_error_ != NULL) {
-				g_propagate_error (error, _inner_error_);
-				_sqlite3_finalize0 (statement);
-				return;
-			}
-		}
-		rc = sqlite3_step (statement);
-		if (rc != SQLITE_DONE) {
-			_tmp18_ = rc != SQLITE_OK;
-		} else {
-			_tmp18_ = FALSE;
-		}
-		if (_tmp18_) {
-			_inner_error_ = g_error_new_literal (RYGEL_MEDIA_DB_ERROR, RYGEL_MEDIA_DB_ERROR_SQLITE_ERROR, sqlite3_errmsg (self->priv->db));
-			if (_inner_error_ != NULL) {
-				g_propagate_error (error, _inner_error_);
-				_sqlite3_finalize0 (statement);
-				return;
-			}
-		}
-	} else {
-		_inner_error_ = g_error_new_literal (RYGEL_MEDIA_DB_ERROR, RYGEL_MEDIA_DB_ERROR_SQLITE_ERROR, sqlite3_errmsg (self->priv->db));
-		if (_inner_error_ != NULL) {
-			g_propagate_error (error, _inner_error_);
-			_sqlite3_finalize0 (statement);
-			return;
-		}
-	}
-	_sqlite3_finalize0 (statement);
-}
-
-
-static void rygel_media_db_create_object (RygelMediaDB* self, RygelMediaObject* item, GError** error) {
-	GError * _inner_error_;
-	sqlite3_stmt* statement;
-	sqlite3_stmt* _tmp2_;
-	gint _tmp1_;
-	sqlite3_stmt* _tmp0_ = NULL;
-	gint rc;
-	g_return_if_fail (self != NULL);
-	g_return_if_fail (item != NULL);
-	_inner_error_ = NULL;
-	statement = NULL;
-	rc = (_tmp1_ = sqlite3_prepare_v2 (self->priv->db, RYGEL_MEDIA_DB_INSERT_OBJECT_STRING, -1, &_tmp0_, NULL), statement = (_tmp2_ = _tmp0_, _sqlite3_finalize0 (statement), _tmp2_), _tmp1_);
-	if (rc == SQLITE_OK) {
-		gboolean _tmp3_ = FALSE;
-		gboolean _tmp4_ = FALSE;
-		gboolean _tmp5_ = FALSE;
-		if (sqlite3_bind_text (statement, 1, g_strdup (item->id), -1, g_free) != SQLITE_OK) {
-			_tmp4_ = TRUE;
-		} else {
-			_tmp4_ = sqlite3_bind_int64 (statement, 5, (gint64) item->modified) != SQLITE_OK;
-		}
-		if (_tmp4_) {
-			_tmp3_ = TRUE;
-		} else {
-			_tmp3_ = sqlite3_bind_text (statement, 2, g_strdup (item->title), -1, g_free) != SQLITE_OK;
-		}
-		if (_tmp3_) {
-			_inner_error_ = g_error_new_literal (RYGEL_MEDIA_DB_ERROR, RYGEL_MEDIA_DB_ERROR_SQLITE_ERROR, sqlite3_errmsg (self->priv->db));
-			if (_inner_error_ != NULL) {
-				g_propagate_error (error, _inner_error_);
-				_sqlite3_finalize0 (statement);
-				return;
-			}
-		}
-		if (RYGEL_IS_MEDIA_ITEM (item)) {
-			rc = sqlite3_bind_int (statement, 3, (gint) RYGEL_MEDIA_DB_OBJECT_TYPE_ITEM);
-		} else {
-			if (RYGEL_IS_MEDIA_OBJECT (item)) {
-				rc = sqlite3_bind_int (statement, 3, (gint) RYGEL_MEDIA_DB_OBJECT_TYPE_CONTAINER);
-			} else {
-				_inner_error_ = g_error_new_literal (RYGEL_MEDIA_DB_ERROR, RYGEL_MEDIA_DB_ERROR_INVALID_TYPE, "Invalid object type");
-				if (_inner_error_ != NULL) {
-					g_propagate_error (error, _inner_error_);
-					_sqlite3_finalize0 (statement);
-					return;
-				}
-			}
-		}
-		if (rc != SQLITE_OK) {
-			_inner_error_ = g_error_new_literal (RYGEL_MEDIA_DB_ERROR, RYGEL_MEDIA_DB_ERROR_SQLITE_ERROR, sqlite3_errmsg (self->priv->db));
-			if (_inner_error_ != NULL) {
-				g_propagate_error (error, _inner_error_);
-				_sqlite3_finalize0 (statement);
-				return;
-			}
-		}
-		if (item->parent == NULL) {
-			rc = sqlite3_bind_null (statement, 4);
-		} else {
-			rc = sqlite3_bind_text (statement, 4, g_strdup (((RygelMediaObject*) item->parent)->id), -1, g_free);
-		}
-		if (rc != SQLITE_OK) {
-			_inner_error_ = g_error_new_literal (RYGEL_MEDIA_DB_ERROR, RYGEL_MEDIA_DB_ERROR_SQLITE_ERROR, sqlite3_errmsg (self->priv->db));
-			if (_inner_error_ != NULL) {
-				g_propagate_error (error, _inner_error_);
-				_sqlite3_finalize0 (statement);
-				return;
-			}
-		}
-		rc = sqlite3_step (statement);
-		if (rc != SQLITE_OK) {
-			_tmp5_ = rc != SQLITE_DONE;
-		} else {
-			_tmp5_ = FALSE;
-		}
-		if (_tmp5_) {
-			_inner_error_ = g_error_new_literal (RYGEL_MEDIA_DB_ERROR, RYGEL_MEDIA_DB_ERROR_SQLITE_ERROR, sqlite3_errmsg (self->priv->db));
-			if (_inner_error_ != NULL) {
-				g_propagate_error (error, _inner_error_);
-				_sqlite3_finalize0 (statement);
-				return;
-			}
-		}
-	} else {
-		_inner_error_ = g_error_new_literal (RYGEL_MEDIA_DB_ERROR, RYGEL_MEDIA_DB_ERROR_SQLITE_ERROR, sqlite3_errmsg (self->priv->db));
-		if (_inner_error_ != NULL) {
-			g_propagate_error (error, _inner_error_);
-			_sqlite3_finalize0 (statement);
-			return;
-		}
-	}
-	_sqlite3_finalize0 (statement);
-}
-
-
-static void rygel_media_db_save_uris (RygelMediaDB* self, RygelMediaObject* obj, GError** error) {
-	GError * _inner_error_;
-	sqlite3_stmt* statement;
-	sqlite3_stmt* _tmp2_;
-	gint _tmp1_;
-	sqlite3_stmt* _tmp0_ = NULL;
-	gint rc;
-	g_return_if_fail (self != NULL);
-	g_return_if_fail (obj != NULL);
-	_inner_error_ = NULL;
-	statement = NULL;
-	rc = (_tmp1_ = sqlite3_prepare_v2 (self->priv->db, RYGEL_MEDIA_DB_INSERT_URI_STRING, -1, &_tmp0_, NULL), statement = (_tmp2_ = _tmp0_, _sqlite3_finalize0 (statement), _tmp2_), _tmp1_);
-	if (rc == SQLITE_OK) {
-		{
-			GeeIterator* _uri_it;
-			_uri_it = gee_abstract_collection_iterator ((GeeAbstractCollection*) obj->uris);
-			while (TRUE) {
-				char* uri;
-				gboolean _tmp3_ = FALSE;
-				gboolean _tmp4_ = FALSE;
-				if (!gee_iterator_next (_uri_it)) {
-					break;
-				}
-				uri = (char*) gee_iterator_get (_uri_it);
-				if (sqlite3_bind_text (statement, 1, g_strdup (obj->id), -1, g_free) != SQLITE_OK) {
-					_tmp3_ = TRUE;
-				} else {
-					_tmp3_ = sqlite3_bind_text (statement, 2, g_strdup (uri), -1, g_free) != SQLITE_OK;
-				}
-				if (_tmp3_) {
-					_inner_error_ = g_error_new_literal (RYGEL_MEDIA_DB_ERROR, RYGEL_MEDIA_DB_ERROR_SQLITE_ERROR, sqlite3_errmsg (self->priv->db));
-					if (_inner_error_ != NULL) {
-						g_propagate_error (error, _inner_error_);
-						_g_free0 (uri);
-						_g_object_unref0 (_uri_it);
-						_sqlite3_finalize0 (statement);
-						return;
-					}
-				}
-				rc = sqlite3_step (statement);
-				if (rc != SQLITE_OK) {
-					_tmp4_ = rc != SQLITE_DONE;
-				} else {
-					_tmp4_ = FALSE;
-				}
-				if (_tmp4_) {
-					_inner_error_ = g_error_new_literal (RYGEL_MEDIA_DB_ERROR, RYGEL_MEDIA_DB_ERROR_SQLITE_ERROR, sqlite3_errmsg (self->priv->db));
-					if (_inner_error_ != NULL) {
-						g_propagate_error (error, _inner_error_);
-						_g_free0 (uri);
-						_g_object_unref0 (_uri_it);
-						_sqlite3_finalize0 (statement);
-						return;
-					}
-				}
-				sqlite3_reset (statement);
-				sqlite3_clear_bindings (statement);
-				_g_free0 (uri);
-			}
-			_g_object_unref0 (_uri_it);
-		}
-	} else {
-		_inner_error_ = g_error_new_literal (RYGEL_MEDIA_DB_ERROR, RYGEL_MEDIA_DB_ERROR_SQLITE_ERROR, sqlite3_errmsg (self->priv->db));
-		if (_inner_error_ != NULL) {
-			g_propagate_error (error, _inner_error_);
-			_sqlite3_finalize0 (statement);
-			return;
-		}
-	}
-	_sqlite3_finalize0 (statement);
-}
-
-
-static gboolean rygel_media_db_create_schema (RygelMediaDB* self) {
-	gboolean result;
-	gint rc;
-	g_return_val_if_fail (self != NULL, FALSE);
-	rc = sqlite3_exec (self->priv->db, "BEGIN", NULL, NULL, NULL);
-	if (rc == SQLITE_OK) {
-		rc = sqlite3_exec (self->priv->db, RYGEL_MEDIA_DB_SCHEMA_STRING, NULL, NULL, NULL);
-		if (rc == SQLITE_OK) {
-			g_debug ("rygel-media-db.vala:625: succeeded in schema creation");
-			rc = sqlite3_exec (self->priv->db, RYGEL_MEDIA_DB_CREATE_TRIGGER_STRING, NULL, NULL, NULL);
-			if (rc == SQLITE_OK) {
-				g_debug ("rygel-media-db.vala:628: succeeded in trigger creation");
-				rc = sqlite3_exec (self->priv->db, "COMMIT", NULL, NULL, NULL);
-				if (rc == SQLITE_OK) {
-					result = TRUE;
-					return result;
-				} else {
-					g_warning ("rygel-media-db.vala:633: Failed to commit schema: %d %s", rc, sqlite3_errmsg (self->priv->db));
-				}
-			} else {
-				g_warning ("rygel-media-db.vala:638: Failed to create triggers: %d %s", rc, sqlite3_errmsg (self->priv->db));
-			}
-		} else {
-			g_warning ("rygel-media-db.vala:643: Failed to create tables: %d %s", rc, sqlite3_errmsg (self->priv->db));
-		}
-	} else {
-		g_warning ("rygel-media-db.vala:648: Failed to start transaction: %d %s", rc, sqlite3_errmsg (self->priv->db));
-	}
-	sqlite3_exec (self->priv->db, "ROLLBACK", NULL, NULL, NULL);
-	result = FALSE;
-	return result;
-}
-
-
-static void rygel_media_db_add_uris (RygelMediaDB* self, RygelMediaObject* obj, GError** error) {
-	GError * _inner_error_;
-	sqlite3_stmt* statement;
-	sqlite3_stmt* _tmp2_;
-	gint _tmp1_;
-	sqlite3_stmt* _tmp0_ = NULL;
-	gint rc;
-	g_return_if_fail (self != NULL);
-	g_return_if_fail (obj != NULL);
-	_inner_error_ = NULL;
-	statement = NULL;
-	rc = (_tmp1_ = sqlite3_prepare_v2 (self->priv->db, RYGEL_MEDIA_DB_URI_GET_STRING, -1, &_tmp0_, NULL), statement = (_tmp2_ = _tmp0_, _sqlite3_finalize0 (statement), _tmp2_), _tmp1_);
-	if (rc == SQLITE_OK) {
-		if (sqlite3_bind_text (statement, 1, g_strdup (obj->id), -1, g_free) != SQLITE_OK) {
-			_inner_error_ = g_error_new_literal (RYGEL_MEDIA_DB_ERROR, RYGEL_MEDIA_DB_ERROR_SQLITE_ERROR, sqlite3_errmsg (self->priv->db));
-			if (_inner_error_ != NULL) {
-				if (_inner_error_->domain == RYGEL_MEDIA_DB_ERROR) {
-					g_propagate_error (error, _inner_error_);
-					_sqlite3_finalize0 (statement);
-					return;
-				} else {
-					_sqlite3_finalize0 (statement);
-					g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
-					g_clear_error (&_inner_error_);
-					return;
-				}
-			}
-		}
-		while (TRUE) {
-			if (!((rc = sqlite3_step (statement)) == SQLITE_ROW)) {
-				break;
-			}
-			if (RYGEL_IS_MEDIA_ITEM (obj)) {
-				rygel_media_item_add_uri (RYGEL_MEDIA_ITEM (obj), sqlite3_column_text (statement, 0), NULL);
-			} else {
-				gee_abstract_collection_add ((GeeAbstractCollection*) obj->uris, sqlite3_column_text (statement, 0));
-			}
-		}
-	} else {
-		g_warning ("rygel-media-db.vala:677: Failed to get uris for obj %s: %s", obj->id, sqlite3_errmsg (self->priv->db));
-		_inner_error_ = g_error_new_literal (RYGEL_MEDIA_DB_ERROR, RYGEL_MEDIA_DB_ERROR_SQLITE_ERROR, sqlite3_errmsg (self->priv->db));
-		if (_inner_error_ != NULL) {
-			if (_inner_error_->domain == RYGEL_MEDIA_DB_ERROR) {
-				g_propagate_error (error, _inner_error_);
-				_sqlite3_finalize0 (statement);
-				return;
-			} else {
-				_sqlite3_finalize0 (statement);
-				g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
-				g_clear_error (&_inner_error_);
-				return;
-			}
-		}
-	}
-	_sqlite3_finalize0 (statement);
-}
-
-
-static RygelMediaObject* rygel_media_db_get_object_from_statement (RygelMediaDB* self, RygelMediaContainer* parent, const char* object_id, sqlite3_stmt* statement) {
-	RygelMediaObject* result;
-	GError * _inner_error_;
-	RygelMediaObject* obj;
-	g_return_val_if_fail (self != NULL, NULL);
-	g_return_val_if_fail (object_id != NULL, NULL);
-	g_return_val_if_fail (statement != NULL, NULL);
-	_inner_error_ = NULL;
-	obj = NULL;
-	switch (sqlite3_column_int (statement, 0)) {
-		case 0:
-		{
-			RygelMediaObject* _tmp0_;
-			obj = (_tmp0_ = (RygelMediaObject*) rygel_media_db_object_factory_get_container (self->priv->factory, self, object_id, sqlite3_column_text (statement, 1), (guint) 0), _g_object_unref0 (obj), _tmp0_);
-			break;
-		}
-		case 1:
-		{
-			RygelMediaObject* _tmp1_;
-			obj = (_tmp1_ = (RygelMediaObject*) rygel_media_db_object_factory_get_item (self->priv->factory, self, parent, object_id, sqlite3_column_text (statement, 1), sqlite3_column_text (statement, 6)), _g_object_unref0 (obj), _tmp1_);
-			rygel_media_db_fill_item (self, statement, RYGEL_MEDIA_ITEM (obj));
-			break;
-		}
-		default:
-		{
-			g_assert_not_reached ();
-		}
-	}
-	{
-		if (obj != NULL) {
-			obj->modified = (guint64) sqlite3_column_int64 (statement, 18);
-			rygel_media_db_add_uris (self, obj, &_inner_error_);
-			if (_inner_error_ != NULL) {
-				if (_inner_error_->domain == RYGEL_MEDIA_DB_ERROR) {
-					goto __catch42_rygel_media_db_error;
-				}
-				goto __finally42;
-			}
-		}
-	}
-	goto __finally42;
-	__catch42_rygel_media_db_error:
-	{
-		GError * err;
-		err = _inner_error_;
-		_inner_error_ = NULL;
-		{
-			RygelMediaObject* _tmp2_;
-			g_warning ("rygel-media-db.vala:715: Failed to load uris from database: %s", err->message);
-			obj = (_tmp2_ = NULL, _g_object_unref0 (obj), _tmp2_);
-			_g_error_free0 (err);
-		}
-	}
-	__finally42:
-	if (_inner_error_ != NULL) {
-		_g_object_unref0 (obj);
-		g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
-		g_clear_error (&_inner_error_);
-		return NULL;
-	}
-	result = obj;
-	return result;
-}
-
-
-RygelMediaObject* rygel_media_db_get_object (RygelMediaDB* self, const char* object_id, GError** error) {
-	RygelMediaObject* result;
-	GError * _inner_error_;
-	RygelMediaObject* obj;
-	sqlite3_stmt* statement;
-	sqlite3_stmt* _tmp2_;
-	gint _tmp1_;
-	sqlite3_stmt* _tmp0_ = NULL;
-	gint rc;
-	g_return_val_if_fail (self != NULL, NULL);
-	g_return_val_if_fail (object_id != NULL, NULL);
-	_inner_error_ = NULL;
-	obj = NULL;
-	statement = NULL;
-	rc = (_tmp1_ = sqlite3_prepare_v2 (self->priv->db, RYGEL_MEDIA_DB_GET_OBJECT_STRING, -1, &_tmp0_, NULL), statement = (_tmp2_ = _tmp0_, _sqlite3_finalize0 (statement), _tmp2_), _tmp1_);
-	if (rc == SQLITE_OK) {
-		if (sqlite3_bind_text (statement, 1, g_strdup (object_id), -1, g_free) != SQLITE_OK) {
-			_inner_error_ = g_error_new_literal (RYGEL_MEDIA_DB_ERROR, RYGEL_MEDIA_DB_ERROR_SQLITE_ERROR, sqlite3_errmsg (self->priv->db));
-			if (_inner_error_ != NULL) {
-				if (_inner_error_->domain == RYGEL_MEDIA_DB_ERROR) {
-					g_propagate_error (error, _inner_error_);
-					_g_object_unref0 (obj);
-					_sqlite3_finalize0 (statement);
-					return NULL;
-				} else {
-					_g_object_unref0 (obj);
-					_sqlite3_finalize0 (statement);
-					g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
-					g_clear_error (&_inner_error_);
-					return NULL;
-				}
-			}
-		}
-		while (TRUE) {
-			RygelMediaContainer* parent;
-			char* parent_id;
-			RygelMediaObject* _tmp5_;
-			RygelMediaContainer* _tmp6_;
-			if (!((rc = sqlite3_step (statement)) == SQLITE_ROW)) {
-				break;
-			}
-			parent = NULL;
-			parent_id = g_strdup (sqlite3_column_text (statement, 17));
-			if (parent_id != NULL) {
-				RygelMediaObject* _tmp3_;
-				RygelMediaContainer* _tmp4_;
-				_tmp3_ = rygel_media_db_get_object (self, sqlite3_column_text (statement, 17), &_inner_error_);
-				if (_inner_error_ != NULL) {
-					if (_inner_error_->domain == RYGEL_MEDIA_DB_ERROR) {
-						g_propagate_error (error, _inner_error_);
-						_g_object_unref0 (parent);
-						_g_free0 (parent_id);
-						_g_object_unref0 (obj);
-						_sqlite3_finalize0 (statement);
-						return NULL;
-					} else {
-						_g_object_unref0 (parent);
-						_g_free0 (parent_id);
-						_g_object_unref0 (obj);
-						_sqlite3_finalize0 (statement);
-						g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
-						g_clear_error (&_inner_error_);
-						return NULL;
-					}
-				}
-				parent = (_tmp4_ = RYGEL_MEDIA_CONTAINER (_tmp3_), _g_object_unref0 (parent), _tmp4_);
-			} else {
-				if (_vala_strcmp0 (sqlite3_column_text (statement, 0), "0") != 0) {
-					g_warning ("Inconsitent database; non-root element " "without parent found. Id is %s", sqlite3_column_text (statement, 0));
-				}
-			}
-			obj = (_tmp5_ = rygel_media_db_get_object_from_statement (self, RYGEL_MEDIA_CONTAINER (parent), object_id, statement), _g_object_unref0 (obj), _tmp5_);
-			obj->parent_ref = (_tmp6_ = _g_object_ref0 (RYGEL_MEDIA_CONTAINER (parent)), _g_object_unref0 (obj->parent_ref), _tmp6_);
-			obj->parent = obj->parent_ref;
-			_g_object_unref0 (parent);
-			_g_free0 (parent_id);
-			break;
-		}
-	} else {
-		_inner_error_ = g_error_new_literal (RYGEL_MEDIA_DB_ERROR, RYGEL_MEDIA_DB_ERROR_SQLITE_ERROR, sqlite3_errmsg (self->priv->db));
-		if (_inner_error_ != NULL) {
-			if (_inner_error_->domain == RYGEL_MEDIA_DB_ERROR) {
-				g_propagate_error (error, _inner_error_);
-				_g_object_unref0 (obj);
-				_sqlite3_finalize0 (statement);
-				return NULL;
-			} else {
-				_g_object_unref0 (obj);
-				_sqlite3_finalize0 (statement);
-				g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
-				g_clear_error (&_inner_error_);
-				return NULL;
-			}
-		}
-	}
-	result = obj;
-	_sqlite3_finalize0 (statement);
-	return result;
-}
-
-
-RygelMediaItem* rygel_media_db_get_item (RygelMediaDB* self, const char* item_id, GError** error) {
-	RygelMediaItem* result;
-	GError * _inner_error_;
-	RygelMediaObject* obj;
-	gboolean _tmp0_ = FALSE;
-	g_return_val_if_fail (self != NULL, NULL);
-	g_return_val_if_fail (item_id != NULL, NULL);
-	_inner_error_ = NULL;
-	obj = rygel_media_db_get_object (self, item_id, &_inner_error_);
-	if (_inner_error_ != NULL) {
-		if (_inner_error_->domain == RYGEL_MEDIA_DB_ERROR) {
-			g_propagate_error (error, _inner_error_);
-			return NULL;
-		} else {
-			g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
-			g_clear_error (&_inner_error_);
-			return NULL;
-		}
-	}
-	if (obj != NULL) {
-		_tmp0_ = !RYGEL_IS_MEDIA_ITEM (obj);
-	} else {
-		_tmp0_ = FALSE;
-	}
-	if (_tmp0_) {
-		_inner_error_ = g_error_new (RYGEL_MEDIA_DB_ERROR, RYGEL_MEDIA_DB_ERROR_INVALID_TYPE, "Object with id %s is not a" "MediaItem", item_id);
-		if (_inner_error_ != NULL) {
-			if (_inner_error_->domain == RYGEL_MEDIA_DB_ERROR) {
-				g_propagate_error (error, _inner_error_);
-				_g_object_unref0 (obj);
-				return NULL;
-			} else {
-				_g_object_unref0 (obj);
-				g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
-				g_clear_error (&_inner_error_);
-				return NULL;
-			}
-		}
-	}
-	result = _g_object_ref0 (RYGEL_MEDIA_ITEM (obj));
-	_g_object_unref0 (obj);
-	return result;
-}
-
-
-RygelMediaContainer* rygel_media_db_get_container (RygelMediaDB* self, const char* container_id, GError** error) {
-	RygelMediaContainer* result;
-	GError * _inner_error_;
-	RygelMediaObject* obj;
-	gboolean _tmp0_ = FALSE;
-	g_return_val_if_fail (self != NULL, NULL);
-	g_return_val_if_fail (container_id != NULL, NULL);
-	_inner_error_ = NULL;
-	obj = rygel_media_db_get_object (self, container_id, &_inner_error_);
-	if (_inner_error_ != NULL) {
-		if (_inner_error_->domain == RYGEL_MEDIA_DB_ERROR) {
-			g_propagate_error (error, _inner_error_);
-			return NULL;
-		} else {
-			g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
-			g_clear_error (&_inner_error_);
-			return NULL;
-		}
-	}
-	if (obj != NULL) {
-		_tmp0_ = !RYGEL_IS_MEDIA_CONTAINER (obj);
-	} else {
-		_tmp0_ = FALSE;
-	}
-	if (_tmp0_) {
-		_inner_error_ = g_error_new (RYGEL_MEDIA_DB_ERROR, RYGEL_MEDIA_DB_ERROR_INVALID_TYPE, "Object with id %s is not a" "MediaContainer", container_id);
-		if (_inner_error_ != NULL) {
-			if (_inner_error_->domain == RYGEL_MEDIA_DB_ERROR) {
-				g_propagate_error (error, _inner_error_);
-				_g_object_unref0 (obj);
-				return NULL;
-			} else {
-				_g_object_unref0 (obj);
-				g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
-				g_clear_error (&_inner_error_);
-				return NULL;
-			}
-		}
-	}
-	result = _g_object_ref0 (RYGEL_MEDIA_CONTAINER (obj));
-	_g_object_unref0 (obj);
-	return result;
-}
-
-
-static void rygel_media_db_fill_item (RygelMediaDB* self, sqlite3_stmt* statement, RygelMediaItem* item) {
-	char* _tmp0_;
-	char* _tmp1_;
-	char* _tmp2_;
-	char* _tmp3_;
-	g_return_if_fail (self != NULL);
-	g_return_if_fail (statement != NULL);
-	g_return_if_fail (item != NULL);
-	item->author = (_tmp0_ = g_strdup (sqlite3_column_text (statement, 7)), _g_free0 (item->author), _tmp0_);
-	item->album = (_tmp1_ = g_strdup (sqlite3_column_text (statement, 8)), _g_free0 (item->album), _tmp1_);
-	item->date = (_tmp2_ = g_strdup (sqlite3_column_text (statement, 9)), _g_free0 (item->date), _tmp2_);
-	item->mime_type = (_tmp3_ = g_strdup (sqlite3_column_text (statement, 3)), _g_free0 (item->mime_type), _tmp3_);
-	item->duration = (glong) sqlite3_column_int64 (statement, 16);
-	item->size = (glong) sqlite3_column_int64 (statement, 2);
-	item->bitrate = sqlite3_column_int (statement, 10);
-	item->sample_freq = sqlite3_column_int (statement, 11);
-	item->bits_per_sample = sqlite3_column_int (statement, 12);
-	item->n_audio_channels = sqlite3_column_int (statement, 13);
-	item->track_number = sqlite3_column_int (statement, 14);
-	item->width = sqlite3_column_int (statement, 4);
-	item->height = sqlite3_column_int (statement, 5);
-	item->color_depth = sqlite3_column_int (statement, 15);
-}
-
-
-GeeArrayList* rygel_media_db_get_child_ids (RygelMediaDB* self, const char* container_id, GError** error) {
-	GeeArrayList* result;
-	GError * _inner_error_;
-	GeeArrayList* children;
-	sqlite3_stmt* statement;
-	sqlite3_stmt* _tmp2_;
-	gint _tmp1_;
-	sqlite3_stmt* _tmp0_ = NULL;
-	gint rc;
-	g_return_val_if_fail (self != NULL, NULL);
-	g_return_val_if_fail (container_id != NULL, NULL);
-	_inner_error_ = NULL;
-	children = gee_array_list_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, g_str_equal);
-	statement = NULL;
-	rc = (_tmp1_ = sqlite3_prepare_v2 (self->priv->db, RYGEL_MEDIA_DB_GET_CHILD_ID_STRING, -1, &_tmp0_, NULL), statement = (_tmp2_ = _tmp0_, _sqlite3_finalize0 (statement), _tmp2_), _tmp1_);
-	if (rc == SQLITE_OK) {
-		if (sqlite3_bind_text (statement, 1, g_strdup (container_id), -1, g_free) != SQLITE_OK) {
-			_inner_error_ = g_error_new_literal (RYGEL_MEDIA_DB_ERROR, RYGEL_MEDIA_DB_ERROR_SQLITE_ERROR, sqlite3_errmsg (self->priv->db));
-			if (_inner_error_ != NULL) {
-				if (_inner_error_->domain == RYGEL_MEDIA_DB_ERROR) {
-					g_propagate_error (error, _inner_error_);
-					_g_object_unref0 (children);
-					_sqlite3_finalize0 (statement);
-					return NULL;
-				} else {
-					_g_object_unref0 (children);
-					_sqlite3_finalize0 (statement);
-					g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
-					g_clear_error (&_inner_error_);
-					return NULL;
-				}
-			}
-		}
-		while (TRUE) {
-			if (!((rc = sqlite3_step (statement)) == SQLITE_ROW)) {
-				break;
-			}
-			gee_abstract_collection_add ((GeeAbstractCollection*) children, sqlite3_column_text (statement, 0));
-		}
-	} else {
-		g_warning ("rygel-media-db.vala:818: Failed to get children for obj %s: %s", container_id, sqlite3_errmsg (self->priv->db));
-		_inner_error_ = g_error_new_literal (RYGEL_MEDIA_DB_ERROR, RYGEL_MEDIA_DB_ERROR_SQLITE_ERROR, sqlite3_errmsg (self->priv->db));
-		if (_inner_error_ != NULL) {
-			if (_inner_error_->domain == RYGEL_MEDIA_DB_ERROR) {
-				g_propagate_error (error, _inner_error_);
-				_g_object_unref0 (children);
-				_sqlite3_finalize0 (statement);
-				return NULL;
-			} else {
-				_g_object_unref0 (children);
-				_sqlite3_finalize0 (statement);
-				g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
-				g_clear_error (&_inner_error_);
-				return NULL;
-			}
-		}
-	}
-	result = children;
-	_sqlite3_finalize0 (statement);
-	return result;
-}
-
-
-gint rygel_media_db_get_child_count (RygelMediaDB* self, const char* container_id, GError** error) {
-	gint result;
-	GError * _inner_error_;
-	sqlite3_stmt* statement;
-	gint count;
-	sqlite3_stmt* _tmp2_;
-	gint _tmp1_;
-	sqlite3_stmt* _tmp0_ = NULL;
-	gint rc;
-	g_return_val_if_fail (self != NULL, 0);
-	g_return_val_if_fail (container_id != NULL, 0);
-	_inner_error_ = NULL;
-	statement = NULL;
-	count = 0;
-	rc = (_tmp1_ = sqlite3_prepare_v2 (self->priv->db, RYGEL_MEDIA_DB_CHILDREN_COUNT_STRING, -1, &_tmp0_, NULL), statement = (_tmp2_ = _tmp0_, _sqlite3_finalize0 (statement), _tmp2_), _tmp1_);
-	if (rc == SQLITE_OK) {
-		if (sqlite3_bind_text (statement, 1, g_strdup (container_id), -1, g_free) != SQLITE_OK) {
-			_inner_error_ = g_error_new_literal (RYGEL_MEDIA_DB_ERROR, RYGEL_MEDIA_DB_ERROR_SQLITE_ERROR, sqlite3_errmsg (self->priv->db));
-			if (_inner_error_ != NULL) {
-				if (_inner_error_->domain == RYGEL_MEDIA_DB_ERROR) {
-					g_propagate_error (error, _inner_error_);
-					_sqlite3_finalize0 (statement);
-					return 0;
-				} else {
-					_sqlite3_finalize0 (statement);
-					g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
-					g_clear_error (&_inner_error_);
-					return 0;
-				}
-			}
-		}
-		while (TRUE) {
-			if (!((rc = sqlite3_step (statement)) == SQLITE_ROW)) {
-				break;
-			}
-			count = sqlite3_column_int (statement, 0);
-			break;
-		}
-	} else {
-		g_warning ("rygel-media-db.vala:843: Could not get child count for object %s: %s", container_id, sqlite3_errmsg (self->priv->db));
-		_inner_error_ = g_error_new_literal (RYGEL_MEDIA_DB_ERROR, RYGEL_MEDIA_DB_ERROR_SQLITE_ERROR, sqlite3_errmsg (self->priv->db));
-		if (_inner_error_ != NULL) {
-			if (_inner_error_->domain == RYGEL_MEDIA_DB_ERROR) {
-				g_propagate_error (error, _inner_error_);
-				_sqlite3_finalize0 (statement);
-				return 0;
-			} else {
-				_sqlite3_finalize0 (statement);
-				g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
-				g_clear_error (&_inner_error_);
-				return 0;
-			}
-		}
-	}
-	result = count;
-	_sqlite3_finalize0 (statement);
-	return result;
-}
-
-
-gboolean rygel_media_db_exists (RygelMediaDB* self, const char* object_id, gint64* timestamp, GError** error) {
-	gboolean result;
-	GError * _inner_error_;
-	sqlite3_stmt* statement;
-	gboolean exists;
-	sqlite3_stmt* _tmp2_;
-	gint _tmp1_;
-	sqlite3_stmt* _tmp0_ = NULL;
-	gint rc;
-	g_return_val_if_fail (self != NULL, FALSE);
-	g_return_val_if_fail (object_id != NULL, FALSE);
-	_inner_error_ = NULL;
-	statement = NULL;
-	exists = FALSE;
-	rc = (_tmp1_ = sqlite3_prepare_v2 (self->priv->db, RYGEL_MEDIA_DB_OBJECT_EXISTS_STRING, -1, &_tmp0_, NULL), statement = (_tmp2_ = _tmp0_, _sqlite3_finalize0 (statement), _tmp2_), _tmp1_);
-	if (rc == SQLITE_OK) {
-		if (sqlite3_bind_text (statement, 1, g_strdup (object_id), -1, g_free) != SQLITE_OK) {
-			_inner_error_ = g_error_new_literal (RYGEL_MEDIA_DB_ERROR, RYGEL_MEDIA_DB_ERROR_SQLITE_ERROR, sqlite3_errmsg (self->priv->db));
-			if (_inner_error_ != NULL) {
-				if (_inner_error_->domain == RYGEL_MEDIA_DB_ERROR) {
-					g_propagate_error (error, _inner_error_);
-					_sqlite3_finalize0 (statement);
-					return FALSE;
-				} else {
-					_sqlite3_finalize0 (statement);
-					g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
-					g_clear_error (&_inner_error_);
-					return FALSE;
-				}
-			}
-		}
-		while (TRUE) {
-			if (!((rc = sqlite3_step (statement)) == SQLITE_ROW)) {
-				break;
-			}
-			exists = sqlite3_column_int (statement, 0) == 1;
-			*timestamp = sqlite3_column_int64 (statement, 1);
-			break;
-		}
-	} else {
-		g_warning ("rygel-media-db.vala:871: Could not get child count for object %s: %s", object_id, sqlite3_errmsg (self->priv->db));
-		_inner_error_ = g_error_new_literal (RYGEL_MEDIA_DB_ERROR, RYGEL_MEDIA_DB_ERROR_SQLITE_ERROR, sqlite3_errmsg (self->priv->db));
-		if (_inner_error_ != NULL) {
-			if (_inner_error_->domain == RYGEL_MEDIA_DB_ERROR) {
-				g_propagate_error (error, _inner_error_);
-				_sqlite3_finalize0 (statement);
-				return FALSE;
-			} else {
-				_sqlite3_finalize0 (statement);
-				g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
-				g_clear_error (&_inner_error_);
-				return FALSE;
-			}
-		}
-	}
-	result = exists;
-	_sqlite3_finalize0 (statement);
-	return result;
-}
-
-
-GeeArrayList* rygel_media_db_get_children (RygelMediaDB* self, const char* container_id, glong offset, glong max_count) {
-	GeeArrayList* result;
-	GError * _inner_error_;
-	sqlite3_stmt* statement;
-	GeeArrayList* children;
-	RygelMediaContainer* parent;
-	sqlite3_stmt* _tmp4_;
-	gint _tmp3_;
-	sqlite3_stmt* _tmp2_ = NULL;
-	gint rc;
-	g_return_val_if_fail (self != NULL, NULL);
-	g_return_val_if_fail (container_id != NULL, NULL);
-	_inner_error_ = NULL;
-	statement = NULL;
-	children = gee_array_list_new (RYGEL_TYPE_MEDIA_OBJECT, (GBoxedCopyFunc) g_object_ref, g_object_unref, g_direct_equal);
-	parent = NULL;
-	{
-		RygelMediaObject* _tmp0_;
-		RygelMediaContainer* _tmp1_;
-		_tmp0_ = rygel_media_db_get_object (self, container_id, &_inner_error_);
-		if (_inner_error_ != NULL) {
-			if (_inner_error_->domain == RYGEL_MEDIA_DB_ERROR) {
-				goto __catch43_rygel_media_db_error;
-			}
-			goto __finally43;
-		}
-		parent = (_tmp1_ = RYGEL_MEDIA_CONTAINER (_tmp0_), _g_object_unref0 (parent), _tmp1_);
-	}
-	goto __finally43;
-	__catch43_rygel_media_db_error:
-	{
-		GError * err;
-		err = _inner_error_;
-		_inner_error_ = NULL;
-		{
-			g_warning ("rygel-media-db.vala:890: Could not get parent object: %s", err->message);
-			result = children;
-			_g_error_free0 (err);
-			_sqlite3_finalize0 (statement);
-			_g_object_unref0 (parent);
-			return result;
-		}
-	}
-	__finally43:
-	if (_inner_error_ != NULL) {
-		_sqlite3_finalize0 (statement);
-		_g_object_unref0 (children);
-		_g_object_unref0 (parent);
-		g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
-		g_clear_error (&_inner_error_);
-		return NULL;
-	}
-	rc = (_tmp3_ = sqlite3_prepare_v2 (self->priv->db, RYGEL_MEDIA_DB_GET_CHILDREN_STRING, -1, &_tmp2_, NULL), statement = (_tmp4_ = _tmp2_, _sqlite3_finalize0 (statement), _tmp4_), _tmp3_);
-	if (rc == SQLITE_OK) {
-		gboolean _tmp5_ = FALSE;
-		gboolean _tmp6_ = FALSE;
-		if (sqlite3_bind_text (statement, 1, g_strdup (container_id), -1, g_free) != SQLITE_OK) {
-			_tmp6_ = TRUE;
-		} else {
-			_tmp6_ = sqlite3_bind_int64 (statement, 2, (gint64) offset) != SQLITE_OK;
-		}
-		if (_tmp6_) {
-			_tmp5_ = TRUE;
-		} else {
-			_tmp5_ = sqlite3_bind_int64 (statement, 3, (gint64) max_count) != SQLITE_OK;
-		}
-		if (_tmp5_) {
-			_inner_error_ = g_error_new_literal (RYGEL_MEDIA_DB_ERROR, RYGEL_MEDIA_DB_ERROR_SQLITE_ERROR, sqlite3_errmsg (self->priv->db));
-			if (_inner_error_ != NULL) {
-				_sqlite3_finalize0 (statement);
-				_g_object_unref0 (children);
-				_g_object_unref0 (parent);
-				g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
-				g_clear_error (&_inner_error_);
-				return NULL;
-			}
-		}
-		while (TRUE) {
-			char* child_id;
-			RygelMediaObject* _tmp7_;
-			RygelMediaObject* _tmp8_;
-			RygelMediaContainer* _tmp11_;
-			RygelMediaContainer* *_tmp10_;
-			RygelMediaObject* _tmp9_;
-			if (!((rc = sqlite3_step (statement)) == SQLITE_ROW)) {
-				break;
-			}
-			child_id = g_strdup (sqlite3_column_text (statement, 17));
-			gee_abstract_collection_add ((GeeAbstractCollection*) children, _tmp7_ = rygel_media_db_get_object_from_statement (self, parent, child_id, statement));
-			_g_object_unref0 (_tmp7_);
-			(_tmp8_ = (RygelMediaObject*) gee_abstract_list_get ((GeeAbstractList*) children, gee_collection_get_size ((GeeCollection*) children) - 1))->parent = parent;
-			_g_object_unref0 (_tmp8_);
-			_tmp10_ = &(_tmp9_ = (RygelMediaObject*) gee_abstract_list_get ((GeeAbstractList*) children, gee_collection_get_size ((GeeCollection*) children) - 1))->parent_ref;
-			(*_tmp10_) = (_tmp11_ = _g_object_ref0 (parent), _g_object_unref0 ((*_tmp10_)), _tmp11_);
-			_g_object_unref0 (_tmp9_);
-			_g_free0 (child_id);
-		}
-	}
-	result = children;
-	_sqlite3_finalize0 (statement);
-	_g_object_unref0 (parent);
-	return result;
-}
-
-
-static void rygel_media_db_class_init (RygelMediaDBClass * klass) {
-	rygel_media_db_parent_class = g_type_class_peek_parent (klass);
-	g_type_class_add_private (klass, sizeof (RygelMediaDBPrivate));
-	G_OBJECT_CLASS (klass)->finalize = rygel_media_db_finalize;
-	g_signal_new ("object_added", RYGEL_TYPE_MEDIA_DB, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__STRING, G_TYPE_NONE, 1, G_TYPE_STRING);
-	g_signal_new ("object_removed", RYGEL_TYPE_MEDIA_DB, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__STRING, G_TYPE_NONE, 1, G_TYPE_STRING);
-	g_signal_new ("object_updated", RYGEL_TYPE_MEDIA_DB, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__STRING, G_TYPE_NONE, 1, G_TYPE_STRING);
-	g_signal_new ("item_removed", RYGEL_TYPE_MEDIA_DB, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__STRING, G_TYPE_NONE, 1, G_TYPE_STRING);
-	g_signal_new ("item_added", RYGEL_TYPE_MEDIA_DB, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__STRING, G_TYPE_NONE, 1, G_TYPE_STRING);
-	g_signal_new ("item_updated", RYGEL_TYPE_MEDIA_DB, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__STRING, G_TYPE_NONE, 1, G_TYPE_STRING);
-	g_signal_new ("container_added", RYGEL_TYPE_MEDIA_DB, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__STRING, G_TYPE_NONE, 1, G_TYPE_STRING);
-	g_signal_new ("container_removed", RYGEL_TYPE_MEDIA_DB, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__STRING, G_TYPE_NONE, 1, G_TYPE_STRING);
-	g_signal_new ("container_updated", RYGEL_TYPE_MEDIA_DB, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__STRING, G_TYPE_NONE, 1, G_TYPE_STRING);
-}
-
-
-static void rygel_media_db_instance_init (RygelMediaDB * self) {
-	self->priv = RYGEL_MEDIA_DB_GET_PRIVATE (self);
-}
-
-
-static void rygel_media_db_finalize (GObject* obj) {
-	RygelMediaDB * self;
-	self = RYGEL_MEDIA_DB (obj);
-	_sqlite3_close0 (self->priv->db);
-	_g_object_unref0 (self->priv->factory);
-	G_OBJECT_CLASS (rygel_media_db_parent_class)->finalize (obj);
-}
-
-
-GType rygel_media_db_get_type (void) {
-	static GType rygel_media_db_type_id = 0;
-	if (rygel_media_db_type_id == 0) {
-		static const GTypeInfo g_define_type_info = { sizeof (RygelMediaDBClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) rygel_media_db_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (RygelMediaDB), 0, (GInstanceInitFunc) rygel_media_db_instance_init, NULL };
-		rygel_media_db_type_id = g_type_register_static (G_TYPE_OBJECT, "RygelMediaDB", &g_define_type_info, 0);
-	}
-	return rygel_media_db_type_id;
-}
-
-
-static int _vala_strcmp0 (const char * str1, const char * str2) {
-	if (str1 == NULL) {
-		return -(str1 != str2);
-	}
-	if (str2 == NULL) {
-		return str1 != str2;
-	}
-	return strcmp (str1, str2);
-}
-
-
-
-
--- a/src/rygel/rygel-media-item.c
+++ /dev/null
@@ -1,621 +0,0 @@
-/* rygel-media-item.c generated by valac, the Vala compiler
- * generated from rygel-media-item.vala, do not modify */
-
-/*
- * Copyright (C) 2008 Zeeshan Ali <zeenix@gmail.com>.
- *
- * Author: Zeeshan Ali <zeenix@gmail.com>
- *
- * This file is part of Rygel.
- *
- * Rygel is free software; you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * Rygel is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this program; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
- */
-
-#include <glib.h>
-#include <glib-object.h>
-#include <stdlib.h>
-#include <string.h>
-#include <gee.h>
-#include <gst/gst.h>
-#include <libgupnp-av/gupnp-av.h>
-
-
-#define RYGEL_TYPE_MEDIA_OBJECT (rygel_media_object_get_type ())
-#define RYGEL_MEDIA_OBJECT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_MEDIA_OBJECT, RygelMediaObject))
-#define RYGEL_MEDIA_OBJECT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_MEDIA_OBJECT, RygelMediaObjectClass))
-#define RYGEL_IS_MEDIA_OBJECT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_MEDIA_OBJECT))
-#define RYGEL_IS_MEDIA_OBJECT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_MEDIA_OBJECT))
-#define RYGEL_MEDIA_OBJECT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_MEDIA_OBJECT, RygelMediaObjectClass))
-
-typedef struct _RygelMediaObject RygelMediaObject;
-typedef struct _RygelMediaObjectClass RygelMediaObjectClass;
-typedef struct _RygelMediaObjectPrivate RygelMediaObjectPrivate;
-
-#define RYGEL_TYPE_MEDIA_CONTAINER (rygel_media_container_get_type ())
-#define RYGEL_MEDIA_CONTAINER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_MEDIA_CONTAINER, RygelMediaContainer))
-#define RYGEL_MEDIA_CONTAINER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_MEDIA_CONTAINER, RygelMediaContainerClass))
-#define RYGEL_IS_MEDIA_CONTAINER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_MEDIA_CONTAINER))
-#define RYGEL_IS_MEDIA_CONTAINER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_MEDIA_CONTAINER))
-#define RYGEL_MEDIA_CONTAINER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_MEDIA_CONTAINER, RygelMediaContainerClass))
-
-typedef struct _RygelMediaContainer RygelMediaContainer;
-typedef struct _RygelMediaContainerClass RygelMediaContainerClass;
-
-#define RYGEL_TYPE_MEDIA_ITEM (rygel_media_item_get_type ())
-#define RYGEL_MEDIA_ITEM(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_MEDIA_ITEM, RygelMediaItem))
-#define RYGEL_MEDIA_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_MEDIA_ITEM, RygelMediaItemClass))
-#define RYGEL_IS_MEDIA_ITEM(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_MEDIA_ITEM))
-#define RYGEL_IS_MEDIA_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_MEDIA_ITEM))
-#define RYGEL_MEDIA_ITEM_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_MEDIA_ITEM, RygelMediaItemClass))
-
-typedef struct _RygelMediaItem RygelMediaItem;
-typedef struct _RygelMediaItemClass RygelMediaItemClass;
-typedef struct _RygelMediaItemPrivate RygelMediaItemPrivate;
-
-#define RYGEL_TYPE_ICON_INFO (rygel_icon_info_get_type ())
-#define RYGEL_ICON_INFO(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_ICON_INFO, RygelIconInfo))
-#define RYGEL_ICON_INFO_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_ICON_INFO, RygelIconInfoClass))
-#define RYGEL_IS_ICON_INFO(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_ICON_INFO))
-#define RYGEL_IS_ICON_INFO_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_ICON_INFO))
-#define RYGEL_ICON_INFO_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_ICON_INFO, RygelIconInfoClass))
-
-typedef struct _RygelIconInfo RygelIconInfo;
-typedef struct _RygelIconInfoClass RygelIconInfoClass;
-
-#define RYGEL_TYPE_THUMBNAIL (rygel_thumbnail_get_type ())
-#define RYGEL_THUMBNAIL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_THUMBNAIL, RygelThumbnail))
-#define RYGEL_THUMBNAIL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_THUMBNAIL, RygelThumbnailClass))
-#define RYGEL_IS_THUMBNAIL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_THUMBNAIL))
-#define RYGEL_IS_THUMBNAIL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_THUMBNAIL))
-#define RYGEL_THUMBNAIL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_THUMBNAIL, RygelThumbnailClass))
-
-typedef struct _RygelThumbnail RygelThumbnail;
-typedef struct _RygelThumbnailClass RygelThumbnailClass;
-#define _g_free0(var) (var = (g_free (var), NULL))
-#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
-#define _gst_object_unref0(var) ((var == NULL) ? NULL : (var = (gst_object_unref (var), NULL)))
-
-#define RYGEL_TYPE_THUMBNAILER (rygel_thumbnailer_get_type ())
-#define RYGEL_THUMBNAILER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_THUMBNAILER, RygelThumbnailer))
-#define RYGEL_THUMBNAILER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_THUMBNAILER, RygelThumbnailerClass))
-#define RYGEL_IS_THUMBNAILER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_THUMBNAILER))
-#define RYGEL_IS_THUMBNAILER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_THUMBNAILER))
-#define RYGEL_THUMBNAILER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_THUMBNAILER, RygelThumbnailerClass))
-
-typedef struct _RygelThumbnailer RygelThumbnailer;
-typedef struct _RygelThumbnailerClass RygelThumbnailerClass;
-#define _rygel_icon_info_unref0(var) ((var == NULL) ? NULL : (var = (rygel_icon_info_unref (var), NULL)))
-#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
-
-#define RYGEL_TYPE_TRANSCODER (rygel_transcoder_get_type ())
-#define RYGEL_TRANSCODER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_TRANSCODER, RygelTranscoder))
-#define RYGEL_TRANSCODER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_TRANSCODER, RygelTranscoderClass))
-#define RYGEL_IS_TRANSCODER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_TRANSCODER))
-#define RYGEL_IS_TRANSCODER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_TRANSCODER))
-#define RYGEL_TRANSCODER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_TRANSCODER, RygelTranscoderClass))
-
-typedef struct _RygelTranscoder RygelTranscoder;
-typedef struct _RygelTranscoderClass RygelTranscoderClass;
-typedef struct _RygelIconInfoPrivate RygelIconInfoPrivate;
-typedef struct _RygelThumbnailPrivate RygelThumbnailPrivate;
-
-typedef enum  {
-	RYGEL_MEDIA_ITEM_ERROR_BAD_URI
-} RygelMediaItemError;
-#define RYGEL_MEDIA_ITEM_ERROR rygel_media_item_error_quark ()
-struct _RygelMediaObject {
-	GObject parent_instance;
-	RygelMediaObjectPrivate * priv;
-	char* id;
-	char* title;
-	guint64 modified;
-	GeeArrayList* uris;
-	RygelMediaContainer* parent;
-	RygelMediaContainer* parent_ref;
-};
-
-struct _RygelMediaObjectClass {
-	GObjectClass parent_class;
-};
-
-struct _RygelMediaItem {
-	RygelMediaObject parent_instance;
-	RygelMediaItemPrivate * priv;
-	char* author;
-	char* album;
-	char* date;
-	char* upnp_class;
-	char* mime_type;
-	char* dlna_profile;
-	glong size;
-	glong duration;
-	gint bitrate;
-	gint sample_freq;
-	gint bits_per_sample;
-	gint n_audio_channels;
-	gint track_number;
-	gint width;
-	gint height;
-	gint pixel_width;
-	gint pixel_height;
-	gint color_depth;
-	GeeArrayList* thumbnails;
-};
-
-struct _RygelMediaItemClass {
-	RygelMediaObjectClass parent_class;
-	GstElement* (*create_stream_source) (RygelMediaItem* self);
-	gboolean (*should_stream) (RygelMediaItem* self);
-};
-
-struct _RygelIconInfo {
-	GTypeInstance parent_instance;
-	volatile int ref_count;
-	RygelIconInfoPrivate * priv;
-	char* mime_type;
-	char* path;
-	glong size;
-	gint width;
-	gint height;
-	gint depth;
-};
-
-struct _RygelIconInfoClass {
-	GTypeClass parent_class;
-	void (*finalize) (RygelIconInfo *self);
-};
-
-struct _RygelThumbnail {
-	RygelIconInfo parent_instance;
-	RygelThumbnailPrivate * priv;
-	char* uri;
-	char* dlna_profile;
-};
-
-struct _RygelThumbnailClass {
-	RygelIconInfoClass parent_class;
-};
-
-
-static gpointer rygel_media_item_parent_class = NULL;
-
-GQuark rygel_media_item_error_quark (void);
-GType rygel_media_object_get_type (void);
-GType rygel_media_container_get_type (void);
-GType rygel_media_item_get_type (void);
-gpointer rygel_icon_info_ref (gpointer instance);
-void rygel_icon_info_unref (gpointer instance);
-GParamSpec* rygel_param_spec_icon_info (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
-void rygel_value_set_icon_info (GValue* value, gpointer v_object);
-gpointer rygel_value_get_icon_info (const GValue* value);
-GType rygel_icon_info_get_type (void);
-GType rygel_thumbnail_get_type (void);
-enum  {
-	RYGEL_MEDIA_ITEM_DUMMY_PROPERTY
-};
-#define RYGEL_MEDIA_ITEM_IMAGE_CLASS "object.item.imageItem"
-#define RYGEL_MEDIA_ITEM_VIDEO_CLASS "object.item.videoItem"
-#define RYGEL_MEDIA_ITEM_AUDIO_CLASS "object.item.audioItem"
-#define RYGEL_MEDIA_ITEM_MUSIC_CLASS "object.item.audioItem.musicTrack"
-RygelMediaObject* rygel_media_object_construct (GType object_type);
-RygelMediaItem* rygel_media_item_new (const char* id, RygelMediaContainer* parent, const char* title, const char* upnp_class);
-RygelMediaItem* rygel_media_item_construct (GType object_type, const char* id, RygelMediaContainer* parent, const char* title, const char* upnp_class);
-static inline void _dynamic_set_tcp_timeout1 (GstElement* obj, gint64 value);
-GstElement* rygel_media_item_create_stream_source (RygelMediaItem* self);
-static GstElement* rygel_media_item_real_create_stream_source (RygelMediaItem* self);
-gboolean rygel_media_item_should_stream (RygelMediaItem* self);
-static gboolean rygel_media_item_real_should_stream (RygelMediaItem* self);
-GType rygel_thumbnailer_get_type (void);
-RygelThumbnailer* rygel_thumbnailer_get_default (void);
-RygelThumbnail* rygel_thumbnailer_get_thumbnail (RygelThumbnailer* self, const char* uri, GError** error);
-void rygel_media_item_add_uri (RygelMediaItem* self, const char* uri, RygelThumbnail* thumbnail);
-GType rygel_transcoder_get_type (void);
-guint rygel_transcoder_get_distance (RygelTranscoder* self, RygelMediaItem* item);
-gint rygel_media_item_compare_transcoders (RygelMediaItem* self, void* a, void* b);
-static char* rygel_media_item_get_protocol_for_uri (RygelMediaItem* self, const char* uri, GError** error);
-GUPnPDIDLLiteResource* rygel_media_item_add_resource (RygelMediaItem* self, GUPnPDIDLLiteItem* didl_item, const char* uri, const char* protocol, GError** error);
-GUPnPDIDLLiteResource* rygel_thumbnail_add_resource (RygelThumbnail* self, GUPnPDIDLLiteItem* didl_item, const char* protocol);
-void rygel_media_item_add_resources (RygelMediaItem* self, GUPnPDIDLLiteItem* didl_item, gboolean allow_internal, GError** error);
-static GUPnPProtocolInfo* rygel_media_item_get_protocol_info (RygelMediaItem* self, const char* uri, const char* protocol);
-static void rygel_media_item_finalize (GObject* obj);
-static int _vala_strcmp0 (const char * str1, const char * str2);
-
-
-
-GQuark rygel_media_item_error_quark (void) {
-	return g_quark_from_static_string ("rygel_media_item_error-quark");
-}
-
-
-RygelMediaItem* rygel_media_item_construct (GType object_type, const char* id, RygelMediaContainer* parent, const char* title, const char* upnp_class) {
-	RygelMediaItem * self;
-	char* _tmp0_;
-	char* _tmp1_;
-	char* _tmp2_;
-	GeeArrayList* _tmp3_;
-	g_return_val_if_fail (id != NULL, NULL);
-	g_return_val_if_fail (parent != NULL, NULL);
-	g_return_val_if_fail (title != NULL, NULL);
-	g_return_val_if_fail (upnp_class != NULL, NULL);
-	self = (RygelMediaItem*) rygel_media_object_construct (object_type);
-	((RygelMediaObject*) self)->id = (_tmp0_ = g_strdup (id), _g_free0 (((RygelMediaObject*) self)->id), _tmp0_);
-	((RygelMediaObject*) self)->parent = parent;
-	((RygelMediaObject*) self)->title = (_tmp1_ = g_strdup (title), _g_free0 (((RygelMediaObject*) self)->title), _tmp1_);
-	self->upnp_class = (_tmp2_ = g_strdup (upnp_class), _g_free0 (self->upnp_class), _tmp2_);
-	self->thumbnails = (_tmp3_ = gee_array_list_new (RYGEL_TYPE_THUMBNAIL, (GBoxedCopyFunc) rygel_icon_info_ref, rygel_icon_info_unref, g_direct_equal), _g_object_unref0 (self->thumbnails), _tmp3_);
-	return self;
-}
-
-
-RygelMediaItem* rygel_media_item_new (const char* id, RygelMediaContainer* parent, const char* title, const char* upnp_class) {
-	return rygel_media_item_construct (RYGEL_TYPE_MEDIA_ITEM, id, parent, title, upnp_class);
-}
-
-
-static inline void _dynamic_set_tcp_timeout1 (GstElement* obj, gint64 value) {
-	g_object_set (obj, "tcp-timeout", value, NULL);
-}
-
-
-static GstElement* rygel_media_item_real_create_stream_source (RygelMediaItem* self) {
-	GstElement* result;
-	GstElement* src;
-	gboolean _tmp2_ = FALSE;
-	g_return_val_if_fail (self != NULL, NULL);
-	src = NULL;
-	if (gee_collection_get_size ((GeeCollection*) ((RygelMediaObject*) self)->uris) != 0) {
-		GstElement* _tmp1_;
-		char* _tmp0_;
-		src = (_tmp1_ = gst_element_make_from_uri (GST_URI_SRC, _tmp0_ = (char*) gee_abstract_list_get ((GeeAbstractList*) ((RygelMediaObject*) self)->uris, 0), NULL), _gst_object_unref0 (src), _tmp1_);
-		_g_free0 (_tmp0_);
-	}
-	if (src != NULL) {
-		_tmp2_ = _vala_strcmp0 (g_type_name (G_TYPE_FROM_INSTANCE ((GObject*) src)), "GstRTSPSrc") == 0;
-	} else {
-		_tmp2_ = FALSE;
-	}
-	if (_tmp2_) {
-		_dynamic_set_tcp_timeout1 (src, (gint64) 60000000);
-	}
-	result = src;
-	return result;
-}
-
-
-GstElement* rygel_media_item_create_stream_source (RygelMediaItem* self) {
-	return RYGEL_MEDIA_ITEM_GET_CLASS (self)->create_stream_source (self);
-}
-
-
-static gboolean rygel_media_item_real_should_stream (RygelMediaItem* self) {
-	gboolean result;
-	g_return_val_if_fail (self != NULL, FALSE);
-	result = self->size <= 0;
-	return result;
-}
-
-
-gboolean rygel_media_item_should_stream (RygelMediaItem* self) {
-	return RYGEL_MEDIA_ITEM_GET_CLASS (self)->should_stream (self);
-}
-
-
-void rygel_media_item_add_uri (RygelMediaItem* self, const char* uri, RygelThumbnail* thumbnail) {
-	GError * _inner_error_;
-	g_return_if_fail (self != NULL);
-	g_return_if_fail (uri != NULL);
-	_inner_error_ = NULL;
-	gee_abstract_collection_add ((GeeAbstractCollection*) ((RygelMediaObject*) self)->uris, uri);
-	if (thumbnail != NULL) {
-		gee_abstract_collection_add ((GeeAbstractCollection*) self->thumbnails, thumbnail);
-	} else {
-		gboolean _tmp0_ = FALSE;
-		if (g_str_has_prefix (self->upnp_class, RYGEL_MEDIA_ITEM_IMAGE_CLASS)) {
-			_tmp0_ = TRUE;
-		} else {
-			_tmp0_ = g_str_has_prefix (self->upnp_class, RYGEL_MEDIA_ITEM_VIDEO_CLASS);
-		}
-		if (_tmp0_) {
-			RygelThumbnailer* thumbnailer;
-			thumbnailer = rygel_thumbnailer_get_default ();
-			if (thumbnailer == NULL) {
-				_g_object_unref0 (thumbnailer);
-				return;
-			}
-			{
-				RygelThumbnail* thumb;
-				thumb = rygel_thumbnailer_get_thumbnail (thumbnailer, uri, &_inner_error_);
-				if (_inner_error_ != NULL) {
-					goto __catch33_g_error;
-					goto __finally33;
-				}
-				gee_abstract_collection_add ((GeeAbstractCollection*) self->thumbnails, thumb);
-				_rygel_icon_info_unref0 (thumb);
-			}
-			goto __finally33;
-			__catch33_g_error:
-			{
-				GError * err;
-				err = _inner_error_;
-				_inner_error_ = NULL;
-				{
-					_g_error_free0 (err);
-				}
-			}
-			__finally33:
-			if (_inner_error_ != NULL) {
-				_g_object_unref0 (thumbnailer);
-				g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
-				g_clear_error (&_inner_error_);
-				return;
-			}
-			_g_object_unref0 (thumbnailer);
-		}
-	}
-}
-
-
-static gpointer _g_object_ref0 (gpointer self) {
-	return self ? g_object_ref (self) : NULL;
-}
-
-
-gint rygel_media_item_compare_transcoders (RygelMediaItem* self, void* a, void* b) {
-	gint result;
-	RygelTranscoder* transcoder1;
-	RygelTranscoder* transcoder2;
-	g_return_val_if_fail (self != NULL, 0);
-	transcoder1 = _g_object_ref0 (RYGEL_TRANSCODER (a));
-	transcoder2 = _g_object_ref0 (RYGEL_TRANSCODER (b));
-	result = ((gint) rygel_transcoder_get_distance (transcoder1, self)) - ((gint) rygel_transcoder_get_distance (transcoder2, self));
-	_g_object_unref0 (transcoder1);
-	_g_object_unref0 (transcoder2);
-	return result;
-}
-
-
-void rygel_media_item_add_resources (RygelMediaItem* self, GUPnPDIDLLiteItem* didl_item, gboolean allow_internal, GError** error) {
-	GError * _inner_error_;
-	g_return_if_fail (self != NULL);
-	g_return_if_fail (didl_item != NULL);
-	_inner_error_ = NULL;
-	{
-		GeeIterator* _uri_it;
-		_uri_it = gee_abstract_collection_iterator ((GeeAbstractCollection*) ((RygelMediaObject*) self)->uris);
-		while (TRUE) {
-			char* uri;
-			char* protocol;
-			gboolean _tmp0_ = FALSE;
-			if (!gee_iterator_next (_uri_it)) {
-				break;
-			}
-			uri = (char*) gee_iterator_get (_uri_it);
-			protocol = rygel_media_item_get_protocol_for_uri (self, uri, &_inner_error_);
-			if (_inner_error_ != NULL) {
-				g_propagate_error (error, _inner_error_);
-				_g_free0 (uri);
-				_g_object_unref0 (_uri_it);
-				return;
-			}
-			if (allow_internal) {
-				_tmp0_ = TRUE;
-			} else {
-				_tmp0_ = _vala_strcmp0 (protocol, "internal") != 0;
-			}
-			if (_tmp0_) {
-				GUPnPDIDLLiteResource* _tmp1_;
-				_tmp1_ = rygel_media_item_add_resource (self, didl_item, uri, protocol, &_inner_error_);
-				if (_inner_error_ != NULL) {
-					g_propagate_error (error, _inner_error_);
-					_g_free0 (uri);
-					_g_free0 (protocol);
-					_g_object_unref0 (_uri_it);
-					return;
-				}
-				_g_object_unref0 (_tmp1_);
-			}
-			_g_free0 (uri);
-			_g_free0 (protocol);
-		}
-		_g_object_unref0 (_uri_it);
-	}
-	{
-		GeeIterator* _thumbnail_it;
-		_thumbnail_it = gee_abstract_collection_iterator ((GeeAbstractCollection*) self->thumbnails);
-		while (TRUE) {
-			RygelThumbnail* thumbnail;
-			char* protocol;
-			gboolean _tmp2_ = FALSE;
-			if (!gee_iterator_next (_thumbnail_it)) {
-				break;
-			}
-			thumbnail = (RygelThumbnail*) gee_iterator_get (_thumbnail_it);
-			protocol = rygel_media_item_get_protocol_for_uri (self, thumbnail->uri, &_inner_error_);
-			if (_inner_error_ != NULL) {
-				g_propagate_error (error, _inner_error_);
-				_rygel_icon_info_unref0 (thumbnail);
-				_g_object_unref0 (_thumbnail_it);
-				return;
-			}
-			if (allow_internal) {
-				_tmp2_ = TRUE;
-			} else {
-				_tmp2_ = _vala_strcmp0 (protocol, "internal") != 0;
-			}
-			if (_tmp2_) {
-				GUPnPDIDLLiteResource* _tmp3_;
-				_tmp3_ = rygel_thumbnail_add_resource (thumbnail, didl_item, protocol);
-				_g_object_unref0 (_tmp3_);
-			}
-			_rygel_icon_info_unref0 (thumbnail);
-			_g_free0 (protocol);
-		}
-		_g_object_unref0 (_thumbnail_it);
-	}
-}
-
-
-GUPnPDIDLLiteResource* rygel_media_item_add_resource (RygelMediaItem* self, GUPnPDIDLLiteItem* didl_item, const char* uri, const char* protocol, GError** error) {
-	GUPnPDIDLLiteResource* result;
-	GUPnPDIDLLiteResource* res;
-	GUPnPProtocolInfo* _tmp0_;
-	g_return_val_if_fail (self != NULL, NULL);
-	g_return_val_if_fail (didl_item != NULL, NULL);
-	g_return_val_if_fail (protocol != NULL, NULL);
-	res = gupnp_didl_lite_object_add_resource ((GUPnPDIDLLiteObject*) didl_item);
-	if (uri != NULL) {
-		gupnp_didl_lite_resource_set_uri (res, uri);
-	}
-	gupnp_didl_lite_resource_set_size (res, self->size);
-	gupnp_didl_lite_resource_set_duration (res, self->duration);
-	gupnp_didl_lite_resource_set_bitrate (res, self->bitrate);
-	gupnp_didl_lite_resource_set_sample_freq (res, self->sample_freq);
-	gupnp_didl_lite_resource_set_bits_per_sample (res, self->bits_per_sample);
-	gupnp_didl_lite_resource_set_audio_channels (res, self->n_audio_channels);
-	gupnp_didl_lite_resource_set_width (res, self->width);
-	gupnp_didl_lite_resource_set_height (res, self->height);
-	gupnp_didl_lite_resource_set_color_depth (res, self->color_depth);
-	gupnp_didl_lite_resource_set_protocol_info (res, _tmp0_ = rygel_media_item_get_protocol_info (self, uri, protocol));
-	_g_object_unref0 (_tmp0_);
-	result = res;
-	return result;
-}
-
-
-static GUPnPProtocolInfo* rygel_media_item_get_protocol_info (RygelMediaItem* self, const char* uri, const char* protocol) {
-	GUPnPProtocolInfo* result;
-	GUPnPProtocolInfo* protocol_info;
-	g_return_val_if_fail (self != NULL, NULL);
-	g_return_val_if_fail (protocol != NULL, NULL);
-	protocol_info = gupnp_protocol_info_new ();
-	gupnp_protocol_info_set_mime_type (protocol_info, self->mime_type);
-	gupnp_protocol_info_set_dlna_profile (protocol_info, self->dlna_profile);
-	gupnp_protocol_info_set_protocol (protocol_info, protocol);
-	if (g_str_has_prefix (self->upnp_class, RYGEL_MEDIA_ITEM_IMAGE_CLASS)) {
-		gupnp_protocol_info_set_dlna_flags (protocol_info, gupnp_protocol_info_get_dlna_flags (protocol_info) | GUPNP_DLNA_FLAGS_INTERACTIVE_TRANSFER_MODE);
-	} else {
-		gupnp_protocol_info_set_dlna_flags (protocol_info, gupnp_protocol_info_get_dlna_flags (protocol_info) | GUPNP_DLNA_FLAGS_STREAMING_TRANSFER_MODE);
-	}
-	if (!rygel_media_item_should_stream (self)) {
-		gupnp_protocol_info_set_dlna_operation (protocol_info, GUPNP_DLNA_OPERATION_RANGE);
-		gupnp_protocol_info_set_dlna_flags (protocol_info, gupnp_protocol_info_get_dlna_flags (protocol_info) | GUPNP_DLNA_FLAGS_BACKGROUND_TRANSFER_MODE);
-	}
-	result = protocol_info;
-	return result;
-}
-
-
-static char* rygel_media_item_get_protocol_for_uri (RygelMediaItem* self, const char* uri, GError** error) {
-	char* result;
-	GError * _inner_error_;
-	char* scheme;
-	g_return_val_if_fail (self != NULL, NULL);
-	g_return_val_if_fail (uri != NULL, NULL);
-	_inner_error_ = NULL;
-	scheme = g_uri_parse_scheme (uri);
-	if (scheme == NULL) {
-		_inner_error_ = g_error_new (RYGEL_MEDIA_ITEM_ERROR, RYGEL_MEDIA_ITEM_ERROR_BAD_URI, "Bad URI: %s", uri);
-		if (_inner_error_ != NULL) {
-			g_propagate_error (error, _inner_error_);
-			_g_free0 (scheme);
-			return NULL;
-		}
-	}
-	if (_vala_strcmp0 (scheme, "http") == 0) {
-		result = g_strdup ("http-get");
-		_g_free0 (scheme);
-		return result;
-	} else {
-		if (_vala_strcmp0 (scheme, "file") == 0) {
-			result = g_strdup ("internal");
-			_g_free0 (scheme);
-			return result;
-		} else {
-			if (_vala_strcmp0 (scheme, "rtsp") == 0) {
-				result = g_strdup ("rtsp-rtp-udp");
-				_g_free0 (scheme);
-				return result;
-			} else {
-				g_warning ("rygel-media-item.vala:223: Failed to probe protocol for URI %s. Assuming '%s'", uri, scheme);
-				result = scheme;
-				return result;
-			}
-		}
-	}
-	_g_free0 (scheme);
-}
-
-
-static void rygel_media_item_class_init (RygelMediaItemClass * klass) {
-	rygel_media_item_parent_class = g_type_class_peek_parent (klass);
-	RYGEL_MEDIA_ITEM_CLASS (klass)->create_stream_source = rygel_media_item_real_create_stream_source;
-	RYGEL_MEDIA_ITEM_CLASS (klass)->should_stream = rygel_media_item_real_should_stream;
-	G_OBJECT_CLASS (klass)->finalize = rygel_media_item_finalize;
-}
-
-
-static void rygel_media_item_instance_init (RygelMediaItem * self) {
-	self->size = (glong) (-1);
-	self->duration = (glong) (-1);
-	self->bitrate = -1;
-	self->sample_freq = -1;
-	self->bits_per_sample = -1;
-	self->n_audio_channels = -1;
-	self->track_number = -1;
-	self->width = -1;
-	self->height = -1;
-	self->pixel_width = -1;
-	self->pixel_height = -1;
-	self->color_depth = -1;
-}
-
-
-static void rygel_media_item_finalize (GObject* obj) {
-	RygelMediaItem * self;
-	self = RYGEL_MEDIA_ITEM (obj);
-	_g_free0 (self->author);
-	_g_free0 (self->album);
-	_g_free0 (self->date);
-	_g_free0 (self->upnp_class);
-	_g_free0 (self->mime_type);
-	_g_free0 (self->dlna_profile);
-	_g_object_unref0 (self->thumbnails);
-	G_OBJECT_CLASS (rygel_media_item_parent_class)->finalize (obj);
-}
-
-
-GType rygel_media_item_get_type (void) {
-	static GType rygel_media_item_type_id = 0;
-	if (rygel_media_item_type_id == 0) {
-		static const GTypeInfo g_define_type_info = { sizeof (RygelMediaItemClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) rygel_media_item_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (RygelMediaItem), 0, (GInstanceInitFunc) rygel_media_item_instance_init, NULL };
-		rygel_media_item_type_id = g_type_register_static (RYGEL_TYPE_MEDIA_OBJECT, "RygelMediaItem", &g_define_type_info, 0);
-	}
-	return rygel_media_item_type_id;
-}
-
-
-static int _vala_strcmp0 (const char * str1, const char * str2) {
-	if (str1 == NULL) {
-		return -(str1 != str2);
-	}
-	if (str2 == NULL) {
-		return str1 != str2;
-	}
-	return strcmp (str1, str2);
-}
-
-
-
-
--- a/src/rygel/rygel-media-object-search.c
+++ /dev/null
@@ -1,348 +0,0 @@
-/* rygel-media-object-search.c generated by valac, the Vala compiler
- * generated from rygel-media-object-search.vala, do not modify */
-
-/*
- * Copyright (C) 2009 Zeeshan Ali (Khattak) <zeeshanak@gnome.org>.
- * Copyright (C) 2009 Nokia Corporation.
- *
- * Author: Zeeshan Ali (Khattak) <zeeshanak@gnome.org>
- *                               <zeeshan.ali@nokia.com>
- *
- * This file is part of Rygel.
- *
- * Rygel is free software; you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * Rygel is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this program; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
- */
-
-#include <glib.h>
-#include <glib-object.h>
-#include <gio/gio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <gee.h>
-
-
-#define RYGEL_TYPE_STATE_MACHINE (rygel_state_machine_get_type ())
-#define RYGEL_STATE_MACHINE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_STATE_MACHINE, RygelStateMachine))
-#define RYGEL_IS_STATE_MACHINE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_STATE_MACHINE))
-#define RYGEL_STATE_MACHINE_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), RYGEL_TYPE_STATE_MACHINE, RygelStateMachineIface))
-
-typedef struct _RygelStateMachine RygelStateMachine;
-typedef struct _RygelStateMachineIface RygelStateMachineIface;
-
-#define RYGEL_TYPE_MEDIA_OBJECT_SEARCH (rygel_media_object_search_get_type ())
-#define RYGEL_MEDIA_OBJECT_SEARCH(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_MEDIA_OBJECT_SEARCH, RygelMediaObjectSearch))
-#define RYGEL_MEDIA_OBJECT_SEARCH_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_MEDIA_OBJECT_SEARCH, RygelMediaObjectSearchClass))
-#define RYGEL_IS_MEDIA_OBJECT_SEARCH(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_MEDIA_OBJECT_SEARCH))
-#define RYGEL_IS_MEDIA_OBJECT_SEARCH_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_MEDIA_OBJECT_SEARCH))
-#define RYGEL_MEDIA_OBJECT_SEARCH_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_MEDIA_OBJECT_SEARCH, RygelMediaObjectSearchClass))
-
-typedef struct _RygelMediaObjectSearch RygelMediaObjectSearch;
-typedef struct _RygelMediaObjectSearchClass RygelMediaObjectSearchClass;
-typedef struct _RygelMediaObjectSearchPrivate RygelMediaObjectSearchPrivate;
-
-#define RYGEL_TYPE_MEDIA_OBJECT (rygel_media_object_get_type ())
-#define RYGEL_MEDIA_OBJECT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_MEDIA_OBJECT, RygelMediaObject))
-#define RYGEL_MEDIA_OBJECT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_MEDIA_OBJECT, RygelMediaObjectClass))
-#define RYGEL_IS_MEDIA_OBJECT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_MEDIA_OBJECT))
-#define RYGEL_IS_MEDIA_OBJECT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_MEDIA_OBJECT))
-#define RYGEL_MEDIA_OBJECT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_MEDIA_OBJECT, RygelMediaObjectClass))
-
-typedef struct _RygelMediaObject RygelMediaObject;
-typedef struct _RygelMediaObjectClass RygelMediaObjectClass;
-
-#define RYGEL_TYPE_MEDIA_CONTAINER (rygel_media_container_get_type ())
-#define RYGEL_MEDIA_CONTAINER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_MEDIA_CONTAINER, RygelMediaContainer))
-#define RYGEL_MEDIA_CONTAINER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_MEDIA_CONTAINER, RygelMediaContainerClass))
-#define RYGEL_IS_MEDIA_CONTAINER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_MEDIA_CONTAINER))
-#define RYGEL_IS_MEDIA_CONTAINER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_MEDIA_CONTAINER))
-#define RYGEL_MEDIA_CONTAINER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_MEDIA_CONTAINER, RygelMediaContainerClass))
-
-typedef struct _RygelMediaContainer RygelMediaContainer;
-typedef struct _RygelMediaContainerClass RygelMediaContainerClass;
-#define _g_free0(var) (var = (g_free (var), NULL))
-#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
-#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
-#define _g_destroy_func0(var) (((var == NULL) || (g_destroy_func == NULL)) ? NULL : (var = (g_destroy_func (var), NULL)))
-
-struct _RygelStateMachineIface {
-	GTypeInterface parent_iface;
-	void (*run) (RygelStateMachine* self);
-	GCancellable* (*get_cancellable) (RygelStateMachine* self);
-	void (*set_cancellable) (RygelStateMachine* self, GCancellable* value);
-};
-
-struct _RygelMediaObjectSearch {
-	GObject parent_instance;
-	RygelMediaObjectSearchPrivate * priv;
-	char* id;
-	gpointer data;
-	RygelMediaObject* media_object;
-	GError* error;
-};
-
-struct _RygelMediaObjectSearchClass {
-	GObjectClass parent_class;
-};
-
-struct _RygelMediaObjectSearchPrivate {
-	GType g_type;
-	GBoxedCopyFunc g_dup_func;
-	GDestroyNotify g_destroy_func;
-	GeeArrayList* containers;
-	GCancellable* _cancellable;
-};
-
-
-static gpointer rygel_media_object_search_parent_class = NULL;
-static RygelStateMachineIface* rygel_media_object_search_rygel_state_machine_parent_iface = NULL;
-
-GType rygel_state_machine_get_type (void);
-GType rygel_media_object_search_get_type (void);
-GType rygel_media_object_get_type (void);
-GType rygel_media_container_get_type (void);
-#define RYGEL_MEDIA_OBJECT_SEARCH_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), RYGEL_TYPE_MEDIA_OBJECT_SEARCH, RygelMediaObjectSearchPrivate))
-enum  {
-	RYGEL_MEDIA_OBJECT_SEARCH_DUMMY_PROPERTY,
-	RYGEL_MEDIA_OBJECT_SEARCH_CANCELLABLE,
-	RYGEL_MEDIA_OBJECT_SEARCH_G_TYPE,
-	RYGEL_MEDIA_OBJECT_SEARCH_G_DUP_FUNC,
-	RYGEL_MEDIA_OBJECT_SEARCH_G_DESTROY_FUNC
-};
-void rygel_state_machine_set_cancellable (RygelStateMachine* self, GCancellable* value);
-RygelMediaObjectSearch* rygel_media_object_search_new (GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, const char* id, GeeArrayList* containers, gconstpointer data, GCancellable* cancellable);
-RygelMediaObjectSearch* rygel_media_object_search_construct (GType object_type, GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, const char* id, GeeArrayList* containers, gconstpointer data, GCancellable* cancellable);
-void rygel_media_container_find_object (RygelMediaContainer* self, const char* id, GCancellable* cancellable, GAsyncReadyCallback callback, void* callback_target);
-GCancellable* rygel_state_machine_get_cancellable (RygelStateMachine* self);
-static void rygel_media_object_search_on_object_found (RygelMediaObjectSearch* self, GObject* source_object, GAsyncResult* res);
-static void _rygel_media_object_search_on_object_found_gasync_ready_callback (GObject* source_object, GAsyncResult* res, gpointer self);
-static void rygel_media_object_search_real_run (RygelStateMachine* base);
-RygelMediaObject* rygel_media_container_find_object_finish (RygelMediaContainer* self, GAsyncResult* res, GError** error);
-void rygel_state_machine_run (RygelStateMachine* self);
-static void rygel_media_object_search_finalize (GObject* obj);
-static void rygel_media_object_search_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
-static void rygel_media_object_search_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);
-
-
-
-static gpointer _g_object_ref0 (gpointer self) {
-	return self ? g_object_ref (self) : NULL;
-}
-
-
-RygelMediaObjectSearch* rygel_media_object_search_construct (GType object_type, GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, const char* id, GeeArrayList* containers, gconstpointer data, GCancellable* cancellable) {
-	RygelMediaObjectSearch * self;
-	char* _tmp0_;
-	GeeArrayList* _tmp1_;
-	gpointer _tmp3_;
-	gconstpointer _tmp2_;
-	g_return_val_if_fail (id != NULL, NULL);
-	g_return_val_if_fail (containers != NULL, NULL);
-	self = (RygelMediaObjectSearch*) g_object_new (object_type, NULL);
-	self->priv->g_type = g_type;
-	self->priv->g_dup_func = g_dup_func;
-	self->priv->g_destroy_func = g_destroy_func;
-	self->id = (_tmp0_ = g_strdup (id), _g_free0 (self->id), _tmp0_);
-	self->priv->containers = (_tmp1_ = _g_object_ref0 (containers), _g_object_unref0 (self->priv->containers), _tmp1_);
-	self->data = (_tmp3_ = (_tmp2_ = data, ((_tmp2_ == NULL) || (g_dup_func == NULL)) ? ((gpointer) _tmp2_) : g_dup_func ((gpointer) _tmp2_)), _g_destroy_func0 (self->data), _tmp3_);
-	rygel_state_machine_set_cancellable ((RygelStateMachine*) self, cancellable);
-	return self;
-}
-
-
-RygelMediaObjectSearch* rygel_media_object_search_new (GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, const char* id, GeeArrayList* containers, gconstpointer data, GCancellable* cancellable) {
-	return rygel_media_object_search_construct (RYGEL_TYPE_MEDIA_OBJECT_SEARCH, g_type, g_dup_func, g_destroy_func, id, containers, data, cancellable);
-}
-
-
-static void _rygel_media_object_search_on_object_found_gasync_ready_callback (GObject* source_object, GAsyncResult* res, gpointer self) {
-	rygel_media_object_search_on_object_found (self, source_object, res);
-}
-
-
-static void rygel_media_object_search_real_run (RygelStateMachine* base) {
-	RygelMediaObjectSearch * self;
-	self = (RygelMediaObjectSearch*) base;
-	if (gee_collection_get_size ((GeeCollection*) self->priv->containers) > 0) {
-		RygelMediaContainer* container;
-		container = (RygelMediaContainer*) gee_abstract_list_get ((GeeAbstractList*) self->priv->containers, 0);
-		rygel_media_container_find_object (container, self->id, rygel_state_machine_get_cancellable ((RygelStateMachine*) self), _rygel_media_object_search_on_object_found_gasync_ready_callback, self);
-		_g_object_unref0 (container);
-	} else {
-		g_signal_emit_by_name ((RygelStateMachine*) self, "completed");
-	}
-}
-
-
-static gpointer _g_error_copy0 (gpointer self) {
-	return self ? g_error_copy (self) : NULL;
-}
-
-
-static void rygel_media_object_search_on_object_found (RygelMediaObjectSearch* self, GObject* source_object, GAsyncResult* res) {
-	GError * _inner_error_;
-	g_return_if_fail (self != NULL);
-	g_return_if_fail (res != NULL);
-	_inner_error_ = NULL;
-	{
-		GObject* _tmp0_;
-		RygelMediaContainer* container;
-		RygelMediaObject* _tmp1_;
-		RygelMediaObject* _tmp2_;
-		container = _g_object_ref0 ((_tmp0_ = source_object, RYGEL_IS_MEDIA_CONTAINER (_tmp0_) ? ((RygelMediaContainer*) _tmp0_) : NULL));
-		_tmp1_ = rygel_media_container_find_object_finish (container, res, &_inner_error_);
-		if (_inner_error_ != NULL) {
-			_g_object_unref0 (container);
-			goto __catch32_g_error;
-			goto __finally32;
-		}
-		self->media_object = (_tmp2_ = _tmp1_, _g_object_unref0 (self->media_object), _tmp2_);
-		if (self->media_object == NULL) {
-			gee_abstract_list_remove_at ((GeeAbstractList*) self->priv->containers, 0);
-			rygel_state_machine_run ((RygelStateMachine*) self);
-		} else {
-			g_signal_emit_by_name ((RygelStateMachine*) self, "completed");
-		}
-		_g_object_unref0 (container);
-	}
-	goto __finally32;
-	__catch32_g_error:
-	{
-		GError * err;
-		err = _inner_error_;
-		_inner_error_ = NULL;
-		{
-			GError* _tmp3_;
-			self->error = (_tmp3_ = _g_error_copy0 (err), _g_error_free0 (self->error), _tmp3_);
-			g_signal_emit_by_name ((RygelStateMachine*) self, "completed");
-			_g_error_free0 (err);
-		}
-	}
-	__finally32:
-	if (_inner_error_ != NULL) {
-		g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
-		g_clear_error (&_inner_error_);
-		return;
-	}
-}
-
-
-static GCancellable* rygel_media_object_search_real_get_cancellable (RygelStateMachine* base) {
-	GCancellable* result;
-	RygelMediaObjectSearch* self;
-	self = (RygelMediaObjectSearch*) base;
-	result = self->priv->_cancellable;
-	return result;
-}
-
-
-static void rygel_media_object_search_real_set_cancellable (RygelStateMachine* base, GCancellable* value) {
-	RygelMediaObjectSearch* self;
-	GCancellable* _tmp0_;
-	self = (RygelMediaObjectSearch*) base;
-	self->priv->_cancellable = (_tmp0_ = _g_object_ref0 (value), _g_object_unref0 (self->priv->_cancellable), _tmp0_);
-	g_object_notify ((GObject *) self, "cancellable");
-}
-
-
-static void rygel_media_object_search_class_init (RygelMediaObjectSearchClass * klass) {
-	rygel_media_object_search_parent_class = g_type_class_peek_parent (klass);
-	g_type_class_add_private (klass, sizeof (RygelMediaObjectSearchPrivate));
-	G_OBJECT_CLASS (klass)->get_property = rygel_media_object_search_get_property;
-	G_OBJECT_CLASS (klass)->set_property = rygel_media_object_search_set_property;
-	G_OBJECT_CLASS (klass)->finalize = rygel_media_object_search_finalize;
-	g_object_class_install_property (G_OBJECT_CLASS (klass), RYGEL_MEDIA_OBJECT_SEARCH_G_TYPE, g_param_spec_gtype ("g-type", "type", "type", G_TYPE_NONE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
-	g_object_class_install_property (G_OBJECT_CLASS (klass), RYGEL_MEDIA_OBJECT_SEARCH_G_DUP_FUNC, g_param_spec_pointer ("g-dup-func", "dup func", "dup func", G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
-	g_object_class_install_property (G_OBJECT_CLASS (klass), RYGEL_MEDIA_OBJECT_SEARCH_G_DESTROY_FUNC, g_param_spec_pointer ("g-destroy-func", "destroy func", "destroy func", G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
-	g_object_class_override_property (G_OBJECT_CLASS (klass), RYGEL_MEDIA_OBJECT_SEARCH_CANCELLABLE, "cancellable");
-}
-
-
-static void rygel_media_object_search_rygel_state_machine_interface_init (RygelStateMachineIface * iface) {
-	rygel_media_object_search_rygel_state_machine_parent_iface = g_type_interface_peek_parent (iface);
-	iface->run = rygel_media_object_search_real_run;
-	iface->get_cancellable = rygel_media_object_search_real_get_cancellable;
-	iface->set_cancellable = rygel_media_object_search_real_set_cancellable;
-}
-
-
-static void rygel_media_object_search_instance_init (RygelMediaObjectSearch * self) {
-	self->priv = RYGEL_MEDIA_OBJECT_SEARCH_GET_PRIVATE (self);
-}
-
-
-static void rygel_media_object_search_finalize (GObject* obj) {
-	RygelMediaObjectSearch * self;
-	self = RYGEL_MEDIA_OBJECT_SEARCH (obj);
-	_g_free0 (self->id);
-	_g_object_unref0 (self->priv->containers);
-	((self->data == NULL) || (self->priv->g_destroy_func == NULL)) ? NULL : (self->data = (self->priv->g_destroy_func (self->data), NULL));
-	_g_object_unref0 (self->priv->_cancellable);
-	_g_object_unref0 (self->media_object);
-	_g_error_free0 (self->error);
-	G_OBJECT_CLASS (rygel_media_object_search_parent_class)->finalize (obj);
-}
-
-
-GType rygel_media_object_search_get_type (void) {
-	static GType rygel_media_object_search_type_id = 0;
-	if (rygel_media_object_search_type_id == 0) {
-		static const GTypeInfo g_define_type_info = { sizeof (RygelMediaObjectSearchClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) rygel_media_object_search_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (RygelMediaObjectSearch), 0, (GInstanceInitFunc) rygel_media_object_search_instance_init, NULL };
-		static const GInterfaceInfo rygel_state_machine_info = { (GInterfaceInitFunc) rygel_media_object_search_rygel_state_machine_interface_init, (GInterfaceFinalizeFunc) NULL, NULL};
-		rygel_media_object_search_type_id = g_type_register_static (G_TYPE_OBJECT, "RygelMediaObjectSearch", &g_define_type_info, 0);
-		g_type_add_interface_static (rygel_media_object_search_type_id, RYGEL_TYPE_STATE_MACHINE, &rygel_state_machine_info);
-	}
-	return rygel_media_object_search_type_id;
-}
-
-
-static void rygel_media_object_search_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
-	RygelMediaObjectSearch * self;
-	self = RYGEL_MEDIA_OBJECT_SEARCH (object);
-	switch (property_id) {
-		case RYGEL_MEDIA_OBJECT_SEARCH_CANCELLABLE:
-		g_value_set_object (value, rygel_state_machine_get_cancellable ((RygelStateMachine*) self));
-		break;
-		default:
-		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
-		break;
-	}
-}
-
-
-static void rygel_media_object_search_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
-	RygelMediaObjectSearch * self;
-	self = RYGEL_MEDIA_OBJECT_SEARCH (object);
-	switch (property_id) {
-		case RYGEL_MEDIA_OBJECT_SEARCH_CANCELLABLE:
-		rygel_state_machine_set_cancellable ((RygelStateMachine*) self, g_value_get_object (value));
-		break;
-		default:
-		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
-		break;
-		case RYGEL_MEDIA_OBJECT_SEARCH_G_TYPE:
-		self->priv->g_type = g_value_get_gtype (value);
-		break;
-		case RYGEL_MEDIA_OBJECT_SEARCH_G_DUP_FUNC:
-		self->priv->g_dup_func = g_value_get_pointer (value);
-		break;
-		case RYGEL_MEDIA_OBJECT_SEARCH_G_DESTROY_FUNC:
-		self->priv->g_destroy_func = g_value_get_pointer (value);
-		break;
-	}
-}
-
-
-
-
--- a/src/rygel/rygel-media-object.c
+++ /dev/null
@@ -1,140 +0,0 @@
-/* rygel-media-object.c generated by valac, the Vala compiler
- * generated from rygel-media-object.vala, do not modify */
-
-/*
- * Copyright (C) 2008 Zeeshan Ali <zeenix@gmail.com>.
- *
- * Author: Zeeshan Ali <zeenix@gmail.com>
- *
- * This file is part of Rygel.
- *
- * Rygel is free software; you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * Rygel is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this program; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
- */
-
-#include <glib.h>
-#include <glib-object.h>
-#include <stdlib.h>
-#include <string.h>
-#include <gee.h>
-
-
-#define RYGEL_TYPE_MEDIA_OBJECT (rygel_media_object_get_type ())
-#define RYGEL_MEDIA_OBJECT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_MEDIA_OBJECT, RygelMediaObject))
-#define RYGEL_MEDIA_OBJECT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_MEDIA_OBJECT, RygelMediaObjectClass))
-#define RYGEL_IS_MEDIA_OBJECT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_MEDIA_OBJECT))
-#define RYGEL_IS_MEDIA_OBJECT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_MEDIA_OBJECT))
-#define RYGEL_MEDIA_OBJECT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_MEDIA_OBJECT, RygelMediaObjectClass))
-
-typedef struct _RygelMediaObject RygelMediaObject;
-typedef struct _RygelMediaObjectClass RygelMediaObjectClass;
-typedef struct _RygelMediaObjectPrivate RygelMediaObjectPrivate;
-
-#define RYGEL_TYPE_MEDIA_CONTAINER (rygel_media_container_get_type ())
-#define RYGEL_MEDIA_CONTAINER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_MEDIA_CONTAINER, RygelMediaContainer))
-#define RYGEL_MEDIA_CONTAINER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_MEDIA_CONTAINER, RygelMediaContainerClass))
-#define RYGEL_IS_MEDIA_CONTAINER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_MEDIA_CONTAINER))
-#define RYGEL_IS_MEDIA_CONTAINER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_MEDIA_CONTAINER))
-#define RYGEL_MEDIA_CONTAINER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_MEDIA_CONTAINER, RygelMediaContainerClass))
-
-typedef struct _RygelMediaContainer RygelMediaContainer;
-typedef struct _RygelMediaContainerClass RygelMediaContainerClass;
-#define _g_free0(var) (var = (g_free (var), NULL))
-#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
-
-struct _RygelMediaObject {
-	GObject parent_instance;
-	RygelMediaObjectPrivate * priv;
-	char* id;
-	char* title;
-	guint64 modified;
-	GeeArrayList* uris;
-	RygelMediaContainer* parent;
-	RygelMediaContainer* parent_ref;
-};
-
-struct _RygelMediaObjectClass {
-	GObjectClass parent_class;
-};
-
-
-static gpointer rygel_media_object_parent_class = NULL;
-
-GType rygel_media_object_get_type (void);
-GType rygel_media_container_get_type (void);
-enum  {
-	RYGEL_MEDIA_OBJECT_DUMMY_PROPERTY
-};
-RygelMediaObject* rygel_media_object_construct (GType object_type);
-static GObject * rygel_media_object_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties);
-static void rygel_media_object_finalize (GObject* obj);
-
-
-
-RygelMediaObject* rygel_media_object_construct (GType object_type) {
-	RygelMediaObject * self;
-	self = g_object_newv (object_type, 0, NULL);
-	return self;
-}
-
-
-static GObject * rygel_media_object_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties) {
-	GObject * obj;
-	GObjectClass * parent_class;
-	RygelMediaObject * self;
-	parent_class = G_OBJECT_CLASS (rygel_media_object_parent_class);
-	obj = parent_class->constructor (type, n_construct_properties, construct_properties);
-	self = RYGEL_MEDIA_OBJECT (obj);
-	{
-		GeeArrayList* _tmp0_;
-		self->uris = (_tmp0_ = gee_array_list_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, g_direct_equal), _g_object_unref0 (self->uris), _tmp0_);
-	}
-	return obj;
-}
-
-
-static void rygel_media_object_class_init (RygelMediaObjectClass * klass) {
-	rygel_media_object_parent_class = g_type_class_peek_parent (klass);
-	G_OBJECT_CLASS (klass)->constructor = rygel_media_object_constructor;
-	G_OBJECT_CLASS (klass)->finalize = rygel_media_object_finalize;
-}
-
-
-static void rygel_media_object_instance_init (RygelMediaObject * self) {
-}
-
-
-static void rygel_media_object_finalize (GObject* obj) {
-	RygelMediaObject * self;
-	self = RYGEL_MEDIA_OBJECT (obj);
-	_g_free0 (self->id);
-	_g_free0 (self->title);
-	_g_object_unref0 (self->uris);
-	_g_object_unref0 (self->parent_ref);
-	G_OBJECT_CLASS (rygel_media_object_parent_class)->finalize (obj);
-}
-
-
-GType rygel_media_object_get_type (void) {
-	static GType rygel_media_object_type_id = 0;
-	if (rygel_media_object_type_id == 0) {
-		static const GTypeInfo g_define_type_info = { sizeof (RygelMediaObjectClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) rygel_media_object_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (RygelMediaObject), 0, (GInstanceInitFunc) rygel_media_object_instance_init, NULL };
-		rygel_media_object_type_id = g_type_register_static (G_TYPE_OBJECT, "RygelMediaObject", &g_define_type_info, G_TYPE_FLAG_ABSTRACT);
-	}
-	return rygel_media_object_type_id;
-}
-
-
-
-
--- a/src/rygel/rygel-meta-config.c
+++ /dev/null
@@ -1,1271 +0,0 @@
-/* rygel-meta-config.c generated by valac, the Vala compiler
- * generated from rygel-meta-config.vala, do not modify */
-
-/*
- * Copyright (C) 2008,2009 Nokia Corporation.
- * Copyright (C) 2008,2009 Zeeshan Ali (Khattak) <zeeshanak@gnome.org>.
- *
- * Author: Zeeshan Ali (Khattak) <zeeshanak@gnome.org>
- *                               <zeeshan.ali@nokia.com>
- *
- * This file is part of Rygel.
- *
- * Rygel is free software; you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * Rygel is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this program; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
- */
-
-#include <glib.h>
-#include <glib-object.h>
-#include <stdlib.h>
-#include <string.h>
-#include <gee.h>
-
-
-#define RYGEL_TYPE_CONFIGURATION (rygel_configuration_get_type ())
-#define RYGEL_CONFIGURATION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_CONFIGURATION, RygelConfiguration))
-#define RYGEL_IS_CONFIGURATION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_CONFIGURATION))
-#define RYGEL_CONFIGURATION_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), RYGEL_TYPE_CONFIGURATION, RygelConfigurationIface))
-
-typedef struct _RygelConfiguration RygelConfiguration;
-typedef struct _RygelConfigurationIface RygelConfigurationIface;
-
-#define RYGEL_TYPE_LOG_LEVEL (rygel_log_level_get_type ())
-
-#define RYGEL_TYPE_META_CONFIG (rygel_meta_config_get_type ())
-#define RYGEL_META_CONFIG(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_META_CONFIG, RygelMetaConfig))
-#define RYGEL_META_CONFIG_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_META_CONFIG, RygelMetaConfigClass))
-#define RYGEL_IS_META_CONFIG(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_META_CONFIG))
-#define RYGEL_IS_META_CONFIG_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_META_CONFIG))
-#define RYGEL_META_CONFIG_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_META_CONFIG, RygelMetaConfigClass))
-
-typedef struct _RygelMetaConfig RygelMetaConfig;
-typedef struct _RygelMetaConfigClass RygelMetaConfigClass;
-typedef struct _RygelMetaConfigPrivate RygelMetaConfigPrivate;
-#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
-
-#define RYGEL_TYPE_CMDLINE_CONFIG (rygel_cmdline_config_get_type ())
-#define RYGEL_CMDLINE_CONFIG(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_CMDLINE_CONFIG, RygelCmdlineConfig))
-#define RYGEL_CMDLINE_CONFIG_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_CMDLINE_CONFIG, RygelCmdlineConfigClass))
-#define RYGEL_IS_CMDLINE_CONFIG(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_CMDLINE_CONFIG))
-#define RYGEL_IS_CMDLINE_CONFIG_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_CMDLINE_CONFIG))
-#define RYGEL_CMDLINE_CONFIG_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_CMDLINE_CONFIG, RygelCmdlineConfigClass))
-
-typedef struct _RygelCmdlineConfig RygelCmdlineConfig;
-typedef struct _RygelCmdlineConfigClass RygelCmdlineConfigClass;
-
-#define RYGEL_TYPE_USER_CONFIG (rygel_user_config_get_type ())
-#define RYGEL_USER_CONFIG(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_USER_CONFIG, RygelUserConfig))
-#define RYGEL_USER_CONFIG_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_USER_CONFIG, RygelUserConfigClass))
-#define RYGEL_IS_USER_CONFIG(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_USER_CONFIG))
-#define RYGEL_IS_USER_CONFIG_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_USER_CONFIG))
-#define RYGEL_USER_CONFIG_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_USER_CONFIG, RygelUserConfigClass))
-
-typedef struct _RygelUserConfig RygelUserConfig;
-typedef struct _RygelUserConfigClass RygelUserConfigClass;
-#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
-#define _g_free0(var) (var = (g_free (var), NULL))
-
-typedef enum  {
-	RYGEL_LOG_LEVEL_INVALID = 0,
-	RYGEL_LOG_LEVEL_CRITICAL = 1,
-	RYGEL_LOG_LEVEL_ERROR = 2,
-	RYGEL_LOG_LEVEL_WARNING = 3,
-	RYGEL_LOG_LEVEL_INFO = 4,
-	RYGEL_LOG_LEVEL_DEFAULT = 4,
-	RYGEL_LOG_LEVEL_DEBUG = 5
-} RygelLogLevel;
-
-struct _RygelConfigurationIface {
-	GTypeInterface parent_iface;
-	gboolean (*get_upnp_enabled) (RygelConfiguration* self, GError** error);
-	char* (*get_interface) (RygelConfiguration* self, GError** error);
-	gint (*get_port) (RygelConfiguration* self, GError** error);
-	gboolean (*get_transcoding) (RygelConfiguration* self, GError** error);
-	gboolean (*get_mp3_transcoder) (RygelConfiguration* self, GError** error);
-	gboolean (*get_mp2ts_transcoder) (RygelConfiguration* self, GError** error);
-	gboolean (*get_lpcm_transcoder) (RygelConfiguration* self, GError** error);
-	RygelLogLevel (*get_log_level) (RygelConfiguration* self, GError** error);
-	gboolean (*get_enabled) (RygelConfiguration* self, const char* section, GError** error);
-	char* (*get_title) (RygelConfiguration* self, const char* section, GError** error);
-	char* (*get_string) (RygelConfiguration* self, const char* section, const char* key, GError** error);
-	GeeArrayList* (*get_string_list) (RygelConfiguration* self, const char* section, const char* key, GError** error);
-	gint (*get_int) (RygelConfiguration* self, const char* section, const char* key, gint min, gint max, GError** error);
-	GeeArrayList* (*get_int_list) (RygelConfiguration* self, const char* section, const char* key, GError** error);
-	gboolean (*get_bool) (RygelConfiguration* self, const char* section, const char* key, GError** error);
-};
-
-struct _RygelMetaConfig {
-	GObject parent_instance;
-	RygelMetaConfigPrivate * priv;
-};
-
-struct _RygelMetaConfigClass {
-	GObjectClass parent_class;
-};
-
-struct _RygelMetaConfigPrivate {
-	GeeArrayList* configs;
-};
-
-typedef enum  {
-	RYGEL_CONFIGURATION_ERROR_NO_VALUE_SET,
-	RYGEL_CONFIGURATION_ERROR_VALUE_OUT_OF_RANGE
-} RygelConfigurationError;
-#define RYGEL_CONFIGURATION_ERROR rygel_configuration_error_quark ()
-
-static RygelMetaConfig* rygel_meta_config_meta_config;
-static RygelMetaConfig* rygel_meta_config_meta_config = NULL;
-static gpointer rygel_meta_config_parent_class = NULL;
-static RygelConfigurationIface* rygel_meta_config_rygel_configuration_parent_iface = NULL;
-
-GType rygel_log_level_get_type (void);
-GType rygel_configuration_get_type (void);
-GType rygel_meta_config_get_type (void);
-#define RYGEL_META_CONFIG_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), RYGEL_TYPE_META_CONFIG, RygelMetaConfigPrivate))
-enum  {
-	RYGEL_META_CONFIG_DUMMY_PROPERTY
-};
-RygelMetaConfig* rygel_meta_config_new (void);
-RygelMetaConfig* rygel_meta_config_construct (GType object_type);
-RygelMetaConfig* rygel_meta_config_get_default (void);
-GType rygel_cmdline_config_get_type (void);
-RygelCmdlineConfig* rygel_cmdline_config_get_default (void);
-GType rygel_user_config_get_type (void);
-RygelUserConfig* rygel_user_config_get_default (GError** error);
-gboolean rygel_configuration_get_upnp_enabled (RygelConfiguration* self, GError** error);
-GQuark rygel_configuration_error_quark (void);
-static gboolean rygel_meta_config_real_get_upnp_enabled (RygelConfiguration* base, GError** error);
-char* rygel_configuration_get_interface (RygelConfiguration* self, GError** error);
-static char* rygel_meta_config_real_get_interface (RygelConfiguration* base, GError** error);
-gint rygel_configuration_get_port (RygelConfiguration* self, GError** error);
-static gint rygel_meta_config_real_get_port (RygelConfiguration* base, GError** error);
-gboolean rygel_configuration_get_transcoding (RygelConfiguration* self, GError** error);
-static gboolean rygel_meta_config_real_get_transcoding (RygelConfiguration* base, GError** error);
-gboolean rygel_configuration_get_mp3_transcoder (RygelConfiguration* self, GError** error);
-static gboolean rygel_meta_config_real_get_mp3_transcoder (RygelConfiguration* base, GError** error);
-gboolean rygel_configuration_get_mp2ts_transcoder (RygelConfiguration* self, GError** error);
-static gboolean rygel_meta_config_real_get_mp2ts_transcoder (RygelConfiguration* base, GError** error);
-gboolean rygel_configuration_get_lpcm_transcoder (RygelConfiguration* self, GError** error);
-static gboolean rygel_meta_config_real_get_lpcm_transcoder (RygelConfiguration* base, GError** error);
-RygelLogLevel rygel_configuration_get_log_level (RygelConfiguration* self, GError** error);
-static RygelLogLevel rygel_meta_config_real_get_log_level (RygelConfiguration* base, GError** error);
-gboolean rygel_configuration_get_enabled (RygelConfiguration* self, const char* section, GError** error);
-static gboolean rygel_meta_config_real_get_enabled (RygelConfiguration* base, const char* section, GError** error);
-char* rygel_configuration_get_title (RygelConfiguration* self, const char* section, GError** error);
-static char* rygel_meta_config_real_get_title (RygelConfiguration* base, const char* section, GError** error);
-char* rygel_configuration_get_string (RygelConfiguration* self, const char* section, const char* key, GError** error);
-static char* rygel_meta_config_real_get_string (RygelConfiguration* base, const char* section, const char* key, GError** error);
-GeeArrayList* rygel_configuration_get_string_list (RygelConfiguration* self, const char* section, const char* key, GError** error);
-static GeeArrayList* rygel_meta_config_real_get_string_list (RygelConfiguration* base, const char* section, const char* key, GError** error);
-gint rygel_configuration_get_int (RygelConfiguration* self, const char* section, const char* key, gint min, gint max, GError** error);
-static gint rygel_meta_config_real_get_int (RygelConfiguration* base, const char* section, const char* key, gint min, gint max, GError** error);
-GeeArrayList* rygel_configuration_get_int_list (RygelConfiguration* self, const char* section, const char* key, GError** error);
-static GeeArrayList* rygel_meta_config_real_get_int_list (RygelConfiguration* base, const char* section, const char* key, GError** error);
-gboolean rygel_configuration_get_bool (RygelConfiguration* self, const char* section, const char* key, GError** error);
-static gboolean rygel_meta_config_real_get_bool (RygelConfiguration* base, const char* section, const char* key, GError** error);
-static void rygel_meta_config_finalize (GObject* obj);
-
-
-
-static gpointer _g_object_ref0 (gpointer self) {
-	return self ? g_object_ref (self) : NULL;
-}
-
-
-RygelMetaConfig* rygel_meta_config_get_default (void) {
-	RygelMetaConfig* result;
-	if (rygel_meta_config_meta_config == NULL) {
-		RygelMetaConfig* _tmp0_;
-		rygel_meta_config_meta_config = (_tmp0_ = rygel_meta_config_new (), _g_object_unref0 (rygel_meta_config_meta_config), _tmp0_);
-	}
-	result = _g_object_ref0 (rygel_meta_config_meta_config);
-	return result;
-}
-
-
-RygelMetaConfig* rygel_meta_config_construct (GType object_type) {
-	GError * _inner_error_;
-	RygelMetaConfig * self;
-	GeeArrayList* _tmp0_;
-	RygelCmdlineConfig* _tmp1_;
-	_inner_error_ = NULL;
-	self = (RygelMetaConfig*) g_object_new (object_type, NULL);
-	self->priv->configs = (_tmp0_ = gee_array_list_new (RYGEL_TYPE_CONFIGURATION, (GBoxedCopyFunc) g_object_ref, g_object_unref, g_direct_equal), _g_object_unref0 (self->priv->configs), _tmp0_);
-	gee_abstract_collection_add ((GeeAbstractCollection*) self->priv->configs, (RygelConfiguration*) (_tmp1_ = rygel_cmdline_config_get_default ()));
-	_g_object_unref0 (_tmp1_);
-	{
-		RygelUserConfig* user_config;
-		user_config = rygel_user_config_get_default (&_inner_error_);
-		if (_inner_error_ != NULL) {
-			goto __catch5_g_error;
-			goto __finally5;
-		}
-		gee_abstract_collection_add ((GeeAbstractCollection*) self->priv->configs, (RygelConfiguration*) user_config);
-		_g_object_unref0 (user_config);
-	}
-	goto __finally5;
-	__catch5_g_error:
-	{
-		GError * err;
-		err = _inner_error_;
-		_inner_error_ = NULL;
-		{
-			g_warning ("rygel-meta-config.vala:57: Failed to load user configuration: %s", err->message);
-			_g_error_free0 (err);
-		}
-	}
-	__finally5:
-	if (_inner_error_ != NULL) {
-		g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
-		g_clear_error (&_inner_error_);
-		return NULL;
-	}
-	return self;
-}
-
-
-RygelMetaConfig* rygel_meta_config_new (void) {
-	return rygel_meta_config_construct (RYGEL_TYPE_META_CONFIG);
-}
-
-
-static gboolean rygel_meta_config_real_get_upnp_enabled (RygelConfiguration* base, GError** error) {
-	RygelMetaConfig * self;
-	gboolean result;
-	GError * _inner_error_;
-	gboolean val;
-	gboolean unavailable;
-	self = (RygelMetaConfig*) base;
-	_inner_error_ = NULL;
-	val = TRUE;
-	unavailable = TRUE;
-	{
-		GeeIterator* _config_it;
-		_config_it = gee_abstract_collection_iterator ((GeeAbstractCollection*) self->priv->configs);
-		while (TRUE) {
-			RygelConfiguration* config;
-			if (!gee_iterator_next (_config_it)) {
-				break;
-			}
-			config = (RygelConfiguration*) gee_iterator_get (_config_it);
-			{
-				gboolean _tmp0_;
-				_tmp0_ = rygel_configuration_get_upnp_enabled (config, &_inner_error_);
-				if (_inner_error_ != NULL) {
-					goto __catch6_g_error;
-					goto __finally6;
-				}
-				val = _tmp0_;
-				unavailable = FALSE;
-				_g_object_unref0 (config);
-				break;
-			}
-			goto __finally6;
-			__catch6_g_error:
-			{
-				GError * err;
-				err = _inner_error_;
-				_inner_error_ = NULL;
-				{
-					_g_error_free0 (err);
-				}
-			}
-			__finally6:
-			if (_inner_error_ != NULL) {
-				g_propagate_error (error, _inner_error_);
-				_g_object_unref0 (config);
-				_g_object_unref0 (_config_it);
-				return FALSE;
-			}
-			_g_object_unref0 (config);
-		}
-		_g_object_unref0 (_config_it);
-	}
-	if (unavailable) {
-		_inner_error_ = g_error_new_literal (RYGEL_CONFIGURATION_ERROR, RYGEL_CONFIGURATION_ERROR_NO_VALUE_SET, "No value available");
-		if (_inner_error_ != NULL) {
-			g_propagate_error (error, _inner_error_);
-			return FALSE;
-		}
-	}
-	result = val;
-	return result;
-}
-
-
-static char* rygel_meta_config_real_get_interface (RygelConfiguration* base, GError** error) {
-	RygelMetaConfig * self;
-	char* result;
-	GError * _inner_error_;
-	char* val;
-	gboolean unavailable;
-	self = (RygelMetaConfig*) base;
-	_inner_error_ = NULL;
-	val = NULL;
-	unavailable = TRUE;
-	{
-		GeeIterator* _config_it;
-		_config_it = gee_abstract_collection_iterator ((GeeAbstractCollection*) self->priv->configs);
-		while (TRUE) {
-			RygelConfiguration* config;
-			if (!gee_iterator_next (_config_it)) {
-				break;
-			}
-			config = (RygelConfiguration*) gee_iterator_get (_config_it);
-			{
-				char* _tmp0_;
-				char* _tmp1_;
-				_tmp0_ = rygel_configuration_get_interface (config, &_inner_error_);
-				if (_inner_error_ != NULL) {
-					goto __catch7_g_error;
-					goto __finally7;
-				}
-				val = (_tmp1_ = _tmp0_, _g_free0 (val), _tmp1_);
-				unavailable = FALSE;
-				_g_object_unref0 (config);
-				break;
-			}
-			goto __finally7;
-			__catch7_g_error:
-			{
-				GError * err;
-				err = _inner_error_;
-				_inner_error_ = NULL;
-				{
-					_g_error_free0 (err);
-				}
-			}
-			__finally7:
-			if (_inner_error_ != NULL) {
-				g_propagate_error (error, _inner_error_);
-				_g_object_unref0 (config);
-				_g_object_unref0 (_config_it);
-				_g_free0 (val);
-				return NULL;
-			}
-			_g_object_unref0 (config);
-		}
-		_g_object_unref0 (_config_it);
-	}
-	if (unavailable) {
-		_inner_error_ = g_error_new_literal (RYGEL_CONFIGURATION_ERROR, RYGEL_CONFIGURATION_ERROR_NO_VALUE_SET, "No value available");
-		if (_inner_error_ != NULL) {
-			g_propagate_error (error, _inner_error_);
-			_g_free0 (val);
-			return NULL;
-		}
-	}
-	result = val;
-	return result;
-}
-
-
-static gint rygel_meta_config_real_get_port (RygelConfiguration* base, GError** error) {
-	RygelMetaConfig * self;
-	gint result;
-	GError * _inner_error_;
-	gint val;
-	gboolean unavailable;
-	self = (RygelMetaConfig*) base;
-	_inner_error_ = NULL;
-	val = 0;
-	unavailable = TRUE;
-	{
-		GeeIterator* _config_it;
-		_config_it = gee_abstract_collection_iterator ((GeeAbstractCollection*) self->priv->configs);
-		while (TRUE) {
-			RygelConfiguration* config;
-			if (!gee_iterator_next (_config_it)) {
-				break;
-			}
-			config = (RygelConfiguration*) gee_iterator_get (_config_it);
-			{
-				gint _tmp0_;
-				_tmp0_ = rygel_configuration_get_port (config, &_inner_error_);
-				if (_inner_error_ != NULL) {
-					goto __catch8_g_error;
-					goto __finally8;
-				}
-				val = _tmp0_;
-				unavailable = FALSE;
-				_g_object_unref0 (config);
-				break;
-			}
-			goto __finally8;
-			__catch8_g_error:
-			{
-				GError * err;
-				err = _inner_error_;
-				_inner_error_ = NULL;
-				{
-					_g_error_free0 (err);
-				}
-			}
-			__finally8:
-			if (_inner_error_ != NULL) {
-				g_propagate_error (error, _inner_error_);
-				_g_object_unref0 (config);
-				_g_object_unref0 (_config_it);
-				return 0;
-			}
-			_g_object_unref0 (config);
-		}
-		_g_object_unref0 (_config_it);
-	}
-	if (unavailable) {
-		_inner_error_ = g_error_new_literal (RYGEL_CONFIGURATION_ERROR, RYGEL_CONFIGURATION_ERROR_NO_VALUE_SET, "No value available");
-		if (_inner_error_ != NULL) {
-			g_propagate_error (error, _inner_error_);
-			return 0;
-		}
-	}
-	result = val;
-	return result;
-}
-
-
-static gboolean rygel_meta_config_real_get_transcoding (RygelConfiguration* base, GError** error) {
-	RygelMetaConfig * self;
-	gboolean result;
-	GError * _inner_error_;
-	gboolean val;
-	gboolean unavailable;
-	self = (RygelMetaConfig*) base;
-	_inner_error_ = NULL;
-	val = TRUE;
-	unavailable = TRUE;
-	{
-		GeeIterator* _config_it;
-		_config_it = gee_abstract_collection_iterator ((GeeAbstractCollection*) self->priv->configs);
-		while (TRUE) {
-			RygelConfiguration* config;
-			if (!gee_iterator_next (_config_it)) {
-				break;
-			}
-			config = (RygelConfiguration*) gee_iterator_get (_config_it);
-			{
-				gboolean _tmp0_;
-				_tmp0_ = rygel_configuration_get_transcoding (config, &_inner_error_);
-				if (_inner_error_ != NULL) {
-					goto __catch9_g_error;
-					goto __finally9;
-				}
-				val = _tmp0_;
-				unavailable = FALSE;
-				_g_object_unref0 (config);
-				break;
-			}
-			goto __finally9;
-			__catch9_g_error:
-			{
-				GError * err;
-				err = _inner_error_;
-				_inner_error_ = NULL;
-				{
-					_g_error_free0 (err);
-				}
-			}
-			__finally9:
-			if (_inner_error_ != NULL) {
-				g_propagate_error (error, _inner_error_);
-				_g_object_unref0 (config);
-				_g_object_unref0 (_config_it);
-				return FALSE;
-			}
-			_g_object_unref0 (config);
-		}
-		_g_object_unref0 (_config_it);
-	}
-	if (unavailable) {
-		_inner_error_ = g_error_new_literal (RYGEL_CONFIGURATION_ERROR, RYGEL_CONFIGURATION_ERROR_NO_VALUE_SET, "No value available");
-		if (_inner_error_ != NULL) {
-			g_propagate_error (error, _inner_error_);
-			return FALSE;
-		}
-	}
-	result = val;
-	return result;
-}
-
-
-static gboolean rygel_meta_config_real_get_mp3_transcoder (RygelConfiguration* base, GError** error) {
-	RygelMetaConfig * self;
-	gboolean result;
-	GError * _inner_error_;
-	gboolean val;
-	gboolean unavailable;
-	self = (RygelMetaConfig*) base;
-	_inner_error_ = NULL;
-	val = TRUE;
-	unavailable = TRUE;
-	{
-		GeeIterator* _config_it;
-		_config_it = gee_abstract_collection_iterator ((GeeAbstractCollection*) self->priv->configs);
-		while (TRUE) {
-			RygelConfiguration* config;
-			if (!gee_iterator_next (_config_it)) {
-				break;
-			}
-			config = (RygelConfiguration*) gee_iterator_get (_config_it);
-			{
-				gboolean _tmp0_;
-				_tmp0_ = rygel_configuration_get_mp3_transcoder (config, &_inner_error_);
-				if (_inner_error_ != NULL) {
-					goto __catch10_g_error;
-					goto __finally10;
-				}
-				val = _tmp0_;
-				unavailable = FALSE;
-				_g_object_unref0 (config);
-				break;
-			}
-			goto __finally10;
-			__catch10_g_error:
-			{
-				GError * err;
-				err = _inner_error_;
-				_inner_error_ = NULL;
-				{
-					_g_error_free0 (err);
-				}
-			}
-			__finally10:
-			if (_inner_error_ != NULL) {
-				g_propagate_error (error, _inner_error_);
-				_g_object_unref0 (config);
-				_g_object_unref0 (_config_it);
-				return FALSE;
-			}
-			_g_object_unref0 (config);
-		}
-		_g_object_unref0 (_config_it);
-	}
-	if (unavailable) {
-		_inner_error_ = g_error_new_literal (RYGEL_CONFIGURATION_ERROR, RYGEL_CONFIGURATION_ERROR_NO_VALUE_SET, "No value available");
-		if (_inner_error_ != NULL) {
-			g_propagate_error (error, _inner_error_);
-			return FALSE;
-		}
-	}
-	result = val;
-	return result;
-}
-
-
-static gboolean rygel_meta_config_real_get_mp2ts_transcoder (RygelConfiguration* base, GError** error) {
-	RygelMetaConfig * self;
-	gboolean result;
-	GError * _inner_error_;
-	gboolean val;
-	gboolean unavailable;
-	self = (RygelMetaConfig*) base;
-	_inner_error_ = NULL;
-	val = TRUE;
-	unavailable = TRUE;
-	{
-		GeeIterator* _config_it;
-		_config_it = gee_abstract_collection_iterator ((GeeAbstractCollection*) self->priv->configs);
-		while (TRUE) {
-			RygelConfiguration* config;
-			if (!gee_iterator_next (_config_it)) {
-				break;
-			}
-			config = (RygelConfiguration*) gee_iterator_get (_config_it);
-			{
-				gboolean _tmp0_;
-				_tmp0_ = rygel_configuration_get_mp2ts_transcoder (config, &_inner_error_);
-				if (_inner_error_ != NULL) {
-					goto __catch11_g_error;
-					goto __finally11;
-				}
-				val = _tmp0_;
-				unavailable = FALSE;
-				_g_object_unref0 (config);
-				break;
-			}
-			goto __finally11;
-			__catch11_g_error:
-			{
-				GError * err;
-				err = _inner_error_;
-				_inner_error_ = NULL;
-				{
-					_g_error_free0 (err);
-				}
-			}
-			__finally11:
-			if (_inner_error_ != NULL) {
-				g_propagate_error (error, _inner_error_);
-				_g_object_unref0 (config);
-				_g_object_unref0 (_config_it);
-				return FALSE;
-			}
-			_g_object_unref0 (config);
-		}
-		_g_object_unref0 (_config_it);
-	}
-	if (unavailable) {
-		_inner_error_ = g_error_new_literal (RYGEL_CONFIGURATION_ERROR, RYGEL_CONFIGURATION_ERROR_NO_VALUE_SET, "No value available");
-		if (_inner_error_ != NULL) {
-			g_propagate_error (error, _inner_error_);
-			return FALSE;
-		}
-	}
-	result = val;
-	return result;
-}
-
-
-static gboolean rygel_meta_config_real_get_lpcm_transcoder (RygelConfiguration* base, GError** error) {
-	RygelMetaConfig * self;
-	gboolean result;
-	GError * _inner_error_;
-	gboolean val;
-	gboolean unavailable;
-	self = (RygelMetaConfig*) base;
-	_inner_error_ = NULL;
-	val = TRUE;
-	unavailable = TRUE;
-	{
-		GeeIterator* _config_it;
-		_config_it = gee_abstract_collection_iterator ((GeeAbstractCollection*) self->priv->configs);
-		while (TRUE) {
-			RygelConfiguration* config;
-			if (!gee_iterator_next (_config_it)) {
-				break;
-			}
-			config = (RygelConfiguration*) gee_iterator_get (_config_it);
-			{
-				gboolean _tmp0_;
-				_tmp0_ = rygel_configuration_get_lpcm_transcoder (config, &_inner_error_);
-				if (_inner_error_ != NULL) {
-					goto __catch12_g_error;
-					goto __finally12;
-				}
-				val = _tmp0_;
-				unavailable = FALSE;
-				_g_object_unref0 (config);
-				break;
-			}
-			goto __finally12;
-			__catch12_g_error:
-			{
-				GError * err;
-				err = _inner_error_;
-				_inner_error_ = NULL;
-				{
-					_g_error_free0 (err);
-				}
-			}
-			__finally12:
-			if (_inner_error_ != NULL) {
-				g_propagate_error (error, _inner_error_);
-				_g_object_unref0 (config);
-				_g_object_unref0 (_config_it);
-				return FALSE;
-			}
-			_g_object_unref0 (config);
-		}
-		_g_object_unref0 (_config_it);
-	}
-	if (unavailable) {
-		_inner_error_ = g_error_new_literal (RYGEL_CONFIGURATION_ERROR, RYGEL_CONFIGURATION_ERROR_NO_VALUE_SET, "No value available");
-		if (_inner_error_ != NULL) {
-			g_propagate_error (error, _inner_error_);
-			return FALSE;
-		}
-	}
-	result = val;
-	return result;
-}
-
-
-static RygelLogLevel rygel_meta_config_real_get_log_level (RygelConfiguration* base, GError** error) {
-	RygelMetaConfig * self;
-	RygelLogLevel result;
-	GError * _inner_error_;
-	RygelLogLevel val;
-	gboolean unavailable;
-	self = (RygelMetaConfig*) base;
-	_inner_error_ = NULL;
-	val = RYGEL_LOG_LEVEL_DEFAULT;
-	unavailable = TRUE;
-	{
-		GeeIterator* _config_it;
-		_config_it = gee_abstract_collection_iterator ((GeeAbstractCollection*) self->priv->configs);
-		while (TRUE) {
-			RygelConfiguration* config;
-			if (!gee_iterator_next (_config_it)) {
-				break;
-			}
-			config = (RygelConfiguration*) gee_iterator_get (_config_it);
-			{
-				RygelLogLevel _tmp0_;
-				_tmp0_ = rygel_configuration_get_log_level (config, &_inner_error_);
-				if (_inner_error_ != NULL) {
-					goto __catch13_g_error;
-					goto __finally13;
-				}
-				val = _tmp0_;
-				unavailable = FALSE;
-				_g_object_unref0 (config);
-				break;
-			}
-			goto __finally13;
-			__catch13_g_error:
-			{
-				GError * err;
-				err = _inner_error_;
-				_inner_error_ = NULL;
-				{
-					_g_error_free0 (err);
-				}
-			}
-			__finally13:
-			if (_inner_error_ != NULL) {
-				g_propagate_error (error, _inner_error_);
-				_g_object_unref0 (config);
-				_g_object_unref0 (_config_it);
-				return 0;
-			}
-			_g_object_unref0 (config);
-		}
-		_g_object_unref0 (_config_it);
-	}
-	if (unavailable) {
-		_inner_error_ = g_error_new_literal (RYGEL_CONFIGURATION_ERROR, RYGEL_CONFIGURATION_ERROR_NO_VALUE_SET, "No value available");
-		if (_inner_error_ != NULL) {
-			g_propagate_error (error, _inner_error_);
-			return 0;
-		}
-	}
-	result = val;
-	return result;
-}
-
-
-static gboolean rygel_meta_config_real_get_enabled (RygelConfiguration* base, const char* section, GError** error) {
-	RygelMetaConfig * self;
-	gboolean result;
-	GError * _inner_error_;
-	gboolean val;
-	gboolean unavailable;
-	self = (RygelMetaConfig*) base;
-	g_return_val_if_fail (section != NULL, FALSE);
-	_inner_error_ = NULL;
-	val = TRUE;
-	unavailable = TRUE;
-	{
-		GeeIterator* _config_it;
-		_config_it = gee_abstract_collection_iterator ((GeeAbstractCollection*) self->priv->configs);
-		while (TRUE) {
-			RygelConfiguration* config;
-			if (!gee_iterator_next (_config_it)) {
-				break;
-			}
-			config = (RygelConfiguration*) gee_iterator_get (_config_it);
-			{
-				gboolean _tmp0_;
-				_tmp0_ = rygel_configuration_get_enabled (config, section, &_inner_error_);
-				if (_inner_error_ != NULL) {
-					goto __catch14_g_error;
-					goto __finally14;
-				}
-				val = _tmp0_;
-				unavailable = FALSE;
-				_g_object_unref0 (config);
-				break;
-			}
-			goto __finally14;
-			__catch14_g_error:
-			{
-				GError * err;
-				err = _inner_error_;
-				_inner_error_ = NULL;
-				{
-					_g_error_free0 (err);
-				}
-			}
-			__finally14:
-			if (_inner_error_ != NULL) {
-				g_propagate_error (error, _inner_error_);
-				_g_object_unref0 (config);
-				_g_object_unref0 (_config_it);
-				return FALSE;
-			}
-			_g_object_unref0 (config);
-		}
-		_g_object_unref0 (_config_it);
-	}
-	if (unavailable) {
-		_inner_error_ = g_error_new (RYGEL_CONFIGURATION_ERROR, RYGEL_CONFIGURATION_ERROR_NO_VALUE_SET, "No value available for '%s/enabled'", section);
-		if (_inner_error_ != NULL) {
-			g_propagate_error (error, _inner_error_);
-			return FALSE;
-		}
-	}
-	result = val;
-	return result;
-}
-
-
-static char* rygel_meta_config_real_get_title (RygelConfiguration* base, const char* section, GError** error) {
-	RygelMetaConfig * self;
-	char* result;
-	GError * _inner_error_;
-	char* val;
-	self = (RygelMetaConfig*) base;
-	g_return_val_if_fail (section != NULL, NULL);
-	_inner_error_ = NULL;
-	val = NULL;
-	{
-		GeeIterator* _config_it;
-		_config_it = gee_abstract_collection_iterator ((GeeAbstractCollection*) self->priv->configs);
-		while (TRUE) {
-			RygelConfiguration* config;
-			if (!gee_iterator_next (_config_it)) {
-				break;
-			}
-			config = (RygelConfiguration*) gee_iterator_get (_config_it);
-			{
-				char* _tmp0_;
-				char* _tmp1_;
-				_tmp0_ = rygel_configuration_get_title (config, section, &_inner_error_);
-				if (_inner_error_ != NULL) {
-					goto __catch15_g_error;
-					goto __finally15;
-				}
-				val = (_tmp1_ = _tmp0_, _g_free0 (val), _tmp1_);
-				_g_object_unref0 (config);
-				break;
-			}
-			goto __finally15;
-			__catch15_g_error:
-			{
-				GError * err;
-				err = _inner_error_;
-				_inner_error_ = NULL;
-				{
-					_g_error_free0 (err);
-				}
-			}
-			__finally15:
-			if (_inner_error_ != NULL) {
-				g_propagate_error (error, _inner_error_);
-				_g_object_unref0 (config);
-				_g_object_unref0 (_config_it);
-				_g_free0 (val);
-				return NULL;
-			}
-			_g_object_unref0 (config);
-		}
-		_g_object_unref0 (_config_it);
-	}
-	if (val == NULL) {
-		_inner_error_ = g_error_new (RYGEL_CONFIGURATION_ERROR, RYGEL_CONFIGURATION_ERROR_NO_VALUE_SET, "No value available for '%s/enabled'", section);
-		if (_inner_error_ != NULL) {
-			g_propagate_error (error, _inner_error_);
-			_g_free0 (val);
-			return NULL;
-		}
-	}
-	result = val;
-	return result;
-}
-
-
-static char* rygel_meta_config_real_get_string (RygelConfiguration* base, const char* section, const char* key, GError** error) {
-	RygelMetaConfig * self;
-	char* result;
-	GError * _inner_error_;
-	char* val;
-	self = (RygelMetaConfig*) base;
-	g_return_val_if_fail (section != NULL, NULL);
-	g_return_val_if_fail (key != NULL, NULL);
-	_inner_error_ = NULL;
-	val = NULL;
-	{
-		GeeIterator* _config_it;
-		_config_it = gee_abstract_collection_iterator ((GeeAbstractCollection*) self->priv->configs);
-		while (TRUE) {
-			RygelConfiguration* config;
-			if (!gee_iterator_next (_config_it)) {
-				break;
-			}
-			config = (RygelConfiguration*) gee_iterator_get (_config_it);
-			{
-				char* _tmp0_;
-				char* _tmp1_;
-				_tmp0_ = rygel_configuration_get_string (config, section, key, &_inner_error_);
-				if (_inner_error_ != NULL) {
-					goto __catch16_g_error;
-					goto __finally16;
-				}
-				val = (_tmp1_ = _tmp0_, _g_free0 (val), _tmp1_);
-				_g_object_unref0 (config);
-				break;
-			}
-			goto __finally16;
-			__catch16_g_error:
-			{
-				GError * err;
-				err = _inner_error_;
-				_inner_error_ = NULL;
-				{
-					_g_error_free0 (err);
-				}
-			}
-			__finally16:
-			if (_inner_error_ != NULL) {
-				g_propagate_error (error, _inner_error_);
-				_g_object_unref0 (config);
-				_g_object_unref0 (_config_it);
-				_g_free0 (val);
-				return NULL;
-			}
-			_g_object_unref0 (config);
-		}
-		_g_object_unref0 (_config_it);
-	}
-	if (val == NULL) {
-		_inner_error_ = g_error_new (RYGEL_CONFIGURATION_ERROR, RYGEL_CONFIGURATION_ERROR_NO_VALUE_SET, "No value available for '%s/%s'", section, key);
-		if (_inner_error_ != NULL) {
-			g_propagate_error (error, _inner_error_);
-			_g_free0 (val);
-			return NULL;
-		}
-	}
-	result = val;
-	return result;
-}
-
-
-static GeeArrayList* rygel_meta_config_real_get_string_list (RygelConfiguration* base, const char* section, const char* key, GError** error) {
-	RygelMetaConfig * self;
-	GeeArrayList* result;
-	GError * _inner_error_;
-	GeeArrayList* val;
-	self = (RygelMetaConfig*) base;
-	g_return_val_if_fail (section != NULL, NULL);
-	g_return_val_if_fail (key != NULL, NULL);
-	_inner_error_ = NULL;
-	val = NULL;
-	{
-		GeeIterator* _config_it;
-		_config_it = gee_abstract_collection_iterator ((GeeAbstractCollection*) self->priv->configs);
-		while (TRUE) {
-			RygelConfiguration* config;
-			if (!gee_iterator_next (_config_it)) {
-				break;
-			}
-			config = (RygelConfiguration*) gee_iterator_get (_config_it);
-			{
-				GeeArrayList* _tmp0_;
-				GeeArrayList* _tmp1_;
-				_tmp0_ = rygel_configuration_get_string_list (config, section, key, &_inner_error_);
-				if (_inner_error_ != NULL) {
-					goto __catch17_g_error;
-					goto __finally17;
-				}
-				val = (_tmp1_ = _tmp0_, _g_object_unref0 (val), _tmp1_);
-				_g_object_unref0 (config);
-				break;
-			}
-			goto __finally17;
-			__catch17_g_error:
-			{
-				GError * err;
-				err = _inner_error_;
-				_inner_error_ = NULL;
-				{
-					_g_error_free0 (err);
-				}
-			}
-			__finally17:
-			if (_inner_error_ != NULL) {
-				g_propagate_error (error, _inner_error_);
-				_g_object_unref0 (config);
-				_g_object_unref0 (_config_it);
-				_g_object_unref0 (val);
-				return NULL;
-			}
-			_g_object_unref0 (config);
-		}
-		_g_object_unref0 (_config_it);
-	}
-	if (val == NULL) {
-		_inner_error_ = g_error_new (RYGEL_CONFIGURATION_ERROR, RYGEL_CONFIGURATION_ERROR_NO_VALUE_SET, "No value available for '%s/%s'", section, key);
-		if (_inner_error_ != NULL) {
-			g_propagate_error (error, _inner_error_);
-			_g_object_unref0 (val);
-			return NULL;
-		}
-	}
-	result = val;
-	return result;
-}
-
-
-static gint rygel_meta_config_real_get_int (RygelConfiguration* base, const char* section, const char* key, gint min, gint max, GError** error) {
-	RygelMetaConfig * self;
-	gint result;
-	GError * _inner_error_;
-	gint val;
-	gboolean unavailable;
-	self = (RygelMetaConfig*) base;
-	g_return_val_if_fail (section != NULL, 0);
-	g_return_val_if_fail (key != NULL, 0);
-	_inner_error_ = NULL;
-	val = 0;
-	unavailable = TRUE;
-	{
-		GeeIterator* _config_it;
-		_config_it = gee_abstract_collection_iterator ((GeeAbstractCollection*) self->priv->configs);
-		while (TRUE) {
-			RygelConfiguration* config;
-			if (!gee_iterator_next (_config_it)) {
-				break;
-			}
-			config = (RygelConfiguration*) gee_iterator_get (_config_it);
-			{
-				gint _tmp0_;
-				_tmp0_ = rygel_configuration_get_int (config, section, key, min, max, &_inner_error_);
-				if (_inner_error_ != NULL) {
-					goto __catch18_g_error;
-					goto __finally18;
-				}
-				val = _tmp0_;
-				unavailable = FALSE;
-				_g_object_unref0 (config);
-				break;
-			}
-			goto __finally18;
-			__catch18_g_error:
-			{
-				GError * err;
-				err = _inner_error_;
-				_inner_error_ = NULL;
-				{
-					_g_error_free0 (err);
-				}
-			}
-			__finally18:
-			if (_inner_error_ != NULL) {
-				g_propagate_error (error, _inner_error_);
-				_g_object_unref0 (config);
-				_g_object_unref0 (_config_it);
-				return 0;
-			}
-			_g_object_unref0 (config);
-		}
-		_g_object_unref0 (_config_it);
-	}
-	if (unavailable) {
-		_inner_error_ = g_error_new (RYGEL_CONFIGURATION_ERROR, RYGEL_CONFIGURATION_ERROR_NO_VALUE_SET, "No value available for '%s/%s'", section, key);
-		if (_inner_error_ != NULL) {
-			g_propagate_error (error, _inner_error_);
-			return 0;
-		}
-	}
-	result = val;
-	return result;
-}
-
-
-static GeeArrayList* rygel_meta_config_real_get_int_list (RygelConfiguration* base, const char* section, const char* key, GError** error) {
-	RygelMetaConfig * self;
-	GeeArrayList* result;
-	GError * _inner_error_;
-	GeeArrayList* val;
-	self = (RygelMetaConfig*) base;
-	g_return_val_if_fail (section != NULL, NULL);
-	g_return_val_if_fail (key != NULL, NULL);
-	_inner_error_ = NULL;
-	val = NULL;
-	{
-		GeeIterator* _config_it;
-		_config_it = gee_abstract_collection_iterator ((GeeAbstractCollection*) self->priv->configs);
-		while (TRUE) {
-			RygelConfiguration* config;
-			if (!gee_iterator_next (_config_it)) {
-				break;
-			}
-			config = (RygelConfiguration*) gee_iterator_get (_config_it);
-			{
-				GeeArrayList* _tmp0_;
-				GeeArrayList* _tmp1_;
-				_tmp0_ = rygel_configuration_get_int_list (config, section, key, &_inner_error_);
-				if (_inner_error_ != NULL) {
-					goto __catch19_g_error;
-					goto __finally19;
-				}
-				val = (_tmp1_ = _tmp0_, _g_object_unref0 (val), _tmp1_);
-				_g_object_unref0 (config);
-				break;
-			}
-			goto __finally19;
-			__catch19_g_error:
-			{
-				GError * err;
-				err = _inner_error_;
-				_inner_error_ = NULL;
-				{
-					_g_error_free0 (err);
-				}
-			}
-			__finally19:
-			if (_inner_error_ != NULL) {
-				g_propagate_error (error, _inner_error_);
-				_g_object_unref0 (config);
-				_g_object_unref0 (_config_it);
-				_g_object_unref0 (val);
-				return NULL;
-			}
-			_g_object_unref0 (config);
-		}
-		_g_object_unref0 (_config_it);
-	}
-	if (val == NULL) {
-		_inner_error_ = g_error_new (RYGEL_CONFIGURATION_ERROR, RYGEL_CONFIGURATION_ERROR_NO_VALUE_SET, "No value available for '%s/%s'", section, key);
-		if (_inner_error_ != NULL) {
-			g_propagate_error (error, _inner_error_);
-			_g_object_unref0 (val);
-			return NULL;
-		}
-	}
-	result = val;
-	return result;
-}
-
-
-static gboolean rygel_meta_config_real_get_bool (RygelConfiguration* base, const char* section, const char* key, GError** error) {
-	RygelMetaConfig * self;
-	gboolean result;
-	GError * _inner_error_;
-	gboolean val;
-	gboolean unavailable;
-	self = (RygelMetaConfig*) base;
-	g_return_val_if_fail (section != NULL, FALSE);
-	g_return_val_if_fail (key != NULL, FALSE);
-	_inner_error_ = NULL;
-	val = FALSE;
-	unavailable = TRUE;
-	{
-		GeeIterator* _config_it;
-		_config_it = gee_abstract_collection_iterator ((GeeAbstractCollection*) self->priv->configs);
-		while (TRUE) {
-			RygelConfiguration* config;
-			if (!gee_iterator_next (_config_it)) {
-				break;
-			}
-			config = (RygelConfiguration*) gee_iterator_get (_config_it);
-			{
-				gboolean _tmp0_;
-				_tmp0_ = rygel_configuration_get_bool (config, section, key, &_inner_error_);
-				if (_inner_error_ != NULL) {
-					goto __catch20_g_error;
-					goto __finally20;
-				}
-				val = _tmp0_;
-				unavailable = FALSE;
-				_g_object_unref0 (config);
-				break;
-			}
-			goto __finally20;
-			__catch20_g_error:
-			{
-				GError * err;
-				err = _inner_error_;
-				_inner_error_ = NULL;
-				{
-					_g_error_free0 (err);
-				}
-			}
-			__finally20:
-			if (_inner_error_ != NULL) {
-				g_propagate_error (error, _inner_error_);
-				_g_object_unref0 (config);
-				_g_object_unref0 (_config_it);
-				return FALSE;
-			}
-			_g_object_unref0 (config);
-		}
-		_g_object_unref0 (_config_it);
-	}
-	if (unavailable) {
-		_inner_error_ = g_error_new (RYGEL_CONFIGURATION_ERROR, RYGEL_CONFIGURATION_ERROR_NO_VALUE_SET, "No value available for '%s/%s'", section, key);
-		if (_inner_error_ != NULL) {
-			g_propagate_error (error, _inner_error_);
-			return FALSE;
-		}
-	}
-	result = val;
-	return result;
-}
-
-
-static void rygel_meta_config_class_init (RygelMetaConfigClass * klass) {
-	rygel_meta_config_parent_class = g_type_class_peek_parent (klass);
-	g_type_class_add_private (klass, sizeof (RygelMetaConfigPrivate));
-	G_OBJECT_CLASS (klass)->finalize = rygel_meta_config_finalize;
-}
-
-
-static void rygel_meta_config_rygel_configuration_interface_init (RygelConfigurationIface * iface) {
-	rygel_meta_config_rygel_configuration_parent_iface = g_type_interface_peek_parent (iface);
-	iface->get_upnp_enabled = rygel_meta_config_real_get_upnp_enabled;
-	iface->get_interface = rygel_meta_config_real_get_interface;
-	iface->get_port = rygel_meta_config_real_get_port;
-	iface->get_transcoding = rygel_meta_config_real_get_transcoding;
-	iface->get_mp3_transcoder = rygel_meta_config_real_get_mp3_transcoder;
-	iface->get_mp2ts_transcoder = rygel_meta_config_real_get_mp2ts_transcoder;
-	iface->get_lpcm_transcoder = rygel_meta_config_real_get_lpcm_transcoder;
-	iface->get_log_level = rygel_meta_config_real_get_log_level;
-	iface->get_enabled = rygel_meta_config_real_get_enabled;
-	iface->get_title = rygel_meta_config_real_get_title;
-	iface->get_string = rygel_meta_config_real_get_string;
-	iface->get_string_list = rygel_meta_config_real_get_string_list;
-	iface->get_int = rygel_meta_config_real_get_int;
-	iface->get_int_list = rygel_meta_config_real_get_int_list;
-	iface->get_bool = rygel_meta_config_real_get_bool;
-}
-
-
-static void rygel_meta_config_instance_init (RygelMetaConfig * self) {
-	self->priv = RYGEL_META_CONFIG_GET_PRIVATE (self);
-}
-
-
-static void rygel_meta_config_finalize (GObject* obj) {
-	RygelMetaConfig * self;
-	self = RYGEL_META_CONFIG (obj);
-	_g_object_unref0 (self->priv->configs);
-	G_OBJECT_CLASS (rygel_meta_config_parent_class)->finalize (obj);
-}
-
-
-GType rygel_meta_config_get_type (void) {
-	static GType rygel_meta_config_type_id = 0;
-	if (rygel_meta_config_type_id == 0) {
-		static const GTypeInfo g_define_type_info = { sizeof (RygelMetaConfigClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) rygel_meta_config_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (RygelMetaConfig), 0, (GInstanceInitFunc) rygel_meta_config_instance_init, NULL };
-		static const GInterfaceInfo rygel_configuration_info = { (GInterfaceInitFunc) rygel_meta_config_rygel_configuration_interface_init, (GInterfaceFinalizeFunc) NULL, NULL};
-		rygel_meta_config_type_id = g_type_register_static (G_TYPE_OBJECT, "RygelMetaConfig", &g_define_type_info, 0);
-		g_type_add_interface_static (rygel_meta_config_type_id, RYGEL_TYPE_CONFIGURATION, &rygel_configuration_info);
-	}
-	return rygel_meta_config_type_id;
-}
-
-
-
-
--- a/src/rygel/rygel-metadata-extractor.c
+++ /dev/null
@@ -1,617 +0,0 @@
-/* rygel-metadata-extractor.c generated by valac, the Vala compiler
- * generated from rygel-metadata-extractor.vala, do not modify */
-
-/*
- * Copyright (C) 2008 Zeeshan Ali (Khattak) <zeeshanak@gnome.org>.
- * Copyright (C) 2009 Jens Georg <mail@jensge.org>.
- *
- * Author: Zeeshan Ali (Khattak) <zeeshanak@gnome.org>
- * Author: Jens Georg <mail@jensge.org>
- *
- * This file is part of Rygel.
- *
- * Rygel is free software; you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * Rygel is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this program; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
- */
-
-#include <glib.h>
-#include <glib-object.h>
-#include <gst/gst.h>
-#include <gio/gio.h>
-#include <stdlib.h>
-#include <string.h>
-
-
-#define GST_TYPE_STREAM_TYPE (gst_stream_type_get_type ())
-
-#define RYGEL_TYPE_METADATA_EXTRACTOR (rygel_metadata_extractor_get_type ())
-#define RYGEL_METADATA_EXTRACTOR(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_METADATA_EXTRACTOR, RygelMetadataExtractor))
-#define RYGEL_METADATA_EXTRACTOR_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_METADATA_EXTRACTOR, RygelMetadataExtractorClass))
-#define RYGEL_IS_METADATA_EXTRACTOR(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_METADATA_EXTRACTOR))
-#define RYGEL_IS_METADATA_EXTRACTOR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_METADATA_EXTRACTOR))
-#define RYGEL_METADATA_EXTRACTOR_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_METADATA_EXTRACTOR, RygelMetadataExtractorClass))
-
-typedef struct _RygelMetadataExtractor RygelMetadataExtractor;
-typedef struct _RygelMetadataExtractorClass RygelMetadataExtractorClass;
-typedef struct _RygelMetadataExtractorPrivate RygelMetadataExtractorPrivate;
-#define _gst_object_unref0(var) ((var == NULL) ? NULL : (var = (gst_object_unref (var), NULL)))
-#define _gst_tag_list_free0(var) ((var == NULL) ? NULL : (var = (gst_tag_list_free (var), NULL)))
-#define _g_queue_free0(var) ((var == NULL) ? NULL : (var = (g_queue_free (var), NULL)))
-#define _g_free0(var) (var = (g_free (var), NULL))
-#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
-#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
-#define _gst_caps_unref0(var) ((var == NULL) ? NULL : (var = (gst_caps_unref (var), NULL)))
-
-typedef enum  {
-	GST_STREAM_TYPE_UNKNOWN = 0,
-	GST_STREAM_TYPE_AUDIO = 1,
-	GST_STREAM_TYPE_VIDEO = 2,
-	GST_STREAM_TYPE_TEXT = 3,
-	GST_STREAM_TYPE_SUBPICTURE = 4,
-	GST_STREAM_TYPE_ELEMENT = 5
-} GstStreamType;
-
-struct _RygelMetadataExtractor {
-	GObject parent_instance;
-	RygelMetadataExtractorPrivate * priv;
-};
-
-struct _RygelMetadataExtractorClass {
-	GObjectClass parent_class;
-};
-
-struct _RygelMetadataExtractorPrivate {
-	GstElement* playbin;
-	GstTagList* tag_list;
-	GQueue* file_queue;
-	guint timeout_id;
-};
-
-
-static gpointer rygel_metadata_extractor_parent_class = NULL;
-
-GType gst_stream_type_get_type (void);
-GType rygel_metadata_extractor_get_type (void);
-#define RYGEL_METADATA_EXTRACTOR_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), RYGEL_TYPE_METADATA_EXTRACTOR, RygelMetadataExtractorPrivate))
-enum  {
-	RYGEL_METADATA_EXTRACTOR_DUMMY_PROPERTY
-};
-#define RYGEL_METADATA_EXTRACTOR_TAG_RYGEL_SIZE "rygel-size"
-#define RYGEL_METADATA_EXTRACTOR_TAG_RYGEL_DURATION "rygel-duration"
-#define RYGEL_METADATA_EXTRACTOR_TAG_RYGEL_MIME "rygel-mime"
-#define RYGEL_METADATA_EXTRACTOR_TAG_RYGEL_CHANNELS "rygel-channels"
-#define RYGEL_METADATA_EXTRACTOR_TAG_RYGEL_RATE "rygel-rate"
-#define RYGEL_METADATA_EXTRACTOR_TAG_RYGEL_WIDTH "rygel-width"
-#define RYGEL_METADATA_EXTRACTOR_TAG_RYGEL_HEIGHT "rygel-height"
-#define RYGEL_METADATA_EXTRACTOR_TAG_RYGEL_DEPTH "rygel-depth"
-#define RYGEL_METADATA_EXTRACTOR_TAG_RYGEL_MTIME "rygel-mtime"
-static void _gst_tag_merge_use_first_gst_tag_merge_func (GValue* dest, GValue* src);
-static void rygel_metadata_extractor_register_custom_tag (const char* tag, GType type);
-static inline void _dynamic_set_video_sink6 (GstElement* obj, GstElement* value);
-static inline void _dynamic_set_audio_sink7 (GstElement* obj, GstElement* value);
-static void rygel_metadata_extractor_tag_cb (RygelMetadataExtractor* self, GstBus* bus, GstMessage* message);
-static void _rygel_metadata_extractor_tag_cb_gst_bus_message (GstBus* _sender, GstMessage* message, gpointer self);
-static void rygel_metadata_extractor_state_changed_cb (RygelMetadataExtractor* self, GstBus* bus, GstMessage* message);
-static void _rygel_metadata_extractor_state_changed_cb_gst_bus_message (GstBus* _sender, GstMessage* message, gpointer self);
-static void rygel_metadata_extractor_error_cb (RygelMetadataExtractor* self, GstBus* bus, GstMessage* message);
-static void _rygel_metadata_extractor_error_cb_gst_bus_message (GstBus* _sender, GstMessage* message, gpointer self);
-static void rygel_metadata_extractor_renew_playbin (RygelMetadataExtractor* self);
-RygelMetadataExtractor* rygel_metadata_extractor_new (void);
-RygelMetadataExtractor* rygel_metadata_extractor_construct (GType object_type);
-static void rygel_metadata_extractor_extract_next (RygelMetadataExtractor* self);
-void rygel_metadata_extractor_extract (RygelMetadataExtractor* self, GFile* file);
-static gboolean rygel_metadata_extractor_on_harvesting_timeout (RygelMetadataExtractor* self);
-static void rygel_metadata_extractor_extract_mime_and_size (RygelMetadataExtractor* self, GError** error);
-static inline void _dynamic_set_uri8 (GstElement* obj, char* value);
-static gboolean _rygel_metadata_extractor_on_harvesting_timeout_gsource_func (gpointer self);
-static void rygel_metadata_extractor_extract_duration (RygelMetadataExtractor* self);
-static void rygel_metadata_extractor_extract_stream_info (RygelMetadataExtractor* self);
-static void rygel_metadata_extractor_extract_av_info (RygelMetadataExtractor* self, GstPad* pad, GstStreamType type);
-static inline GstElement* _dynamic_get_video_sink9 (GstElement* obj);
-static inline GstElement* _dynamic_get_audio_sink10 (GstElement* obj);
-static void rygel_metadata_extractor_extract_audio_info (RygelMetadataExtractor* self, const GstStructure* structure);
-static void rygel_metadata_extractor_extract_video_info (RygelMetadataExtractor* self, const GstStructure* structure);
-static void rygel_metadata_extractor_extract_int_value (RygelMetadataExtractor* self, const GstStructure* structure, const char* key, const char* tag);
-static void rygel_metadata_extractor_finalize (GObject* obj);
-
-
-static void g_cclosure_user_marshal_VOID__OBJECT_POINTER (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data);
-
-
-GType gst_stream_type_get_type (void) {
-	static GType gst_stream_type_type_id = 0;
-	if (G_UNLIKELY (gst_stream_type_type_id == 0)) {
-		static const GEnumValue values[] = {{GST_STREAM_TYPE_UNKNOWN, "GST_STREAM_TYPE_UNKNOWN", "unknown"}, {GST_STREAM_TYPE_AUDIO, "GST_STREAM_TYPE_AUDIO", "audio"}, {GST_STREAM_TYPE_VIDEO, "GST_STREAM_TYPE_VIDEO", "video"}, {GST_STREAM_TYPE_TEXT, "GST_STREAM_TYPE_TEXT", "text"}, {GST_STREAM_TYPE_SUBPICTURE, "GST_STREAM_TYPE_SUBPICTURE", "subpicture"}, {GST_STREAM_TYPE_ELEMENT, "GST_STREAM_TYPE_ELEMENT", "element"}, {0, NULL, NULL}};
-		gst_stream_type_type_id = g_enum_register_static ("GstStreamType", values);
-	}
-	return gst_stream_type_type_id;
-}
-
-
-static void _gst_tag_merge_use_first_gst_tag_merge_func (GValue* dest, GValue* src) {
-	gst_tag_merge_use_first (dest, src);
-}
-
-
-static void rygel_metadata_extractor_register_custom_tag (const char* tag, GType type) {
-	g_return_if_fail (tag != NULL);
-	gst_tag_register (tag, GST_TAG_FLAG_META, type, tag, "", _gst_tag_merge_use_first_gst_tag_merge_func);
-}
-
-
-static inline void _dynamic_set_video_sink6 (GstElement* obj, GstElement* value) {
-	g_object_set (obj, "video-sink", value, NULL);
-}
-
-
-static inline void _dynamic_set_audio_sink7 (GstElement* obj, GstElement* value) {
-	g_object_set (obj, "audio-sink", value, NULL);
-}
-
-
-static void _rygel_metadata_extractor_tag_cb_gst_bus_message (GstBus* _sender, GstMessage* message, gpointer self) {
-	rygel_metadata_extractor_tag_cb (self, _sender, message);
-}
-
-
-static void _rygel_metadata_extractor_state_changed_cb_gst_bus_message (GstBus* _sender, GstMessage* message, gpointer self) {
-	rygel_metadata_extractor_state_changed_cb (self, _sender, message);
-}
-
-
-static void _rygel_metadata_extractor_error_cb_gst_bus_message (GstBus* _sender, GstMessage* message, gpointer self) {
-	rygel_metadata_extractor_error_cb (self, _sender, message);
-}
-
-
-static void rygel_metadata_extractor_renew_playbin (RygelMetadataExtractor* self) {
-	GstElement* _tmp0_;
-	GstElement* sink;
-	GstElement* _tmp2_;
-	GstBus* bus;
-	g_return_if_fail (self != NULL);
-	self->priv->playbin = (_tmp0_ = gst_element_factory_make ("playbin2", NULL), _gst_object_unref0 (self->priv->playbin), _tmp0_);
-	if (self->priv->playbin == NULL) {
-		GstElement* _tmp1_;
-		self->priv->playbin = (_tmp1_ = gst_element_factory_make ("playbin", NULL), _gst_object_unref0 (self->priv->playbin), _tmp1_);
-	}
-	sink = gst_element_factory_make ("fakesink", NULL);
-	gst_object_ref ((GstObject*) sink);
-	_dynamic_set_video_sink6 (self->priv->playbin, sink);
-	sink = (_tmp2_ = gst_element_factory_make ("fakesink", NULL), _gst_object_unref0 (sink), _tmp2_);
-	gst_object_ref ((GstObject*) sink);
-	_dynamic_set_audio_sink7 (self->priv->playbin, sink);
-	bus = gst_element_get_bus (self->priv->playbin);
-	gst_bus_add_signal_watch (bus);
-	g_signal_connect_object (bus, "message::tag", (GCallback) _rygel_metadata_extractor_tag_cb_gst_bus_message, self, 0);
-	g_signal_connect_object (bus, "message::state-changed", (GCallback) _rygel_metadata_extractor_state_changed_cb_gst_bus_message, self, 0);
-	g_signal_connect_object (bus, "message::error", (GCallback) _rygel_metadata_extractor_error_cb_gst_bus_message, self, 0);
-	_gst_object_unref0 (sink);
-	_gst_object_unref0 (bus);
-}
-
-
-RygelMetadataExtractor* rygel_metadata_extractor_construct (GType object_type) {
-	RygelMetadataExtractor * self;
-	GQueue* _tmp0_;
-	GstTagList* _tmp1_;
-	self = (RygelMetadataExtractor*) g_object_new (object_type, NULL);
-	rygel_metadata_extractor_register_custom_tag (RYGEL_METADATA_EXTRACTOR_TAG_RYGEL_SIZE, G_TYPE_INT64);
-	rygel_metadata_extractor_register_custom_tag (RYGEL_METADATA_EXTRACTOR_TAG_RYGEL_DURATION, G_TYPE_INT64);
-	rygel_metadata_extractor_register_custom_tag (RYGEL_METADATA_EXTRACTOR_TAG_RYGEL_MIME, G_TYPE_STRING);
-	rygel_metadata_extractor_register_custom_tag (RYGEL_METADATA_EXTRACTOR_TAG_RYGEL_CHANNELS, G_TYPE_INT);
-	rygel_metadata_extractor_register_custom_tag (RYGEL_METADATA_EXTRACTOR_TAG_RYGEL_RATE, G_TYPE_INT);
-	rygel_metadata_extractor_register_custom_tag (RYGEL_METADATA_EXTRACTOR_TAG_RYGEL_WIDTH, G_TYPE_INT);
-	rygel_metadata_extractor_register_custom_tag (RYGEL_METADATA_EXTRACTOR_TAG_RYGEL_HEIGHT, G_TYPE_INT);
-	rygel_metadata_extractor_register_custom_tag (RYGEL_METADATA_EXTRACTOR_TAG_RYGEL_DEPTH, G_TYPE_INT);
-	rygel_metadata_extractor_register_custom_tag (RYGEL_METADATA_EXTRACTOR_TAG_RYGEL_MTIME, G_TYPE_UINT64);
-	self->priv->file_queue = (_tmp0_ = g_queue_new (), _g_queue_free0 (self->priv->file_queue), _tmp0_);
-	self->priv->tag_list = (_tmp1_ = gst_tag_list_new (), _gst_tag_list_free0 (self->priv->tag_list), _tmp1_);
-	return self;
-}
-
-
-RygelMetadataExtractor* rygel_metadata_extractor_new (void) {
-	return rygel_metadata_extractor_construct (RYGEL_TYPE_METADATA_EXTRACTOR);
-}
-
-
-static gpointer _g_object_ref0 (gpointer self) {
-	return self ? g_object_ref (self) : NULL;
-}
-
-
-void rygel_metadata_extractor_extract (RygelMetadataExtractor* self, GFile* file) {
-	gboolean trigger_run;
-	g_return_if_fail (self != NULL);
-	g_return_if_fail (file != NULL);
-	trigger_run = g_queue_get_length (self->priv->file_queue) == 0;
-	g_queue_push_tail (self->priv->file_queue, _g_object_ref0 (file));
-	if (trigger_run) {
-		rygel_metadata_extractor_extract_next (self);
-	}
-}
-
-
-static gboolean rygel_metadata_extractor_on_harvesting_timeout (RygelMetadataExtractor* self) {
-	gboolean result;
-	char* _tmp0_;
-	GError* _tmp1_;
-	GFile* _tmp2_;
-	g_return_val_if_fail (self != NULL, FALSE);
-	g_warning ("rygel-metadata-extractor.vala:128: Metadata extractor timed out on %s, restarting", _tmp0_ = g_file_get_uri ((GFile*) g_queue_peek_head (self->priv->file_queue)));
-	_g_free0 (_tmp0_);
-	gst_element_set_state (self->priv->playbin, GST_STATE_NULL);
-	g_signal_emit_by_name (self, "error", (GFile*) g_queue_peek_head (self->priv->file_queue), _tmp1_ = g_error_new_literal (G_IO_CHANNEL_ERROR, G_IO_CHANNEL_ERROR_FAILED, "Pipeline stuck while reading file info"));
-	_g_error_free0 (_tmp1_);
-	_tmp2_ = (GFile*) g_queue_pop_head (self->priv->file_queue);
-	_g_object_unref0 (_tmp2_);
-	rygel_metadata_extractor_extract_next (self);
-	result = FALSE;
-	return result;
-}
-
-
-static inline void _dynamic_set_uri8 (GstElement* obj, char* value) {
-	g_object_set (obj, "uri", value, NULL);
-}
-
-
-static gboolean _rygel_metadata_extractor_on_harvesting_timeout_gsource_func (gpointer self) {
-	return rygel_metadata_extractor_on_harvesting_timeout (self);
-}
-
-
-static void rygel_metadata_extractor_extract_next (RygelMetadataExtractor* self) {
-	GError * _inner_error_;
-	g_return_if_fail (self != NULL);
-	_inner_error_ = NULL;
-	if (self->priv->timeout_id != 0) {
-		g_source_remove (self->priv->timeout_id);
-	}
-	if (g_queue_get_length (self->priv->file_queue) > 0) {
-		{
-			GFile* item;
-			char* _tmp0_;
-			char* _tmp1_;
-			item = _g_object_ref0 ((GFile*) g_queue_peek_head (self->priv->file_queue));
-			g_debug ("rygel-metadata-extractor.vala:147: Scheduling file %s for metadata extraction", _tmp0_ = g_file_get_uri (item));
-			_g_free0 (_tmp0_);
-			rygel_metadata_extractor_extract_mime_and_size (self, &_inner_error_);
-			if (_inner_error_ != NULL) {
-				_g_object_unref0 (item);
-				goto __catch44_g_error;
-				goto __finally44;
-			}
-			rygel_metadata_extractor_renew_playbin (self);
-			_dynamic_set_uri8 (self->priv->playbin, _tmp1_ = g_file_get_uri (item));
-			_g_free0 (_tmp1_);
-			self->priv->timeout_id = g_timeout_add_seconds_full (G_PRIORITY_DEFAULT, (guint) 5, _rygel_metadata_extractor_on_harvesting_timeout_gsource_func, g_object_ref (self), g_object_unref);
-			gst_element_set_state (self->priv->playbin, GST_STATE_PAUSED);
-			_g_object_unref0 (item);
-		}
-		goto __finally44;
-		__catch44_g_error:
-		{
-			GError * _error_;
-			_error_ = _inner_error_;
-			_inner_error_ = NULL;
-			{
-				rygel_metadata_extractor_extract_next (self);
-				_g_error_free0 (_error_);
-			}
-		}
-		__finally44:
-		if (_inner_error_ != NULL) {
-			g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
-			g_clear_error (&_inner_error_);
-			return;
-		}
-	}
-}
-
-
-static void rygel_metadata_extractor_tag_cb (RygelMetadataExtractor* self, GstBus* bus, GstMessage* message) {
-	GstTagList* new_tag_list;
-	GstTagList* _tmp1_;
-	GstTagList* _tmp0_ = NULL;
-	GstTagList* _tmp2_;
-	g_return_if_fail (self != NULL);
-	g_return_if_fail (bus != NULL);
-	g_return_if_fail (message != NULL);
-	new_tag_list = NULL;
-	gst_message_parse_tag (message, &_tmp0_);
-	new_tag_list = (_tmp1_ = _tmp0_, _gst_tag_list_free0 (new_tag_list), _tmp1_);
-	self->priv->tag_list = (_tmp2_ = gst_tag_list_merge (new_tag_list, self->priv->tag_list, GST_TAG_MERGE_REPLACE), _gst_tag_list_free0 (self->priv->tag_list), _tmp2_);
-	_gst_tag_list_free0 (new_tag_list);
-}
-
-
-static void rygel_metadata_extractor_state_changed_cb (RygelMetadataExtractor* self, GstBus* bus, GstMessage* message) {
-	GstState new_state = 0;
-	GstState old_state = 0;
-	gboolean _tmp0_ = FALSE;
-	g_return_if_fail (self != NULL);
-	g_return_if_fail (bus != NULL);
-	g_return_if_fail (message != NULL);
-	if (message->src != GST_OBJECT (self->priv->playbin)) {
-		return;
-	}
-	gst_message_parse_state_changed (message, &old_state, &new_state, NULL);
-	if (new_state == GST_STATE_PAUSED) {
-		_tmp0_ = old_state == GST_STATE_READY;
-	} else {
-		_tmp0_ = FALSE;
-	}
-	if (_tmp0_) {
-		GstTagList* _tmp1_;
-		GFile* _tmp2_;
-		rygel_metadata_extractor_extract_duration (self);
-		rygel_metadata_extractor_extract_stream_info (self);
-		g_signal_emit_by_name (self, "extraction-done", (GFile*) g_queue_peek_head (self->priv->file_queue), self->priv->tag_list);
-		gst_element_set_state (self->priv->playbin, GST_STATE_NULL);
-		self->priv->tag_list = (_tmp1_ = gst_tag_list_new (), _gst_tag_list_free0 (self->priv->tag_list), _tmp1_);
-		_tmp2_ = (GFile*) g_queue_pop_head (self->priv->file_queue);
-		_g_object_unref0 (_tmp2_);
-		rygel_metadata_extractor_extract_next (self);
-	}
-}
-
-
-static void rygel_metadata_extractor_error_cb (RygelMetadataExtractor* self, GstBus* bus, GstMessage* message) {
-	GError* _error_;
-	char* debug;
-	char* _tmp3_;
-	char* _tmp2_ = NULL;
-	GError* _tmp1_;
-	GError* _tmp0_ = NULL;
-	GstTagList* _tmp5_;
-	GFile* _tmp6_;
-	g_return_if_fail (self != NULL);
-	g_return_if_fail (bus != NULL);
-	g_return_if_fail (message != NULL);
-	g_return_if_fail (g_queue_get_length (self->priv->file_queue) != 0);
-	_error_ = NULL;
-	debug = NULL;
-	(gst_message_parse_error (message, &_tmp0_, &_tmp2_), _error_ = (_tmp1_ = _tmp0_, _g_error_free0 (_error_), _tmp1_));
-	debug = (_tmp3_ = _tmp2_, _g_free0 (debug), _tmp3_);
-	if (_error_ != NULL) {
-		char* _tmp4_;
-		debug = (_tmp4_ = g_strdup (_error_->message), _g_free0 (debug), _tmp4_);
-	}
-	g_signal_emit_by_name (self, "error", (GFile*) g_queue_peek_head (self->priv->file_queue), _error_);
-	gst_element_set_state (self->priv->playbin, GST_STATE_NULL);
-	self->priv->tag_list = (_tmp5_ = gst_tag_list_new (), _gst_tag_list_free0 (self->priv->tag_list), _tmp5_);
-	_tmp6_ = (GFile*) g_queue_pop_head (self->priv->file_queue);
-	_g_object_unref0 (_tmp6_);
-	rygel_metadata_extractor_extract_next (self);
-	_g_error_free0 (_error_);
-	_g_free0 (debug);
-}
-
-
-static gpointer _g_error_copy0 (gpointer self) {
-	return self ? g_error_copy (self) : NULL;
-}
-
-
-static void rygel_metadata_extractor_extract_mime_and_size (RygelMetadataExtractor* self, GError** error) {
-	GError * _inner_error_;
-	GFile* file;
-	GFileInfo* file_info;
-	const char* content_type;
-	const char* mime;
-	gint64 size;
-	guint64 mtime;
-	g_return_if_fail (self != NULL);
-	_inner_error_ = NULL;
-	file = _g_object_ref0 ((GFile*) g_queue_peek_head (self->priv->file_queue));
-	file_info = NULL;
-	{
-		GFileInfo* _tmp0_;
-		GFileInfo* _tmp1_;
-		_tmp0_ = g_file_query_info (file, G_FILE_ATTRIBUTE_STANDARD_CONTENT_TYPE "," G_FILE_ATTRIBUTE_STANDARD_SIZE "," G_FILE_ATTRIBUTE_TIME_MODIFIED, G_FILE_QUERY_INFO_NONE, NULL, &_inner_error_);
-		if (_inner_error_ != NULL) {
-			goto __catch45_g_error;
-			goto __finally45;
-		}
-		file_info = (_tmp1_ = _tmp0_, _g_object_unref0 (file_info), _tmp1_);
-	}
-	goto __finally45;
-	__catch45_g_error:
-	{
-		GError * _error_;
-		_error_ = _inner_error_;
-		_inner_error_ = NULL;
-		{
-			char* _tmp2_;
-			g_warning ("rygel-metadata-extractor.vala:233: Failed to query content type for '%s'\n", _tmp2_ = g_file_get_uri (file));
-			_g_free0 (_tmp2_);
-			g_signal_emit_by_name (self, "error", file, _error_);
-			_inner_error_ = _g_error_copy0 (_error_);
-			if (_inner_error_ != NULL) {
-				_g_error_free0 (_error_);
-				_g_object_unref0 (file);
-				_g_object_unref0 (file_info);
-				goto __finally45;
-			}
-			_g_error_free0 (_error_);
-		}
-	}
-	__finally45:
-	if (_inner_error_ != NULL) {
-		g_propagate_error (error, _inner_error_);
-		_g_object_unref0 (file);
-		_g_object_unref0 (file_info);
-		return;
-	}
-	content_type = g_file_info_get_content_type (file_info);
-	mime = g_content_type_get_mime_type (content_type);
-	if (mime != NULL) {
-		gst_tag_list_add (self->priv->tag_list, GST_TAG_MERGE_REPLACE, RYGEL_METADATA_EXTRACTOR_TAG_RYGEL_MIME, mime, NULL);
-	}
-	size = g_file_info_get_size (file_info);
-	gst_tag_list_add (self->priv->tag_list, GST_TAG_MERGE_REPLACE, RYGEL_METADATA_EXTRACTOR_TAG_RYGEL_SIZE, size, NULL);
-	mtime = g_file_info_get_attribute_uint64 (file_info, G_FILE_ATTRIBUTE_TIME_MODIFIED);
-	gst_tag_list_add (self->priv->tag_list, GST_TAG_MERGE_REPLACE, RYGEL_METADATA_EXTRACTOR_TAG_RYGEL_MTIME, mtime, NULL);
-	_g_object_unref0 (file);
-	_g_object_unref0 (file_info);
-}
-
-
-static void rygel_metadata_extractor_extract_duration (RygelMetadataExtractor* self) {
-	gint64 duration = 0LL;
-	GstFormat format;
-	g_return_if_fail (self != NULL);
-	format = GST_FORMAT_TIME;
-	if (gst_element_query_duration (self->priv->playbin, &format, &duration)) {
-		gst_tag_list_add (self->priv->tag_list, GST_TAG_MERGE_REPLACE, RYGEL_METADATA_EXTRACTOR_TAG_RYGEL_DURATION, duration, NULL);
-	}
-}
-
-
-static inline GstElement* _dynamic_get_video_sink9 (GstElement* obj) {
-	GstElement* result;
-	g_object_get (obj, "video-sink", &result, NULL);
-	return result;
-}
-
-
-static inline GstElement* _dynamic_get_audio_sink10 (GstElement* obj) {
-	GstElement* result;
-	g_object_get (obj, "audio-sink", &result, NULL);
-	return result;
-}
-
-
-static void rygel_metadata_extractor_extract_stream_info (RygelMetadataExtractor* self) {
-	g_return_if_fail (self != NULL);
-	rygel_metadata_extractor_extract_av_info (self, gst_element_get_pad (_dynamic_get_video_sink9 (self->priv->playbin), "sink"), GST_STREAM_TYPE_VIDEO);
-	rygel_metadata_extractor_extract_av_info (self, gst_element_get_pad (_dynamic_get_audio_sink10 (self->priv->playbin), "sink"), GST_STREAM_TYPE_AUDIO);
-}
-
-
-static void rygel_metadata_extractor_extract_av_info (RygelMetadataExtractor* self, GstPad* pad, GstStreamType type) {
-	GstCaps* caps;
-	const GstStructure* structure;
-	g_return_if_fail (self != NULL);
-	g_return_if_fail (pad != NULL);
-	if (pad == NULL) {
-		return;
-	}
-	caps = gst_pad_get_negotiated_caps (pad);
-	if (caps == NULL) {
-		_gst_caps_unref0 (caps);
-		return;
-	}
-	structure = gst_caps_get_structure (caps, (guint) 0);
-	if (structure == NULL) {
-		_gst_caps_unref0 (caps);
-		return;
-	}
-	if (type == GST_STREAM_TYPE_AUDIO) {
-		rygel_metadata_extractor_extract_audio_info (self, structure);
-	} else {
-		if (type == GST_STREAM_TYPE_VIDEO) {
-			rygel_metadata_extractor_extract_video_info (self, structure);
-		}
-	}
-	_gst_caps_unref0 (caps);
-}
-
-
-static void rygel_metadata_extractor_extract_audio_info (RygelMetadataExtractor* self, const GstStructure* structure) {
-	g_return_if_fail (self != NULL);
-	g_return_if_fail (structure != NULL);
-	rygel_metadata_extractor_extract_int_value (self, structure, "channels", RYGEL_METADATA_EXTRACTOR_TAG_RYGEL_CHANNELS);
-	rygel_metadata_extractor_extract_int_value (self, structure, "rate", RYGEL_METADATA_EXTRACTOR_TAG_RYGEL_RATE);
-}
-
-
-static void rygel_metadata_extractor_extract_video_info (RygelMetadataExtractor* self, const GstStructure* structure) {
-	g_return_if_fail (self != NULL);
-	g_return_if_fail (structure != NULL);
-	rygel_metadata_extractor_extract_int_value (self, structure, "width", RYGEL_METADATA_EXTRACTOR_TAG_RYGEL_WIDTH);
-	rygel_metadata_extractor_extract_int_value (self, structure, "height", RYGEL_METADATA_EXTRACTOR_TAG_RYGEL_HEIGHT);
-	rygel_metadata_extractor_extract_int_value (self, structure, "depth", RYGEL_METADATA_EXTRACTOR_TAG_RYGEL_DEPTH);
-}
-
-
-static void rygel_metadata_extractor_extract_int_value (RygelMetadataExtractor* self, const GstStructure* structure, const char* key, const char* tag) {
-	gint val = 0;
-	g_return_if_fail (self != NULL);
-	g_return_if_fail (structure != NULL);
-	g_return_if_fail (key != NULL);
-	g_return_if_fail (tag != NULL);
-	if (gst_structure_get_int (structure, key, &val)) {
-		gst_tag_list_add (self->priv->tag_list, GST_TAG_MERGE_REPLACE, tag, val, NULL);
-	}
-}
-
-
-static void rygel_metadata_extractor_class_init (RygelMetadataExtractorClass * klass) {
-	rygel_metadata_extractor_parent_class = g_type_class_peek_parent (klass);
-	g_type_class_add_private (klass, sizeof (RygelMetadataExtractorPrivate));
-	G_OBJECT_CLASS (klass)->finalize = rygel_metadata_extractor_finalize;
-	g_signal_new ("extraction_done", RYGEL_TYPE_METADATA_EXTRACTOR, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_user_marshal_VOID__OBJECT_POINTER, G_TYPE_NONE, 2, G_TYPE_FILE, G_TYPE_POINTER);
-	g_signal_new ("error", RYGEL_TYPE_METADATA_EXTRACTOR, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_user_marshal_VOID__OBJECT_POINTER, G_TYPE_NONE, 2, G_TYPE_FILE, G_TYPE_POINTER);
-}
-
-
-static void rygel_metadata_extractor_instance_init (RygelMetadataExtractor * self) {
-	self->priv = RYGEL_METADATA_EXTRACTOR_GET_PRIVATE (self);
-}
-
-
-static void rygel_metadata_extractor_finalize (GObject* obj) {
-	RygelMetadataExtractor * self;
-	self = RYGEL_METADATA_EXTRACTOR (obj);
-	_gst_object_unref0 (self->priv->playbin);
-	_gst_tag_list_free0 (self->priv->tag_list);
-	_g_queue_free0 (self->priv->file_queue);
-	G_OBJECT_CLASS (rygel_metadata_extractor_parent_class)->finalize (obj);
-}
-
-
-GType rygel_metadata_extractor_get_type (void) {
-	static GType rygel_metadata_extractor_type_id = 0;
-	if (rygel_metadata_extractor_type_id == 0) {
-		static const GTypeInfo g_define_type_info = { sizeof (RygelMetadataExtractorClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) rygel_metadata_extractor_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (RygelMetadataExtractor), 0, (GInstanceInitFunc) rygel_metadata_extractor_instance_init, NULL };
-		rygel_metadata_extractor_type_id = g_type_register_static (G_TYPE_OBJECT, "RygelMetadataExtractor", &g_define_type_info, 0);
-	}
-	return rygel_metadata_extractor_type_id;
-}
-
-
-
-static void g_cclosure_user_marshal_VOID__OBJECT_POINTER (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data) {
-	typedef void (*GMarshalFunc_VOID__OBJECT_POINTER) (gpointer data1, gpointer arg_1, gpointer arg_2, gpointer data2);
-	register GMarshalFunc_VOID__OBJECT_POINTER callback;
-	register GCClosure * cc;
-	register gpointer data1, data2;
-	cc = (GCClosure *) closure;
-	g_return_if_fail (n_param_values == 3);
-	if (G_CCLOSURE_SWAP_DATA (closure)) {
-		data1 = closure->data;
-		data2 = param_values->data[0].v_pointer;
-	} else {
-		data1 = param_values->data[0].v_pointer;
-		data2 = closure->data;
-	}
-	callback = (GMarshalFunc_VOID__OBJECT_POINTER) (marshal_data ? marshal_data : cc->callback);
-	callback (data1, g_value_get_object (param_values + 1), g_value_get_pointer (param_values + 2), data2);
-}
-
-
-
--- a/src/rygel/rygel-metadata-extractor.vala
+++ /dev/null
@@ -1,326 +0,0 @@
-/*
- * Copyright (C) 2008 Zeeshan Ali (Khattak) <zeeshanak@gnome.org>.
- * Copyright (C) 2009 Jens Georg <mail@jensge.org>.
- *
- * Author: Zeeshan Ali (Khattak) <zeeshanak@gnome.org>
- * Author: Jens Georg <mail@jensge.org>
- *
- * This file is part of Rygel.
- *
- * Rygel is free software; you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * Rygel is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this program; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
- */
-
-
-using Gst;
-using Gee;
-
-private enum Gst.StreamType {
-    UNKNOWN = 0,
-    AUDIO   = 1,    /* an audio stream */
-    VIDEO   = 2,    /* a video stream */
-    TEXT    = 3,    /* a subtitle/text stream */
-    SUBPICTURE = 4, /* a subtitle in picture-form */
-    ELEMENT = 5     /* stream handled by an element */
-}
-
-/**
- * Metadata extractor based on Gstreamer. Just set the URI of the media on the
- * uri property, it will extact the metadata for you and emit signal
- * metadata_available for each key/value pair extracted.
- */
-public class Rygel.MetadataExtractor: GLib.Object {
-    public const string TAG_RYGEL_SIZE = "rygel-size";
-    public const string TAG_RYGEL_DURATION = "rygel-duration";
-    public const string TAG_RYGEL_MIME = "rygel-mime";
-    public const string TAG_RYGEL_CHANNELS = "rygel-channels";
-    public const string TAG_RYGEL_RATE = "rygel-rate";
-    public const string TAG_RYGEL_WIDTH = "rygel-width";
-    public const string TAG_RYGEL_HEIGHT = "rygel-height";
-    public const string TAG_RYGEL_DEPTH = "rygel-depth";
-    public const string TAG_RYGEL_MTIME = "rygel-mtime";
-
-    /* TODO: Use tagbin instead once it's ready */
-    private dynamic Gst.Element playbin;
-
-    /* Signals */
-    public signal void extraction_done (File file, Gst.TagList tag_list);
-
-    /**
-     * Signalize that an error occured during metadata extraction
-     */
-    public signal void error (File file, Error err);
-
-    private TagList tag_list;
-
-    private GLib.Queue<File> file_queue;
-
-    private uint timeout_id;
-
-    private static void register_custom_tag (string tag, Type type) {
-        Gst.tag_register (tag,
-                          TagFlag.META,
-                          type,
-                          tag,
-                          "",
-                          Gst.tag_merge_use_first);
-    }
-
-    private void renew_playbin () {
-        // setup fake sinks
-        this.playbin = ElementFactory.make ("playbin2", null);
-        if (this.playbin == null) {
-            this.playbin = ElementFactory.make ("playbin", null);
-        }
-
-        // increase reference count of sinks to workaround
-        // bug #596078
-        var sink = ElementFactory.make ("fakesink", null);
-        sink.ref ();
-        this.playbin.video_sink = sink;
-
-        sink = ElementFactory.make ("fakesink", null);
-        sink.ref ();
-        this.playbin.audio_sink = sink;
-
-        var bus = this.playbin.get_bus ();
-        bus.add_signal_watch ();
-        bus.message["tag"] += this.tag_cb;
-        bus.message["state-changed"] += this.state_changed_cb;
-        bus.message["error"] += this.error_cb;
-    }
-
-    public MetadataExtractor () {
-        this.register_custom_tag (TAG_RYGEL_SIZE, typeof (int64));
-        this.register_custom_tag (TAG_RYGEL_DURATION, typeof (int64));
-        this.register_custom_tag (TAG_RYGEL_MIME, typeof (string));
-        this.register_custom_tag (TAG_RYGEL_CHANNELS, typeof (int));
-        this.register_custom_tag (TAG_RYGEL_RATE, typeof (int));
-        this.register_custom_tag (TAG_RYGEL_WIDTH, typeof (int));
-        this.register_custom_tag (TAG_RYGEL_HEIGHT, typeof (int));
-        this.register_custom_tag (TAG_RYGEL_DEPTH, typeof (int));
-        this.register_custom_tag (TAG_RYGEL_MTIME, typeof (uint64));
-
-        this.file_queue = new GLib.Queue<File> ();
-        this.tag_list = new Gst.TagList ();
-    }
-
-    public void extract (File file) {
-        var trigger_run = this.file_queue.get_length () == 0;
-        this.file_queue.push_tail (file);
-        if (trigger_run) {
-            this.extract_next ();
-        }
-    }
-
-    private bool on_harvesting_timeout () {
-        warning ("Metadata extractor timed out on %s, restarting",
-               this.file_queue.peek_head ().get_uri ());
-        this.playbin.set_state (State.NULL);
-
-        this.error (file_queue.peek_head (),
-                    new IOChannelError.FAILED (
-                                "Pipeline stuck while reading file info"));
-        this.file_queue.pop_head ();
-        extract_next ();
-        return false;
-    }
-
-    private void extract_next () {
-        if (this.timeout_id != 0)
-            Source.remove (this.timeout_id);
-
-        if (this.file_queue.get_length () > 0) {
-            try {
-                var item = this.file_queue.peek_head ();
-                debug ("Scheduling file %s for metadata extraction",
-                       item.get_uri ());
-               this.extract_mime_and_size ();
-                renew_playbin ();
-                this.playbin.uri = item.get_uri ();
-                this.timeout_id = Timeout.add_seconds_full (
-                                                         Priority.DEFAULT,
-                                                         5,
-                                                         on_harvesting_timeout);
-                this.playbin.set_state (State.PAUSED);
-            } catch (Error error) {
-                // on error just move to the next uri in queue
-                this.extract_next ();
-            }
-        }
-    }
-
-    /* Callback for tags found by playbin */
-    private void tag_cb (Gst.Bus     bus,
-                         Gst.Message message) {
-        TagList new_tag_list;
-
-        message.parse_tag (out new_tag_list);
-        this.tag_list = new_tag_list.merge (this.tag_list,
-                                            TagMergeMode.REPLACE);
-    }
-
-    /* Callback for state-change in playbin */
-    private void state_changed_cb (Gst.Bus     bus,
-                                   Gst.Message message) {
-        if (message.src != this.playbin)
-            return;
-
-        State new_state;
-        State old_state;
-
-        message.parse_state_changed (out old_state, out new_state, null);
-        if (new_state == State.PAUSED && old_state == State.READY) {
-            this.extract_duration ();
-            this.extract_stream_info ();
-
-            /* No hopes of getting any tags after this point */
-            this.extraction_done (this.file_queue.peek_head (), tag_list);
-            this.playbin.set_state (State.NULL);
-            this.tag_list = new Gst.TagList ();
-            this.file_queue.pop_head ();
-            this.extract_next ();
-        }
-    }
-
-    /* Callback for errors in playbin */
-    private void error_cb (Gst.Bus     bus,
-                           Gst.Message message) {
-
-        return_if_fail (this.file_queue.get_length() != 0);
-
-        Error error = null;
-        string debug;
-
-        message.parse_error (out error, out debug);
-        if (error != null) {
-            debug = error.message;
-        }
-
-        // signalize error to listeners
-        this.error (this.file_queue.peek_head (), error);
-
-        /* We have a list of URIs to harvest, so lets jump to next one */
-        this.playbin.set_state (State.NULL);
-        this.tag_list = new Gst.TagList ();
-        this.file_queue.pop_head ();
-        this.extract_next ();
-    }
-
-    private void extract_mime_and_size () throws Error {
-        var file = this.file_queue.peek_head ();
-        FileInfo file_info;
-
-        try {
-            file_info = file.query_info (FILE_ATTRIBUTE_STANDARD_CONTENT_TYPE
-                                         + "," +
-                                         FILE_ATTRIBUTE_STANDARD_SIZE + "," +
-                                         FILE_ATTRIBUTE_TIME_MODIFIED,
-                                         FileQueryInfoFlags.NONE,
-                                         null);
-        } catch (Error error) {
-            warning ("Failed to query content type for '%s'\n",
-                      file.get_uri ());
-
-            // signal error to parent
-            this.error (file, error);
-
-            throw error;
-        }
-
-        weak string content_type = file_info.get_content_type ();
-        weak string mime = g_content_type_get_mime_type (content_type);
-        if (mime != null) {
-            /* add custom mime tag to tag list */
-            this.tag_list.add (TagMergeMode.REPLACE,
-                               TAG_RYGEL_MIME,
-                               mime);
-        }
-
-        var size = file_info.get_size ();
-        this.tag_list.add (TagMergeMode.REPLACE,
-                           TAG_RYGEL_SIZE,
-                           size);
-
-        var mtime = file_info.get_attribute_uint64(
-                                                FILE_ATTRIBUTE_TIME_MODIFIED);
-        this.tag_list.add (TagMergeMode.REPLACE,
-                           TAG_RYGEL_MTIME,
-                           mtime);
-    }
-
-    private void extract_duration () {
-        int64 duration;
-
-        Format format = Format.TIME;
-        if (this.playbin.query_duration (ref format, out duration)) {
-            this.tag_list.add (TagMergeMode.REPLACE,
-                               TAG_RYGEL_DURATION,
-                               duration);
-        }
-    }
-
-    private void extract_stream_info () {
-        extract_av_info (this.playbin.video_sink.get_pad ("sink"),
-                StreamType.VIDEO);
-        extract_av_info (this.playbin.audio_sink.get_pad ("sink"),
-                StreamType.AUDIO);
-    }
-
-    private void extract_av_info (Pad pad, StreamType type) {
-        if (pad == null) {
-            return;
-        }
-
-        Gst.Caps caps = pad.get_negotiated_caps ();
-        if (caps == null) {
-            return;
-        }
-
-        weak Structure structure = caps.get_structure (0);
-        if (structure == null) {
-            return;
-        }
-
-        if (type == StreamType.AUDIO) {
-            this.extract_audio_info (structure);
-        } else if (type == StreamType.VIDEO) {
-            this.extract_video_info (structure);
-        }
-    }
-
-    private void extract_audio_info (Structure structure) {
-        this.extract_int_value (structure, "channels", TAG_RYGEL_CHANNELS);
-        this.extract_int_value (structure, "rate", TAG_RYGEL_RATE);
-    }
-
-    private void extract_video_info (Structure structure) {
-        this.extract_int_value (structure, "width", TAG_RYGEL_WIDTH);
-        this.extract_int_value (structure, "height", TAG_RYGEL_HEIGHT);
-        this.extract_int_value (structure, "depth", TAG_RYGEL_DEPTH);
-    }
-
-    private void extract_int_value (Structure structure,
-                                    string key,
-                                    string tag) {
-        int val;
-
-        if (structure.get_int (key, out val)) {
-            tag_list.add (TagMergeMode.REPLACE,
-                          tag,
-                          val);
-        }
-    }
-}
-
--- a/src/rygel/rygel-mp2ts-transcoder-bin.c
+++ /dev/null
@@ -1,317 +0,0 @@
-/* rygel-mp2ts-transcoder-bin.c generated by valac, the Vala compiler
- * generated from rygel-mp2ts-transcoder-bin.vala, do not modify */
-
-/*
- * Copyright (C) 2009 Nokia Corporation.
- *
- * Author: Zeeshan Ali (Khattak) <zeeshanak@gnome.org>
- *                               <zeeshan.ali@nokia.com>
- *
- * This file is part of Rygel.
- *
- * Rygel is free software; you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * Rygel is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this program; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
- */
-
-#include <glib.h>
-#include <glib-object.h>
-#include <gst/gst.h>
-#include <stdlib.h>
-#include <string.h>
-
-
-#define RYGEL_TYPE_MP2_TS_TRANSCODER_BIN (rygel_mp2_ts_transcoder_bin_get_type ())
-#define RYGEL_MP2_TS_TRANSCODER_BIN(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_MP2_TS_TRANSCODER_BIN, RygelMP2TSTranscoderBin))
-#define RYGEL_MP2_TS_TRANSCODER_BIN_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_MP2_TS_TRANSCODER_BIN, RygelMP2TSTranscoderBinClass))
-#define RYGEL_IS_MP2_TS_TRANSCODER_BIN(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_MP2_TS_TRANSCODER_BIN))
-#define RYGEL_IS_MP2_TS_TRANSCODER_BIN_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_MP2_TS_TRANSCODER_BIN))
-#define RYGEL_MP2_TS_TRANSCODER_BIN_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_MP2_TS_TRANSCODER_BIN, RygelMP2TSTranscoderBinClass))
-
-typedef struct _RygelMP2TSTranscoderBin RygelMP2TSTranscoderBin;
-typedef struct _RygelMP2TSTranscoderBinClass RygelMP2TSTranscoderBinClass;
-typedef struct _RygelMP2TSTranscoderBinPrivate RygelMP2TSTranscoderBinPrivate;
-#define _gst_object_unref0(var) ((var == NULL) ? NULL : (var = (gst_object_unref (var), NULL)))
-
-#define RYGEL_TYPE_MP3_LAYER (rygel_mp3_layer_get_type ())
-
-#define RYGEL_TYPE_TRANSCODER (rygel_transcoder_get_type ())
-#define RYGEL_TRANSCODER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_TRANSCODER, RygelTranscoder))
-#define RYGEL_TRANSCODER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_TRANSCODER, RygelTranscoderClass))
-#define RYGEL_IS_TRANSCODER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_TRANSCODER))
-#define RYGEL_IS_TRANSCODER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_TRANSCODER))
-#define RYGEL_TRANSCODER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_TRANSCODER, RygelTranscoderClass))
-
-typedef struct _RygelTranscoder RygelTranscoder;
-typedef struct _RygelTranscoderClass RygelTranscoderClass;
-
-#define RYGEL_TYPE_MP3_TRANSCODER (rygel_mp3_transcoder_get_type ())
-#define RYGEL_MP3_TRANSCODER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_MP3_TRANSCODER, RygelMP3Transcoder))
-#define RYGEL_MP3_TRANSCODER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_MP3_TRANSCODER, RygelMP3TranscoderClass))
-#define RYGEL_IS_MP3_TRANSCODER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_MP3_TRANSCODER))
-#define RYGEL_IS_MP3_TRANSCODER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_MP3_TRANSCODER))
-#define RYGEL_MP3_TRANSCODER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_MP3_TRANSCODER, RygelMP3TranscoderClass))
-
-typedef struct _RygelMP3Transcoder RygelMP3Transcoder;
-typedef struct _RygelMP3TranscoderClass RygelMP3TranscoderClass;
-
-#define RYGEL_TYPE_MEDIA_OBJECT (rygel_media_object_get_type ())
-#define RYGEL_MEDIA_OBJECT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_MEDIA_OBJECT, RygelMediaObject))
-#define RYGEL_MEDIA_OBJECT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_MEDIA_OBJECT, RygelMediaObjectClass))
-#define RYGEL_IS_MEDIA_OBJECT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_MEDIA_OBJECT))
-#define RYGEL_IS_MEDIA_OBJECT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_MEDIA_OBJECT))
-#define RYGEL_MEDIA_OBJECT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_MEDIA_OBJECT, RygelMediaObjectClass))
-
-typedef struct _RygelMediaObject RygelMediaObject;
-typedef struct _RygelMediaObjectClass RygelMediaObjectClass;
-
-#define RYGEL_TYPE_MEDIA_ITEM (rygel_media_item_get_type ())
-#define RYGEL_MEDIA_ITEM(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_MEDIA_ITEM, RygelMediaItem))
-#define RYGEL_MEDIA_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_MEDIA_ITEM, RygelMediaItemClass))
-#define RYGEL_IS_MEDIA_ITEM(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_MEDIA_ITEM))
-#define RYGEL_IS_MEDIA_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_MEDIA_ITEM))
-#define RYGEL_MEDIA_ITEM_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_MEDIA_ITEM, RygelMediaItemClass))
-
-typedef struct _RygelMediaItem RygelMediaItem;
-typedef struct _RygelMediaItemClass RygelMediaItemClass;
-#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
-
-#define RYGEL_TYPE_MP2_TS_TRANSCODER (rygel_mp2_ts_transcoder_get_type ())
-#define RYGEL_MP2_TS_TRANSCODER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_MP2_TS_TRANSCODER, RygelMP2TSTranscoder))
-#define RYGEL_MP2_TS_TRANSCODER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_MP2_TS_TRANSCODER, RygelMP2TSTranscoderClass))
-#define RYGEL_IS_MP2_TS_TRANSCODER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_MP2_TS_TRANSCODER))
-#define RYGEL_IS_MP2_TS_TRANSCODER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_MP2_TS_TRANSCODER))
-#define RYGEL_MP2_TS_TRANSCODER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_MP2_TS_TRANSCODER, RygelMP2TSTranscoderClass))
-
-typedef struct _RygelMP2TSTranscoder RygelMP2TSTranscoder;
-typedef struct _RygelMP2TSTranscoderClass RygelMP2TSTranscoderClass;
-#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
-
-struct _RygelMP2TSTranscoderBin {
-	GstBin parent_instance;
-	RygelMP2TSTranscoderBinPrivate * priv;
-};
-
-struct _RygelMP2TSTranscoderBinClass {
-	GstBinClass parent_class;
-};
-
-struct _RygelMP2TSTranscoderBinPrivate {
-	GstElement* audio_enc;
-	GstElement* video_enc;
-	GstElement* muxer;
-};
-
-typedef enum  {
-	RYGEL_MP3_LAYER_TWO = 1,
-	RYGEL_MP3_LAYER_THREE = 2
-} RygelMP3Layer;
-
-typedef enum  {
-	RYGEL_LIVE_RESPONSE_ERROR_MISSING_PLUGIN,
-	RYGEL_LIVE_RESPONSE_ERROR_LINK
-} RygelLiveResponseError;
-#define RYGEL_LIVE_RESPONSE_ERROR rygel_live_response_error_quark ()
-
-static gpointer rygel_mp2_ts_transcoder_bin_parent_class = NULL;
-
-GType rygel_mp2_ts_transcoder_bin_get_type (void);
-#define RYGEL_MP2_TS_TRANSCODER_BIN_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), RYGEL_TYPE_MP2_TS_TRANSCODER_BIN, RygelMP2TSTranscoderBinPrivate))
-enum  {
-	RYGEL_MP2_TS_TRANSCODER_BIN_DUMMY_PROPERTY
-};
-#define RYGEL_MP2_TS_TRANSCODER_BIN_DECODEBIN "decodebin2"
-#define RYGEL_MP2_TS_TRANSCODER_BIN_MUXER "mpegtsmux"
-#define RYGEL_MP2_TS_TRANSCODER_BIN_AUDIO_ENC_SINK "audio-enc-sink-pad"
-#define RYGEL_MP2_TS_TRANSCODER_BIN_VIDEO_ENC_SINK "sink"
-GstElement* rygel_gst_utils_create_element (const char* factoryname, const char* name, GError** error);
-GType rygel_mp3_layer_get_type (void);
-RygelMP3Transcoder* rygel_mp3_transcoder_new (RygelMP3Layer layer);
-RygelMP3Transcoder* rygel_mp3_transcoder_construct (GType object_type, RygelMP3Layer layer);
-GType rygel_transcoder_get_type (void);
-GType rygel_mp3_transcoder_get_type (void);
-GType rygel_media_object_get_type (void);
-GType rygel_media_item_get_type (void);
-GstElement* rygel_mp3_transcoder_create_encoder (RygelMP3Transcoder* self, RygelMediaItem* item, const char* src_pad_name, const char* sink_pad_name, GError** error);
-GType rygel_mp2_ts_transcoder_get_type (void);
-GstElement* rygel_mp2_ts_transcoder_create_encoder (RygelMP2TSTranscoder* self, RygelMediaItem* item, const char* src_pad_name, const char* sink_pad_name, GError** error);
-static void rygel_mp2_ts_transcoder_bin_decodebin_pad_added (RygelMP2TSTranscoderBin* self, GstElement* decodebin, GstPad* new_pad);
-static void _rygel_mp2_ts_transcoder_bin_decodebin_pad_added_gst_element_pad_added (GstElement* _sender, GstPad* pad, gpointer self);
-RygelMP2TSTranscoderBin* rygel_mp2_ts_transcoder_bin_new (RygelMediaItem* item, GstElement* src, RygelMP2TSTranscoder* transcoder, GError** error);
-RygelMP2TSTranscoderBin* rygel_mp2_ts_transcoder_bin_construct (GType object_type, RygelMediaItem* item, GstElement* src, RygelMP2TSTranscoder* transcoder, GError** error);
-void rygel_gst_utils_post_error (GstElement* dest, GError* _error_);
-GQuark rygel_live_response_error_quark (void);
-static void rygel_mp2_ts_transcoder_bin_finalize (GObject* obj);
-
-
-
-static gpointer _gst_object_ref0 (gpointer self) {
-	return self ? gst_object_ref (self) : NULL;
-}
-
-
-static void _rygel_mp2_ts_transcoder_bin_decodebin_pad_added_gst_element_pad_added (GstElement* _sender, GstPad* pad, gpointer self) {
-	rygel_mp2_ts_transcoder_bin_decodebin_pad_added (self, _sender, pad);
-}
-
-
-RygelMP2TSTranscoderBin* rygel_mp2_ts_transcoder_bin_construct (GType object_type, RygelMediaItem* item, GstElement* src, RygelMP2TSTranscoder* transcoder, GError** error) {
-	GError * _inner_error_;
-	RygelMP2TSTranscoderBin * self;
-	GstElement* decodebin;
-	RygelMP3Transcoder* mp3_transcoder;
-	GstElement* _tmp0_;
-	GstElement* _tmp1_;
-	GstElement* _tmp2_;
-	GstElement* _tmp3_;
-	GstElement* _tmp4_;
-	GstElement* _tmp5_;
-	GstPad* src_pad;
-	GstGhostPad* ghost;
-	g_return_val_if_fail (item != NULL, NULL);
-	g_return_val_if_fail (src != NULL, NULL);
-	g_return_val_if_fail (transcoder != NULL, NULL);
-	_inner_error_ = NULL;
-	self = g_object_newv (object_type, 0, NULL);
-	decodebin = rygel_gst_utils_create_element (RYGEL_MP2_TS_TRANSCODER_BIN_DECODEBIN, RYGEL_MP2_TS_TRANSCODER_BIN_DECODEBIN, &_inner_error_);
-	if (_inner_error_ != NULL) {
-		g_propagate_error (error, _inner_error_);
-		return;
-	}
-	mp3_transcoder = rygel_mp3_transcoder_new (RYGEL_MP3_LAYER_TWO);
-	_tmp0_ = rygel_mp3_transcoder_create_encoder (mp3_transcoder, item, NULL, RYGEL_MP2_TS_TRANSCODER_BIN_AUDIO_ENC_SINK, &_inner_error_);
-	if (_inner_error_ != NULL) {
-		g_propagate_error (error, _inner_error_);
-		_gst_object_unref0 (decodebin);
-		_g_object_unref0 (mp3_transcoder);
-		return;
-	}
-	self->priv->audio_enc = (_tmp1_ = _tmp0_, _gst_object_unref0 (self->priv->audio_enc), _tmp1_);
-	_tmp2_ = rygel_mp2_ts_transcoder_create_encoder (transcoder, item, NULL, RYGEL_MP2_TS_TRANSCODER_BIN_VIDEO_ENC_SINK, &_inner_error_);
-	if (_inner_error_ != NULL) {
-		g_propagate_error (error, _inner_error_);
-		_gst_object_unref0 (decodebin);
-		_g_object_unref0 (mp3_transcoder);
-		return;
-	}
-	self->priv->video_enc = (_tmp3_ = _tmp2_, _gst_object_unref0 (self->priv->video_enc), _tmp3_);
-	_tmp4_ = rygel_gst_utils_create_element (RYGEL_MP2_TS_TRANSCODER_BIN_MUXER, RYGEL_MP2_TS_TRANSCODER_BIN_MUXER, &_inner_error_);
-	if (_inner_error_ != NULL) {
-		g_propagate_error (error, _inner_error_);
-		_gst_object_unref0 (decodebin);
-		_g_object_unref0 (mp3_transcoder);
-		return;
-	}
-	self->priv->muxer = (_tmp5_ = _tmp4_, _gst_object_unref0 (self->priv->muxer), _tmp5_);
-	gst_bin_add_many ((GstBin*) self, _gst_object_ref0 (src), _gst_object_ref0 (decodebin), _gst_object_ref0 (self->priv->audio_enc), _gst_object_ref0 (self->priv->video_enc), _gst_object_ref0 (self->priv->muxer), NULL);
-	gst_element_link (src, decodebin);
-	src_pad = gst_element_get_static_pad (self->priv->muxer, "src");
-	ghost = (GstGhostPad*) gst_ghost_pad_new (NULL, src_pad);
-	gst_element_add_pad ((GstElement*) self, _gst_object_ref0 ((GstPad*) ghost));
-	g_signal_connect_object (decodebin, "pad-added", (GCallback) _rygel_mp2_ts_transcoder_bin_decodebin_pad_added_gst_element_pad_added, self, 0);
-	_gst_object_unref0 (decodebin);
-	_g_object_unref0 (mp3_transcoder);
-	_gst_object_unref0 (src_pad);
-	_gst_object_unref0 (ghost);
-	return self;
-}
-
-
-RygelMP2TSTranscoderBin* rygel_mp2_ts_transcoder_bin_new (RygelMediaItem* item, GstElement* src, RygelMP2TSTranscoder* transcoder, GError** error) {
-	return rygel_mp2_ts_transcoder_bin_construct (RYGEL_TYPE_MP2_TS_TRANSCODER_BIN, item, src, transcoder, error);
-}
-
-
-static void rygel_mp2_ts_transcoder_bin_decodebin_pad_added (RygelMP2TSTranscoderBin* self, GstElement* decodebin, GstPad* new_pad) {
-	GstElement* encoder;
-	GstPad* enc_pad;
-	GstPad* audio_enc_pad;
-	GstPad* video_enc_pad;
-	g_return_if_fail (self != NULL);
-	g_return_if_fail (decodebin != NULL);
-	g_return_if_fail (new_pad != NULL);
-	encoder = NULL;
-	enc_pad = NULL;
-	audio_enc_pad = _gst_object_ref0 (gst_element_get_pad (self->priv->audio_enc, RYGEL_MP2_TS_TRANSCODER_BIN_AUDIO_ENC_SINK));
-	video_enc_pad = _gst_object_ref0 (gst_element_get_pad (self->priv->video_enc, RYGEL_MP2_TS_TRANSCODER_BIN_VIDEO_ENC_SINK));
-	if (gst_pad_can_link (new_pad, audio_enc_pad)) {
-		GstElement* _tmp0_;
-		GstPad* _tmp1_;
-		encoder = (_tmp0_ = _gst_object_ref0 (self->priv->audio_enc), _gst_object_unref0 (encoder), _tmp0_);
-		enc_pad = (_tmp1_ = _gst_object_ref0 (audio_enc_pad), _gst_object_unref0 (enc_pad), _tmp1_);
-	} else {
-		if (gst_pad_can_link (new_pad, video_enc_pad)) {
-			GstElement* _tmp2_;
-			GstPad* _tmp3_;
-			encoder = (_tmp2_ = _gst_object_ref0 (self->priv->video_enc), _gst_object_unref0 (encoder), _tmp2_);
-			enc_pad = (_tmp3_ = _gst_object_ref0 (video_enc_pad), _gst_object_unref0 (enc_pad), _tmp3_);
-		} else {
-			_gst_object_unref0 (encoder);
-			_gst_object_unref0 (enc_pad);
-			_gst_object_unref0 (audio_enc_pad);
-			_gst_object_unref0 (video_enc_pad);
-			return;
-		}
-	}
-	gst_element_link (encoder, self->priv->muxer);
-	if (gst_pad_link (new_pad, enc_pad) != GST_PAD_LINK_OK) {
-		GError* _tmp4_;
-		rygel_gst_utils_post_error ((GstElement*) self, _tmp4_ = g_error_new (RYGEL_LIVE_RESPONSE_ERROR, RYGEL_LIVE_RESPONSE_ERROR_LINK, "Failed to link pad %s to %s", gst_object_get_name ((GstObject*) new_pad), gst_object_get_name ((GstObject*) enc_pad)));
-		_g_error_free0 (_tmp4_);
-		_gst_object_unref0 (encoder);
-		_gst_object_unref0 (enc_pad);
-		_gst_object_unref0 (audio_enc_pad);
-		_gst_object_unref0 (video_enc_pad);
-		return;
-	}
-	_gst_object_unref0 (encoder);
-	_gst_object_unref0 (enc_pad);
-	_gst_object_unref0 (audio_enc_pad);
-	_gst_object_unref0 (video_enc_pad);
-}
-
-
-static void rygel_mp2_ts_transcoder_bin_class_init (RygelMP2TSTranscoderBinClass * klass) {
-	rygel_mp2_ts_transcoder_bin_parent_class = g_type_class_peek_parent (klass);
-	g_type_class_add_private (klass, sizeof (RygelMP2TSTranscoderBinPrivate));
-	G_OBJECT_CLASS (klass)->finalize = rygel_mp2_ts_transcoder_bin_finalize;
-}
-
-
-static void rygel_mp2_ts_transcoder_bin_instance_init (RygelMP2TSTranscoderBin * self) {
-	self->priv = RYGEL_MP2_TS_TRANSCODER_BIN_GET_PRIVATE (self);
-}
-
-
-static void rygel_mp2_ts_transcoder_bin_finalize (GObject* obj) {
-	RygelMP2TSTranscoderBin * self;
-	self = RYGEL_MP2_TS_TRANSCODER_BIN (obj);
-	_gst_object_unref0 (self->priv->audio_enc);
-	_gst_object_unref0 (self->priv->video_enc);
-	_gst_object_unref0 (self->priv->muxer);
-	G_OBJECT_CLASS (rygel_mp2_ts_transcoder_bin_parent_class)->finalize (obj);
-}
-
-
-GType rygel_mp2_ts_transcoder_bin_get_type (void) {
-	static GType rygel_mp2_ts_transcoder_bin_type_id = 0;
-	if (rygel_mp2_ts_transcoder_bin_type_id == 0) {
-		static const GTypeInfo g_define_type_info = { sizeof (RygelMP2TSTranscoderBinClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) rygel_mp2_ts_transcoder_bin_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (RygelMP2TSTranscoderBin), 0, (GInstanceInitFunc) rygel_mp2_ts_transcoder_bin_instance_init, NULL };
-		rygel_mp2_ts_transcoder_bin_type_id = g_type_register_static (GST_TYPE_BIN, "RygelMP2TSTranscoderBin", &g_define_type_info, 0);
-	}
-	return rygel_mp2_ts_transcoder_bin_type_id;
-}
-
-
-
-
--- a/src/rygel/rygel-mp2ts-transcoder-bin.vala
+++ /dev/null
@@ -1,96 +0,0 @@
-/*
- * Copyright (C) 2009 Nokia Corporation.
- *
- * Author: Zeeshan Ali (Khattak) <zeeshanak@gnome.org>
- *                               <zeeshan.ali@nokia.com>
- *
- * This file is part of Rygel.
- *
- * Rygel is free software; you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * Rygel is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this program; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
- */
-
-using Gst;
-
-/**
- * A Gst.Bin derivative that implements transcoding of any type of media (using
- * decodebin2) to mpeg transport stream containing mpeg 2 video and mp2 audio.
- */
-internal class Rygel.MP2TSTranscoderBin : Gst.Bin {
-    private const string DECODEBIN = "decodebin2";
-    private const string MUXER = "mpegtsmux";
-
-    private const string AUDIO_ENC_SINK = "audio-enc-sink-pad";
-    private const string VIDEO_ENC_SINK = "sink";
-
-    private dynamic Element audio_enc;
-    private dynamic Element video_enc;
-    private dynamic Element muxer;
-
-    public MP2TSTranscoderBin (MediaItem       item,
-                               Element         src,
-                               MP2TSTranscoder transcoder)
-                               throws Error {
-        Element decodebin = GstUtils.create_element (DECODEBIN, DECODEBIN);
-        var mp3_transcoder = new MP3Transcoder (MP3Layer.TWO);
-        this.audio_enc = mp3_transcoder.create_encoder (item,
-                                                        null,
-                                                        AUDIO_ENC_SINK);
-        this.video_enc = transcoder.create_encoder (item, null, VIDEO_ENC_SINK);
-        this.muxer = GstUtils.create_element (MUXER, MUXER);
-
-        this.add_many (src,
-                       decodebin,
-                       this.audio_enc,
-                       this.video_enc,
-                       this.muxer);
-        src.link (decodebin);
-
-        var src_pad = muxer.get_static_pad ("src");
-        var ghost = new GhostPad (null, src_pad);
-        this.add_pad (ghost);
-
-        decodebin.pad_added += this.decodebin_pad_added;
-    }
-
-    private void decodebin_pad_added (Element decodebin, Pad new_pad) {
-        Element encoder;
-        Pad enc_pad;
-
-        var audio_enc_pad = this.audio_enc.get_pad (AUDIO_ENC_SINK);
-        var video_enc_pad = this.video_enc.get_pad (VIDEO_ENC_SINK);
-
-        // Check which encoder to use
-        if (new_pad.can_link (audio_enc_pad)) {
-            encoder = this.audio_enc;
-            enc_pad = audio_enc_pad;
-        } else if (new_pad.can_link (video_enc_pad)) {
-            encoder = this.video_enc;
-            enc_pad = video_enc_pad;
-        } else {
-            return;
-        }
-
-        encoder.link (this.muxer);
-
-        if (new_pad.link (enc_pad) != PadLinkReturn.OK) {
-            GstUtils.post_error (this,
-                                 new LiveResponseError.LINK (
-                                                "Failed to link pad %s to %s",
-                                                new_pad.name,
-                                                enc_pad.name));
-            return;
-        }
-    }
-}
--- a/src/rygel/rygel-mp2ts-transcoder.c
+++ /dev/null
@@ -1,484 +0,0 @@
-/* rygel-mp2ts-transcoder.c generated by valac, the Vala compiler
- * generated from rygel-mp2ts-transcoder.vala, do not modify */
-
-/*
- * Copyright (C) 2009 Nokia Corporation.
- *
- * Author: Zeeshan Ali (Khattak) <zeeshanak@gnome.org>
- *                               <zeeshan.ali@nokia.com>
- *
- * This file is part of Rygel.
- *
- * Rygel is free software; you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * Rygel is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this program; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
- */
-
-#include <glib.h>
-#include <glib-object.h>
-#include <gst/gst.h>
-#include <libgupnp-av/gupnp-av.h>
-#include <stdlib.h>
-#include <string.h>
-#include <gee.h>
-
-
-#define RYGEL_TYPE_MP2_TS_PROFILE (rygel_mp2_ts_profile_get_type ())
-
-#define RYGEL_TYPE_TRANSCODER (rygel_transcoder_get_type ())
-#define RYGEL_TRANSCODER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_TRANSCODER, RygelTranscoder))
-#define RYGEL_TRANSCODER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_TRANSCODER, RygelTranscoderClass))
-#define RYGEL_IS_TRANSCODER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_TRANSCODER))
-#define RYGEL_IS_TRANSCODER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_TRANSCODER))
-#define RYGEL_TRANSCODER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_TRANSCODER, RygelTranscoderClass))
-
-typedef struct _RygelTranscoder RygelTranscoder;
-typedef struct _RygelTranscoderClass RygelTranscoderClass;
-typedef struct _RygelTranscoderPrivate RygelTranscoderPrivate;
-
-#define RYGEL_TYPE_MEDIA_OBJECT (rygel_media_object_get_type ())
-#define RYGEL_MEDIA_OBJECT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_MEDIA_OBJECT, RygelMediaObject))
-#define RYGEL_MEDIA_OBJECT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_MEDIA_OBJECT, RygelMediaObjectClass))
-#define RYGEL_IS_MEDIA_OBJECT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_MEDIA_OBJECT))
-#define RYGEL_IS_MEDIA_OBJECT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_MEDIA_OBJECT))
-#define RYGEL_MEDIA_OBJECT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_MEDIA_OBJECT, RygelMediaObjectClass))
-
-typedef struct _RygelMediaObject RygelMediaObject;
-typedef struct _RygelMediaObjectClass RygelMediaObjectClass;
-
-#define RYGEL_TYPE_MEDIA_ITEM (rygel_media_item_get_type ())
-#define RYGEL_MEDIA_ITEM(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_MEDIA_ITEM, RygelMediaItem))
-#define RYGEL_MEDIA_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_MEDIA_ITEM, RygelMediaItemClass))
-#define RYGEL_IS_MEDIA_ITEM(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_MEDIA_ITEM))
-#define RYGEL_IS_MEDIA_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_MEDIA_ITEM))
-#define RYGEL_MEDIA_ITEM_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_MEDIA_ITEM, RygelMediaItemClass))
-
-typedef struct _RygelMediaItem RygelMediaItem;
-typedef struct _RygelMediaItemClass RygelMediaItemClass;
-
-#define RYGEL_TYPE_TRANSCODE_MANAGER (rygel_transcode_manager_get_type ())
-#define RYGEL_TRANSCODE_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_TRANSCODE_MANAGER, RygelTranscodeManager))
-#define RYGEL_TRANSCODE_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_TRANSCODE_MANAGER, RygelTranscodeManagerClass))
-#define RYGEL_IS_TRANSCODE_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_TRANSCODE_MANAGER))
-#define RYGEL_IS_TRANSCODE_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_TRANSCODE_MANAGER))
-#define RYGEL_TRANSCODE_MANAGER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_TRANSCODE_MANAGER, RygelTranscodeManagerClass))
-
-typedef struct _RygelTranscodeManager RygelTranscodeManager;
-typedef struct _RygelTranscodeManagerClass RygelTranscodeManagerClass;
-
-#define RYGEL_TYPE_MP2_TS_TRANSCODER (rygel_mp2_ts_transcoder_get_type ())
-#define RYGEL_MP2_TS_TRANSCODER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_MP2_TS_TRANSCODER, RygelMP2TSTranscoder))
-#define RYGEL_MP2_TS_TRANSCODER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_MP2_TS_TRANSCODER, RygelMP2TSTranscoderClass))
-#define RYGEL_IS_MP2_TS_TRANSCODER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_MP2_TS_TRANSCODER))
-#define RYGEL_IS_MP2_TS_TRANSCODER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_MP2_TS_TRANSCODER))
-#define RYGEL_MP2_TS_TRANSCODER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_MP2_TS_TRANSCODER, RygelMP2TSTranscoderClass))
-
-typedef struct _RygelMP2TSTranscoder RygelMP2TSTranscoder;
-typedef struct _RygelMP2TSTranscoderClass RygelMP2TSTranscoderClass;
-typedef struct _RygelMP2TSTranscoderPrivate RygelMP2TSTranscoderPrivate;
-
-#define RYGEL_TYPE_MP2_TS_TRANSCODER_BIN (rygel_mp2_ts_transcoder_bin_get_type ())
-#define RYGEL_MP2_TS_TRANSCODER_BIN(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_MP2_TS_TRANSCODER_BIN, RygelMP2TSTranscoderBin))
-#define RYGEL_MP2_TS_TRANSCODER_BIN_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_MP2_TS_TRANSCODER_BIN, RygelMP2TSTranscoderBinClass))
-#define RYGEL_IS_MP2_TS_TRANSCODER_BIN(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_MP2_TS_TRANSCODER_BIN))
-#define RYGEL_IS_MP2_TS_TRANSCODER_BIN_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_MP2_TS_TRANSCODER_BIN))
-#define RYGEL_MP2_TS_TRANSCODER_BIN_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_MP2_TS_TRANSCODER_BIN, RygelMP2TSTranscoderBinClass))
-
-typedef struct _RygelMP2TSTranscoderBin RygelMP2TSTranscoderBin;
-typedef struct _RygelMP2TSTranscoderBinClass RygelMP2TSTranscoderBinClass;
-#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
-typedef struct _RygelMediaObjectPrivate RygelMediaObjectPrivate;
-
-#define RYGEL_TYPE_MEDIA_CONTAINER (rygel_media_container_get_type ())
-#define RYGEL_MEDIA_CONTAINER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_MEDIA_CONTAINER, RygelMediaContainer))
-#define RYGEL_MEDIA_CONTAINER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_MEDIA_CONTAINER, RygelMediaContainerClass))
-#define RYGEL_IS_MEDIA_CONTAINER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_MEDIA_CONTAINER))
-#define RYGEL_IS_MEDIA_CONTAINER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_MEDIA_CONTAINER))
-#define RYGEL_MEDIA_CONTAINER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_MEDIA_CONTAINER, RygelMediaContainerClass))
-
-typedef struct _RygelMediaContainer RygelMediaContainer;
-typedef struct _RygelMediaContainerClass RygelMediaContainerClass;
-typedef struct _RygelMediaItemPrivate RygelMediaItemPrivate;
-
-#define RYGEL_TYPE_ICON_INFO (rygel_icon_info_get_type ())
-#define RYGEL_ICON_INFO(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_ICON_INFO, RygelIconInfo))
-#define RYGEL_ICON_INFO_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_ICON_INFO, RygelIconInfoClass))
-#define RYGEL_IS_ICON_INFO(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_ICON_INFO))
-#define RYGEL_IS_ICON_INFO_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_ICON_INFO))
-#define RYGEL_ICON_INFO_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_ICON_INFO, RygelIconInfoClass))
-
-typedef struct _RygelIconInfo RygelIconInfo;
-typedef struct _RygelIconInfoClass RygelIconInfoClass;
-
-#define RYGEL_TYPE_THUMBNAIL (rygel_thumbnail_get_type ())
-#define RYGEL_THUMBNAIL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_THUMBNAIL, RygelThumbnail))
-#define RYGEL_THUMBNAIL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_THUMBNAIL, RygelThumbnailClass))
-#define RYGEL_IS_THUMBNAIL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_THUMBNAIL))
-#define RYGEL_IS_THUMBNAIL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_THUMBNAIL))
-#define RYGEL_THUMBNAIL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_THUMBNAIL, RygelThumbnailClass))
-
-typedef struct _RygelThumbnail RygelThumbnail;
-typedef struct _RygelThumbnailClass RygelThumbnailClass;
-#define _gst_object_unref0(var) ((var == NULL) ? NULL : (var = (gst_object_unref (var), NULL)))
-#define _gst_caps_unref0(var) ((var == NULL) ? NULL : (var = (gst_caps_unref (var), NULL)))
-
-typedef enum  {
-	RYGEL_MP2_TS_PROFILE_SD = 0,
-	RYGEL_MP2_TS_PROFILE_HD
-} RygelMP2TSProfile;
-
-struct _RygelTranscoder {
-	GObject parent_instance;
-	RygelTranscoderPrivate * priv;
-};
-
-struct _RygelTranscoderClass {
-	GObjectClass parent_class;
-	GstElement* (*create_source) (RygelTranscoder* self, RygelMediaItem* item, GstElement* src, GError** error);
-	GUPnPDIDLLiteResource* (*add_resource) (RygelTranscoder* self, GUPnPDIDLLiteItem* didl_item, RygelMediaItem* item, RygelTranscodeManager* manager, GError** error);
-	guint (*get_distance) (RygelTranscoder* self, RygelMediaItem* item);
-};
-
-struct _RygelMP2TSTranscoder {
-	RygelTranscoder parent_instance;
-	RygelMP2TSTranscoderPrivate * priv;
-};
-
-struct _RygelMP2TSTranscoderClass {
-	RygelTranscoderClass parent_class;
-};
-
-struct _RygelMP2TSTranscoderPrivate {
-	RygelMP2TSProfile profile;
-};
-
-struct _RygelMediaObject {
-	GObject parent_instance;
-	RygelMediaObjectPrivate * priv;
-	char* id;
-	char* title;
-	guint64 modified;
-	GeeArrayList* uris;
-	RygelMediaContainer* parent;
-	RygelMediaContainer* parent_ref;
-};
-
-struct _RygelMediaObjectClass {
-	GObjectClass parent_class;
-};
-
-struct _RygelMediaItem {
-	RygelMediaObject parent_instance;
-	RygelMediaItemPrivate * priv;
-	char* author;
-	char* album;
-	char* date;
-	char* upnp_class;
-	char* mime_type;
-	char* dlna_profile;
-	glong size;
-	glong duration;
-	gint bitrate;
-	gint sample_freq;
-	gint bits_per_sample;
-	gint n_audio_channels;
-	gint track_number;
-	gint width;
-	gint height;
-	gint pixel_width;
-	gint pixel_height;
-	gint color_depth;
-	GeeArrayList* thumbnails;
-};
-
-struct _RygelMediaItemClass {
-	RygelMediaObjectClass parent_class;
-	GstElement* (*create_stream_source) (RygelMediaItem* self);
-	gboolean (*should_stream) (RygelMediaItem* self);
-};
-
-
-static gpointer rygel_mp2_ts_transcoder_parent_class = NULL;
-
-GType rygel_mp2_ts_profile_get_type (void);
-GType rygel_transcoder_get_type (void);
-GType rygel_media_object_get_type (void);
-GType rygel_media_item_get_type (void);
-GType rygel_transcode_manager_get_type (void);
-GType rygel_mp2_ts_transcoder_get_type (void);
-#define RYGEL_MP2_TS_TRANSCODER_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), RYGEL_TYPE_MP2_TS_TRANSCODER, RygelMP2TSTranscoderPrivate))
-enum  {
-	RYGEL_MP2_TS_TRANSCODER_DUMMY_PROPERTY
-};
-#define RYGEL_MP2_TS_TRANSCODER_VIDEO_BITRATE 3000
-#define RYGEL_MP2_TS_TRANSCODER_BITRATE 3000000
-#define RYGEL_MP2_TS_TRANSCODER_VIDEO_ENCODER "ffenc_mpeg2video"
-#define RYGEL_MP2_TS_TRANSCODER_COLORSPACE_CONVERT "ffmpegcolorspace"
-#define RYGEL_MP2_TS_TRANSCODER_VIDEO_RATE "videorate"
-#define RYGEL_MP2_TS_TRANSCODER_VIDEO_SCALE "videoscale"
-#define RYGEL_MEDIA_ITEM_VIDEO_CLASS "object.item.videoItem"
-RygelTranscoder* rygel_transcoder_construct (GType object_type, const char* mime_type, const char* dlna_profile, const char* upnp_class);
-RygelMP2TSTranscoder* rygel_mp2_ts_transcoder_new (RygelMP2TSProfile profile);
-RygelMP2TSTranscoder* rygel_mp2_ts_transcoder_construct (GType object_type, RygelMP2TSProfile profile);
-RygelMP2TSTranscoderBin* rygel_mp2_ts_transcoder_bin_new (RygelMediaItem* item, GstElement* src, RygelMP2TSTranscoder* transcoder, GError** error);
-RygelMP2TSTranscoderBin* rygel_mp2_ts_transcoder_bin_construct (GType object_type, RygelMediaItem* item, GstElement* src, RygelMP2TSTranscoder* transcoder, GError** error);
-GType rygel_mp2_ts_transcoder_bin_get_type (void);
-static GstElement* rygel_mp2_ts_transcoder_real_create_source (RygelTranscoder* base, RygelMediaItem* item, GstElement* src, GError** error);
-GUPnPDIDLLiteResource* rygel_transcoder_add_resource (RygelTranscoder* self, GUPnPDIDLLiteItem* didl_item, RygelMediaItem* item, RygelTranscodeManager* manager, GError** error);
-#define RYGEL_MP3_TRANSCODER_BITRATE 256
-static GUPnPDIDLLiteResource* rygel_mp2_ts_transcoder_real_add_resource (RygelTranscoder* base, GUPnPDIDLLiteItem* didl_item, RygelMediaItem* item, RygelTranscodeManager* manager, GError** error);
-GType rygel_media_container_get_type (void);
-gpointer rygel_icon_info_ref (gpointer instance);
-void rygel_icon_info_unref (gpointer instance);
-GParamSpec* rygel_param_spec_icon_info (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
-void rygel_value_set_icon_info (GValue* value, gpointer v_object);
-gpointer rygel_value_get_icon_info (const GValue* value);
-GType rygel_icon_info_get_type (void);
-GType rygel_thumbnail_get_type (void);
-#define RYGEL_MEDIA_ITEM_IMAGE_CLASS "object.item.imageItem"
-static guint rygel_mp2_ts_transcoder_real_get_distance (RygelTranscoder* base, RygelMediaItem* item);
-GstElement* rygel_gst_utils_create_element (const char* factoryname, const char* name, GError** error);
-static inline void _dynamic_set_bitrate2 (GstElement* obj, gint value);
-GstElement* rygel_mp2_ts_transcoder_create_encoder (RygelMP2TSTranscoder* self, RygelMediaItem* item, const char* src_pad_name, const char* sink_pad_name, GError** error);
-static void rygel_mp2_ts_transcoder_finalize (GObject* obj);
-
-static const gint RYGEL_MP2_TS_TRANSCODER_WIDTH[] = {640, 1280};
-static const gint RYGEL_MP2_TS_TRANSCODER_HEIGHT[] = {480, 720};
-static const char* RYGEL_MP2_TS_TRANSCODER_PROFILES[] = {"MPEG_TS_SD_US", "MPEG_TS_HD_US"};
-
-
-
-GType rygel_mp2_ts_profile_get_type (void) {
-	static GType rygel_mp2_ts_profile_type_id = 0;
-	if (G_UNLIKELY (rygel_mp2_ts_profile_type_id == 0)) {
-		static const GEnumValue values[] = {{RYGEL_MP2_TS_PROFILE_SD, "RYGEL_MP2_TS_PROFILE_SD", "sd"}, {RYGEL_MP2_TS_PROFILE_HD, "RYGEL_MP2_TS_PROFILE_HD", "hd"}, {0, NULL, NULL}};
-		rygel_mp2_ts_profile_type_id = g_enum_register_static ("RygelMP2TSProfile", values);
-	}
-	return rygel_mp2_ts_profile_type_id;
-}
-
-
-RygelMP2TSTranscoder* rygel_mp2_ts_transcoder_construct (GType object_type, RygelMP2TSProfile profile) {
-	RygelMP2TSTranscoder * self;
-	self = (RygelMP2TSTranscoder*) rygel_transcoder_construct (object_type, "video/mpeg", RYGEL_MP2_TS_TRANSCODER_PROFILES[profile], RYGEL_MEDIA_ITEM_VIDEO_CLASS);
-	self->priv->profile = profile;
-	return self;
-}
-
-
-RygelMP2TSTranscoder* rygel_mp2_ts_transcoder_new (RygelMP2TSProfile profile) {
-	return rygel_mp2_ts_transcoder_construct (RYGEL_TYPE_MP2_TS_TRANSCODER, profile);
-}
-
-
-static GstElement* rygel_mp2_ts_transcoder_real_create_source (RygelTranscoder* base, RygelMediaItem* item, GstElement* src, GError** error) {
-	RygelMP2TSTranscoder * self;
-	GstElement* result;
-	GError * _inner_error_;
-	RygelMP2TSTranscoderBin* _tmp0_;
-	self = (RygelMP2TSTranscoder*) base;
-	g_return_val_if_fail (item != NULL, NULL);
-	g_return_val_if_fail (src != NULL, NULL);
-	_inner_error_ = NULL;
-	_tmp0_ = rygel_mp2_ts_transcoder_bin_new (item, src, self, &_inner_error_);
-	if (_inner_error_ != NULL) {
-		g_propagate_error (error, _inner_error_);
-		return NULL;
-	}
-	result = (GstElement*) _tmp0_;
-	return result;
-}
-
-
-static GUPnPDIDLLiteResource* rygel_mp2_ts_transcoder_real_add_resource (RygelTranscoder* base, GUPnPDIDLLiteItem* didl_item, RygelMediaItem* item, RygelTranscodeManager* manager, GError** error) {
-	RygelMP2TSTranscoder * self;
-	GUPnPDIDLLiteResource* result;
-	GError * _inner_error_;
-	GUPnPDIDLLiteResource* resource;
-	self = (RygelMP2TSTranscoder*) base;
-	g_return_val_if_fail (didl_item != NULL, NULL);
-	g_return_val_if_fail (item != NULL, NULL);
-	g_return_val_if_fail (manager != NULL, NULL);
-	_inner_error_ = NULL;
-	resource = RYGEL_TRANSCODER_CLASS (rygel_mp2_ts_transcoder_parent_class)->add_resource (RYGEL_TRANSCODER (self), didl_item, item, manager, &_inner_error_);
-	if (_inner_error_ != NULL) {
-		g_propagate_error (error, _inner_error_);
-		return NULL;
-	}
-	if (resource == NULL) {
-		result = NULL;
-		_g_object_unref0 (resource);
-		return result;
-	}
-	gupnp_didl_lite_resource_set_width (resource, RYGEL_MP2_TS_TRANSCODER_WIDTH[self->priv->profile]);
-	gupnp_didl_lite_resource_set_height (resource, RYGEL_MP2_TS_TRANSCODER_HEIGHT[self->priv->profile]);
-	gupnp_didl_lite_resource_set_bitrate (resource, ((RYGEL_MP2_TS_TRANSCODER_VIDEO_BITRATE + RYGEL_MP3_TRANSCODER_BITRATE) * 1000) / 8);
-	result = resource;
-	return result;
-}
-
-
-static guint rygel_mp2_ts_transcoder_real_get_distance (RygelTranscoder* base, RygelMediaItem* item) {
-	RygelMP2TSTranscoder * self;
-	guint result;
-	guint distance = 0U;
-	self = (RygelMP2TSTranscoder*) base;
-	g_return_val_if_fail (item != NULL, 0U);
-	if (g_str_has_prefix (item->upnp_class, RYGEL_MEDIA_ITEM_IMAGE_CLASS)) {
-		result = G_MAXUINT;
-		return result;
-	}
-	if (g_str_has_prefix (item->upnp_class, RYGEL_MEDIA_ITEM_VIDEO_CLASS)) {
-		distance = 0;
-		if (item->bitrate > 0) {
-			distance = distance + ((guint) abs (item->bitrate - RYGEL_MP2_TS_TRANSCODER_BITRATE));
-		}
-		if (item->width > 0) {
-			distance = distance + ((guint) abs (item->width - RYGEL_MP2_TS_TRANSCODER_WIDTH[self->priv->profile]));
-		}
-		if (item->height > 0) {
-			distance = distance + ((guint) abs (item->height - RYGEL_MP2_TS_TRANSCODER_HEIGHT[self->priv->profile]));
-		}
-	} else {
-		distance = G_MAXUINT / 2;
-	}
-	result = distance;
-	return result;
-}
-
-
-static inline void _dynamic_set_bitrate2 (GstElement* obj, gint value) {
-	g_object_set (obj, "bitrate", value, NULL);
-}
-
-
-static gpointer _gst_object_ref0 (gpointer self) {
-	return self ? gst_object_ref (self) : NULL;
-}
-
-
-GstElement* rygel_mp2_ts_transcoder_create_encoder (RygelMP2TSTranscoder* self, RygelMediaItem* item, const char* src_pad_name, const char* sink_pad_name, GError** error) {
-	GstElement* result;
-	GError * _inner_error_;
-	GstElement* videorate;
-	GstElement* videoscale;
-	GstElement* convert;
-	GstElement* encoder;
-	GstBin* bin;
-	gint pixel_w = 0;
-	gint pixel_h = 0;
-	gboolean _tmp0_ = FALSE;
-	GstCaps* caps;
-	GstPad* pad;
-	GstGhostPad* ghost;
-	GstPad* _tmp1_;
-	GstGhostPad* _tmp2_;
-	g_return_val_if_fail (self != NULL, NULL);
-	g_return_val_if_fail (item != NULL, NULL);
-	_inner_error_ = NULL;
-	videorate = rygel_gst_utils_create_element (RYGEL_MP2_TS_TRANSCODER_VIDEO_RATE, RYGEL_MP2_TS_TRANSCODER_VIDEO_RATE, &_inner_error_);
-	if (_inner_error_ != NULL) {
-		g_propagate_error (error, _inner_error_);
-		return NULL;
-	}
-	videoscale = rygel_gst_utils_create_element (RYGEL_MP2_TS_TRANSCODER_VIDEO_SCALE, RYGEL_MP2_TS_TRANSCODER_VIDEO_SCALE, &_inner_error_);
-	if (_inner_error_ != NULL) {
-		g_propagate_error (error, _inner_error_);
-		_gst_object_unref0 (videorate);
-		return NULL;
-	}
-	convert = rygel_gst_utils_create_element (RYGEL_MP2_TS_TRANSCODER_COLORSPACE_CONVERT, RYGEL_MP2_TS_TRANSCODER_COLORSPACE_CONVERT, &_inner_error_);
-	if (_inner_error_ != NULL) {
-		g_propagate_error (error, _inner_error_);
-		_gst_object_unref0 (videorate);
-		_gst_object_unref0 (videoscale);
-		return NULL;
-	}
-	encoder = rygel_gst_utils_create_element (RYGEL_MP2_TS_TRANSCODER_VIDEO_ENCODER, RYGEL_MP2_TS_TRANSCODER_VIDEO_ENCODER, &_inner_error_);
-	if (_inner_error_ != NULL) {
-		g_propagate_error (error, _inner_error_);
-		_gst_object_unref0 (videorate);
-		_gst_object_unref0 (videoscale);
-		_gst_object_unref0 (convert);
-		return NULL;
-	}
-	_dynamic_set_bitrate2 (encoder, ((gint) RYGEL_MP2_TS_TRANSCODER_VIDEO_BITRATE) * 1000);
-	bin = (GstBin*) gst_bin_new ("video-encoder-bin");
-	gst_bin_add_many (bin, _gst_object_ref0 (videorate), _gst_object_ref0 (videoscale), _gst_object_ref0 (convert), _gst_object_ref0 (encoder), NULL);
-	gst_element_link_many (convert, videoscale, videorate, NULL);
-	if (item->pixel_width > 0) {
-		_tmp0_ = item->pixel_height > 0;
-	} else {
-		_tmp0_ = FALSE;
-	}
-	if (_tmp0_) {
-		pixel_w = (item->width * RYGEL_MP2_TS_TRANSCODER_HEIGHT[self->priv->profile]) * item->pixel_width;
-		pixel_h = (item->height * RYGEL_MP2_TS_TRANSCODER_WIDTH[self->priv->profile]) * item->pixel_height;
-	} else {
-		pixel_w = 1;
-		pixel_h = 1;
-	}
-	caps = gst_caps_new_simple ("video/x-raw-yuv", "width", G_TYPE_INT, RYGEL_MP2_TS_TRANSCODER_WIDTH[self->priv->profile], "height", G_TYPE_INT, RYGEL_MP2_TS_TRANSCODER_HEIGHT[self->priv->profile], "framerate", GST_TYPE_FRACTION, 30, 1, "pixel-aspect-ratio", GST_TYPE_FRACTION, pixel_w, pixel_h, NULL);
-	gst_element_link_filtered (videorate, encoder, caps);
-	pad = gst_element_get_static_pad (convert, "sink");
-	ghost = (GstGhostPad*) gst_ghost_pad_new (sink_pad_name, pad);
-	gst_element_add_pad ((GstElement*) bin, _gst_object_ref0 ((GstPad*) ghost));
-	pad = (_tmp1_ = gst_element_get_static_pad (encoder, "src"), _gst_object_unref0 (pad), _tmp1_);
-	ghost = (_tmp2_ = (GstGhostPad*) gst_ghost_pad_new (src_pad_name, pad), _gst_object_unref0 (ghost), _tmp2_);
-	gst_element_add_pad ((GstElement*) bin, _gst_object_ref0 ((GstPad*) ghost));
-	result = (GstElement*) bin;
-	_gst_object_unref0 (videorate);
-	_gst_object_unref0 (videoscale);
-	_gst_object_unref0 (convert);
-	_gst_object_unref0 (encoder);
-	_gst_caps_unref0 (caps);
-	_gst_object_unref0 (pad);
-	_gst_object_unref0 (ghost);
-	return result;
-}
-
-
-static void rygel_mp2_ts_transcoder_class_init (RygelMP2TSTranscoderClass * klass) {
-	rygel_mp2_ts_transcoder_parent_class = g_type_class_peek_parent (klass);
-	g_type_class_add_private (klass, sizeof (RygelMP2TSTranscoderPrivate));
-	RYGEL_TRANSCODER_CLASS (klass)->create_source = rygel_mp2_ts_transcoder_real_create_source;
-	RYGEL_TRANSCODER_CLASS (klass)->add_resource = rygel_mp2_ts_transcoder_real_add_resource;
-	RYGEL_TRANSCODER_CLASS (klass)->get_distance = rygel_mp2_ts_transcoder_real_get_distance;
-	G_OBJECT_CLASS (klass)->finalize = rygel_mp2_ts_transcoder_finalize;
-}
-
-
-static void rygel_mp2_ts_transcoder_instance_init (RygelMP2TSTranscoder * self) {
-	self->priv = RYGEL_MP2_TS_TRANSCODER_GET_PRIVATE (self);
-}
-
-
-static void rygel_mp2_ts_transcoder_finalize (GObject* obj) {
-	RygelMP2TSTranscoder * self;
-	self = RYGEL_MP2_TS_TRANSCODER (obj);
-	G_OBJECT_CLASS (rygel_mp2_ts_transcoder_parent_class)->finalize (obj);
-}
-
-
-GType rygel_mp2_ts_transcoder_get_type (void) {
-	static GType rygel_mp2_ts_transcoder_type_id = 0;
-	if (rygel_mp2_ts_transcoder_type_id == 0) {
-		static const GTypeInfo g_define_type_info = { sizeof (RygelMP2TSTranscoderClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) rygel_mp2_ts_transcoder_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (RygelMP2TSTranscoder), 0, (GInstanceInitFunc) rygel_mp2_ts_transcoder_instance_init, NULL };
-		rygel_mp2_ts_transcoder_type_id = g_type_register_static (RYGEL_TYPE_TRANSCODER, "RygelMP2TSTranscoder", &g_define_type_info, 0);
-	}
-	return rygel_mp2_ts_transcoder_type_id;
-}
-
-
-
-
--- a/src/rygel/rygel-mp2ts-transcoder.vala
+++ /dev/null
@@ -1,164 +0,0 @@
-/*
- * Copyright (C) 2009 Nokia Corporation.
- *
- * Author: Zeeshan Ali (Khattak) <zeeshanak@gnome.org>
- *                               <zeeshan.ali@nokia.com>
- *
- * This file is part of Rygel.
- *
- * Rygel is free software; you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * Rygel is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this program; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
- */
-using Gst;
-using GUPnP;
-using Gee;
-
-internal enum Rygel.MP2TSProfile {
-    SD = 0,
-    HD
-}
-
-/**
- * Transcoder for mpeg transport stream containing mpeg 2 video and mp2 audio.
- * This element uses MP2TSTrancoderBin for actual transcoding.
- */
-internal class Rygel.MP2TSTranscoder : Rygel.Transcoder {
-    private const int VIDEO_BITRATE = 3000;
-
-    // HD
-    private const int[] WIDTH = {640, 1280};
-    private const int[] HEIGHT = {480, 720};
-    private const string[] PROFILES = {"MPEG_TS_SD_US", "MPEG_TS_HD_US"};
-    private const int BITRATE = 3000000;
-
-    private const string VIDEO_ENCODER = "ffenc_mpeg2video";
-    private const string COLORSPACE_CONVERT = "ffmpegcolorspace";
-    private const string VIDEO_RATE = "videorate";
-    private const string VIDEO_SCALE = "videoscale";
-
-    private MP2TSProfile profile;
-
-    public MP2TSTranscoder (MP2TSProfile profile) {
-        base ("video/mpeg", PROFILES[profile], MediaItem.VIDEO_CLASS);
-
-        this.profile = profile;
-    }
-
-    public override Element create_source (MediaItem item,
-                                           Element   src)
-                                           throws Error {
-        return new MP2TSTranscoderBin (item, src, this);
-    }
-
-    public override DIDLLiteResource? add_resource (DIDLLiteItem     didl_item,
-                                                    MediaItem        item,
-                                                    TranscodeManager manager)
-                                                    throws Error {
-        var resource = base.add_resource (didl_item, item, manager);
-        if (resource == null)
-            return null;
-
-        resource.width = WIDTH[profile];
-        resource.height = HEIGHT[profile];
-        resource.bitrate = (VIDEO_BITRATE + MP3Transcoder.BITRATE) * 1000 / 8;
-
-        return resource;
-    }
-
-    public override uint get_distance (MediaItem item) {
-        if (item.upnp_class.has_prefix (MediaItem.IMAGE_CLASS)) {
-            return uint.MAX;
-        }
-
-        uint distance;
-
-        if (item.upnp_class.has_prefix (MediaItem.VIDEO_CLASS)) {
-            distance = uint.MIN;
-
-            if (item.bitrate > 0) {
-                distance += (item.bitrate - BITRATE).abs ();
-            }
-
-            if (item.width > 0) {
-                distance += (item.width - WIDTH[this.profile]).abs ();
-            }
-
-            if (item.height > 0) {
-                distance += (item.height - HEIGHT[this.profile]).abs ();
-            }
-        } else {
-            distance = uint.MAX / 2;
-        }
-
-        return distance;
-    }
-
-    public Element create_encoder (MediaItem item,
-                                   string?   src_pad_name,
-                                   string?   sink_pad_name)
-                                   throws Error {
-        var videorate = GstUtils.create_element (VIDEO_RATE, VIDEO_RATE);
-        var videoscale = GstUtils.create_element (VIDEO_SCALE, VIDEO_SCALE);
-        var convert = GstUtils.create_element (COLORSPACE_CONVERT,
-                                               COLORSPACE_CONVERT);
-        dynamic Element encoder = GstUtils.create_element (VIDEO_ENCODER,
-                                                           VIDEO_ENCODER);
-
-        encoder.bitrate = (int) VIDEO_BITRATE * 1000;
-
-        var bin = new Bin ("video-encoder-bin");
-        bin.add_many (videorate, videoscale, convert, encoder);
-
-        convert.link_many (videoscale, videorate);
-
-        int pixel_w;
-        int pixel_h;
-
-        if (item.pixel_width > 0 && item.pixel_height > 0) {
-            pixel_w = item.width * HEIGHT[this.profile] * item.pixel_width;
-            pixel_h = item.height * WIDTH[this.profile] * item.pixel_height;
-        } else {
-            // Original pixel-ratio not provided, lets just use 1:1
-            pixel_w = 1;
-            pixel_h = 1;
-        }
-
-        var caps = new Caps.simple ("video/x-raw-yuv",
-                                    "width",
-                                        typeof (int),
-                                        WIDTH[this.profile],
-                                    "height",
-                                        typeof (int),
-                                        HEIGHT[this.profile],
-                                    "framerate",
-                                        typeof (Fraction),
-                                        30,
-                                        1,
-                                    "pixel-aspect-ratio",
-                                        typeof (Fraction),
-                                        pixel_w,
-                                        pixel_h);
-        videorate.link_filtered (encoder, caps);
-
-        var pad = convert.get_static_pad ("sink");
-        var ghost = new GhostPad (sink_pad_name, pad);
-        bin.add_pad (ghost);
-
-        pad = encoder.get_static_pad ("src");
-        ghost = new GhostPad (src_pad_name, pad);
-        bin.add_pad (ghost);
-
-        return bin;
-    }
-}
--- a/src/rygel/rygel-mp3-transcoder-bin.c
+++ /dev/null
@@ -1,256 +0,0 @@
-/* rygel-mp3-transcoder-bin.c generated by valac, the Vala compiler
- * generated from rygel-mp3-transcoder-bin.vala, do not modify */
-
-/*
- * Copyright (C) 2009 Nokia Corporation.
- *
- * Author: Zeeshan Ali (Khattak) <zeeshanak@gnome.org>
- *                               <zeeshan.ali@nokia.com>
- *
- * This file is part of Rygel.
- *
- * Rygel is free software; you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * Rygel is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this program; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
- */
-
-#include <glib.h>
-#include <glib-object.h>
-#include <gst/gst.h>
-#include <stdlib.h>
-#include <string.h>
-
-
-#define RYGEL_TYPE_MP3_LAYER (rygel_mp3_layer_get_type ())
-
-#define RYGEL_TYPE_MP3_TRANSCODER_BIN (rygel_mp3_transcoder_bin_get_type ())
-#define RYGEL_MP3_TRANSCODER_BIN(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_MP3_TRANSCODER_BIN, RygelMP3TranscoderBin))
-#define RYGEL_MP3_TRANSCODER_BIN_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_MP3_TRANSCODER_BIN, RygelMP3TranscoderBinClass))
-#define RYGEL_IS_MP3_TRANSCODER_BIN(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_MP3_TRANSCODER_BIN))
-#define RYGEL_IS_MP3_TRANSCODER_BIN_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_MP3_TRANSCODER_BIN))
-#define RYGEL_MP3_TRANSCODER_BIN_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_MP3_TRANSCODER_BIN, RygelMP3TranscoderBinClass))
-
-typedef struct _RygelMP3TranscoderBin RygelMP3TranscoderBin;
-typedef struct _RygelMP3TranscoderBinClass RygelMP3TranscoderBinClass;
-typedef struct _RygelMP3TranscoderBinPrivate RygelMP3TranscoderBinPrivate;
-#define _gst_object_unref0(var) ((var == NULL) ? NULL : (var = (gst_object_unref (var), NULL)))
-
-#define RYGEL_TYPE_TRANSCODER (rygel_transcoder_get_type ())
-#define RYGEL_TRANSCODER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_TRANSCODER, RygelTranscoder))
-#define RYGEL_TRANSCODER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_TRANSCODER, RygelTranscoderClass))
-#define RYGEL_IS_TRANSCODER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_TRANSCODER))
-#define RYGEL_IS_TRANSCODER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_TRANSCODER))
-#define RYGEL_TRANSCODER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_TRANSCODER, RygelTranscoderClass))
-
-typedef struct _RygelTranscoder RygelTranscoder;
-typedef struct _RygelTranscoderClass RygelTranscoderClass;
-
-#define RYGEL_TYPE_MP3_TRANSCODER (rygel_mp3_transcoder_get_type ())
-#define RYGEL_MP3_TRANSCODER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_MP3_TRANSCODER, RygelMP3Transcoder))
-#define RYGEL_MP3_TRANSCODER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_MP3_TRANSCODER, RygelMP3TranscoderClass))
-#define RYGEL_IS_MP3_TRANSCODER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_MP3_TRANSCODER))
-#define RYGEL_IS_MP3_TRANSCODER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_MP3_TRANSCODER))
-#define RYGEL_MP3_TRANSCODER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_MP3_TRANSCODER, RygelMP3TranscoderClass))
-
-typedef struct _RygelMP3Transcoder RygelMP3Transcoder;
-typedef struct _RygelMP3TranscoderClass RygelMP3TranscoderClass;
-
-#define RYGEL_TYPE_MEDIA_OBJECT (rygel_media_object_get_type ())
-#define RYGEL_MEDIA_OBJECT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_MEDIA_OBJECT, RygelMediaObject))
-#define RYGEL_MEDIA_OBJECT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_MEDIA_OBJECT, RygelMediaObjectClass))
-#define RYGEL_IS_MEDIA_OBJECT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_MEDIA_OBJECT))
-#define RYGEL_IS_MEDIA_OBJECT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_MEDIA_OBJECT))
-#define RYGEL_MEDIA_OBJECT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_MEDIA_OBJECT, RygelMediaObjectClass))
-
-typedef struct _RygelMediaObject RygelMediaObject;
-typedef struct _RygelMediaObjectClass RygelMediaObjectClass;
-
-#define RYGEL_TYPE_MEDIA_ITEM (rygel_media_item_get_type ())
-#define RYGEL_MEDIA_ITEM(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_MEDIA_ITEM, RygelMediaItem))
-#define RYGEL_MEDIA_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_MEDIA_ITEM, RygelMediaItemClass))
-#define RYGEL_IS_MEDIA_ITEM(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_MEDIA_ITEM))
-#define RYGEL_IS_MEDIA_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_MEDIA_ITEM))
-#define RYGEL_MEDIA_ITEM_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_MEDIA_ITEM, RygelMediaItemClass))
-
-typedef struct _RygelMediaItem RygelMediaItem;
-typedef struct _RygelMediaItemClass RygelMediaItemClass;
-#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
-
-typedef enum  {
-	RYGEL_MP3_LAYER_TWO = 1,
-	RYGEL_MP3_LAYER_THREE = 2
-} RygelMP3Layer;
-
-struct _RygelMP3TranscoderBin {
-	GstBin parent_instance;
-	RygelMP3TranscoderBinPrivate * priv;
-};
-
-struct _RygelMP3TranscoderBinClass {
-	GstBinClass parent_class;
-};
-
-struct _RygelMP3TranscoderBinPrivate {
-	GstElement* audio_enc;
-};
-
-typedef enum  {
-	RYGEL_LIVE_RESPONSE_ERROR_MISSING_PLUGIN,
-	RYGEL_LIVE_RESPONSE_ERROR_LINK
-} RygelLiveResponseError;
-#define RYGEL_LIVE_RESPONSE_ERROR rygel_live_response_error_quark ()
-
-static gpointer rygel_mp3_transcoder_bin_parent_class = NULL;
-
-GType rygel_mp3_layer_get_type (void);
-GType rygel_mp3_transcoder_bin_get_type (void);
-#define RYGEL_MP3_TRANSCODER_BIN_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), RYGEL_TYPE_MP3_TRANSCODER_BIN, RygelMP3TranscoderBinPrivate))
-enum  {
-	RYGEL_MP3_TRANSCODER_BIN_DUMMY_PROPERTY
-};
-#define RYGEL_MP3_TRANSCODER_BIN_DECODEBIN "decodebin2"
-#define RYGEL_MP3_TRANSCODER_BIN_AUDIO_SRC_PAD "audio-src-pad"
-#define RYGEL_MP3_TRANSCODER_BIN_AUDIO_SINK_PAD "audio-sink-pad"
-GstElement* rygel_gst_utils_create_element (const char* factoryname, const char* name, GError** error);
-GType rygel_transcoder_get_type (void);
-GType rygel_mp3_transcoder_get_type (void);
-GType rygel_media_object_get_type (void);
-GType rygel_media_item_get_type (void);
-GstElement* rygel_mp3_transcoder_create_encoder (RygelMP3Transcoder* self, RygelMediaItem* item, const char* src_pad_name, const char* sink_pad_name, GError** error);
-static void rygel_mp3_transcoder_bin_decodebin_pad_added (RygelMP3TranscoderBin* self, GstElement* decodebin, GstPad* new_pad);
-static void _rygel_mp3_transcoder_bin_decodebin_pad_added_gst_element_pad_added (GstElement* _sender, GstPad* pad, gpointer self);
-RygelMP3TranscoderBin* rygel_mp3_transcoder_bin_new (RygelMediaItem* item, GstElement* src, RygelMP3Transcoder* transcoder, GError** error);
-RygelMP3TranscoderBin* rygel_mp3_transcoder_bin_construct (GType object_type, RygelMediaItem* item, GstElement* src, RygelMP3Transcoder* transcoder, GError** error);
-void rygel_gst_utils_post_error (GstElement* dest, GError* _error_);
-GQuark rygel_live_response_error_quark (void);
-static void rygel_mp3_transcoder_bin_finalize (GObject* obj);
-
-
-
-
-GType rygel_mp3_layer_get_type (void) {
-	static GType rygel_mp3_layer_type_id = 0;
-	if (G_UNLIKELY (rygel_mp3_layer_type_id == 0)) {
-		static const GEnumValue values[] = {{RYGEL_MP3_LAYER_TWO, "RYGEL_MP3_LAYER_TWO", "two"}, {RYGEL_MP3_LAYER_THREE, "RYGEL_MP3_LAYER_THREE", "three"}, {0, NULL, NULL}};
-		rygel_mp3_layer_type_id = g_enum_register_static ("RygelMP3Layer", values);
-	}
-	return rygel_mp3_layer_type_id;
-}
-
-
-static gpointer _gst_object_ref0 (gpointer self) {
-	return self ? gst_object_ref (self) : NULL;
-}
-
-
-static void _rygel_mp3_transcoder_bin_decodebin_pad_added_gst_element_pad_added (GstElement* _sender, GstPad* pad, gpointer self) {
-	rygel_mp3_transcoder_bin_decodebin_pad_added (self, _sender, pad);
-}
-
-
-RygelMP3TranscoderBin* rygel_mp3_transcoder_bin_construct (GType object_type, RygelMediaItem* item, GstElement* src, RygelMP3Transcoder* transcoder, GError** error) {
-	GError * _inner_error_;
-	RygelMP3TranscoderBin * self;
-	GstElement* decodebin;
-	GstElement* _tmp0_;
-	GstElement* _tmp1_;
-	GstPad* src_pad;
-	GstGhostPad* ghost;
-	g_return_val_if_fail (item != NULL, NULL);
-	g_return_val_if_fail (src != NULL, NULL);
-	g_return_val_if_fail (transcoder != NULL, NULL);
-	_inner_error_ = NULL;
-	self = g_object_newv (object_type, 0, NULL);
-	decodebin = rygel_gst_utils_create_element (RYGEL_MP3_TRANSCODER_BIN_DECODEBIN, RYGEL_MP3_TRANSCODER_BIN_DECODEBIN, &_inner_error_);
-	if (_inner_error_ != NULL) {
-		g_propagate_error (error, _inner_error_);
-		return;
-	}
-	_tmp0_ = rygel_mp3_transcoder_create_encoder (transcoder, item, RYGEL_MP3_TRANSCODER_BIN_AUDIO_SRC_PAD, RYGEL_MP3_TRANSCODER_BIN_AUDIO_SINK_PAD, &_inner_error_);
-	if (_inner_error_ != NULL) {
-		g_propagate_error (error, _inner_error_);
-		_gst_object_unref0 (decodebin);
-		return;
-	}
-	self->priv->audio_enc = (_tmp1_ = _tmp0_, _gst_object_unref0 (self->priv->audio_enc), _tmp1_);
-	gst_bin_add_many ((GstBin*) self, _gst_object_ref0 (src), _gst_object_ref0 (decodebin), _gst_object_ref0 (self->priv->audio_enc), NULL);
-	gst_element_link (src, decodebin);
-	src_pad = gst_element_get_static_pad (self->priv->audio_enc, RYGEL_MP3_TRANSCODER_BIN_AUDIO_SRC_PAD);
-	ghost = (GstGhostPad*) gst_ghost_pad_new (NULL, src_pad);
-	gst_element_add_pad ((GstElement*) self, _gst_object_ref0 ((GstPad*) ghost));
-	g_signal_connect_object (decodebin, "pad-added", (GCallback) _rygel_mp3_transcoder_bin_decodebin_pad_added_gst_element_pad_added, self, 0);
-	_gst_object_unref0 (decodebin);
-	_gst_object_unref0 (src_pad);
-	_gst_object_unref0 (ghost);
-	return self;
-}
-
-
-RygelMP3TranscoderBin* rygel_mp3_transcoder_bin_new (RygelMediaItem* item, GstElement* src, RygelMP3Transcoder* transcoder, GError** error) {
-	return rygel_mp3_transcoder_bin_construct (RYGEL_TYPE_MP3_TRANSCODER_BIN, item, src, transcoder, error);
-}
-
-
-static void rygel_mp3_transcoder_bin_decodebin_pad_added (RygelMP3TranscoderBin* self, GstElement* decodebin, GstPad* new_pad) {
-	GstPad* enc_pad;
-	g_return_if_fail (self != NULL);
-	g_return_if_fail (decodebin != NULL);
-	g_return_if_fail (new_pad != NULL);
-	enc_pad = _gst_object_ref0 (gst_element_get_pad (self->priv->audio_enc, RYGEL_MP3_TRANSCODER_BIN_AUDIO_SINK_PAD));
-	if (!gst_pad_can_link (new_pad, enc_pad)) {
-		_gst_object_unref0 (enc_pad);
-		return;
-	}
-	if (gst_pad_link (new_pad, enc_pad) != GST_PAD_LINK_OK) {
-		GError* _tmp0_;
-		rygel_gst_utils_post_error ((GstElement*) self, _tmp0_ = g_error_new (RYGEL_LIVE_RESPONSE_ERROR, RYGEL_LIVE_RESPONSE_ERROR_LINK, "Failed to link pad %s to %s", gst_object_get_name ((GstObject*) new_pad), gst_object_get_name ((GstObject*) enc_pad)));
-		_g_error_free0 (_tmp0_);
-		_gst_object_unref0 (enc_pad);
-		return;
-	}
-	_gst_object_unref0 (enc_pad);
-}
-
-
-static void rygel_mp3_transcoder_bin_class_init (RygelMP3TranscoderBinClass * klass) {
-	rygel_mp3_transcoder_bin_parent_class = g_type_class_peek_parent (klass);
-	g_type_class_add_private (klass, sizeof (RygelMP3TranscoderBinPrivate));
-	G_OBJECT_CLASS (klass)->finalize = rygel_mp3_transcoder_bin_finalize;
-}
-
-
-static void rygel_mp3_transcoder_bin_instance_init (RygelMP3TranscoderBin * self) {
-	self->priv = RYGEL_MP3_TRANSCODER_BIN_GET_PRIVATE (self);
-}
-
-
-static void rygel_mp3_transcoder_bin_finalize (GObject* obj) {
-	RygelMP3TranscoderBin * self;
-	self = RYGEL_MP3_TRANSCODER_BIN (obj);
-	_gst_object_unref0 (self->priv->audio_enc);
-	G_OBJECT_CLASS (rygel_mp3_transcoder_bin_parent_class)->finalize (obj);
-}
-
-
-GType rygel_mp3_transcoder_bin_get_type (void) {
-	static GType rygel_mp3_transcoder_bin_type_id = 0;
-	if (rygel_mp3_transcoder_bin_type_id == 0) {
-		static const GTypeInfo g_define_type_info = { sizeof (RygelMP3TranscoderBinClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) rygel_mp3_transcoder_bin_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (RygelMP3TranscoderBin), 0, (GInstanceInitFunc) rygel_mp3_transcoder_bin_instance_init, NULL };
-		rygel_mp3_transcoder_bin_type_id = g_type_register_static (GST_TYPE_BIN, "RygelMP3TranscoderBin", &g_define_type_info, 0);
-	}
-	return rygel_mp3_transcoder_bin_type_id;
-}
-
-
-
-
--- a/src/rygel/rygel-mp3-transcoder-bin.vala
+++ /dev/null
@@ -1,77 +0,0 @@
-/*
- * Copyright (C) 2009 Nokia Corporation.
- *
- * Author: Zeeshan Ali (Khattak) <zeeshanak@gnome.org>
- *                               <zeeshan.ali@nokia.com>
- *
- * This file is part of Rygel.
- *
- * Rygel is free software; you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * Rygel is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this program; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
- */
-
-using Gst;
-
-internal enum Rygel.MP3Layer {
-    TWO = 1,
-    THREE = 2
-}
-
-/**
- * A Gst.Bin derivative that implements transcoding of any type of media (using
- * decodebin2) to mpeg 1 layer 2 and 3 format.
- */
-internal class Rygel.MP3TranscoderBin : Gst.Bin {
-    private const string DECODEBIN = "decodebin2";
-
-    private const string AUDIO_SRC_PAD = "audio-src-pad";
-    private const string AUDIO_SINK_PAD = "audio-sink-pad";
-
-    private dynamic Element audio_enc;
-
-    public MP3TranscoderBin (MediaItem     item,
-                             Element       src,
-                             MP3Transcoder transcoder) throws Error {
-        Element decodebin = GstUtils.create_element (DECODEBIN, DECODEBIN);
-
-        this.audio_enc = transcoder.create_encoder (item,
-                                                    AUDIO_SRC_PAD,
-                                                    AUDIO_SINK_PAD);
-
-        this.add_many (src, decodebin, this.audio_enc);
-        src.link (decodebin);
-
-        var src_pad = this.audio_enc.get_static_pad (AUDIO_SRC_PAD);
-        var ghost = new GhostPad (null, src_pad);
-        this.add_pad (ghost);
-
-        decodebin.pad_added += this.decodebin_pad_added;
-    }
-
-    private void decodebin_pad_added (Element decodebin, Pad new_pad) {
-        Pad enc_pad = this.audio_enc.get_pad (AUDIO_SINK_PAD);
-        if (!new_pad.can_link (enc_pad)) {
-            return;
-        }
-
-        if (new_pad.link (enc_pad) != PadLinkReturn.OK) {
-            GstUtils.post_error (this,
-                                 new LiveResponseError.LINK (
-                                                "Failed to link pad %s to %s",
-                                                new_pad.name,
-                                                enc_pad.name));
-            return;
-        }
-    }
-}
--- a/src/rygel/rygel-mp3-transcoder.c
+++ /dev/null
@@ -1,466 +0,0 @@
-/* rygel-mp3-transcoder.c generated by valac, the Vala compiler
- * generated from rygel-mp3-transcoder.vala, do not modify */
-
-/*
- * Copyright (C) 2009 Nokia Corporation.
- *
- * Author: Zeeshan Ali (Khattak) <zeeshanak@gnome.org>
- *                               <zeeshan.ali@nokia.com>
- *
- * This file is part of Rygel.
- *
- * Rygel is free software; you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * Rygel is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this program; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
- */
-
-#include <glib.h>
-#include <glib-object.h>
-#include <gst/gst.h>
-#include <libgupnp-av/gupnp-av.h>
-#include <stdlib.h>
-#include <string.h>
-#include <gee.h>
-
-
-#define RYGEL_TYPE_TRANSCODER (rygel_transcoder_get_type ())
-#define RYGEL_TRANSCODER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_TRANSCODER, RygelTranscoder))
-#define RYGEL_TRANSCODER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_TRANSCODER, RygelTranscoderClass))
-#define RYGEL_IS_TRANSCODER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_TRANSCODER))
-#define RYGEL_IS_TRANSCODER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_TRANSCODER))
-#define RYGEL_TRANSCODER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_TRANSCODER, RygelTranscoderClass))
-
-typedef struct _RygelTranscoder RygelTranscoder;
-typedef struct _RygelTranscoderClass RygelTranscoderClass;
-typedef struct _RygelTranscoderPrivate RygelTranscoderPrivate;
-
-#define RYGEL_TYPE_MEDIA_OBJECT (rygel_media_object_get_type ())
-#define RYGEL_MEDIA_OBJECT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_MEDIA_OBJECT, RygelMediaObject))
-#define RYGEL_MEDIA_OBJECT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_MEDIA_OBJECT, RygelMediaObjectClass))
-#define RYGEL_IS_MEDIA_OBJECT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_MEDIA_OBJECT))
-#define RYGEL_IS_MEDIA_OBJECT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_MEDIA_OBJECT))
-#define RYGEL_MEDIA_OBJECT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_MEDIA_OBJECT, RygelMediaObjectClass))
-
-typedef struct _RygelMediaObject RygelMediaObject;
-typedef struct _RygelMediaObjectClass RygelMediaObjectClass;
-
-#define RYGEL_TYPE_MEDIA_ITEM (rygel_media_item_get_type ())
-#define RYGEL_MEDIA_ITEM(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_MEDIA_ITEM, RygelMediaItem))
-#define RYGEL_MEDIA_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_MEDIA_ITEM, RygelMediaItemClass))
-#define RYGEL_IS_MEDIA_ITEM(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_MEDIA_ITEM))
-#define RYGEL_IS_MEDIA_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_MEDIA_ITEM))
-#define RYGEL_MEDIA_ITEM_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_MEDIA_ITEM, RygelMediaItemClass))
-
-typedef struct _RygelMediaItem RygelMediaItem;
-typedef struct _RygelMediaItemClass RygelMediaItemClass;
-
-#define RYGEL_TYPE_TRANSCODE_MANAGER (rygel_transcode_manager_get_type ())
-#define RYGEL_TRANSCODE_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_TRANSCODE_MANAGER, RygelTranscodeManager))
-#define RYGEL_TRANSCODE_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_TRANSCODE_MANAGER, RygelTranscodeManagerClass))
-#define RYGEL_IS_TRANSCODE_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_TRANSCODE_MANAGER))
-#define RYGEL_IS_TRANSCODE_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_TRANSCODE_MANAGER))
-#define RYGEL_TRANSCODE_MANAGER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_TRANSCODE_MANAGER, RygelTranscodeManagerClass))
-
-typedef struct _RygelTranscodeManager RygelTranscodeManager;
-typedef struct _RygelTranscodeManagerClass RygelTranscodeManagerClass;
-
-#define RYGEL_TYPE_MP3_TRANSCODER (rygel_mp3_transcoder_get_type ())
-#define RYGEL_MP3_TRANSCODER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_MP3_TRANSCODER, RygelMP3Transcoder))
-#define RYGEL_MP3_TRANSCODER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_MP3_TRANSCODER, RygelMP3TranscoderClass))
-#define RYGEL_IS_MP3_TRANSCODER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_MP3_TRANSCODER))
-#define RYGEL_IS_MP3_TRANSCODER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_MP3_TRANSCODER))
-#define RYGEL_MP3_TRANSCODER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_MP3_TRANSCODER, RygelMP3TranscoderClass))
-
-typedef struct _RygelMP3Transcoder RygelMP3Transcoder;
-typedef struct _RygelMP3TranscoderClass RygelMP3TranscoderClass;
-typedef struct _RygelMP3TranscoderPrivate RygelMP3TranscoderPrivate;
-
-#define RYGEL_TYPE_MP3_LAYER (rygel_mp3_layer_get_type ())
-
-#define RYGEL_TYPE_MP3_TRANSCODER_BIN (rygel_mp3_transcoder_bin_get_type ())
-#define RYGEL_MP3_TRANSCODER_BIN(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_MP3_TRANSCODER_BIN, RygelMP3TranscoderBin))
-#define RYGEL_MP3_TRANSCODER_BIN_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_MP3_TRANSCODER_BIN, RygelMP3TranscoderBinClass))
-#define RYGEL_IS_MP3_TRANSCODER_BIN(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_MP3_TRANSCODER_BIN))
-#define RYGEL_IS_MP3_TRANSCODER_BIN_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_MP3_TRANSCODER_BIN))
-#define RYGEL_MP3_TRANSCODER_BIN_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_MP3_TRANSCODER_BIN, RygelMP3TranscoderBinClass))
-
-typedef struct _RygelMP3TranscoderBin RygelMP3TranscoderBin;
-typedef struct _RygelMP3TranscoderBinClass RygelMP3TranscoderBinClass;
-#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
-typedef struct _RygelMediaObjectPrivate RygelMediaObjectPrivate;
-
-#define RYGEL_TYPE_MEDIA_CONTAINER (rygel_media_container_get_type ())
-#define RYGEL_MEDIA_CONTAINER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_MEDIA_CONTAINER, RygelMediaContainer))
-#define RYGEL_MEDIA_CONTAINER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_MEDIA_CONTAINER, RygelMediaContainerClass))
-#define RYGEL_IS_MEDIA_CONTAINER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_MEDIA_CONTAINER))
-#define RYGEL_IS_MEDIA_CONTAINER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_MEDIA_CONTAINER))
-#define RYGEL_MEDIA_CONTAINER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_MEDIA_CONTAINER, RygelMediaContainerClass))
-
-typedef struct _RygelMediaContainer RygelMediaContainer;
-typedef struct _RygelMediaContainerClass RygelMediaContainerClass;
-typedef struct _RygelMediaItemPrivate RygelMediaItemPrivate;
-
-#define RYGEL_TYPE_ICON_INFO (rygel_icon_info_get_type ())
-#define RYGEL_ICON_INFO(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_ICON_INFO, RygelIconInfo))
-#define RYGEL_ICON_INFO_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_ICON_INFO, RygelIconInfoClass))
-#define RYGEL_IS_ICON_INFO(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_ICON_INFO))
-#define RYGEL_IS_ICON_INFO_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_ICON_INFO))
-#define RYGEL_ICON_INFO_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_ICON_INFO, RygelIconInfoClass))
-
-typedef struct _RygelIconInfo RygelIconInfo;
-typedef struct _RygelIconInfoClass RygelIconInfoClass;
-
-#define RYGEL_TYPE_THUMBNAIL (rygel_thumbnail_get_type ())
-#define RYGEL_THUMBNAIL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_THUMBNAIL, RygelThumbnail))
-#define RYGEL_THUMBNAIL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_THUMBNAIL, RygelThumbnailClass))
-#define RYGEL_IS_THUMBNAIL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_THUMBNAIL))
-#define RYGEL_IS_THUMBNAIL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_THUMBNAIL))
-#define RYGEL_THUMBNAIL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_THUMBNAIL, RygelThumbnailClass))
-
-typedef struct _RygelThumbnail RygelThumbnail;
-typedef struct _RygelThumbnailClass RygelThumbnailClass;
-
-#define TYPE_ENDIANNESS (endianness_get_type ())
-
-#define RYGEL_TYPE_L16_TRANSCODER (rygel_l16_transcoder_get_type ())
-#define RYGEL_L16_TRANSCODER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_L16_TRANSCODER, RygelL16Transcoder))
-#define RYGEL_L16_TRANSCODER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_L16_TRANSCODER, RygelL16TranscoderClass))
-#define RYGEL_IS_L16_TRANSCODER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_L16_TRANSCODER))
-#define RYGEL_IS_L16_TRANSCODER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_L16_TRANSCODER))
-#define RYGEL_L16_TRANSCODER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_L16_TRANSCODER, RygelL16TranscoderClass))
-
-typedef struct _RygelL16Transcoder RygelL16Transcoder;
-typedef struct _RygelL16TranscoderClass RygelL16TranscoderClass;
-#define _gst_object_unref0(var) ((var == NULL) ? NULL : (var = (gst_object_unref (var), NULL)))
-
-struct _RygelTranscoder {
-	GObject parent_instance;
-	RygelTranscoderPrivate * priv;
-};
-
-struct _RygelTranscoderClass {
-	GObjectClass parent_class;
-	GstElement* (*create_source) (RygelTranscoder* self, RygelMediaItem* item, GstElement* src, GError** error);
-	GUPnPDIDLLiteResource* (*add_resource) (RygelTranscoder* self, GUPnPDIDLLiteItem* didl_item, RygelMediaItem* item, RygelTranscodeManager* manager, GError** error);
-	guint (*get_distance) (RygelTranscoder* self, RygelMediaItem* item);
-};
-
-struct _RygelMP3Transcoder {
-	RygelTranscoder parent_instance;
-	RygelMP3TranscoderPrivate * priv;
-};
-
-struct _RygelMP3TranscoderClass {
-	RygelTranscoderClass parent_class;
-};
-
-typedef enum  {
-	RYGEL_MP3_LAYER_TWO = 1,
-	RYGEL_MP3_LAYER_THREE = 2
-} RygelMP3Layer;
-
-struct _RygelMP3TranscoderPrivate {
-	RygelMP3Layer layer;
-};
-
-struct _RygelMediaObject {
-	GObject parent_instance;
-	RygelMediaObjectPrivate * priv;
-	char* id;
-	char* title;
-	guint64 modified;
-	GeeArrayList* uris;
-	RygelMediaContainer* parent;
-	RygelMediaContainer* parent_ref;
-};
-
-struct _RygelMediaObjectClass {
-	GObjectClass parent_class;
-};
-
-struct _RygelMediaItem {
-	RygelMediaObject parent_instance;
-	RygelMediaItemPrivate * priv;
-	char* author;
-	char* album;
-	char* date;
-	char* upnp_class;
-	char* mime_type;
-	char* dlna_profile;
-	glong size;
-	glong duration;
-	gint bitrate;
-	gint sample_freq;
-	gint bits_per_sample;
-	gint n_audio_channels;
-	gint track_number;
-	gint width;
-	gint height;
-	gint pixel_width;
-	gint pixel_height;
-	gint color_depth;
-	GeeArrayList* thumbnails;
-};
-
-struct _RygelMediaItemClass {
-	RygelMediaObjectClass parent_class;
-	GstElement* (*create_stream_source) (RygelMediaItem* self);
-	gboolean (*should_stream) (RygelMediaItem* self);
-};
-
-typedef enum  {
-	ENDIANNESS_LITTLE = G_LITTLE_ENDIAN,
-	ENDIANNESS_BIG = G_BIG_ENDIAN
-} Endianness;
-
-
-static gpointer rygel_mp3_transcoder_parent_class = NULL;
-
-GType rygel_transcoder_get_type (void);
-GType rygel_media_object_get_type (void);
-GType rygel_media_item_get_type (void);
-GType rygel_transcode_manager_get_type (void);
-GType rygel_mp3_transcoder_get_type (void);
-GType rygel_mp3_layer_get_type (void);
-#define RYGEL_MP3_TRANSCODER_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), RYGEL_TYPE_MP3_TRANSCODER, RygelMP3TranscoderPrivate))
-enum  {
-	RYGEL_MP3_TRANSCODER_DUMMY_PROPERTY
-};
-#define RYGEL_MP3_TRANSCODER_BITRATE 256
-#define RYGEL_MP3_TRANSCODER_AUDIO_PARSER "mp3parse"
-#define RYGEL_MP3_TRANSCODER_CONVERT_SINK_PAD "convert-sink-pad"
-#define RYGEL_MEDIA_ITEM_AUDIO_CLASS "object.item.audioItem"
-RygelTranscoder* rygel_transcoder_construct (GType object_type, const char* mime_type, const char* dlna_profile, const char* upnp_class);
-RygelMP3Transcoder* rygel_mp3_transcoder_new (RygelMP3Layer layer);
-RygelMP3Transcoder* rygel_mp3_transcoder_construct (GType object_type, RygelMP3Layer layer);
-RygelMP3TranscoderBin* rygel_mp3_transcoder_bin_new (RygelMediaItem* item, GstElement* src, RygelMP3Transcoder* transcoder, GError** error);
-RygelMP3TranscoderBin* rygel_mp3_transcoder_bin_construct (GType object_type, RygelMediaItem* item, GstElement* src, RygelMP3Transcoder* transcoder, GError** error);
-GType rygel_mp3_transcoder_bin_get_type (void);
-static GstElement* rygel_mp3_transcoder_real_create_source (RygelTranscoder* base, RygelMediaItem* item, GstElement* src, GError** error);
-GUPnPDIDLLiteResource* rygel_transcoder_add_resource (RygelTranscoder* self, GUPnPDIDLLiteItem* didl_item, RygelMediaItem* item, RygelTranscodeManager* manager, GError** error);
-static GUPnPDIDLLiteResource* rygel_mp3_transcoder_real_add_resource (RygelTranscoder* base, GUPnPDIDLLiteItem* didl_item, RygelMediaItem* item, RygelTranscodeManager* manager, GError** error);
-GType rygel_media_container_get_type (void);
-gpointer rygel_icon_info_ref (gpointer instance);
-void rygel_icon_info_unref (gpointer instance);
-GParamSpec* rygel_param_spec_icon_info (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
-void rygel_value_set_icon_info (GValue* value, gpointer v_object);
-gpointer rygel_value_get_icon_info (const GValue* value);
-GType rygel_icon_info_get_type (void);
-GType rygel_thumbnail_get_type (void);
-#define RYGEL_MEDIA_ITEM_IMAGE_CLASS "object.item.imageItem"
-static guint rygel_mp3_transcoder_real_get_distance (RygelTranscoder* base, RygelMediaItem* item);
-GType endianness_get_type (void);
-RygelL16Transcoder* rygel_l16_transcoder_new (Endianness endianness);
-RygelL16Transcoder* rygel_l16_transcoder_construct (GType object_type, Endianness endianness);
-GType rygel_l16_transcoder_get_type (void);
-GstElement* rygel_l16_transcoder_create_encoder (RygelL16Transcoder* self, RygelMediaItem* item, const char* src_pad_name, const char* sink_pad_name, GError** error);
-GstElement* rygel_gst_utils_create_element (const char* factoryname, const char* name, GError** error);
-static inline void _dynamic_set_quality3 (GstElement* obj, gint value);
-static inline void _dynamic_set_bitrate4 (GstElement* obj, gint value);
-GstElement* rygel_mp3_transcoder_create_encoder (RygelMP3Transcoder* self, RygelMediaItem* item, const char* src_pad_name, const char* sink_pad_name, GError** error);
-static void rygel_mp3_transcoder_finalize (GObject* obj);
-
-static const char* RYGEL_MP3_TRANSCODER_AUDIO_ENCODER[] = {NULL, "twolame", "lame"};
-
-
-RygelMP3Transcoder* rygel_mp3_transcoder_construct (GType object_type, RygelMP3Layer layer) {
-	RygelMP3Transcoder * self;
-	self = (RygelMP3Transcoder*) rygel_transcoder_construct (object_type, "audio/mpeg", "MP3", RYGEL_MEDIA_ITEM_AUDIO_CLASS);
-	self->priv->layer = layer;
-	return self;
-}
-
-
-RygelMP3Transcoder* rygel_mp3_transcoder_new (RygelMP3Layer layer) {
-	return rygel_mp3_transcoder_construct (RYGEL_TYPE_MP3_TRANSCODER, layer);
-}
-
-
-static GstElement* rygel_mp3_transcoder_real_create_source (RygelTranscoder* base, RygelMediaItem* item, GstElement* src, GError** error) {
-	RygelMP3Transcoder * self;
-	GstElement* result;
-	GError * _inner_error_;
-	RygelMP3TranscoderBin* _tmp0_;
-	self = (RygelMP3Transcoder*) base;
-	g_return_val_if_fail (item != NULL, NULL);
-	g_return_val_if_fail (src != NULL, NULL);
-	_inner_error_ = NULL;
-	_tmp0_ = rygel_mp3_transcoder_bin_new (item, src, self, &_inner_error_);
-	if (_inner_error_ != NULL) {
-		g_propagate_error (error, _inner_error_);
-		return NULL;
-	}
-	result = (GstElement*) _tmp0_;
-	return result;
-}
-
-
-static GUPnPDIDLLiteResource* rygel_mp3_transcoder_real_add_resource (RygelTranscoder* base, GUPnPDIDLLiteItem* didl_item, RygelMediaItem* item, RygelTranscodeManager* manager, GError** error) {
-	RygelMP3Transcoder * self;
-	GUPnPDIDLLiteResource* result;
-	GError * _inner_error_;
-	GUPnPDIDLLiteResource* resource;
-	self = (RygelMP3Transcoder*) base;
-	g_return_val_if_fail (didl_item != NULL, NULL);
-	g_return_val_if_fail (item != NULL, NULL);
-	g_return_val_if_fail (manager != NULL, NULL);
-	_inner_error_ = NULL;
-	resource = RYGEL_TRANSCODER_CLASS (rygel_mp3_transcoder_parent_class)->add_resource (RYGEL_TRANSCODER (self), didl_item, item, manager, &_inner_error_);
-	if (_inner_error_ != NULL) {
-		g_propagate_error (error, _inner_error_);
-		return NULL;
-	}
-	if (resource == NULL) {
-		result = NULL;
-		_g_object_unref0 (resource);
-		return result;
-	}
-	gupnp_didl_lite_resource_set_bitrate (resource, (RYGEL_MP3_TRANSCODER_BITRATE * 1000) / 8);
-	result = resource;
-	return result;
-}
-
-
-static guint rygel_mp3_transcoder_real_get_distance (RygelTranscoder* base, RygelMediaItem* item) {
-	RygelMP3Transcoder * self;
-	guint result;
-	guint distance = 0U;
-	self = (RygelMP3Transcoder*) base;
-	g_return_val_if_fail (item != NULL, 0U);
-	if (g_str_has_prefix (item->upnp_class, RYGEL_MEDIA_ITEM_IMAGE_CLASS)) {
-		result = G_MAXUINT;
-		return result;
-	}
-	if (g_str_has_prefix (item->upnp_class, RYGEL_MEDIA_ITEM_AUDIO_CLASS)) {
-		distance = 0;
-		if (item->bitrate > 0) {
-			distance = distance + ((guint) abs (item->bitrate - RYGEL_MP3_TRANSCODER_BITRATE));
-		}
-	} else {
-		distance = G_MAXUINT / 2;
-	}
-	result = distance;
-	return result;
-}
-
-
-static inline void _dynamic_set_quality3 (GstElement* obj, gint value) {
-	g_object_set (obj, "quality", value, NULL);
-}
-
-
-static inline void _dynamic_set_bitrate4 (GstElement* obj, gint value) {
-	g_object_set (obj, "bitrate", value, NULL);
-}
-
-
-static gpointer _gst_object_ref0 (gpointer self) {
-	return self ? gst_object_ref (self) : NULL;
-}
-
-
-GstElement* rygel_mp3_transcoder_create_encoder (RygelMP3Transcoder* self, RygelMediaItem* item, const char* src_pad_name, const char* sink_pad_name, GError** error) {
-	GstElement* result;
-	GError * _inner_error_;
-	RygelL16Transcoder* l16_transcoder;
-	GstElement* convert;
-	GstElement* encoder;
-	GstElement* parser;
-	GstBin* bin;
-	GstPad* pad;
-	GstGhostPad* ghost;
-	GstPad* _tmp0_;
-	GstGhostPad* _tmp1_;
-	g_return_val_if_fail (self != NULL, NULL);
-	g_return_val_if_fail (item != NULL, NULL);
-	_inner_error_ = NULL;
-	l16_transcoder = rygel_l16_transcoder_new (ENDIANNESS_LITTLE);
-	convert = rygel_l16_transcoder_create_encoder (l16_transcoder, item, NULL, RYGEL_MP3_TRANSCODER_CONVERT_SINK_PAD, &_inner_error_);
-	if (_inner_error_ != NULL) {
-		g_propagate_error (error, _inner_error_);
-		_g_object_unref0 (l16_transcoder);
-		return NULL;
-	}
-	encoder = rygel_gst_utils_create_element (RYGEL_MP3_TRANSCODER_AUDIO_ENCODER[self->priv->layer], RYGEL_MP3_TRANSCODER_AUDIO_ENCODER[self->priv->layer], &_inner_error_);
-	if (_inner_error_ != NULL) {
-		g_propagate_error (error, _inner_error_);
-		_g_object_unref0 (l16_transcoder);
-		_gst_object_unref0 (convert);
-		return NULL;
-	}
-	parser = rygel_gst_utils_create_element (RYGEL_MP3_TRANSCODER_AUDIO_PARSER, RYGEL_MP3_TRANSCODER_AUDIO_PARSER, &_inner_error_);
-	if (_inner_error_ != NULL) {
-		g_propagate_error (error, _inner_error_);
-		_g_object_unref0 (l16_transcoder);
-		_gst_object_unref0 (convert);
-		_gst_object_unref0 (encoder);
-		return NULL;
-	}
-	if (self->priv->layer == RYGEL_MP3_LAYER_THREE) {
-		_dynamic_set_quality3 (encoder, 0);
-	}
-	_dynamic_set_bitrate4 (encoder, RYGEL_MP3_TRANSCODER_BITRATE);
-	bin = (GstBin*) gst_bin_new ("mp3-encoder-bin");
-	gst_bin_add_many (bin, _gst_object_ref0 (convert), _gst_object_ref0 (encoder), _gst_object_ref0 (parser), NULL);
-	gst_element_link_many (convert, encoder, parser, NULL);
-	pad = gst_element_get_static_pad (convert, RYGEL_MP3_TRANSCODER_CONVERT_SINK_PAD);
-	ghost = (GstGhostPad*) gst_ghost_pad_new (sink_pad_name, pad);
-	gst_element_add_pad ((GstElement*) bin, _gst_object_ref0 ((GstPad*) ghost));
-	pad = (_tmp0_ = gst_element_get_static_pad (parser, "src"), _gst_object_unref0 (pad), _tmp0_);
-	ghost = (_tmp1_ = (GstGhostPad*) gst_ghost_pad_new (src_pad_name, pad), _gst_object_unref0 (ghost), _tmp1_);
-	gst_element_add_pad ((GstElement*) bin, _gst_object_ref0 ((GstPad*) ghost));
-	result = (GstElement*) bin;
-	_g_object_unref0 (l16_transcoder);
-	_gst_object_unref0 (convert);
-	_gst_object_unref0 (encoder);
-	_gst_object_unref0 (parser);
-	_gst_object_unref0 (pad);
-	_gst_object_unref0 (ghost);
-	return result;
-}
-
-
-static void rygel_mp3_transcoder_class_init (RygelMP3TranscoderClass * klass) {
-	rygel_mp3_transcoder_parent_class = g_type_class_peek_parent (klass);
-	g_type_class_add_private (klass, sizeof (RygelMP3TranscoderPrivate));
-	RYGEL_TRANSCODER_CLASS (klass)->create_source = rygel_mp3_transcoder_real_create_source;
-	RYGEL_TRANSCODER_CLASS (klass)->add_resource = rygel_mp3_transcoder_real_add_resource;
-	RYGEL_TRANSCODER_CLASS (klass)->get_distance = rygel_mp3_transcoder_real_get_distance;
-	G_OBJECT_CLASS (klass)->finalize = rygel_mp3_transcoder_finalize;
-}
-
-
-static void rygel_mp3_transcoder_instance_init (RygelMP3Transcoder * self) {
-	self->priv = RYGEL_MP3_TRANSCODER_GET_PRIVATE (self);
-}
-
-
-static void rygel_mp3_transcoder_finalize (GObject* obj) {
-	RygelMP3Transcoder * self;
-	self = RYGEL_MP3_TRANSCODER (obj);
-	G_OBJECT_CLASS (rygel_mp3_transcoder_parent_class)->finalize (obj);
-}
-
-
-GType rygel_mp3_transcoder_get_type (void) {
-	static GType rygel_mp3_transcoder_type_id = 0;
-	if (rygel_mp3_transcoder_type_id == 0) {
-		static const GTypeInfo g_define_type_info = { sizeof (RygelMP3TranscoderClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) rygel_mp3_transcoder_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (RygelMP3Transcoder), 0, (GInstanceInitFunc) rygel_mp3_transcoder_instance_init, NULL };
-		rygel_mp3_transcoder_type_id = g_type_register_static (RYGEL_TYPE_TRANSCODER, "RygelMP3Transcoder", &g_define_type_info, 0);
-	}
-	return rygel_mp3_transcoder_type_id;
-}
-
-
-
-
--- a/src/rygel/rygel-mp3-transcoder.vala
+++ /dev/null
@@ -1,124 +0,0 @@
-/*
- * Copyright (C) 2009 Nokia Corporation.
- *
- * Author: Zeeshan Ali (Khattak) <zeeshanak@gnome.org>
- *                               <zeeshan.ali@nokia.com>
- *
- * This file is part of Rygel.
- *
- * Rygel is free software; you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * Rygel is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this program; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
- */
-using Gst;
-using GUPnP;
-using Gee;
-
-/**
- * Transcoder for mpeg 1 layer 2 and 3 audio. This element uses MP3TrancoderBin
- * for actual transcoding.
- */
-internal class Rygel.MP3Transcoder : Rygel.Transcoder {
-    private const int BITRATE = 256;
-
-    private const string[] AUDIO_ENCODER = {null, "twolame", "lame"};
-    private const string AUDIO_PARSER = "mp3parse";
-
-    private const string CONVERT_SINK_PAD = "convert-sink-pad";
-
-    private MP3Layer layer;
-
-    public MP3Transcoder (MP3Layer layer) {
-        base ("audio/mpeg", "MP3", MediaItem.AUDIO_CLASS);
-
-        this.layer = layer;
-    }
-
-    public override Element create_source (MediaItem item,
-                                           Element   src)
-                                           throws Error {
-        return new MP3TranscoderBin (item, src, this);
-    }
-
-    public override DIDLLiteResource? add_resource (DIDLLiteItem     didl_item,
-                                                    MediaItem        item,
-                                                    TranscodeManager manager)
-                                                    throws Error {
-        var resource = base.add_resource (didl_item, item, manager);
-        if (resource == null)
-            return null;
-
-        // Convert bitrate to bytes/second
-        resource.bitrate = BITRATE * 1000 / 8;
-
-        return resource;
-    }
-
-    public override uint get_distance (MediaItem item) {
-        if (item.upnp_class.has_prefix (MediaItem.IMAGE_CLASS)) {
-            return uint.MAX;
-        }
-
-        uint distance;
-
-        if (item.upnp_class.has_prefix (MediaItem.AUDIO_CLASS)) {
-            distance = uint.MIN;
-
-            if (item.bitrate > 0) {
-                distance += (item.bitrate - BITRATE).abs ();
-            }
-        } else {
-            distance = uint.MAX / 2;
-        }
-
-        return distance;
-    }
-
-    public Element create_encoder (MediaItem item,
-                                   string?   src_pad_name,
-                                   string?   sink_pad_name)
-                                   throws Error {
-        var l16_transcoder = new L16Transcoder (Endianness.LITTLE);
-        dynamic Element convert = l16_transcoder.create_encoder (
-                                                    item,
-                                                    null,
-                                                    CONVERT_SINK_PAD);
-        dynamic Element encoder = GstUtils.create_element (
-                                                    AUDIO_ENCODER[this.layer],
-                                                    AUDIO_ENCODER[this.layer]);
-        dynamic Element parser = GstUtils.create_element (AUDIO_PARSER,
-                                                          AUDIO_PARSER);
-
-        if (this.layer == MP3Layer.THREE) {
-            // Best quality
-            encoder.quality = 0;
-        }
-
-        encoder.bitrate = BITRATE;
-
-        var bin = new Bin ("mp3-encoder-bin");
-        bin.add_many (convert, encoder, parser);
-
-        convert.link_many (encoder, parser);
-
-        var pad = convert.get_static_pad (CONVERT_SINK_PAD);
-        var ghost = new GhostPad (sink_pad_name, pad);
-        bin.add_pad (ghost);
-
-        pad = parser.get_static_pad ("src");
-        ghost = new GhostPad (src_pad_name, pad);
-        bin.add_pad (ghost);
-
-        return bin;
-    }
-}
--- /dev/null
+++ b/src/rygel/rygel-network-device.c
@@ -0,0 +1,242 @@
+/*
+ * rygel-network-device.c
+ *   Helper methods to query network devices
+ *
+ * (C) Copyright 2010, Ubicom, Inc.
+ *
+ * This file is part of the Ubicom32 Rygel.
+ *
+ * This program is free software: you can redistribute
+ * it and/or modify it under the terms of the GNU Lesser General Public 
+ * License (LGPL) as published by the Free Software Foundation, either version 2.1
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it
+ * will be useful, but WITHOUT ANY WARRANTY; without even the implied
+ * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+ * the GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program.  If not,
+ * see <http://www.gnu.org/licenses/>.
+ */
+
+#include <stdio.h>
+#include <string.h>
+#include <ctype.h>
+#include <netinet/in.h>
+#include <net/if.h>
+#include <ifaddrs.h>
+#include <sys/ioctl.h>
+#include <errno.h>
+#include <glib.h>
+#include "rygel-network-device.h"
+
+/*
+ * Returns the list of network device names
+ *
+ * Returns NULL in case of failure.
+ */
+GList *
+rygel_network_device_get_interface_list ()
+{
+    struct ifaddrs *ifa_list, *ifa;
+    GList *processed = NULL;
+
+    /*
+     * Get the linked list of network interfaces
+     */
+    if (getifaddrs (&ifa_list) != 0) {
+            g_warning ("Failed to retrieve list of network interfaces:%s\n",
+                       strerror (errno));
+
+            return NULL;
+    }
+
+    /* 
+     * Create contexts for each up interface
+     */
+    for (ifa = ifa_list; ifa != NULL; ifa = ifa->ifa_next) {
+            if (ifa->ifa_addr == NULL ||
+                ifa->ifa_flags & IFF_LOOPBACK ||
+                g_list_find_custom (processed, ifa->ifa_name, (GCompareFunc) strcmp) != NULL) {
+                    continue;
+            }
+
+            char ip[INET6_ADDRSTRLEN];
+            struct sockaddr_in *s4;
+            struct sockaddr_in6 *s6;
+            const char *p = NULL;
+
+            switch (ifa->ifa_addr->sa_family) {
+            case AF_INET:
+                    s4 = (struct sockaddr_in *) ifa->ifa_addr;
+                    p = inet_ntop (AF_INET,
+                                   &s4->sin_addr, ip, sizeof (ip));
+                    break;
+            case AF_INET6:
+                    s6 = (struct sockaddr_in6 *) ifa->ifa_addr;
+                    p = inet_ntop (AF_INET6,
+                                   &s6->sin6_addr, ip, sizeof (ip));
+                    break;
+            default:
+                    continue; /* Unknown: ignore */
+            }
+
+            /*
+             * Ignore interfaces without name
+             */
+            if (p == NULL) {
+                continue;
+            }
+
+            processed = g_list_append (processed, g_strdup (ifa->ifa_name));
+    }
+
+    freeifaddrs (ifa_list);
+
+    return processed;
+}
+
+/*
+ * A wrapper for ioctl executions
+ *
+ * Returns 0 in case of success, -1 otherwise.
+ */
+static int
+execute_ioctl (const char *interface_name, int flag, struct ifreq *ifr)
+{
+    int fd;
+
+    fd = socket (AF_INET, SOCK_DGRAM, 0);
+    if (fd == -1) {
+        g_warning ("Failed to create socket:%s\n", strerror (errno));
+        close (fd);
+        return -1;
+    }
+
+    /* I want an IPv4 netmask */
+    ifr->ifr_addr.sa_family = AF_INET;
+
+    /* I want netmask attached to the interface */
+    strncpy (ifr->ifr_name, interface_name, IFNAMSIZ-1);
+
+    if (ioctl (fd, flag, ifr) == -1) {
+        g_warning ("ioctl operation(%d) failed:%s\n", flag, strerror (errno));
+        close (fd);
+        return -1;
+    }
+
+    close (fd);
+    return 0;
+}
+
+/*
+ * Returns the state of the network interface as either
+ * NM_DEVICE_STATE_UNKNOWN or NM_DEVICE_STATE_ACTIVATED
+ *
+ * Returns 0 in case of success, -1 otherwise.
+ */
+int
+rygel_network_device_get_state (const char *interface_name, NMDeviceState *state) {
+    struct ifreq ifr;
+
+    if (execute_ioctl (interface_name, SIOCGIFFLAGS, &ifr) == -1) {
+        return -1;
+    }
+
+    *state = (ifr.ifr_flags & IFF_UP) ? NM_DEVICE_STATE_ACTIVATED : NM_DEVICE_STATE_UNKNOWN;
+
+    return 0;
+}
+
+/*
+ * Returns the ip address of the network interface
+ *
+ * Returns 0 in case of success, -1 otherwise.
+ */
+int
+rygel_network_device_get_ip (const char *interface_name, char **ip_addr) {
+    struct ifreq ifr;
+
+    if (execute_ioctl (interface_name, SIOCGIFADDR, &ifr) == -1) {
+        return -1;
+    }
+
+    *ip_addr = g_strdup (inet_ntoa (((struct sockaddr_in *)&ifr.ifr_addr)->sin_addr));
+
+    return 0;
+}
+
+/*
+ * Returns the netmask of the network interface
+ *
+ * Returns 0 in case of success, -1 otherwise.
+ */
+int
+rygel_network_device_get_netmask (const char *interface_name, char **netmask) {
+    struct ifreq ifr;
+
+    if (execute_ioctl (interface_name, SIOCGIFNETMASK, &ifr) == -1) {
+        return -1;
+    }
+
+    *netmask = g_strdup (inet_ntoa (((struct sockaddr_in *)&ifr.ifr_addr)->sin_addr));
+
+    return 0;
+}
+
+/*
+ * Returns 1 if given Ralink device is connected, -1 at any failures.
+ *
+ * This command specific to Ralink drivers, connStatus is 
+ * subcommand only works with Ralink wireless driver.
+ */
+int
+rygel_network_device_get_status(const char *interface_name, gboolean *status)
+{
+    if (!interface_name) {
+        g_warning("NULL interface name");
+        return -1;
+    }
+
+    if (!status) {
+        g_warning("NULL status pointer");
+        return -1;
+    }
+
+    /* Skip driver if not ralink (not checking for all of possibilities, just checking for ra[0-9]) */
+    if (strncmp(interface_name, "ra", 2) || !isdigit(interface_name[2])) {
+        return -1;
+    }
+
+    char cmd[32], line[32];
+    int ret = 0;
+    char *read;
+    FILE *fp;
+
+    /*
+     * Command to be executed
+     */
+    snprintf(cmd, 32, "iwpriv %s connStatus", interface_name);
+    fp = popen(cmd, "r");
+    if (fp < 0) {
+      ret = -1;
+      goto exit;
+    }
+
+    read = fgets(line, 32, fp);
+    if (!read) {
+	g_warning("cannot read command output. ('%s')", cmd);
+	ret = -1;
+	goto exit;
+    }
+
+    if (strstr(line, "Connected")) {
+	*status = TRUE;
+    }
+
+exit:
+    pclose(fp);
+    return ret;
+}
--- /dev/null
+++ b/src/rygel/rygel-network-device.h
@@ -0,0 +1,46 @@
+/*
+ * rygel-network-device.h
+ *   Helper methods to query network devices
+ *
+ * (C) Copyright 2010, Ubicom, Inc.
+ *
+ * This file is part of the Ubicom32 Rygel.
+ *
+ * This program is free software: you can redistribute
+ * it and/or modify it under the terms of the GNU Lesser General Public 
+ * License (LGPL) as published by the Free Software Foundation, either version 2.1
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it
+ * will be useful, but WITHOUT ANY WARRANTY; without even the implied
+ * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+ * the GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program.  If not,
+ * see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef __RYGEL_NETWORK_DEVICE_H__
+#define __RYGEL_NETWORK_DEVICE_H__
+
+typedef enum {
+    NM_DEVICE_STATE_UNKNOWN,
+    NM_DEVICE_STATE_UNMANAGED,
+    NM_DEVICE_STATE_UNAVAILABLE,
+    NM_DEVICE_STATE_DISCONNECTED,
+    NM_DEVICE_STATE_PREPARE,
+    NM_DEVICE_STATE_CONFIG,
+    NM_DEVICE_STATE_NEED_AUTH,
+    NM_DEVICE_STATE_IP_CONFIG,
+    NM_DEVICE_STATE_ACTIVATED,
+    NM_DEVICE_STATE_FAILED
+} NMDeviceState;
+
+GList * rygel_network_device_get_interface_list ();
+int rygel_network_device_get_state (const char *interface, NMDeviceState *is_up);
+int rygel_network_device_get_ip (const char *interface, char **ip_addr);
+int rygel_network_device_get_netmask (const char *interface, char **netmask);
+int rygel_network_device_get_status(const char *interface_name, gboolean *status);
+
+#endif /* __RYGEL_NETWORK_DEVICE_H__ */
--- /dev/null
+++ b/src/rygel/rygel-network-device.vapi
@@ -0,0 +1,48 @@
+/*
+ * rygel-network-device.vapi
+ *   Helper methods to query network devices
+ *
+ * (C) Copyright 2010, Ubicom, Inc.
+ *
+ * This file is part of the Ubicom32 Rygel.
+ *
+ * This program is free software: you can redistribute
+ * it and/or modify it under the terms of the GNU Lesser General Public 
+ * License (LGPL) as published by the Free Software Foundation, either version 2.1
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it
+ * will be useful, but WITHOUT ANY WARRANTY; without even the implied
+ * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+ * the GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program.  If not,
+ * see <http://www.gnu.org/licenses/>.
+ */
+
+[CCode (cprefix = "Rygel", lower_case_cprefix = "rygel_")]
+namespace Rygel {
+    [CCode (cheader_filename = "rygel-network-device.h")]
+    namespace NetworkDevice {
+        [CCode (cprefix = "", cname = "NMDeviceState", cheader_filename = "rygel-network-device.h")]
+        public enum NMDeviceState {
+            NM_DEVICE_STATE_UNKNOWN,
+            NM_DEVICE_STATE_UNMANAGED,
+            NM_DEVICE_STATE_UNAVAILABLE,
+            NM_DEVICE_STATE_DISCONNECTED,
+            NM_DEVICE_STATE_PREPARE,
+            NM_DEVICE_STATE_CONFIG,
+            NM_DEVICE_STATE_NEED_AUTH,
+            NM_DEVICE_STATE_IP_CONFIG,
+            NM_DEVICE_STATE_ACTIVATED,
+            NM_DEVICE_STATE_FAILED
+        }
+
+        public static GLib.List<string> get_interface_list ();
+        public static int get_state (string interface, NMDeviceState *state);
+        public static int get_ip (string interface, string **ip);
+        public static int get_netmask (string interface, string **netmask);
+	public static int get_status(string interface, bool *status);
+    }
+}
--- a/src/rygel/rygel-plugin-loader.c
+++ /dev/null
@@ -1,501 +0,0 @@
-/* rygel-plugin-loader.c generated by valac, the Vala compiler
- * generated from rygel-plugin-loader.vala, do not modify */
-
-/*
- * Copyright (C) 2008 Nokia Corporation.
- * Copyright (C) 2008 Zeeshan Ali (Khattak) <zeeshanak@gnome.org>.
- *
- * Author: Zeeshan Ali (Khattak) <zeeshanak@gnome.org>
- *
- * This file is part of Rygel.
- *
- * Rygel is free software; you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * Rygel is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this program; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
- */
-
-#include <glib.h>
-#include <glib-object.h>
-#include <gee.h>
-#include <stdlib.h>
-#include <string.h>
-#include <libgupnp/gupnp.h>
-#include <gmodule.h>
-#include <gio/gio.h>
-
-
-#define RYGEL_TYPE_PLUGIN_LOADER (rygel_plugin_loader_get_type ())
-#define RYGEL_PLUGIN_LOADER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_PLUGIN_LOADER, RygelPluginLoader))
-#define RYGEL_PLUGIN_LOADER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_PLUGIN_LOADER, RygelPluginLoaderClass))
-#define RYGEL_IS_PLUGIN_LOADER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_PLUGIN_LOADER))
-#define RYGEL_IS_PLUGIN_LOADER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_PLUGIN_LOADER))
-#define RYGEL_PLUGIN_LOADER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_PLUGIN_LOADER, RygelPluginLoaderClass))
-
-typedef struct _RygelPluginLoader RygelPluginLoader;
-typedef struct _RygelPluginLoaderClass RygelPluginLoaderClass;
-typedef struct _RygelPluginLoaderPrivate RygelPluginLoaderPrivate;
-
-#define RYGEL_TYPE_PLUGIN (rygel_plugin_get_type ())
-#define RYGEL_PLUGIN(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_PLUGIN, RygelPlugin))
-#define RYGEL_PLUGIN_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_PLUGIN, RygelPluginClass))
-#define RYGEL_IS_PLUGIN(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_PLUGIN))
-#define RYGEL_IS_PLUGIN_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_PLUGIN))
-#define RYGEL_PLUGIN_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_PLUGIN, RygelPluginClass))
-
-typedef struct _RygelPlugin RygelPlugin;
-typedef struct _RygelPluginClass RygelPluginClass;
-#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
-typedef struct _RygelPluginPrivate RygelPluginPrivate;
-
-#define RYGEL_TYPE_RESOURCE_INFO (rygel_resource_info_get_type ())
-#define RYGEL_RESOURCE_INFO(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_RESOURCE_INFO, RygelResourceInfo))
-#define RYGEL_RESOURCE_INFO_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_RESOURCE_INFO, RygelResourceInfoClass))
-#define RYGEL_IS_RESOURCE_INFO(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_RESOURCE_INFO))
-#define RYGEL_IS_RESOURCE_INFO_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_RESOURCE_INFO))
-#define RYGEL_RESOURCE_INFO_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_RESOURCE_INFO, RygelResourceInfoClass))
-
-typedef struct _RygelResourceInfo RygelResourceInfo;
-typedef struct _RygelResourceInfoClass RygelResourceInfoClass;
-
-#define RYGEL_TYPE_ICON_INFO (rygel_icon_info_get_type ())
-#define RYGEL_ICON_INFO(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_ICON_INFO, RygelIconInfo))
-#define RYGEL_ICON_INFO_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_ICON_INFO, RygelIconInfoClass))
-#define RYGEL_IS_ICON_INFO(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_ICON_INFO))
-#define RYGEL_IS_ICON_INFO_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_ICON_INFO))
-#define RYGEL_ICON_INFO_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_ICON_INFO, RygelIconInfoClass))
-
-typedef struct _RygelIconInfo RygelIconInfo;
-typedef struct _RygelIconInfoClass RygelIconInfoClass;
-#define _g_free0(var) (var = (g_free (var), NULL))
-#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
-#define __g_list_free_g_object_unref0(var) ((var == NULL) ? NULL : (var = (_g_list_free_g_object_unref (var), NULL)))
-#define _g_module_close0(var) ((var == NULL) ? NULL : (var = (g_module_close (var), NULL)))
-
-struct _RygelPluginLoader {
-	GObject parent_instance;
-	RygelPluginLoaderPrivate * priv;
-};
-
-struct _RygelPluginLoaderClass {
-	GObjectClass parent_class;
-};
-
-struct _RygelPluginLoaderPrivate {
-	GeeHashMap* plugin_hash;
-};
-
-struct _RygelPlugin {
-	GUPnPResourceFactory parent_instance;
-	RygelPluginPrivate * priv;
-	char* name;
-	char* title;
-	char* desc_path;
-	GeeArrayList* resource_infos;
-	GeeArrayList* icon_infos;
-};
-
-struct _RygelPluginClass {
-	GUPnPResourceFactoryClass parent_class;
-};
-
-typedef void (*RygelPluginLoaderModuleInitFunc) (RygelPluginLoader* loader, void* user_data);
-
-static gpointer rygel_plugin_loader_parent_class = NULL;
-
-GType rygel_plugin_loader_get_type (void);
-GType rygel_plugin_get_type (void);
-#define RYGEL_PLUGIN_LOADER_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), RYGEL_TYPE_PLUGIN_LOADER, RygelPluginLoaderPrivate))
-enum  {
-	RYGEL_PLUGIN_LOADER_DUMMY_PROPERTY
-};
-RygelPluginLoader* rygel_plugin_loader_new (void);
-RygelPluginLoader* rygel_plugin_loader_construct (GType object_type);
-static gboolean rygel_plugin_loader_is_dir (GFile* file);
-static void rygel_plugin_loader_load_modules_from_dir (RygelPluginLoader* self, GFile* dir);
-void rygel_plugin_loader_load_plugins (RygelPluginLoader* self);
-gpointer rygel_resource_info_ref (gpointer instance);
-void rygel_resource_info_unref (gpointer instance);
-GParamSpec* rygel_param_spec_resource_info (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
-void rygel_value_set_resource_info (GValue* value, gpointer v_object);
-gpointer rygel_value_get_resource_info (const GValue* value);
-GType rygel_resource_info_get_type (void);
-gpointer rygel_icon_info_ref (gpointer instance);
-void rygel_icon_info_unref (gpointer instance);
-GParamSpec* rygel_param_spec_icon_info (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
-void rygel_value_set_icon_info (GValue* value, gpointer v_object);
-gpointer rygel_value_get_icon_info (const GValue* value);
-GType rygel_icon_info_get_type (void);
-void rygel_plugin_loader_add_plugin (RygelPluginLoader* self, RygelPlugin* plugin);
-RygelPlugin* rygel_plugin_loader_get_plugin_by_name (RygelPluginLoader* self, const char* name);
-GeeCollection* rygel_plugin_loader_list_plugins (RygelPluginLoader* self);
-static void rygel_plugin_loader_on_children_enumerated (RygelPluginLoader* self, GObject* source_object, GAsyncResult* res);
-static void _rygel_plugin_loader_on_children_enumerated_gasync_ready_callback (GObject* source_object, GAsyncResult* res, gpointer self);
-static void rygel_plugin_loader_on_next_files_enumerated (RygelPluginLoader* self, GObject* source_object, GAsyncResult* res);
-static void _rygel_plugin_loader_on_next_files_enumerated_gasync_ready_callback (GObject* source_object, GAsyncResult* res, gpointer self);
-static void _g_list_free_g_object_unref (GList* self);
-static void rygel_plugin_loader_load_module_from_file (RygelPluginLoader* self, const char* file_path);
-static void rygel_plugin_loader_finalize (GObject* obj);
-static int _vala_strcmp0 (const char * str1, const char * str2);
-
-
-
-RygelPluginLoader* rygel_plugin_loader_construct (GType object_type) {
-	RygelPluginLoader * self;
-	GeeHashMap* _tmp0_;
-	self = (RygelPluginLoader*) g_object_new (object_type, NULL);
-	self->priv->plugin_hash = (_tmp0_ = gee_hash_map_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, RYGEL_TYPE_PLUGIN, (GBoxedCopyFunc) g_object_ref, g_object_unref, g_str_hash, g_str_equal, g_direct_equal), _g_object_unref0 (self->priv->plugin_hash), _tmp0_);
-	return self;
-}
-
-
-RygelPluginLoader* rygel_plugin_loader_new (void) {
-	return rygel_plugin_loader_construct (RYGEL_TYPE_PLUGIN_LOADER);
-}
-
-
-void rygel_plugin_loader_load_plugins (RygelPluginLoader* self) {
-	GFile* dir;
-	gboolean _tmp0_ = FALSE;
-	g_return_if_fail (self != NULL);
-	g_assert (g_module_supported ());
-	dir = g_file_new_for_path (PLUGIN_DIR);
-	if (dir != NULL) {
-		_tmp0_ = rygel_plugin_loader_is_dir (dir);
-	} else {
-		_tmp0_ = FALSE;
-	}
-	g_assert (_tmp0_);
-	rygel_plugin_loader_load_modules_from_dir (self, dir);
-	_g_object_unref0 (dir);
-}
-
-
-void rygel_plugin_loader_add_plugin (RygelPluginLoader* self, RygelPlugin* plugin) {
-	g_return_if_fail (self != NULL);
-	g_return_if_fail (plugin != NULL);
-	gee_abstract_map_set ((GeeAbstractMap*) self->priv->plugin_hash, plugin->name, plugin);
-	g_debug ("rygel-plugin-loader.vala:59: New plugin '%s' available", plugin->name);
-	g_signal_emit_by_name (self, "plugin-available", plugin);
-}
-
-
-RygelPlugin* rygel_plugin_loader_get_plugin_by_name (RygelPluginLoader* self, const char* name) {
-	RygelPlugin* result;
-	g_return_val_if_fail (self != NULL, NULL);
-	g_return_val_if_fail (name != NULL, NULL);
-	result = (RygelPlugin*) gee_abstract_map_get ((GeeAbstractMap*) self->priv->plugin_hash, name);
-	return result;
-}
-
-
-GeeCollection* rygel_plugin_loader_list_plugins (RygelPluginLoader* self) {
-	GeeCollection* result;
-	g_return_val_if_fail (self != NULL, NULL);
-	result = gee_abstract_map_get_values ((GeeAbstractMap*) self->priv->plugin_hash);
-	return result;
-}
-
-
-static void _rygel_plugin_loader_on_children_enumerated_gasync_ready_callback (GObject* source_object, GAsyncResult* res, gpointer self) {
-	rygel_plugin_loader_on_children_enumerated (self, source_object, res);
-}
-
-
-static void rygel_plugin_loader_load_modules_from_dir (RygelPluginLoader* self, GFile* dir) {
-	char* attributes;
-	g_return_if_fail (self != NULL);
-	g_return_if_fail (dir != NULL);
-	attributes = g_strdup (G_FILE_ATTRIBUTE_STANDARD_NAME "," G_FILE_ATTRIBUTE_STANDARD_TYPE "," G_FILE_ATTRIBUTE_STANDARD_CONTENT_TYPE);
-	g_file_enumerate_children_async (dir, attributes, G_FILE_QUERY_INFO_NONE, G_PRIORITY_DEFAULT, NULL, _rygel_plugin_loader_on_children_enumerated_gasync_ready_callback, self);
-	_g_free0 (attributes);
-}
-
-
-static gpointer _g_object_ref0 (gpointer self) {
-	return self ? g_object_ref (self) : NULL;
-}
-
-
-static void _rygel_plugin_loader_on_next_files_enumerated_gasync_ready_callback (GObject* source_object, GAsyncResult* res, gpointer self) {
-	rygel_plugin_loader_on_next_files_enumerated (self, source_object, res);
-}
-
-
-static void rygel_plugin_loader_on_children_enumerated (RygelPluginLoader* self, GObject* source_object, GAsyncResult* res) {
-	GError * _inner_error_;
-	GFile* dir;
-	GFileEnumerator* enumerator;
-	g_return_if_fail (self != NULL);
-	g_return_if_fail (res != NULL);
-	_inner_error_ = NULL;
-	dir = _g_object_ref0 (G_FILE (source_object));
-	enumerator = NULL;
-	{
-		GFileEnumerator* _tmp0_;
-		GFileEnumerator* _tmp1_;
-		_tmp0_ = g_file_enumerate_children_finish (dir, res, &_inner_error_);
-		if (_inner_error_ != NULL) {
-			goto __catch29_g_error;
-			goto __finally29;
-		}
-		enumerator = (_tmp1_ = _tmp0_, _g_object_unref0 (enumerator), _tmp1_);
-	}
-	goto __finally29;
-	__catch29_g_error:
-	{
-		GError * _error_;
-		_error_ = _inner_error_;
-		_inner_error_ = NULL;
-		{
-			char* _tmp2_;
-			g_critical ("rygel-plugin-loader.vala:91: Error listing contents of directory '%s': %s\n", _tmp2_ = g_file_get_path (dir), _error_->message);
-			_g_free0 (_tmp2_);
-			_g_error_free0 (_error_);
-			_g_object_unref0 (dir);
-			_g_object_unref0 (enumerator);
-			return;
-		}
-	}
-	__finally29:
-	if (_inner_error_ != NULL) {
-		_g_object_unref0 (dir);
-		_g_object_unref0 (enumerator);
-		g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
-		g_clear_error (&_inner_error_);
-		return;
-	}
-	g_file_enumerator_next_files_async (enumerator, G_MAXINT, G_PRIORITY_DEFAULT, NULL, _rygel_plugin_loader_on_next_files_enumerated_gasync_ready_callback, self);
-	_g_object_unref0 (dir);
-	_g_object_unref0 (enumerator);
-}
-
-
-static void _g_list_free_g_object_unref (GList* self) {
-	g_list_foreach (self, (GFunc) g_object_unref, NULL);
-	g_list_free (self);
-}
-
-
-static void rygel_plugin_loader_on_next_files_enumerated (RygelPluginLoader* self, GObject* source_object, GAsyncResult* res) {
-	GError * _inner_error_;
-	GFileEnumerator* enumerator;
-	GFile* dir;
-	GList* infos;
-	g_return_if_fail (self != NULL);
-	g_return_if_fail (res != NULL);
-	_inner_error_ = NULL;
-	enumerator = _g_object_ref0 (G_FILE_ENUMERATOR (source_object));
-	dir = _g_object_ref0 (G_FILE (g_file_enumerator_get_container (enumerator)));
-	infos = NULL;
-	{
-		GList* _tmp0_;
-		GList* _tmp1_;
-		_tmp0_ = g_file_enumerator_next_files_finish (enumerator, res, &_inner_error_);
-		if (_inner_error_ != NULL) {
-			goto __catch30_g_error;
-			goto __finally30;
-		}
-		infos = (_tmp1_ = _tmp0_, __g_list_free_g_object_unref0 (infos), _tmp1_);
-	}
-	goto __finally30;
-	__catch30_g_error:
-	{
-		GError * _error_;
-		_error_ = _inner_error_;
-		_inner_error_ = NULL;
-		{
-			char* _tmp2_;
-			g_critical ("rygel-plugin-loader.vala:113: Error listing contents of directory '%s': %s\n", _tmp2_ = g_file_get_path (dir), _error_->message);
-			_g_free0 (_tmp2_);
-			_g_error_free0 (_error_);
-			_g_object_unref0 (enumerator);
-			_g_object_unref0 (dir);
-			__g_list_free_g_object_unref0 (infos);
-			return;
-		}
-	}
-	__finally30:
-	if (_inner_error_ != NULL) {
-		_g_object_unref0 (enumerator);
-		_g_object_unref0 (dir);
-		__g_list_free_g_object_unref0 (infos);
-		g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
-		g_clear_error (&_inner_error_);
-		return;
-	}
-	{
-		GList* info_collection;
-		GList* info_it;
-		info_collection = infos;
-		for (info_it = info_collection; info_it != NULL; info_it = info_it->next) {
-			GFileInfo* info;
-			info = _g_object_ref0 ((GFileInfo*) info_it->data);
-			{
-				char* file_name;
-				char* _tmp3_;
-				char* _tmp4_;
-				char* file_path;
-				GFile* file;
-				GFileType file_type;
-				char* content_type;
-				const char* mime;
-				file_name = g_strdup (g_file_info_get_name (info));
-				file_path = (_tmp4_ = g_build_filename (_tmp3_ = g_file_get_path (dir), file_name, NULL), _g_free0 (_tmp3_), _tmp4_);
-				file = g_file_new_for_path (file_path);
-				file_type = g_file_info_get_file_type (info);
-				content_type = g_strdup (g_file_info_get_content_type (info));
-				mime = g_content_type_get_mime_type (content_type);
-				if (file_type == G_FILE_TYPE_DIRECTORY) {
-					rygel_plugin_loader_load_modules_from_dir (self, file);
-				} else {
-					if (_vala_strcmp0 (mime, "application/x-sharedlib") == 0) {
-						rygel_plugin_loader_load_module_from_file (self, file_path);
-					}
-				}
-				_g_object_unref0 (info);
-				_g_free0 (file_name);
-				_g_free0 (file_path);
-				_g_object_unref0 (file);
-				_g_free0 (content_type);
-			}
-		}
-	}
-	_g_object_unref0 (enumerator);
-	_g_object_unref0 (dir);
-	__g_list_free_g_object_unref0 (infos);
-}
-
-
-static void rygel_plugin_loader_load_module_from_file (RygelPluginLoader* self, const char* file_path) {
-	GModule* module;
-	void* function = NULL;
-	RygelPluginLoaderModuleInitFunc _tmp0_;
-	GDestroyNotify module_init_target_destroy_notify;
-	void* module_init_target = NULL;
-	RygelPluginLoaderModuleInitFunc module_init;
-	g_return_if_fail (self != NULL);
-	g_return_if_fail (file_path != NULL);
-	module = g_module_open (file_path, G_MODULE_BIND_LOCAL);
-	if (module == NULL) {
-		g_warning ("rygel-plugin-loader.vala:142: Failed to load module from path '%s' : %s\n", file_path, g_module_error ());
-		_g_module_close0 (module);
-		return;
-	}
-	if (!g_module_symbol (module, "module_init", &function)) {
-		g_warning ("Failed to find entry point function 'module_init'" " in module loaded from path '%s': %s\n", file_path, g_module_error ());
-		_g_module_close0 (module);
-		return;
-	}
-	module_init = (_tmp0_ = (RygelPluginLoaderModuleInitFunc) function, module_init_target = NULL, module_init_target_destroy_notify = NULL, _tmp0_);
-	g_assert (module_init != NULL);
-	g_module_make_resident (module);
-	module_init (self, module_init_target);
-	g_debug ("rygel-plugin-loader.vala:168: Loaded module source: '%s'\n", g_module_name (module));
-	_g_module_close0 (module);
-	(module_init_target_destroy_notify == NULL) ? NULL : module_init_target_destroy_notify (module_init_target);
-	module_init = NULL;
-	module_init_target = NULL;
-	module_init_target_destroy_notify = NULL;
-}
-
-
-static gboolean rygel_plugin_loader_is_dir (GFile* file) {
-	gboolean result;
-	GError * _inner_error_;
-	GFileInfo* file_info;
-	g_return_val_if_fail (file != NULL, FALSE);
-	_inner_error_ = NULL;
-	file_info = NULL;
-	{
-		GFileInfo* _tmp0_;
-		GFileInfo* _tmp1_;
-		_tmp0_ = g_file_query_info (file, G_FILE_ATTRIBUTE_STANDARD_TYPE, G_FILE_QUERY_INFO_NONE, NULL, &_inner_error_);
-		if (_inner_error_ != NULL) {
-			goto __catch31_g_error;
-			goto __finally31;
-		}
-		file_info = (_tmp1_ = _tmp0_, _g_object_unref0 (file_info), _tmp1_);
-	}
-	goto __finally31;
-	__catch31_g_error:
-	{
-		GError * _error_;
-		_error_ = _inner_error_;
-		_inner_error_ = NULL;
-		{
-			char* _tmp2_;
-			g_critical ("rygel-plugin-loader.vala:179: Failed to query content type for '%s'\n", _tmp2_ = g_file_get_path (file));
-			_g_free0 (_tmp2_);
-			result = FALSE;
-			_g_error_free0 (_error_);
-			_g_object_unref0 (file_info);
-			return result;
-		}
-	}
-	__finally31:
-	if (_inner_error_ != NULL) {
-		_g_object_unref0 (file_info);
-		g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
-		g_clear_error (&_inner_error_);
-		return FALSE;
-	}
-	result = g_file_info_get_file_type (file_info) == G_FILE_TYPE_DIRECTORY;
-	_g_object_unref0 (file_info);
-	return result;
-}
-
-
-static void rygel_plugin_loader_class_init (RygelPluginLoaderClass * klass) {
-	rygel_plugin_loader_parent_class = g_type_class_peek_parent (klass);
-	g_type_class_add_private (klass, sizeof (RygelPluginLoaderPrivate));
-	G_OBJECT_CLASS (klass)->finalize = rygel_plugin_loader_finalize;
-	g_signal_new ("plugin_available", RYGEL_TYPE_PLUGIN_LOADER, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__OBJECT, G_TYPE_NONE, 1, RYGEL_TYPE_PLUGIN);
-}
-
-
-static void rygel_plugin_loader_instance_init (RygelPluginLoader * self) {
-	self->priv = RYGEL_PLUGIN_LOADER_GET_PRIVATE (self);
-}
-
-
-static void rygel_plugin_loader_finalize (GObject* obj) {
-	RygelPluginLoader * self;
-	self = RYGEL_PLUGIN_LOADER (obj);
-	_g_object_unref0 (self->priv->plugin_hash);
-	G_OBJECT_CLASS (rygel_plugin_loader_parent_class)->finalize (obj);
-}
-
-
-GType rygel_plugin_loader_get_type (void) {
-	static GType rygel_plugin_loader_type_id = 0;
-	if (rygel_plugin_loader_type_id == 0) {
-		static const GTypeInfo g_define_type_info = { sizeof (RygelPluginLoaderClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) rygel_plugin_loader_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (RygelPluginLoader), 0, (GInstanceInitFunc) rygel_plugin_loader_instance_init, NULL };
-		rygel_plugin_loader_type_id = g_type_register_static (G_TYPE_OBJECT, "RygelPluginLoader", &g_define_type_info, 0);
-	}
-	return rygel_plugin_loader_type_id;
-}
-
-
-static int _vala_strcmp0 (const char * str1, const char * str2) {
-	if (str1 == NULL) {
-		return -(str1 != str2);
-	}
-	if (str2 == NULL) {
-		return str1 != str2;
-	}
-	return strcmp (str1, str2);
-}
-
-
-
-
--- a/src/rygel/rygel-plugin.c
+++ /dev/null
@@ -1,297 +0,0 @@
-/* rygel-plugin.c generated by valac, the Vala compiler
- * generated from rygel-plugin.vala, do not modify */
-
-/*
- * Copyright (C) 2008 Nokia Corporation.
- *
- * Author: Zeeshan Ali (Khattak) <zeeshanak@gnome.org>
- *                               <zeeshan.ali@nokia.com>
- *
- * This file is part of Rygel.
- *
- * Rygel is free software; you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * Rygel is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this program; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
- */
-
-#include <glib.h>
-#include <glib-object.h>
-#include <libgupnp/gupnp.h>
-#include <stdlib.h>
-#include <string.h>
-#include <gee.h>
-
-
-#define RYGEL_TYPE_PLUGIN (rygel_plugin_get_type ())
-#define RYGEL_PLUGIN(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_PLUGIN, RygelPlugin))
-#define RYGEL_PLUGIN_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_PLUGIN, RygelPluginClass))
-#define RYGEL_IS_PLUGIN(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_PLUGIN))
-#define RYGEL_IS_PLUGIN_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_PLUGIN))
-#define RYGEL_PLUGIN_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_PLUGIN, RygelPluginClass))
-
-typedef struct _RygelPlugin RygelPlugin;
-typedef struct _RygelPluginClass RygelPluginClass;
-typedef struct _RygelPluginPrivate RygelPluginPrivate;
-
-#define RYGEL_TYPE_RESOURCE_INFO (rygel_resource_info_get_type ())
-#define RYGEL_RESOURCE_INFO(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_RESOURCE_INFO, RygelResourceInfo))
-#define RYGEL_RESOURCE_INFO_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_RESOURCE_INFO, RygelResourceInfoClass))
-#define RYGEL_IS_RESOURCE_INFO(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_RESOURCE_INFO))
-#define RYGEL_IS_RESOURCE_INFO_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_RESOURCE_INFO))
-#define RYGEL_RESOURCE_INFO_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_RESOURCE_INFO, RygelResourceInfoClass))
-
-typedef struct _RygelResourceInfo RygelResourceInfo;
-typedef struct _RygelResourceInfoClass RygelResourceInfoClass;
-
-#define RYGEL_TYPE_ICON_INFO (rygel_icon_info_get_type ())
-#define RYGEL_ICON_INFO(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_ICON_INFO, RygelIconInfo))
-#define RYGEL_ICON_INFO_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_ICON_INFO, RygelIconInfoClass))
-#define RYGEL_IS_ICON_INFO(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_ICON_INFO))
-#define RYGEL_IS_ICON_INFO_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_ICON_INFO))
-#define RYGEL_ICON_INFO_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_ICON_INFO, RygelIconInfoClass))
-
-typedef struct _RygelIconInfo RygelIconInfo;
-typedef struct _RygelIconInfoClass RygelIconInfoClass;
-#define _g_free0(var) (var = (g_free (var), NULL))
-#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
-
-#define RYGEL_TYPE_CONNECTION_MANAGER (rygel_connection_manager_get_type ())
-#define RYGEL_CONNECTION_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_CONNECTION_MANAGER, RygelConnectionManager))
-#define RYGEL_CONNECTION_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_CONNECTION_MANAGER, RygelConnectionManagerClass))
-#define RYGEL_IS_CONNECTION_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_CONNECTION_MANAGER))
-#define RYGEL_IS_CONNECTION_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_CONNECTION_MANAGER))
-#define RYGEL_CONNECTION_MANAGER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_CONNECTION_MANAGER, RygelConnectionManagerClass))
-
-typedef struct _RygelConnectionManager RygelConnectionManager;
-typedef struct _RygelConnectionManagerClass RygelConnectionManagerClass;
-#define _rygel_resource_info_unref0(var) ((var == NULL) ? NULL : (var = (rygel_resource_info_unref (var), NULL)))
-typedef struct _RygelResourceInfoPrivate RygelResourceInfoPrivate;
-
-struct _RygelPlugin {
-	GUPnPResourceFactory parent_instance;
-	RygelPluginPrivate * priv;
-	char* name;
-	char* title;
-	char* desc_path;
-	GeeArrayList* resource_infos;
-	GeeArrayList* icon_infos;
-};
-
-struct _RygelPluginClass {
-	GUPnPResourceFactoryClass parent_class;
-};
-
-struct _RygelPluginPrivate {
-	gboolean _available;
-};
-
-struct _RygelResourceInfo {
-	GTypeInstance parent_instance;
-	volatile int ref_count;
-	RygelResourceInfoPrivate * priv;
-	char* upnp_type;
-	char* upnp_id;
-	char* description_path;
-	GType type;
-};
-
-struct _RygelResourceInfoClass {
-	GTypeClass parent_class;
-	void (*finalize) (RygelResourceInfo *self);
-};
-
-
-static gpointer rygel_plugin_parent_class = NULL;
-
-GType rygel_plugin_get_type (void);
-gpointer rygel_resource_info_ref (gpointer instance);
-void rygel_resource_info_unref (gpointer instance);
-GParamSpec* rygel_param_spec_resource_info (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
-void rygel_value_set_resource_info (GValue* value, gpointer v_object);
-gpointer rygel_value_get_resource_info (const GValue* value);
-GType rygel_resource_info_get_type (void);
-gpointer rygel_icon_info_ref (gpointer instance);
-void rygel_icon_info_unref (gpointer instance);
-GParamSpec* rygel_param_spec_icon_info (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
-void rygel_value_set_icon_info (GValue* value, gpointer v_object);
-gpointer rygel_value_get_icon_info (const GValue* value);
-GType rygel_icon_info_get_type (void);
-#define RYGEL_PLUGIN_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), RYGEL_TYPE_PLUGIN, RygelPluginPrivate))
-enum  {
-	RYGEL_PLUGIN_DUMMY_PROPERTY,
-	RYGEL_PLUGIN_AVAILABLE
-};
-#define RYGEL_PLUGIN_MEDIA_SERVER_DESC_PATH DATA_DIR "/xml/MediaServer2.xml"
-void rygel_plugin_set_available (RygelPlugin* self, gboolean value);
-RygelPlugin* rygel_plugin_new (const char* desc_path, const char* name, const char* title);
-RygelPlugin* rygel_plugin_construct (GType object_type, const char* desc_path, const char* name, const char* title);
-#define RYGEL_CONNECTION_MANAGER_UPNP_ID "urn:upnp-org:serviceId:ConnectionManager"
-#define RYGEL_CONNECTION_MANAGER_UPNP_TYPE "urn:schemas-upnp-org:service:ConnectionManager:2"
-#define RYGEL_CONNECTION_MANAGER_DESCRIPTION_PATH "xml/ConnectionManager.xml"
-GType rygel_connection_manager_get_type (void);
-RygelResourceInfo* rygel_resource_info_new (const char* upnp_id, const char* upnp_type, const char* description_path, GType type);
-RygelResourceInfo* rygel_resource_info_construct (GType object_type, const char* upnp_id, const char* upnp_type, const char* description_path, GType type);
-void rygel_plugin_add_resource (RygelPlugin* self, RygelResourceInfo* resource_info);
-RygelPlugin* rygel_plugin_new_MediaServer (const char* name, const char* title);
-RygelPlugin* rygel_plugin_construct_MediaServer (GType object_type, const char* name, const char* title);
-void rygel_plugin_add_icon (RygelPlugin* self, RygelIconInfo* icon_info);
-gboolean rygel_plugin_get_available (RygelPlugin* self);
-static void rygel_plugin_finalize (GObject* obj);
-static void rygel_plugin_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
-static void rygel_plugin_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);
-
-
-
-RygelPlugin* rygel_plugin_construct (GType object_type, const char* desc_path, const char* name, const char* title) {
-	RygelPlugin * self;
-	char* _tmp0_;
-	char* _tmp1_;
-	char* _tmp2_;
-	GeeArrayList* _tmp4_;
-	GeeArrayList* _tmp5_;
-	g_return_val_if_fail (desc_path != NULL, NULL);
-	g_return_val_if_fail (name != NULL, NULL);
-	self = g_object_newv (object_type, 0, NULL);
-	self->desc_path = (_tmp0_ = g_strdup (desc_path), _g_free0 (self->desc_path), _tmp0_);
-	self->name = (_tmp1_ = g_strdup (name), _g_free0 (self->name), _tmp1_);
-	self->title = (_tmp2_ = g_strdup (title), _g_free0 (self->title), _tmp2_);
-	rygel_plugin_set_available (self, TRUE);
-	if (title == NULL) {
-		char* _tmp3_;
-		self->title = (_tmp3_ = g_strdup (name), _g_free0 (self->title), _tmp3_);
-	}
-	self->resource_infos = (_tmp4_ = gee_array_list_new (RYGEL_TYPE_RESOURCE_INFO, (GBoxedCopyFunc) rygel_resource_info_ref, rygel_resource_info_unref, g_direct_equal), _g_object_unref0 (self->resource_infos), _tmp4_);
-	self->icon_infos = (_tmp5_ = gee_array_list_new (RYGEL_TYPE_ICON_INFO, (GBoxedCopyFunc) rygel_icon_info_ref, rygel_icon_info_unref, g_direct_equal), _g_object_unref0 (self->icon_infos), _tmp5_);
-	return self;
-}
-
-
-RygelPlugin* rygel_plugin_new (const char* desc_path, const char* name, const char* title) {
-	return rygel_plugin_construct (RYGEL_TYPE_PLUGIN, desc_path, name, title);
-}
-
-
-RygelPlugin* rygel_plugin_construct_MediaServer (GType object_type, const char* name, const char* title) {
-	RygelPlugin * self;
-	RygelResourceInfo* resource_info;
-	g_return_val_if_fail (name != NULL, NULL);
-	self = (RygelPlugin*) rygel_plugin_construct (object_type, RYGEL_PLUGIN_MEDIA_SERVER_DESC_PATH, name, title);
-	resource_info = rygel_resource_info_new (RYGEL_CONNECTION_MANAGER_UPNP_ID, RYGEL_CONNECTION_MANAGER_UPNP_TYPE, RYGEL_CONNECTION_MANAGER_DESCRIPTION_PATH, RYGEL_TYPE_CONNECTION_MANAGER);
-	rygel_plugin_add_resource (self, resource_info);
-	_rygel_resource_info_unref0 (resource_info);
-	return self;
-}
-
-
-RygelPlugin* rygel_plugin_new_MediaServer (const char* name, const char* title) {
-	return rygel_plugin_construct_MediaServer (RYGEL_TYPE_PLUGIN, name, title);
-}
-
-
-void rygel_plugin_add_resource (RygelPlugin* self, RygelResourceInfo* resource_info) {
-	g_return_if_fail (self != NULL);
-	g_return_if_fail (resource_info != NULL);
-	gee_abstract_collection_add ((GeeAbstractCollection*) self->resource_infos, resource_info);
-	gupnp_resource_factory_register_resource_type ((GUPnPResourceFactory*) self, resource_info->upnp_type, resource_info->type);
-}
-
-
-void rygel_plugin_add_icon (RygelPlugin* self, RygelIconInfo* icon_info) {
-	g_return_if_fail (self != NULL);
-	g_return_if_fail (icon_info != NULL);
-	gee_abstract_collection_add ((GeeAbstractCollection*) self->icon_infos, icon_info);
-}
-
-
-gboolean rygel_plugin_get_available (RygelPlugin* self) {
-	gboolean result;
-	g_return_val_if_fail (self != NULL, FALSE);
-	result = self->priv->_available;
-	return result;
-}
-
-
-void rygel_plugin_set_available (RygelPlugin* self, gboolean value) {
-	g_return_if_fail (self != NULL);
-	self->priv->_available = value;
-	g_object_notify ((GObject *) self, "available");
-}
-
-
-static void rygel_plugin_class_init (RygelPluginClass * klass) {
-	rygel_plugin_parent_class = g_type_class_peek_parent (klass);
-	g_type_class_add_private (klass, sizeof (RygelPluginPrivate));
-	G_OBJECT_CLASS (klass)->get_property = rygel_plugin_get_property;
-	G_OBJECT_CLASS (klass)->set_property = rygel_plugin_set_property;
-	G_OBJECT_CLASS (klass)->finalize = rygel_plugin_finalize;
-	g_object_class_install_property (G_OBJECT_CLASS (klass), RYGEL_PLUGIN_AVAILABLE, g_param_spec_boolean ("available", "available", "available", FALSE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
-}
-
-
-static void rygel_plugin_instance_init (RygelPlugin * self) {
-	self->priv = RYGEL_PLUGIN_GET_PRIVATE (self);
-}
-
-
-static void rygel_plugin_finalize (GObject* obj) {
-	RygelPlugin * self;
-	self = RYGEL_PLUGIN (obj);
-	_g_free0 (self->name);
-	_g_free0 (self->title);
-	_g_free0 (self->desc_path);
-	_g_object_unref0 (self->resource_infos);
-	_g_object_unref0 (self->icon_infos);
-	G_OBJECT_CLASS (rygel_plugin_parent_class)->finalize (obj);
-}
-
-
-GType rygel_plugin_get_type (void) {
-	static GType rygel_plugin_type_id = 0;
-	if (rygel_plugin_type_id == 0) {
-		static const GTypeInfo g_define_type_info = { sizeof (RygelPluginClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) rygel_plugin_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (RygelPlugin), 0, (GInstanceInitFunc) rygel_plugin_instance_init, NULL };
-		rygel_plugin_type_id = g_type_register_static (GUPNP_TYPE_RESOURCE_FACTORY, "RygelPlugin", &g_define_type_info, 0);
-	}
-	return rygel_plugin_type_id;
-}
-
-
-static void rygel_plugin_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
-	RygelPlugin * self;
-	self = RYGEL_PLUGIN (object);
-	switch (property_id) {
-		case RYGEL_PLUGIN_AVAILABLE:
-		g_value_set_boolean (value, rygel_plugin_get_available (self));
-		break;
-		default:
-		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
-		break;
-	}
-}
-
-
-static void rygel_plugin_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
-	RygelPlugin * self;
-	self = RYGEL_PLUGIN (object);
-	switch (property_id) {
-		case RYGEL_PLUGIN_AVAILABLE:
-		rygel_plugin_set_available (self, g_value_get_boolean (value));
-		break;
-		default:
-		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
-		break;
-	}
-}
-
-
-
-
--- a/src/rygel/rygel-resource-info.c
+++ /dev/null
@@ -1,250 +0,0 @@
-/* rygel-resource-info.c generated by valac, the Vala compiler
- * generated from rygel-resource-info.vala, do not modify */
-
-/*
- * Copyright (C) 2008 Nokia Corporation.
- *
- * Author: Zeeshan Ali (Khattak) <zeeshanak@gnome.org>
- *                               <zeeshan.ali@nokia.com>
- *
- * This file is part of Rygel.
- *
- * Rygel is free software; you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * Rygel is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this program; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
- */
-
-#include <glib.h>
-#include <glib-object.h>
-#include <stdlib.h>
-#include <string.h>
-#include <gobject/gvaluecollector.h>
-
-
-#define RYGEL_TYPE_RESOURCE_INFO (rygel_resource_info_get_type ())
-#define RYGEL_RESOURCE_INFO(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_RESOURCE_INFO, RygelResourceInfo))
-#define RYGEL_RESOURCE_INFO_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_RESOURCE_INFO, RygelResourceInfoClass))
-#define RYGEL_IS_RESOURCE_INFO(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_RESOURCE_INFO))
-#define RYGEL_IS_RESOURCE_INFO_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_RESOURCE_INFO))
-#define RYGEL_RESOURCE_INFO_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_RESOURCE_INFO, RygelResourceInfoClass))
-
-typedef struct _RygelResourceInfo RygelResourceInfo;
-typedef struct _RygelResourceInfoClass RygelResourceInfoClass;
-typedef struct _RygelResourceInfoPrivate RygelResourceInfoPrivate;
-#define _g_free0(var) (var = (g_free (var), NULL))
-typedef struct _RygelParamSpecResourceInfo RygelParamSpecResourceInfo;
-
-struct _RygelResourceInfo {
-	GTypeInstance parent_instance;
-	volatile int ref_count;
-	RygelResourceInfoPrivate * priv;
-	char* upnp_type;
-	char* upnp_id;
-	char* description_path;
-	GType type;
-};
-
-struct _RygelResourceInfoClass {
-	GTypeClass parent_class;
-	void (*finalize) (RygelResourceInfo *self);
-};
-
-struct _RygelParamSpecResourceInfo {
-	GParamSpec parent_instance;
-};
-
-
-static gpointer rygel_resource_info_parent_class = NULL;
-
-gpointer rygel_resource_info_ref (gpointer instance);
-void rygel_resource_info_unref (gpointer instance);
-GParamSpec* rygel_param_spec_resource_info (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
-void rygel_value_set_resource_info (GValue* value, gpointer v_object);
-gpointer rygel_value_get_resource_info (const GValue* value);
-GType rygel_resource_info_get_type (void);
-enum  {
-	RYGEL_RESOURCE_INFO_DUMMY_PROPERTY
-};
-RygelResourceInfo* rygel_resource_info_new (const char* upnp_id, const char* upnp_type, const char* description_path, GType type);
-RygelResourceInfo* rygel_resource_info_construct (GType object_type, const char* upnp_id, const char* upnp_type, const char* description_path, GType type);
-static void rygel_resource_info_finalize (RygelResourceInfo* obj);
-
-
-
-RygelResourceInfo* rygel_resource_info_construct (GType object_type, const char* upnp_id, const char* upnp_type, const char* description_path, GType type) {
-	RygelResourceInfo* self;
-	char* _tmp0_;
-	char* _tmp1_;
-	char* _tmp2_;
-	g_return_val_if_fail (upnp_id != NULL, NULL);
-	g_return_val_if_fail (upnp_type != NULL, NULL);
-	g_return_val_if_fail (description_path != NULL, NULL);
-	self = (RygelResourceInfo*) g_type_create_instance (object_type);
-	self->upnp_type = (_tmp0_ = g_strdup (upnp_type), _g_free0 (self->upnp_type), _tmp0_);
-	self->upnp_id = (_tmp1_ = g_strdup (upnp_id), _g_free0 (self->upnp_id), _tmp1_);
-	self->description_path = (_tmp2_ = g_strdup (description_path), _g_free0 (self->description_path), _tmp2_);
-	self->type = type;
-	return self;
-}
-
-
-RygelResourceInfo* rygel_resource_info_new (const char* upnp_id, const char* upnp_type, const char* description_path, GType type) {
-	return rygel_resource_info_construct (RYGEL_TYPE_RESOURCE_INFO, upnp_id, upnp_type, description_path, type);
-}
-
-
-static void rygel_value_resource_info_init (GValue* value) {
-	value->data[0].v_pointer = NULL;
-}
-
-
-static void rygel_value_resource_info_free_value (GValue* value) {
-	if (value->data[0].v_pointer) {
-		rygel_resource_info_unref (value->data[0].v_pointer);
-	}
-}
-
-
-static void rygel_value_resource_info_copy_value (const GValue* src_value, GValue* dest_value) {
-	if (src_value->data[0].v_pointer) {
-		dest_value->data[0].v_pointer = rygel_resource_info_ref (src_value->data[0].v_pointer);
-	} else {
-		dest_value->data[0].v_pointer = NULL;
-	}
-}
-
-
-static gpointer rygel_value_resource_info_peek_pointer (const GValue* value) {
-	return value->data[0].v_pointer;
-}
-
-
-static gchar* rygel_value_resource_info_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
-	if (collect_values[0].v_pointer) {
-		RygelResourceInfo* object;
-		object = collect_values[0].v_pointer;
-		if (object->parent_instance.g_class == NULL) {
-			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
-		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
-			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
-		}
-		value->data[0].v_pointer = rygel_resource_info_ref (object);
-	} else {
-		value->data[0].v_pointer = NULL;
-	}
-	return NULL;
-}
-
-
-static gchar* rygel_value_resource_info_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
-	RygelResourceInfo** object_p;
-	object_p = collect_values[0].v_pointer;
-	if (!object_p) {
-		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
-	}
-	if (!value->data[0].v_pointer) {
-		*object_p = NULL;
-	} else if (collect_flags && G_VALUE_NOCOPY_CONTENTS) {
-		*object_p = value->data[0].v_pointer;
-	} else {
-		*object_p = rygel_resource_info_ref (value->data[0].v_pointer);
-	}
-	return NULL;
-}
-
-
-GParamSpec* rygel_param_spec_resource_info (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
-	RygelParamSpecResourceInfo* spec;
-	g_return_val_if_fail (g_type_is_a (object_type, RYGEL_TYPE_RESOURCE_INFO), NULL);
-	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
-	G_PARAM_SPEC (spec)->value_type = object_type;
-	return G_PARAM_SPEC (spec);
-}
-
-
-gpointer rygel_value_get_resource_info (const GValue* value) {
-	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, RYGEL_TYPE_RESOURCE_INFO), NULL);
-	return value->data[0].v_pointer;
-}
-
-
-void rygel_value_set_resource_info (GValue* value, gpointer v_object) {
-	RygelResourceInfo* old;
-	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, RYGEL_TYPE_RESOURCE_INFO));
-	old = value->data[0].v_pointer;
-	if (v_object) {
-		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, RYGEL_TYPE_RESOURCE_INFO));
-		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
-		value->data[0].v_pointer = v_object;
-		rygel_resource_info_ref (value->data[0].v_pointer);
-	} else {
-		value->data[0].v_pointer = NULL;
-	}
-	if (old) {
-		rygel_resource_info_unref (old);
-	}
-}
-
-
-static void rygel_resource_info_class_init (RygelResourceInfoClass * klass) {
-	rygel_resource_info_parent_class = g_type_class_peek_parent (klass);
-	RYGEL_RESOURCE_INFO_CLASS (klass)->finalize = rygel_resource_info_finalize;
-}
-
-
-static void rygel_resource_info_instance_init (RygelResourceInfo * self) {
-	self->ref_count = 1;
-}
-
-
-static void rygel_resource_info_finalize (RygelResourceInfo* obj) {
-	RygelResourceInfo * self;
-	self = RYGEL_RESOURCE_INFO (obj);
-	_g_free0 (self->upnp_type);
-	_g_free0 (self->upnp_id);
-	_g_free0 (self->description_path);
-}
-
-
-GType rygel_resource_info_get_type (void) {
-	static GType rygel_resource_info_type_id = 0;
-	if (rygel_resource_info_type_id == 0) {
-		static const GTypeValueTable g_define_type_value_table = { rygel_value_resource_info_init, rygel_value_resource_info_free_value, rygel_value_resource_info_copy_value, rygel_value_resource_info_peek_pointer, "p", rygel_value_resource_info_collect_value, "p", rygel_value_resource_info_lcopy_value };
-		static const GTypeInfo g_define_type_info = { sizeof (RygelResourceInfoClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) rygel_resource_info_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (RygelResourceInfo), 0, (GInstanceInitFunc) rygel_resource_info_instance_init, &g_define_type_value_table };
-		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
-		rygel_resource_info_type_id = g_type_register_fundamental (g_type_fundamental_next (), "RygelResourceInfo", &g_define_type_info, &g_define_type_fundamental_info, 0);
-	}
-	return rygel_resource_info_type_id;
-}
-
-
-gpointer rygel_resource_info_ref (gpointer instance) {
-	RygelResourceInfo* self;
-	self = instance;
-	g_atomic_int_inc (&self->ref_count);
-	return instance;
-}
-
-
-void rygel_resource_info_unref (gpointer instance) {
-	RygelResourceInfo* self;
-	self = instance;
-	if (g_atomic_int_dec_and_test (&self->ref_count)) {
-		RYGEL_RESOURCE_INFO_GET_CLASS (self)->finalize (self);
-		g_type_free_instance ((GTypeInstance *) self);
-	}
-}
-
-
-
-
--- a/src/rygel/rygel-root-device-factory.c
+++ /dev/null
@@ -1,908 +0,0 @@
-/* rygel-root-device-factory.c generated by valac, the Vala compiler
- * generated from rygel-root-device-factory.vala, do not modify */
-
-/*
- * Copyright (C) 2008 Nokia Corporation.
- * Copyright (C) 2008 Zeeshan Ali (Khattak) <zeeshanak@gnome.org>.
- *
- * Author: Zeeshan Ali (Khattak) <zeeshanak@gnome.org>
- *                               <zeeshan.ali@nokia.com>
- *
- * This file is part of Rygel.
- *
- * Rygel is free software; you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * Rygel is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this program; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
- */
-
-#include <glib.h>
-#include <glib-object.h>
-#include <libgupnp/gupnp.h>
-#include <stdlib.h>
-#include <string.h>
-#include <gee.h>
-#include <libxml/tree.h>
-#include <cstuff.h>
-#include <stdio.h>
-#include <libxml/parser.h>
-#include <gio/gio.h>
-#include <gobject/gvaluecollector.h>
-
-
-#define RYGEL_TYPE_ROOT_DEVICE_FACTORY (rygel_root_device_factory_get_type ())
-#define RYGEL_ROOT_DEVICE_FACTORY(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_ROOT_DEVICE_FACTORY, RygelRootDeviceFactory))
-#define RYGEL_ROOT_DEVICE_FACTORY_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_ROOT_DEVICE_FACTORY, RygelRootDeviceFactoryClass))
-#define RYGEL_IS_ROOT_DEVICE_FACTORY(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_ROOT_DEVICE_FACTORY))
-#define RYGEL_IS_ROOT_DEVICE_FACTORY_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_ROOT_DEVICE_FACTORY))
-#define RYGEL_ROOT_DEVICE_FACTORY_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_ROOT_DEVICE_FACTORY, RygelRootDeviceFactoryClass))
-
-typedef struct _RygelRootDeviceFactory RygelRootDeviceFactory;
-typedef struct _RygelRootDeviceFactoryClass RygelRootDeviceFactoryClass;
-typedef struct _RygelRootDeviceFactoryPrivate RygelRootDeviceFactoryPrivate;
-
-#define RYGEL_TYPE_CONFIGURATION (rygel_configuration_get_type ())
-#define RYGEL_CONFIGURATION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_CONFIGURATION, RygelConfiguration))
-#define RYGEL_IS_CONFIGURATION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_CONFIGURATION))
-#define RYGEL_CONFIGURATION_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), RYGEL_TYPE_CONFIGURATION, RygelConfigurationIface))
-
-typedef struct _RygelConfiguration RygelConfiguration;
-typedef struct _RygelConfigurationIface RygelConfigurationIface;
-
-#define RYGEL_TYPE_LOG_LEVEL (rygel_log_level_get_type ())
-#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
-#define _g_free0(var) (var = (g_free (var), NULL))
-
-#define RYGEL_TYPE_META_CONFIG (rygel_meta_config_get_type ())
-#define RYGEL_META_CONFIG(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_META_CONFIG, RygelMetaConfig))
-#define RYGEL_META_CONFIG_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_META_CONFIG, RygelMetaConfigClass))
-#define RYGEL_IS_META_CONFIG(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_META_CONFIG))
-#define RYGEL_IS_META_CONFIG_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_META_CONFIG))
-#define RYGEL_META_CONFIG_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_META_CONFIG, RygelMetaConfigClass))
-
-typedef struct _RygelMetaConfig RygelMetaConfig;
-typedef struct _RygelMetaConfigClass RygelMetaConfigClass;
-
-#define RYGEL_TYPE_PLUGIN (rygel_plugin_get_type ())
-#define RYGEL_PLUGIN(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_PLUGIN, RygelPlugin))
-#define RYGEL_PLUGIN_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_PLUGIN, RygelPluginClass))
-#define RYGEL_IS_PLUGIN(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_PLUGIN))
-#define RYGEL_IS_PLUGIN_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_PLUGIN))
-#define RYGEL_PLUGIN_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_PLUGIN, RygelPluginClass))
-
-typedef struct _RygelPlugin RygelPlugin;
-typedef struct _RygelPluginClass RygelPluginClass;
-typedef struct _RygelPluginPrivate RygelPluginPrivate;
-
-#define RYGEL_TYPE_RESOURCE_INFO (rygel_resource_info_get_type ())
-#define RYGEL_RESOURCE_INFO(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_RESOURCE_INFO, RygelResourceInfo))
-#define RYGEL_RESOURCE_INFO_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_RESOURCE_INFO, RygelResourceInfoClass))
-#define RYGEL_IS_RESOURCE_INFO(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_RESOURCE_INFO))
-#define RYGEL_IS_RESOURCE_INFO_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_RESOURCE_INFO))
-#define RYGEL_RESOURCE_INFO_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_RESOURCE_INFO, RygelResourceInfoClass))
-
-typedef struct _RygelResourceInfo RygelResourceInfo;
-typedef struct _RygelResourceInfoClass RygelResourceInfoClass;
-
-#define RYGEL_TYPE_ICON_INFO (rygel_icon_info_get_type ())
-#define RYGEL_ICON_INFO(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_ICON_INFO, RygelIconInfo))
-#define RYGEL_ICON_INFO_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_ICON_INFO, RygelIconInfoClass))
-#define RYGEL_IS_ICON_INFO(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_ICON_INFO))
-#define RYGEL_IS_ICON_INFO_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_ICON_INFO))
-#define RYGEL_ICON_INFO_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_ICON_INFO, RygelIconInfoClass))
-
-typedef struct _RygelIconInfo RygelIconInfo;
-typedef struct _RygelIconInfoClass RygelIconInfoClass;
-#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
-
-#define RYGEL_TYPE_ROOT_DEVICE (rygel_root_device_get_type ())
-#define RYGEL_ROOT_DEVICE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_ROOT_DEVICE, RygelRootDevice))
-#define RYGEL_ROOT_DEVICE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_ROOT_DEVICE, RygelRootDeviceClass))
-#define RYGEL_IS_ROOT_DEVICE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_ROOT_DEVICE))
-#define RYGEL_IS_ROOT_DEVICE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_ROOT_DEVICE))
-#define RYGEL_ROOT_DEVICE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_ROOT_DEVICE, RygelRootDeviceClass))
-
-typedef struct _RygelRootDevice RygelRootDevice;
-typedef struct _RygelRootDeviceClass RygelRootDeviceClass;
-#define _g_regex_unref0(var) ((var == NULL) ? NULL : (var = (g_regex_unref (var), NULL)))
-typedef struct _RygelResourceInfoPrivate RygelResourceInfoPrivate;
-#define _rygel_resource_info_unref0(var) ((var == NULL) ? NULL : (var = (rygel_resource_info_unref (var), NULL)))
-#define _rygel_icon_info_unref0(var) ((var == NULL) ? NULL : (var = (rygel_icon_info_unref (var), NULL)))
-typedef struct _RygelIconInfoPrivate RygelIconInfoPrivate;
-#define _fclose0(var) ((var == NULL) ? NULL : (var = (fclose (var), NULL)))
-typedef struct _RygelParamSpecRootDeviceFactory RygelParamSpecRootDeviceFactory;
-
-typedef enum  {
-	ROOT_DEVICE_FACTORY_ERROR_XML_PARSE,
-	ROOT_DEVICE_FACTORY_ERROR_PLUGIN_DISABLED
-} RootDeviceFactoryError;
-#define ROOT_DEVICE_FACTORY_ERROR root_device_factory_error_quark ()
-struct _RygelRootDeviceFactory {
-	GTypeInstance parent_instance;
-	volatile int ref_count;
-	RygelRootDeviceFactoryPrivate * priv;
-	GUPnPContext* context;
-};
-
-struct _RygelRootDeviceFactoryClass {
-	GTypeClass parent_class;
-	void (*finalize) (RygelRootDeviceFactory *self);
-};
-
-typedef enum  {
-	RYGEL_LOG_LEVEL_INVALID = 0,
-	RYGEL_LOG_LEVEL_CRITICAL = 1,
-	RYGEL_LOG_LEVEL_ERROR = 2,
-	RYGEL_LOG_LEVEL_WARNING = 3,
-	RYGEL_LOG_LEVEL_INFO = 4,
-	RYGEL_LOG_LEVEL_DEFAULT = 4,
-	RYGEL_LOG_LEVEL_DEBUG = 5
-} RygelLogLevel;
-
-struct _RygelConfigurationIface {
-	GTypeInterface parent_iface;
-	gboolean (*get_upnp_enabled) (RygelConfiguration* self, GError** error);
-	char* (*get_interface) (RygelConfiguration* self, GError** error);
-	gint (*get_port) (RygelConfiguration* self, GError** error);
-	gboolean (*get_transcoding) (RygelConfiguration* self, GError** error);
-	gboolean (*get_mp3_transcoder) (RygelConfiguration* self, GError** error);
-	gboolean (*get_mp2ts_transcoder) (RygelConfiguration* self, GError** error);
-	gboolean (*get_lpcm_transcoder) (RygelConfiguration* self, GError** error);
-	RygelLogLevel (*get_log_level) (RygelConfiguration* self, GError** error);
-	gboolean (*get_enabled) (RygelConfiguration* self, const char* section, GError** error);
-	char* (*get_title) (RygelConfiguration* self, const char* section, GError** error);
-	char* (*get_string) (RygelConfiguration* self, const char* section, const char* key, GError** error);
-	GeeArrayList* (*get_string_list) (RygelConfiguration* self, const char* section, const char* key, GError** error);
-	gint (*get_int) (RygelConfiguration* self, const char* section, const char* key, gint min, gint max, GError** error);
-	GeeArrayList* (*get_int_list) (RygelConfiguration* self, const char* section, const char* key, GError** error);
-	gboolean (*get_bool) (RygelConfiguration* self, const char* section, const char* key, GError** error);
-};
-
-struct _RygelRootDeviceFactoryPrivate {
-	RygelConfiguration* config;
-	char* desc_dir;
-};
-
-struct _RygelPlugin {
-	GUPnPResourceFactory parent_instance;
-	RygelPluginPrivate * priv;
-	char* name;
-	char* title;
-	char* desc_path;
-	GeeArrayList* resource_infos;
-	GeeArrayList* icon_infos;
-};
-
-struct _RygelPluginClass {
-	GUPnPResourceFactoryClass parent_class;
-};
-
-struct _RygelResourceInfo {
-	GTypeInstance parent_instance;
-	volatile int ref_count;
-	RygelResourceInfoPrivate * priv;
-	char* upnp_type;
-	char* upnp_id;
-	char* description_path;
-	GType type;
-};
-
-struct _RygelResourceInfoClass {
-	GTypeClass parent_class;
-	void (*finalize) (RygelResourceInfo *self);
-};
-
-struct _RygelIconInfo {
-	GTypeInstance parent_instance;
-	volatile int ref_count;
-	RygelIconInfoPrivate * priv;
-	char* mime_type;
-	char* path;
-	glong size;
-	gint width;
-	gint height;
-	gint depth;
-};
-
-struct _RygelIconInfoClass {
-	GTypeClass parent_class;
-	void (*finalize) (RygelIconInfo *self);
-};
-
-struct _RygelParamSpecRootDeviceFactory {
-	GParamSpec parent_instance;
-};
-
-
-static gpointer rygel_root_device_factory_parent_class = NULL;
-
-GQuark root_device_factory_error_quark (void);
-gpointer rygel_root_device_factory_ref (gpointer instance);
-void rygel_root_device_factory_unref (gpointer instance);
-GParamSpec* rygel_param_spec_root_device_factory (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
-void rygel_value_set_root_device_factory (GValue* value, gpointer v_object);
-gpointer rygel_value_get_root_device_factory (const GValue* value);
-GType rygel_root_device_factory_get_type (void);
-GType rygel_log_level_get_type (void);
-GType rygel_configuration_get_type (void);
-#define RYGEL_ROOT_DEVICE_FACTORY_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), RYGEL_TYPE_ROOT_DEVICE_FACTORY, RygelRootDeviceFactoryPrivate))
-enum  {
-	RYGEL_ROOT_DEVICE_FACTORY_DUMMY_PROPERTY
-};
-GType rygel_meta_config_get_type (void);
-RygelMetaConfig* rygel_meta_config_get_default (void);
-static void rygel_root_device_factory_ensure_dir_exists (RygelRootDeviceFactory* self, const char* dir_path, GError** error);
-RygelRootDeviceFactory* rygel_root_device_factory_new (GUPnPContext* context, GError** error);
-RygelRootDeviceFactory* rygel_root_device_factory_construct (GType object_type, GUPnPContext* context, GError** error);
-gboolean rygel_configuration_get_enabled (RygelConfiguration* self, const char* section, GError** error);
-GType rygel_plugin_get_type (void);
-gpointer rygel_resource_info_ref (gpointer instance);
-void rygel_resource_info_unref (gpointer instance);
-GParamSpec* rygel_param_spec_resource_info (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
-void rygel_value_set_resource_info (GValue* value, gpointer v_object);
-gpointer rygel_value_get_resource_info (const GValue* value);
-GType rygel_resource_info_get_type (void);
-gpointer rygel_icon_info_ref (gpointer instance);
-void rygel_icon_info_unref (gpointer instance);
-GParamSpec* rygel_param_spec_icon_info (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
-void rygel_value_set_icon_info (GValue* value, gpointer v_object);
-gpointer rygel_value_get_icon_info (const GValue* value);
-GType rygel_icon_info_get_type (void);
-static GUPnPXMLDoc* rygel_root_device_factory_create_desc (RygelRootDeviceFactory* self, RygelPlugin* plugin, const char* desc_path, GError** error);
-RygelRootDevice* rygel_root_device_new (GUPnPContext* context, RygelPlugin* plugin, GUPnPXMLDoc* description_doc, const char* description_path, const char* description_dir);
-RygelRootDevice* rygel_root_device_construct (GType object_type, GUPnPContext* context, RygelPlugin* plugin, GUPnPXMLDoc* description_doc, const char* description_path, const char* description_dir);
-GType rygel_root_device_get_type (void);
-RygelRootDevice* rygel_root_device_factory_create (RygelRootDeviceFactory* self, RygelPlugin* plugin, GError** error);
-static gboolean rygel_root_device_factory_check_path_exist (RygelRootDeviceFactory* self, const char* path);
-static void rygel_root_device_factory_prepare_desc_for_plugin (RygelRootDeviceFactory* self, GUPnPXMLDoc* doc, RygelPlugin* plugin);
-static void rygel_root_device_factory_save_modified_desc (RygelRootDeviceFactory* self, GUPnPXMLDoc* doc, const char* desc_path, GError** error);
-static void rygel_root_device_factory_set_friendly_name_and_udn (RygelRootDeviceFactory* self, xmlNode* device_element, const char* plugin_name, const char* plugin_title);
-static void rygel_root_device_factory_add_icons_to_desc (RygelRootDeviceFactory* self, xmlNode* device_element, RygelPlugin* plugin);
-static void rygel_root_device_factory_add_services_to_desc (RygelRootDeviceFactory* self, xmlNode* device_element, RygelPlugin* plugin);
-char* rygel_configuration_get_title (RygelConfiguration* self, const char* section, GError** error);
-static void rygel_root_device_factory_add_service_to_desc (RygelRootDeviceFactory* self, xmlNode* service_list_node, const char* plugin_name, RygelResourceInfo* resource_info);
-static void rygel_root_device_factory_add_icon_to_desc (RygelRootDeviceFactory* self, xmlNode* icon_list_node, RygelIconInfo* icon_info, RygelPlugin* plugin);
-static void rygel_root_device_factory_finalize (RygelRootDeviceFactory* obj);
-static int _vala_strcmp0 (const char * str1, const char * str2);
-
-
-
-GQuark root_device_factory_error_quark (void) {
-	return g_quark_from_static_string ("root_device_factory_error-quark");
-}
-
-
-static gpointer _g_object_ref0 (gpointer self) {
-	return self ? g_object_ref (self) : NULL;
-}
-
-
-RygelRootDeviceFactory* rygel_root_device_factory_construct (GType object_type, GUPnPContext* context, GError** error) {
-	GError * _inner_error_;
-	RygelRootDeviceFactory* self;
-	RygelConfiguration* _tmp0_;
-	GUPnPContext* _tmp1_;
-	char* _tmp2_;
-	g_return_val_if_fail (context != NULL, NULL);
-	_inner_error_ = NULL;
-	self = (RygelRootDeviceFactory*) g_type_create_instance (object_type);
-	self->priv->config = (_tmp0_ = (RygelConfiguration*) rygel_meta_config_get_default (), _g_object_unref0 (self->priv->config), _tmp0_);
-	self->context = (_tmp1_ = _g_object_ref0 (context), _g_object_unref0 (self->context), _tmp1_);
-	self->priv->desc_dir = (_tmp2_ = g_build_filename (g_get_user_config_dir (), "Rygel", NULL), _g_free0 (self->priv->desc_dir), _tmp2_);
-	rygel_root_device_factory_ensure_dir_exists (self, self->priv->desc_dir, &_inner_error_);
-	if (_inner_error_ != NULL) {
-		g_propagate_error (error, _inner_error_);
-		return;
-	}
-	return self;
-}
-
-
-RygelRootDeviceFactory* rygel_root_device_factory_new (GUPnPContext* context, GError** error) {
-	return rygel_root_device_factory_construct (RYGEL_TYPE_ROOT_DEVICE_FACTORY, context, error);
-}
-
-
-RygelRootDevice* rygel_root_device_factory_create (RygelRootDeviceFactory* self, RygelPlugin* plugin, GError** error) {
-	RygelRootDevice* result;
-	GError * _inner_error_;
-	gboolean enabled;
-	char* modified_desc;
-	char* desc_path;
-	GUPnPXMLDoc* doc;
-	g_return_val_if_fail (self != NULL, NULL);
-	g_return_val_if_fail (plugin != NULL, NULL);
-	_inner_error_ = NULL;
-	enabled = TRUE;
-	{
-		gboolean _tmp0_;
-		_tmp0_ = rygel_configuration_get_enabled (self->priv->config, plugin->name, &_inner_error_);
-		if (_inner_error_ != NULL) {
-			goto __catch47_g_error;
-			goto __finally47;
-		}
-		enabled = _tmp0_;
-	}
-	goto __finally47;
-	__catch47_g_error:
-	{
-		GError * err;
-		err = _inner_error_;
-		_inner_error_ = NULL;
-		{
-			_g_error_free0 (err);
-		}
-	}
-	__finally47:
-	if (_inner_error_ != NULL) {
-		g_propagate_error (error, _inner_error_);
-		return NULL;
-	}
-	if (!enabled) {
-		_inner_error_ = g_error_new_literal (ROOT_DEVICE_FACTORY_ERROR, ROOT_DEVICE_FACTORY_ERROR_PLUGIN_DISABLED, "Plugin disabled in user configuration.");
-		if (_inner_error_ != NULL) {
-			g_propagate_error (error, _inner_error_);
-			return NULL;
-		}
-	}
-	modified_desc = g_strconcat (plugin->name, ".xml", NULL);
-	desc_path = g_build_filename (self->priv->desc_dir, modified_desc, NULL);
-	doc = rygel_root_device_factory_create_desc (self, plugin, desc_path, &_inner_error_);
-	if (_inner_error_ != NULL) {
-		g_propagate_error (error, _inner_error_);
-		_g_free0 (modified_desc);
-		_g_free0 (desc_path);
-		return NULL;
-	}
-	result = rygel_root_device_new (self->context, plugin, doc, desc_path, DATA_DIR);
-	_g_free0 (modified_desc);
-	_g_free0 (desc_path);
-	_g_object_unref0 (doc);
-	return result;
-}
-
-
-static GUPnPXMLDoc* rygel_root_device_factory_create_desc (RygelRootDeviceFactory* self, RygelPlugin* plugin, const char* desc_path, GError** error) {
-	GUPnPXMLDoc* result;
-	GError * _inner_error_;
-	char* path;
-	GUPnPXMLDoc* doc;
-	g_return_val_if_fail (self != NULL, NULL);
-	g_return_val_if_fail (plugin != NULL, NULL);
-	g_return_val_if_fail (desc_path != NULL, NULL);
-	_inner_error_ = NULL;
-	path = NULL;
-	if (rygel_root_device_factory_check_path_exist (self, desc_path)) {
-		char* _tmp0_;
-		path = (_tmp0_ = g_strdup (desc_path), _g_free0 (path), _tmp0_);
-	} else {
-		char* _tmp1_;
-		path = (_tmp1_ = g_strdup (plugin->desc_path), _g_free0 (path), _tmp1_);
-	}
-	doc = gupnp_xml_doc_new_from_path (path, &_inner_error_);
-	if (_inner_error_ != NULL) {
-		g_propagate_error (error, _inner_error_);
-		_g_free0 (path);
-		return NULL;
-	}
-	rygel_root_device_factory_prepare_desc_for_plugin (self, doc, plugin);
-	rygel_root_device_factory_save_modified_desc (self, doc, desc_path, &_inner_error_);
-	if (_inner_error_ != NULL) {
-		g_propagate_error (error, _inner_error_);
-		_g_free0 (path);
-		_g_object_unref0 (doc);
-		return NULL;
-	}
-	result = doc;
-	_g_free0 (path);
-	return result;
-}
-
-
-static void rygel_root_device_factory_prepare_desc_for_plugin (RygelRootDeviceFactory* self, GUPnPXMLDoc* doc, RygelPlugin* plugin) {
-	xmlNode* device_element = NULL;
-	g_return_if_fail (self != NULL);
-	g_return_if_fail (doc != NULL);
-	g_return_if_fail (plugin != NULL);
-	device_element = get_xml_element ((xmlNode*) doc->doc, "root", "device", NULL, NULL);
-	if (device_element == NULL) {
-		g_warning ("rygel-root-device-factory.vala:108: Element /root/device not found.");
-		return;
-	}
-	rygel_root_device_factory_set_friendly_name_and_udn (self, device_element, plugin->name, plugin->title);
-	rygel_root_device_factory_add_icons_to_desc (self, device_element, plugin);
-	rygel_root_device_factory_add_services_to_desc (self, device_element, plugin);
-}
-
-
-static char* string_replace (const char* self, const char* old, const char* replacement) {
-	char* result;
-	GError * _inner_error_;
-	g_return_val_if_fail (self != NULL, NULL);
-	g_return_val_if_fail (old != NULL, NULL);
-	g_return_val_if_fail (replacement != NULL, NULL);
-	_inner_error_ = NULL;
-	{
-		char* _tmp0_;
-		GRegex* _tmp1_;
-		GRegex* regex;
-		char* _tmp2_;
-		regex = (_tmp1_ = g_regex_new (_tmp0_ = g_regex_escape_string (old, -1), 0, 0, &_inner_error_), _g_free0 (_tmp0_), _tmp1_);
-		if (_inner_error_ != NULL) {
-			if (_inner_error_->domain == G_REGEX_ERROR) {
-				goto __catch49_g_regex_error;
-			}
-			goto __finally49;
-		}
-		_tmp2_ = g_regex_replace_literal (regex, self, (glong) (-1), 0, replacement, 0, &_inner_error_);
-		if (_inner_error_ != NULL) {
-			_g_regex_unref0 (regex);
-			if (_inner_error_->domain == G_REGEX_ERROR) {
-				goto __catch49_g_regex_error;
-			}
-			goto __finally49;
-		}
-		result = _tmp2_;
-		_g_regex_unref0 (regex);
-		return result;
-	}
-	goto __finally49;
-	__catch49_g_regex_error:
-	{
-		GError * e;
-		e = _inner_error_;
-		_inner_error_ = NULL;
-		{
-			g_assert_not_reached ();
-			_g_error_free0 (e);
-		}
-	}
-	__finally49:
-	if (_inner_error_ != NULL) {
-		g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
-		g_clear_error (&_inner_error_);
-		return NULL;
-	}
-}
-
-
-static void rygel_root_device_factory_set_friendly_name_and_udn (RygelRootDeviceFactory* self, xmlNode* device_element, const char* plugin_name, const char* plugin_title) {
-	GError * _inner_error_;
-	xmlNode* element;
-	char* title;
-	char* _tmp3_;
-	char* _tmp4_;
-	char* _tmp5_;
-	char* udn;
-	gboolean _tmp6_ = FALSE;
-	g_return_if_fail (self != NULL);
-	g_return_if_fail (plugin_name != NULL);
-	g_return_if_fail (plugin_title != NULL);
-	_inner_error_ = NULL;
-	element = get_xml_element (device_element, "friendlyName", NULL, NULL);
-	if (element == NULL) {
-		g_warning ("rygel-root-device-factory.vala:137: Element /root/device/friendlyName not found.");
-		return;
-	}
-	title = NULL;
-	{
-		char* _tmp0_;
-		char* _tmp1_;
-		_tmp0_ = rygel_configuration_get_title (self->priv->config, plugin_name, &_inner_error_);
-		if (_inner_error_ != NULL) {
-			goto __catch48_g_error;
-			goto __finally48;
-		}
-		title = (_tmp1_ = _tmp0_, _g_free0 (title), _tmp1_);
-	}
-	goto __finally48;
-	__catch48_g_error:
-	{
-		GError * err;
-		err = _inner_error_;
-		_inner_error_ = NULL;
-		{
-			char* _tmp2_;
-			title = (_tmp2_ = g_strdup (plugin_title), _g_free0 (title), _tmp2_);
-			_g_error_free0 (err);
-		}
-	}
-	__finally48:
-	if (_inner_error_ != NULL) {
-		_g_free0 (title);
-		g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
-		g_clear_error (&_inner_error_);
-		return;
-	}
-	title = (_tmp3_ = string_replace (title, "@REALNAME@", g_get_real_name ()), _g_free0 (title), _tmp3_);
-	title = (_tmp4_ = string_replace (title, "@USERNAME@", g_get_user_name ()), _g_free0 (title), _tmp4_);
-	title = (_tmp5_ = string_replace (title, "@HOSTNAME@", g_get_host_name ()), _g_free0 (title), _tmp5_);
-	xmlNodeSetContent (element, title);
-	element = get_xml_element (device_element, "UDN", NULL);
-	if (element == NULL) {
-		g_warning ("rygel-root-device-factory.vala:158: Element /root/device/UDN not found.");
-		_g_free0 (title);
-		return;
-	}
-	udn = xmlNodeGetContent (element);
-	if (udn == NULL) {
-		_tmp6_ = TRUE;
-	} else {
-		_tmp6_ = _vala_strcmp0 (udn, "") == 0;
-	}
-	if (_tmp6_) {
-		char* _tmp7_;
-		udn = (_tmp7_ = generate_random_udn (), _g_free0 (udn), _tmp7_);
-		xmlNodeSetContent (element, udn);
-	}
-	_g_free0 (title);
-	_g_free0 (udn);
-}
-
-
-static void rygel_root_device_factory_add_services_to_desc (RygelRootDeviceFactory* self, xmlNode* device_element, RygelPlugin* plugin) {
-	xmlNode* service_list_node;
-	g_return_if_fail (self != NULL);
-	g_return_if_fail (plugin != NULL);
-	service_list_node = get_xml_element (device_element, "serviceList", NULL, NULL);
-	if (service_list_node == NULL) {
-		g_warning ("rygel-root-device-factory.vala:177: Element /root/device/serviceList not found.");
-		return;
-	}
-	xmlNodeSetContent (service_list_node, "");
-	{
-		GeeIterator* _resource_info_it;
-		_resource_info_it = gee_abstract_collection_iterator ((GeeAbstractCollection*) plugin->resource_infos);
-		while (TRUE) {
-			RygelResourceInfo* resource_info;
-			if (!gee_iterator_next (_resource_info_it)) {
-				break;
-			}
-			resource_info = (RygelResourceInfo*) gee_iterator_get (_resource_info_it);
-			if (g_type_is_a (resource_info->type, GUPNP_TYPE_SERVICE)) {
-				rygel_root_device_factory_add_service_to_desc (self, service_list_node, plugin->name, resource_info);
-			}
-			_rygel_resource_info_unref0 (resource_info);
-		}
-		_g_object_unref0 (_resource_info_it);
-	}
-}
-
-
-static void rygel_root_device_factory_add_service_to_desc (RygelRootDeviceFactory* self, xmlNode* service_list_node, const char* plugin_name, RygelResourceInfo* resource_info) {
-	xmlNode* service_node;
-	char* url;
-	char* _tmp2_;
-	char* _tmp1_;
-	char* _tmp0_;
-	char* _tmp5_;
-	char* _tmp4_;
-	char* _tmp3_;
-	g_return_if_fail (self != NULL);
-	g_return_if_fail (plugin_name != NULL);
-	g_return_if_fail (resource_info != NULL);
-	service_node = xmlNewChild (service_list_node, NULL, "service", NULL);
-	xmlNewChild (service_node, NULL, "serviceType", resource_info->upnp_type);
-	xmlNewChild (service_node, NULL, "serviceId", resource_info->upnp_id);
-	url = g_strdup (resource_info->description_path);
-	xmlNewChild (service_node, NULL, "SCPDURL", url);
-	url = (_tmp2_ = g_strconcat (_tmp1_ = g_strconcat (_tmp0_ = g_strconcat (plugin_name, "/", NULL), g_type_name (resource_info->type), NULL), "/Event", NULL), _g_free0 (url), _tmp2_);
-	_g_free0 (_tmp1_);
-	_g_free0 (_tmp0_);
-	xmlNewChild (service_node, NULL, "eventSubURL", url);
-	url = (_tmp5_ = g_strconcat (_tmp4_ = g_strconcat (_tmp3_ = g_strconcat (plugin_name, "/", NULL), g_type_name (resource_info->type), NULL), "/Control", NULL), _g_free0 (url), _tmp5_);
-	_g_free0 (_tmp4_);
-	_g_free0 (_tmp3_);
-	xmlNewChild (service_node, NULL, "controlURL", url);
-	_g_free0 (url);
-}
-
-
-static void rygel_root_device_factory_add_icons_to_desc (RygelRootDeviceFactory* self, xmlNode* device_element, RygelPlugin* plugin) {
-	gboolean _tmp0_ = FALSE;
-	xmlNode* icon_list_node;
-	g_return_if_fail (self != NULL);
-	g_return_if_fail (plugin != NULL);
-	if (plugin->icon_infos == NULL) {
-		_tmp0_ = TRUE;
-	} else {
-		_tmp0_ = gee_collection_get_size ((GeeCollection*) plugin->icon_infos) == 0;
-	}
-	if (_tmp0_) {
-		g_debug ("rygel-root-device-factory.vala:218: No icon provided by %s.", plugin->name);
-		return;
-	}
-	icon_list_node = get_xml_element (device_element, "iconList", NULL, NULL);
-	if (icon_list_node == NULL) {
-		icon_list_node = xmlNewChild (device_element, NULL, "iconList", NULL);
-	} else {
-		xmlNodeSetContent (icon_list_node, "");
-	}
-	{
-		GeeIterator* _icon_info_it;
-		_icon_info_it = gee_abstract_collection_iterator ((GeeAbstractCollection*) plugin->icon_infos);
-		while (TRUE) {
-			RygelIconInfo* icon_info;
-			if (!gee_iterator_next (_icon_info_it)) {
-				break;
-			}
-			icon_info = (RygelIconInfo*) gee_iterator_get (_icon_info_it);
-			rygel_root_device_factory_add_icon_to_desc (self, icon_list_node, icon_info, plugin);
-			_rygel_icon_info_unref0 (icon_info);
-		}
-		_g_object_unref0 (_icon_info_it);
-	}
-}
-
-
-static void rygel_root_device_factory_add_icon_to_desc (RygelRootDeviceFactory* self, xmlNode* icon_list_node, RygelIconInfo* icon_info, RygelPlugin* plugin) {
-	xmlNode* icon_node;
-	char* width;
-	char* height;
-	char* depth;
-	char* _tmp5_;
-	char* _tmp4_;
-	char* _tmp3_;
-	char* _tmp2_;
-	char* _tmp1_;
-	char* _tmp0_;
-	char* _tmp6_;
-	char* url;
-	char* _tmp7_;
-	g_return_if_fail (self != NULL);
-	g_return_if_fail (icon_info != NULL);
-	g_return_if_fail (plugin != NULL);
-	icon_node = xmlNewChild (icon_list_node, NULL, "icon", NULL);
-	width = g_strdup_printf ("%i", icon_info->width);
-	height = g_strdup_printf ("%i", icon_info->height);
-	depth = g_strdup_printf ("%i", icon_info->depth);
-	xmlNewChild (icon_node, NULL, "mimetype", icon_info->mime_type);
-	xmlNewChild (icon_node, NULL, "width", width);
-	xmlNewChild (icon_node, NULL, "height", height);
-	xmlNewChild (icon_node, NULL, "depth", depth);
-	url = (_tmp6_ = g_strconcat (_tmp5_ = g_strconcat (_tmp4_ = g_strconcat (_tmp3_ = g_strconcat (_tmp2_ = g_strconcat (_tmp1_ = g_strconcat (_tmp0_ = g_strconcat (plugin->name, "-", NULL), width, NULL), "x", NULL), height, NULL), "x", NULL), depth, NULL), ".png", NULL), _g_free0 (_tmp5_), _g_free0 (_tmp4_), _g_free0 (_tmp3_), _g_free0 (_tmp2_), _g_free0 (_tmp1_), _g_free0 (_tmp0_), _tmp6_);
-	gupnp_context_host_path (self->context, icon_info->path, _tmp7_ = g_strconcat ("/", url, NULL));
-	_g_free0 (_tmp7_);
-	xmlNewChild (icon_node, NULL, "url", url);
-	_g_free0 (width);
-	_g_free0 (height);
-	_g_free0 (depth);
-	_g_free0 (url);
-}
-
-
-static void rygel_root_device_factory_save_modified_desc (RygelRootDeviceFactory* self, GUPnPXMLDoc* doc, const char* desc_path, GError** error) {
-	GError * _inner_error_;
-	FILE* f;
-	gint res;
-	gboolean _tmp0_ = FALSE;
-	g_return_if_fail (self != NULL);
-	g_return_if_fail (doc != NULL);
-	g_return_if_fail (desc_path != NULL);
-	_inner_error_ = NULL;
-	f = fopen (desc_path, "w+");
-	res = -1;
-	if (f != NULL) {
-		res = xmlDocDump (f, doc->doc);
-	}
-	if (f == NULL) {
-		_tmp0_ = TRUE;
-	} else {
-		_tmp0_ = res == (-1);
-	}
-	if (_tmp0_) {
-		char* _tmp1_;
-		char* _tmp2_;
-		char* message;
-		message = (_tmp2_ = g_strconcat ("Failed to write modified description", _tmp1_ = g_strdup_printf (" to %s.\n", desc_path), NULL), _g_free0 (_tmp1_), _tmp2_);
-		_inner_error_ = g_error_new_literal (G_IO_ERROR, G_IO_ERROR_FAILED, message);
-		if (_inner_error_ != NULL) {
-			g_propagate_error (error, _inner_error_);
-			_g_free0 (message);
-			_fclose0 (f);
-			return;
-		}
-		_g_free0 (message);
-	}
-	_fclose0 (f);
-}
-
-
-static gboolean rygel_root_device_factory_check_path_exist (RygelRootDeviceFactory* self, const char* path) {
-	gboolean result;
-	GFile* file;
-	g_return_val_if_fail (self != NULL, FALSE);
-	g_return_val_if_fail (path != NULL, FALSE);
-	file = g_file_new_for_path (path);
-	result = g_file_query_exists (file, NULL);
-	_g_object_unref0 (file);
-	return result;
-}
-
-
-static void rygel_root_device_factory_ensure_dir_exists (RygelRootDeviceFactory* self, const char* dir_path, GError** error) {
-	GError * _inner_error_;
-	g_return_if_fail (self != NULL);
-	g_return_if_fail (dir_path != NULL);
-	_inner_error_ = NULL;
-	if (!rygel_root_device_factory_check_path_exist (self, dir_path)) {
-		GFile* file;
-		file = g_file_new_for_path (dir_path);
-		g_file_make_directory (file, NULL, &_inner_error_);
-		if (_inner_error_ != NULL) {
-			g_propagate_error (error, _inner_error_);
-			_g_object_unref0 (file);
-			return;
-		}
-		_g_object_unref0 (file);
-	}
-}
-
-
-static void rygel_value_root_device_factory_init (GValue* value) {
-	value->data[0].v_pointer = NULL;
-}
-
-
-static void rygel_value_root_device_factory_free_value (GValue* value) {
-	if (value->data[0].v_pointer) {
-		rygel_root_device_factory_unref (value->data[0].v_pointer);
-	}
-}
-
-
-static void rygel_value_root_device_factory_copy_value (const GValue* src_value, GValue* dest_value) {
-	if (src_value->data[0].v_pointer) {
-		dest_value->data[0].v_pointer = rygel_root_device_factory_ref (src_value->data[0].v_pointer);
-	} else {
-		dest_value->data[0].v_pointer = NULL;
-	}
-}
-
-
-static gpointer rygel_value_root_device_factory_peek_pointer (const GValue* value) {
-	return value->data[0].v_pointer;
-}
-
-
-static gchar* rygel_value_root_device_factory_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
-	if (collect_values[0].v_pointer) {
-		RygelRootDeviceFactory* object;
-		object = collect_values[0].v_pointer;
-		if (object->parent_instance.g_class == NULL) {
-			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
-		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
-			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
-		}
-		value->data[0].v_pointer = rygel_root_device_factory_ref (object);
-	} else {
-		value->data[0].v_pointer = NULL;
-	}
-	return NULL;
-}
-
-
-static gchar* rygel_value_root_device_factory_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
-	RygelRootDeviceFactory** object_p;
-	object_p = collect_values[0].v_pointer;
-	if (!object_p) {
-		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
-	}
-	if (!value->data[0].v_pointer) {
-		*object_p = NULL;
-	} else if (collect_flags && G_VALUE_NOCOPY_CONTENTS) {
-		*object_p = value->data[0].v_pointer;
-	} else {
-		*object_p = rygel_root_device_factory_ref (value->data[0].v_pointer);
-	}
-	return NULL;
-}
-
-
-GParamSpec* rygel_param_spec_root_device_factory (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
-	RygelParamSpecRootDeviceFactory* spec;
-	g_return_val_if_fail (g_type_is_a (object_type, RYGEL_TYPE_ROOT_DEVICE_FACTORY), NULL);
-	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
-	G_PARAM_SPEC (spec)->value_type = object_type;
-	return G_PARAM_SPEC (spec);
-}
-
-
-gpointer rygel_value_get_root_device_factory (const GValue* value) {
-	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, RYGEL_TYPE_ROOT_DEVICE_FACTORY), NULL);
-	return value->data[0].v_pointer;
-}
-
-
-void rygel_value_set_root_device_factory (GValue* value, gpointer v_object) {
-	RygelRootDeviceFactory* old;
-	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, RYGEL_TYPE_ROOT_DEVICE_FACTORY));
-	old = value->data[0].v_pointer;
-	if (v_object) {
-		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, RYGEL_TYPE_ROOT_DEVICE_FACTORY));
-		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
-		value->data[0].v_pointer = v_object;
-		rygel_root_device_factory_ref (value->data[0].v_pointer);
-	} else {
-		value->data[0].v_pointer = NULL;
-	}
-	if (old) {
-		rygel_root_device_factory_unref (old);
-	}
-}
-
-
-static void rygel_root_device_factory_class_init (RygelRootDeviceFactoryClass * klass) {
-	rygel_root_device_factory_parent_class = g_type_class_peek_parent (klass);
-	RYGEL_ROOT_DEVICE_FACTORY_CLASS (klass)->finalize = rygel_root_device_factory_finalize;
-	g_type_class_add_private (klass, sizeof (RygelRootDeviceFactoryPrivate));
-}
-
-
-static void rygel_root_device_factory_instance_init (RygelRootDeviceFactory * self) {
-	self->priv = RYGEL_ROOT_DEVICE_FACTORY_GET_PRIVATE (self);
-	self->ref_count = 1;
-}
-
-
-static void rygel_root_device_factory_finalize (RygelRootDeviceFactory* obj) {
-	RygelRootDeviceFactory * self;
-	self = RYGEL_ROOT_DEVICE_FACTORY (obj);
-	_g_object_unref0 (self->context);
-	_g_object_unref0 (self->priv->config);
-	_g_free0 (self->priv->desc_dir);
-}
-
-
-GType rygel_root_device_factory_get_type (void) {
-	static GType rygel_root_device_factory_type_id = 0;
-	if (rygel_root_device_factory_type_id == 0) {
-		static const GTypeValueTable g_define_type_value_table = { rygel_value_root_device_factory_init, rygel_value_root_device_factory_free_value, rygel_value_root_device_factory_copy_value, rygel_value_root_device_factory_peek_pointer, "p", rygel_value_root_device_factory_collect_value, "p", rygel_value_root_device_factory_lcopy_value };
-		static const GTypeInfo g_define_type_info = { sizeof (RygelRootDeviceFactoryClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) rygel_root_device_factory_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (RygelRootDeviceFactory), 0, (GInstanceInitFunc) rygel_root_device_factory_instance_init, &g_define_type_value_table };
-		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
-		rygel_root_device_factory_type_id = g_type_register_fundamental (g_type_fundamental_next (), "RygelRootDeviceFactory", &g_define_type_info, &g_define_type_fundamental_info, 0);
-	}
-	return rygel_root_device_factory_type_id;
-}
-
-
-gpointer rygel_root_device_factory_ref (gpointer instance) {
-	RygelRootDeviceFactory* self;
-	self = instance;
-	g_atomic_int_inc (&self->ref_count);
-	return instance;
-}
-
-
-void rygel_root_device_factory_unref (gpointer instance) {
-	RygelRootDeviceFactory* self;
-	self = instance;
-	if (g_atomic_int_dec_and_test (&self->ref_count)) {
-		RYGEL_ROOT_DEVICE_FACTORY_GET_CLASS (self)->finalize (self);
-		g_type_free_instance ((GTypeInstance *) self);
-	}
-}
-
-
-static int _vala_strcmp0 (const char * str1, const char * str2) {
-	if (str1 == NULL) {
-		return -(str1 != str2);
-	}
-	if (str2 == NULL) {
-		return str1 != str2;
-	}
-	return strcmp (str1, str2);
-}
-
-
-
-
--- a/src/rygel/rygel-root-device.c
+++ /dev/null
@@ -1,245 +0,0 @@
-/* rygel-root-device.c generated by valac, the Vala compiler
- * generated from rygel-root-device.vala, do not modify */
-
-/*
- * Copyright (C) 2008 Nokia Corporation.
- * Copyright (C) 2008 Zeeshan Ali (Khattak) <zeeshanak@gnome.org>.
- *
- * Author: Zeeshan Ali (Khattak) <zeeshanak@gnome.org>
- *
- * This file is part of Rygel.
- *
- * Rygel is free software; you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * Rygel is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this program; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
- */
-
-#include <glib.h>
-#include <glib-object.h>
-#include <libgupnp/gupnp.h>
-#include <gee.h>
-#include <stdlib.h>
-#include <string.h>
-
-
-#define RYGEL_TYPE_ROOT_DEVICE (rygel_root_device_get_type ())
-#define RYGEL_ROOT_DEVICE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_ROOT_DEVICE, RygelRootDevice))
-#define RYGEL_ROOT_DEVICE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_ROOT_DEVICE, RygelRootDeviceClass))
-#define RYGEL_IS_ROOT_DEVICE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_ROOT_DEVICE))
-#define RYGEL_IS_ROOT_DEVICE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_ROOT_DEVICE))
-#define RYGEL_ROOT_DEVICE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_ROOT_DEVICE, RygelRootDeviceClass))
-
-typedef struct _RygelRootDevice RygelRootDevice;
-typedef struct _RygelRootDeviceClass RygelRootDeviceClass;
-typedef struct _RygelRootDevicePrivate RygelRootDevicePrivate;
-#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
-
-#define RYGEL_TYPE_PLUGIN (rygel_plugin_get_type ())
-#define RYGEL_PLUGIN(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_PLUGIN, RygelPlugin))
-#define RYGEL_PLUGIN_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_PLUGIN, RygelPluginClass))
-#define RYGEL_IS_PLUGIN(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_PLUGIN))
-#define RYGEL_IS_PLUGIN_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_PLUGIN))
-#define RYGEL_PLUGIN_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_PLUGIN, RygelPluginClass))
-
-typedef struct _RygelPlugin RygelPlugin;
-typedef struct _RygelPluginClass RygelPluginClass;
-typedef struct _RygelPluginPrivate RygelPluginPrivate;
-
-#define RYGEL_TYPE_RESOURCE_INFO (rygel_resource_info_get_type ())
-#define RYGEL_RESOURCE_INFO(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_RESOURCE_INFO, RygelResourceInfo))
-#define RYGEL_RESOURCE_INFO_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_RESOURCE_INFO, RygelResourceInfoClass))
-#define RYGEL_IS_RESOURCE_INFO(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_RESOURCE_INFO))
-#define RYGEL_IS_RESOURCE_INFO_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_RESOURCE_INFO))
-#define RYGEL_RESOURCE_INFO_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_RESOURCE_INFO, RygelResourceInfoClass))
-
-typedef struct _RygelResourceInfo RygelResourceInfo;
-typedef struct _RygelResourceInfoClass RygelResourceInfoClass;
-
-#define RYGEL_TYPE_ICON_INFO (rygel_icon_info_get_type ())
-#define RYGEL_ICON_INFO(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_ICON_INFO, RygelIconInfo))
-#define RYGEL_ICON_INFO_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_ICON_INFO, RygelIconInfoClass))
-#define RYGEL_IS_ICON_INFO(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_ICON_INFO))
-#define RYGEL_IS_ICON_INFO_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_ICON_INFO))
-#define RYGEL_ICON_INFO_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_ICON_INFO, RygelIconInfoClass))
-
-typedef struct _RygelIconInfo RygelIconInfo;
-typedef struct _RygelIconInfoClass RygelIconInfoClass;
-typedef struct _RygelResourceInfoPrivate RygelResourceInfoPrivate;
-#define _rygel_resource_info_unref0(var) ((var == NULL) ? NULL : (var = (rygel_resource_info_unref (var), NULL)))
-
-struct _RygelRootDevice {
-	GUPnPRootDevice parent_instance;
-	RygelRootDevicePrivate * priv;
-	GeeArrayList* services;
-};
-
-struct _RygelRootDeviceClass {
-	GUPnPRootDeviceClass parent_class;
-};
-
-struct _RygelPlugin {
-	GUPnPResourceFactory parent_instance;
-	RygelPluginPrivate * priv;
-	char* name;
-	char* title;
-	char* desc_path;
-	GeeArrayList* resource_infos;
-	GeeArrayList* icon_infos;
-};
-
-struct _RygelPluginClass {
-	GUPnPResourceFactoryClass parent_class;
-};
-
-struct _RygelResourceInfo {
-	GTypeInstance parent_instance;
-	volatile int ref_count;
-	RygelResourceInfoPrivate * priv;
-	char* upnp_type;
-	char* upnp_id;
-	char* description_path;
-	GType type;
-};
-
-struct _RygelResourceInfoClass {
-	GTypeClass parent_class;
-	void (*finalize) (RygelResourceInfo *self);
-};
-
-
-static gpointer rygel_root_device_parent_class = NULL;
-
-GType rygel_root_device_get_type (void);
-enum  {
-	RYGEL_ROOT_DEVICE_DUMMY_PROPERTY
-};
-GType rygel_plugin_get_type (void);
-gpointer rygel_resource_info_ref (gpointer instance);
-void rygel_resource_info_unref (gpointer instance);
-GParamSpec* rygel_param_spec_resource_info (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
-void rygel_value_set_resource_info (GValue* value, gpointer v_object);
-gpointer rygel_value_get_resource_info (const GValue* value);
-GType rygel_resource_info_get_type (void);
-gpointer rygel_icon_info_ref (gpointer instance);
-void rygel_icon_info_unref (gpointer instance);
-GParamSpec* rygel_param_spec_icon_info (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
-void rygel_value_set_icon_info (GValue* value, gpointer v_object);
-gpointer rygel_value_get_icon_info (const GValue* value);
-GType rygel_icon_info_get_type (void);
-RygelRootDevice* rygel_root_device_new (GUPnPContext* context, RygelPlugin* plugin, GUPnPXMLDoc* description_doc, const char* description_path, const char* description_dir);
-RygelRootDevice* rygel_root_device_construct (GType object_type, GUPnPContext* context, RygelPlugin* plugin, GUPnPXMLDoc* description_doc, const char* description_path, const char* description_dir);
-static void rygel_root_device_finalize (GObject* obj);
-
-
-
-RygelRootDevice* rygel_root_device_construct (GType object_type, GUPnPContext* context, RygelPlugin* plugin, GUPnPXMLDoc* description_doc, const char* description_path, const char* description_dir) {
-	GParameter * __params;
-	GParameter * __params_it;
-	RygelRootDevice * self;
-	GeeArrayList* _tmp0_;
-	g_return_val_if_fail (context != NULL, NULL);
-	g_return_val_if_fail (plugin != NULL, NULL);
-	g_return_val_if_fail (description_doc != NULL, NULL);
-	g_return_val_if_fail (description_path != NULL, NULL);
-	g_return_val_if_fail (description_dir != NULL, NULL);
-	__params = g_new0 (GParameter, 6);
-	__params_it = __params;
-	__params_it->name = "resource-factory";
-	g_value_init (&__params_it->value, GUPNP_TYPE_RESOURCE_FACTORY);
-	g_value_set_object (&__params_it->value, (GUPnPResourceFactory*) plugin);
-	__params_it++;
-	__params_it->name = "root-device";
-	g_value_init (&__params_it->value, GUPNP_TYPE_ROOT_DEVICE);
-	g_value_set_object (&__params_it->value, NULL);
-	__params_it++;
-	__params_it->name = "context";
-	g_value_init (&__params_it->value, GUPNP_TYPE_CONTEXT);
-	g_value_set_object (&__params_it->value, context);
-	__params_it++;
-	__params_it->name = "description-doc";
-	g_value_init (&__params_it->value, GUPNP_TYPE_XML_DOC);
-	g_value_set_object (&__params_it->value, description_doc);
-	__params_it++;
-	__params_it->name = "description-path";
-	g_value_init (&__params_it->value, G_TYPE_STRING);
-	g_value_set_string (&__params_it->value, description_path);
-	__params_it++;
-	__params_it->name = "description-dir";
-	g_value_init (&__params_it->value, G_TYPE_STRING);
-	g_value_set_string (&__params_it->value, description_dir);
-	__params_it++;
-	self = g_object_newv (object_type, __params_it - __params, __params);
-	self->services = (_tmp0_ = gee_array_list_new (GUPNP_TYPE_SERVICE_INFO, (GBoxedCopyFunc) g_object_ref, g_object_unref, g_direct_equal), _g_object_unref0 (self->services), _tmp0_);
-	{
-		GeeIterator* _info_it;
-		_info_it = gee_abstract_collection_iterator ((GeeAbstractCollection*) plugin->resource_infos);
-		while (TRUE) {
-			RygelResourceInfo* info;
-			if (!gee_iterator_next (_info_it)) {
-				break;
-			}
-			info = (RygelResourceInfo*) gee_iterator_get (_info_it);
-			if (g_type_is_a (info->type, GUPNP_TYPE_SERVICE)) {
-				GUPnPServiceInfo* service;
-				service = gupnp_device_info_get_service ((GUPnPDeviceInfo*) self, info->upnp_type);
-				gee_abstract_collection_add ((GeeAbstractCollection*) self->services, service);
-				_g_object_unref0 (service);
-			}
-			_rygel_resource_info_unref0 (info);
-		}
-		_g_object_unref0 (_info_it);
-	}
-	while (__params_it > __params) {
-		--__params_it;
-		g_value_unset (&__params_it->value);
-	}
-	g_free (__params);
-	return self;
-}
-
-
-RygelRootDevice* rygel_root_device_new (GUPnPContext* context, RygelPlugin* plugin, GUPnPXMLDoc* description_doc, const char* description_path, const char* description_dir) {
-	return rygel_root_device_construct (RYGEL_TYPE_ROOT_DEVICE, context, plugin, description_doc, description_path, description_dir);
-}
-
-
-static void rygel_root_device_class_init (RygelRootDeviceClass * klass) {
-	rygel_root_device_parent_class = g_type_class_peek_parent (klass);
-	G_OBJECT_CLASS (klass)->finalize = rygel_root_device_finalize;
-}
-
-
-static void rygel_root_device_instance_init (RygelRootDevice * self) {
-}
-
-
-static void rygel_root_device_finalize (GObject* obj) {
-	RygelRootDevice * self;
-	self = RYGEL_ROOT_DEVICE (obj);
-	_g_object_unref0 (self->services);
-	G_OBJECT_CLASS (rygel_root_device_parent_class)->finalize (obj);
-}
-
-
-GType rygel_root_device_get_type (void) {
-	static GType rygel_root_device_type_id = 0;
-	if (rygel_root_device_type_id == 0) {
-		static const GTypeInfo g_define_type_info = { sizeof (RygelRootDeviceClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) rygel_root_device_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (RygelRootDevice), 0, (GInstanceInitFunc) rygel_root_device_instance_init, NULL };
-		rygel_root_device_type_id = g_type_register_static (GUPNP_TYPE_ROOT_DEVICE, "RygelRootDevice", &g_define_type_info, 0);
-	}
-	return rygel_root_device_type_id;
-}
-
-
-
-
--- a/src/rygel/rygel-seekable-response.c
+++ /dev/null
@@ -1,468 +0,0 @@
-/* rygel-seekable-response.c generated by valac, the Vala compiler
- * generated from rygel-seekable-response.vala, do not modify */
-
-/*
- * Copyright (C) 2008 Zeeshan Ali (Khattak) <zeeshanak@gnome.org>.
- * Copyright (C) 2008 Nokia Corporation.
- *
- * Author: Zeeshan Ali (Khattak) <zeeshanak@gnome.org>
- *                               <zeeshan.ali@nokia.com>
- *
- * This file is part of Rygel.
- *
- * Rygel is free software; you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * Rygel is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this program; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
- */
-
-#include <glib.h>
-#include <glib-object.h>
-#include <gio/gio.h>
-#include <libsoup/soup.h>
-#include <stdlib.h>
-#include <string.h>
-
-
-#define RYGEL_TYPE_STATE_MACHINE (rygel_state_machine_get_type ())
-#define RYGEL_STATE_MACHINE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_STATE_MACHINE, RygelStateMachine))
-#define RYGEL_IS_STATE_MACHINE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_STATE_MACHINE))
-#define RYGEL_STATE_MACHINE_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), RYGEL_TYPE_STATE_MACHINE, RygelStateMachineIface))
-
-typedef struct _RygelStateMachine RygelStateMachine;
-typedef struct _RygelStateMachineIface RygelStateMachineIface;
-
-#define RYGEL_TYPE_HTTP_RESPONSE (rygel_http_response_get_type ())
-#define RYGEL_HTTP_RESPONSE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_HTTP_RESPONSE, RygelHTTPResponse))
-#define RYGEL_HTTP_RESPONSE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_HTTP_RESPONSE, RygelHTTPResponseClass))
-#define RYGEL_IS_HTTP_RESPONSE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_HTTP_RESPONSE))
-#define RYGEL_IS_HTTP_RESPONSE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_HTTP_RESPONSE))
-#define RYGEL_HTTP_RESPONSE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_HTTP_RESPONSE, RygelHTTPResponseClass))
-
-typedef struct _RygelHTTPResponse RygelHTTPResponse;
-typedef struct _RygelHTTPResponseClass RygelHTTPResponseClass;
-typedef struct _RygelHTTPResponsePrivate RygelHTTPResponsePrivate;
-
-#define RYGEL_TYPE_SEEKABLE_RESPONSE (rygel_seekable_response_get_type ())
-#define RYGEL_SEEKABLE_RESPONSE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_SEEKABLE_RESPONSE, RygelSeekableResponse))
-#define RYGEL_SEEKABLE_RESPONSE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_SEEKABLE_RESPONSE, RygelSeekableResponseClass))
-#define RYGEL_IS_SEEKABLE_RESPONSE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_SEEKABLE_RESPONSE))
-#define RYGEL_IS_SEEKABLE_RESPONSE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_SEEKABLE_RESPONSE))
-#define RYGEL_SEEKABLE_RESPONSE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_SEEKABLE_RESPONSE, RygelSeekableResponseClass))
-
-typedef struct _RygelSeekableResponse RygelSeekableResponse;
-typedef struct _RygelSeekableResponseClass RygelSeekableResponseClass;
-typedef struct _RygelSeekableResponsePrivate RygelSeekableResponsePrivate;
-
-#define RYGEL_TYPE_HTTP_SEEK (rygel_http_seek_get_type ())
-#define RYGEL_HTTP_SEEK(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_HTTP_SEEK, RygelHTTPSeek))
-#define RYGEL_HTTP_SEEK_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_HTTP_SEEK, RygelHTTPSeekClass))
-#define RYGEL_IS_HTTP_SEEK(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_HTTP_SEEK))
-#define RYGEL_IS_HTTP_SEEK_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_HTTP_SEEK))
-#define RYGEL_HTTP_SEEK_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_HTTP_SEEK, RygelHTTPSeekClass))
-
-typedef struct _RygelHTTPSeek RygelHTTPSeek;
-typedef struct _RygelHTTPSeekClass RygelHTTPSeekClass;
-#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
-#define _g_free0(var) (var = (g_free (var), NULL))
-#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
-
-struct _RygelStateMachineIface {
-	GTypeInterface parent_iface;
-	void (*run) (RygelStateMachine* self);
-	GCancellable* (*get_cancellable) (RygelStateMachine* self);
-	void (*set_cancellable) (RygelStateMachine* self, GCancellable* value);
-};
-
-struct _RygelHTTPResponse {
-	GObject parent_instance;
-	RygelHTTPResponsePrivate * priv;
-	SoupMessage* msg;
-};
-
-struct _RygelHTTPResponseClass {
-	GObjectClass parent_class;
-	void (*run) (RygelHTTPResponse* self);
-	void (*end) (RygelHTTPResponse* self, gboolean aborted, guint status);
-};
-
-struct _RygelSeekableResponse {
-	RygelHTTPResponse parent_instance;
-	RygelSeekableResponsePrivate * priv;
-};
-
-struct _RygelSeekableResponseClass {
-	RygelHTTPResponseClass parent_class;
-};
-
-struct _RygelSeekableResponsePrivate {
-	RygelHTTPSeek* seek;
-	GFile* file;
-	GFileInputStream* input_stream;
-	gchar* buffer;
-	gint buffer_length1;
-	gint buffer_size;
-	gsize total_length;
-	gint priority;
-};
-
-
-static gpointer rygel_seekable_response_parent_class = NULL;
-
-GType rygel_state_machine_get_type (void);
-GType rygel_http_response_get_type (void);
-GType rygel_seekable_response_get_type (void);
-GType rygel_http_seek_get_type (void);
-#define RYGEL_SEEKABLE_RESPONSE_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), RYGEL_TYPE_SEEKABLE_RESPONSE, RygelSeekableResponsePrivate))
-enum  {
-	RYGEL_SEEKABLE_RESPONSE_DUMMY_PROPERTY
-};
-#define RYGEL_SEEKABLE_RESPONSE_BUFFER_LENGTH ((gsize) 4096)
-RygelHTTPResponse* rygel_http_response_construct (GType object_type, SoupServer* server, SoupMessage* msg, gboolean partial, GCancellable* cancellable);
-static gint rygel_seekable_response_get_requested_priority (RygelSeekableResponse* self);
-gint64 rygel_http_seek_get_length (RygelHTTPSeek* self);
-static void rygel_seekable_response_on_wrote_chunk (RygelSeekableResponse* self, SoupMessage* msg);
-static void _rygel_seekable_response_on_wrote_chunk_soup_message_wrote_chunk (SoupMessage* _sender, gpointer self);
-RygelSeekableResponse* rygel_seekable_response_new (SoupServer* server, SoupMessage* msg, const char* uri, RygelHTTPSeek* seek, gsize file_length, GCancellable* cancellable);
-RygelSeekableResponse* rygel_seekable_response_construct (GType object_type, SoupServer* server, SoupMessage* msg, const char* uri, RygelHTTPSeek* seek, gsize file_length, GCancellable* cancellable);
-GCancellable* rygel_state_machine_get_cancellable (RygelStateMachine* self);
-void rygel_state_machine_set_cancellable (RygelStateMachine* self, GCancellable* value);
-static void rygel_seekable_response_on_file_read (RygelSeekableResponse* self, GObject* source_object, GAsyncResult* _result_);
-static void _rygel_seekable_response_on_file_read_gasync_ready_callback (GObject* source_object, GAsyncResult* res, gpointer self);
-static void rygel_seekable_response_real_run (RygelHTTPResponse* base);
-void rygel_http_response_end (RygelHTTPResponse* self, gboolean aborted, guint status);
-gint64 rygel_http_seek_get_start (RygelHTTPSeek* self);
-gint64 rygel_http_seek_get_stop (RygelHTTPSeek* self);
-static void rygel_seekable_response_on_contents_read (RygelSeekableResponse* self, GObject* source_object, GAsyncResult* _result_);
-static void _rygel_seekable_response_on_contents_read_gasync_ready_callback (GObject* source_object, GAsyncResult* res, gpointer self);
-void rygel_http_response_push_data (RygelHTTPResponse* self, void* data, gsize length);
-static void rygel_seekable_response_on_input_stream_closed (RygelSeekableResponse* self, GObject* source_object, GAsyncResult* _result_);
-static void _rygel_seekable_response_on_input_stream_closed_gasync_ready_callback (GObject* source_object, GAsyncResult* res, gpointer self);
-static void rygel_seekable_response_finalize (GObject* obj);
-static int _vala_strcmp0 (const char * str1, const char * str2);
-
-
-
-static gpointer _g_object_ref0 (gpointer self) {
-	return self ? g_object_ref (self) : NULL;
-}
-
-
-static void _rygel_seekable_response_on_wrote_chunk_soup_message_wrote_chunk (SoupMessage* _sender, gpointer self) {
-	rygel_seekable_response_on_wrote_chunk (self, _sender);
-}
-
-
-RygelSeekableResponse* rygel_seekable_response_construct (GType object_type, SoupServer* server, SoupMessage* msg, const char* uri, RygelHTTPSeek* seek, gsize file_length, GCancellable* cancellable) {
-	RygelSeekableResponse * self;
-	RygelHTTPSeek* _tmp0_;
-	gchar* _tmp1_;
-	GFile* _tmp2_;
-	g_return_val_if_fail (server != NULL, NULL);
-	g_return_val_if_fail (msg != NULL, NULL);
-	g_return_val_if_fail (uri != NULL, NULL);
-	self = (RygelSeekableResponse*) rygel_http_response_construct (object_type, server, msg, seek != NULL, cancellable);
-	self->priv->seek = (_tmp0_ = _g_object_ref0 (seek), _g_object_unref0 (self->priv->seek), _tmp0_);
-	self->priv->total_length = file_length;
-	self->priv->priority = rygel_seekable_response_get_requested_priority (self);
-	if (seek != NULL) {
-		self->priv->total_length = (gsize) rygel_http_seek_get_length (seek);
-	} else {
-		self->priv->total_length = file_length;
-	}
-	g_signal_connect_object (msg, "wrote-chunk", (GCallback) _rygel_seekable_response_on_wrote_chunk_soup_message_wrote_chunk, self, 0);
-	self->priv->buffer = (_tmp1_ = g_new0 (gchar, RYGEL_SEEKABLE_RESPONSE_BUFFER_LENGTH), self->priv->buffer = (g_free (self->priv->buffer), NULL), self->priv->buffer_length1 = RYGEL_SEEKABLE_RESPONSE_BUFFER_LENGTH, self->priv->buffer_size = self->priv->buffer_length1, _tmp1_);
-	self->priv->file = (_tmp2_ = g_file_new_for_uri (uri), _g_object_unref0 (self->priv->file), _tmp2_);
-	return self;
-}
-
-
-RygelSeekableResponse* rygel_seekable_response_new (SoupServer* server, SoupMessage* msg, const char* uri, RygelHTTPSeek* seek, gsize file_length, GCancellable* cancellable) {
-	return rygel_seekable_response_construct (RYGEL_TYPE_SEEKABLE_RESPONSE, server, msg, uri, seek, file_length, cancellable);
-}
-
-
-static void _rygel_seekable_response_on_file_read_gasync_ready_callback (GObject* source_object, GAsyncResult* res, gpointer self) {
-	rygel_seekable_response_on_file_read (self, source_object, res);
-}
-
-
-static void rygel_seekable_response_real_run (RygelHTTPResponse* base) {
-	RygelSeekableResponse * self;
-	self = (RygelSeekableResponse*) base;
-	rygel_state_machine_set_cancellable ((RygelStateMachine*) self, rygel_state_machine_get_cancellable ((RygelStateMachine*) self));
-	g_file_read_async (self->priv->file, self->priv->priority, rygel_state_machine_get_cancellable ((RygelStateMachine*) self), _rygel_seekable_response_on_file_read_gasync_ready_callback, self);
-}
-
-
-static void _rygel_seekable_response_on_contents_read_gasync_ready_callback (GObject* source_object, GAsyncResult* res, gpointer self) {
-	rygel_seekable_response_on_contents_read (self, source_object, res);
-}
-
-
-static void rygel_seekable_response_on_file_read (RygelSeekableResponse* self, GObject* source_object, GAsyncResult* _result_) {
-	GError * _inner_error_;
-	g_return_if_fail (self != NULL);
-	g_return_if_fail (_result_ != NULL);
-	_inner_error_ = NULL;
-	{
-		GFileInputStream* _tmp0_;
-		GFileInputStream* _tmp1_;
-		_tmp0_ = g_file_read_finish (self->priv->file, _result_, &_inner_error_);
-		if (_inner_error_ != NULL) {
-			goto __catch25_g_error;
-			goto __finally25;
-		}
-		self->priv->input_stream = (_tmp1_ = _tmp0_, _g_object_unref0 (self->priv->input_stream), _tmp1_);
-	}
-	goto __finally25;
-	__catch25_g_error:
-	{
-		GError * err;
-		err = _inner_error_;
-		_inner_error_ = NULL;
-		{
-			char* _tmp2_;
-			g_warning ("rygel-seekable-response.vala:74: Failed to read from URI: %s: %s\n", _tmp2_ = g_file_get_uri (self->priv->file), err->message);
-			_g_free0 (_tmp2_);
-			rygel_http_response_end ((RygelHTTPResponse*) self, FALSE, (guint) SOUP_STATUS_NOT_FOUND);
-			_g_error_free0 (err);
-			return;
-		}
-	}
-	__finally25:
-	if (_inner_error_ != NULL) {
-		g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
-		g_clear_error (&_inner_error_);
-		return;
-	}
-	if (self->priv->seek != NULL) {
-		{
-			G_FILE_INPUT_STREAM_GET_CLASS (self->priv->input_stream)->seek (self->priv->input_stream, rygel_http_seek_get_start (self->priv->seek), G_SEEK_SET, rygel_state_machine_get_cancellable ((RygelStateMachine*) self), &_inner_error_);
-			if (_inner_error_ != NULL) {
-				goto __catch26_g_error;
-				goto __finally26;
-			}
-		}
-		goto __finally26;
-		__catch26_g_error:
-		{
-			GError * err;
-			err = _inner_error_;
-			_inner_error_ = NULL;
-			{
-				char* _tmp5_;
-				char* _tmp4_;
-				char* _tmp3_;
-				g_warning ("rygel-seekable-response.vala:87: Failed to seek to %s-%s on URI %s: %s\n", _tmp3_ = g_strdup_printf ("%lli", rygel_http_seek_get_start (self->priv->seek)), _tmp4_ = g_strdup_printf ("%lli", rygel_http_seek_get_stop (self->priv->seek)), _tmp5_ = g_file_get_uri (self->priv->file), err->message);
-				_g_free0 (_tmp5_);
-				_g_free0 (_tmp4_);
-				_g_free0 (_tmp3_);
-				rygel_http_response_end ((RygelHTTPResponse*) self, FALSE, (guint) SOUP_STATUS_REQUESTED_RANGE_NOT_SATISFIABLE);
-				_g_error_free0 (err);
-				return;
-			}
-		}
-		__finally26:
-		if (_inner_error_ != NULL) {
-			g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
-			g_clear_error (&_inner_error_);
-			return;
-		}
-	}
-	g_input_stream_read_async ((GInputStream*) self->priv->input_stream, self->priv->buffer, RYGEL_SEEKABLE_RESPONSE_BUFFER_LENGTH, self->priv->priority, rygel_state_machine_get_cancellable ((RygelStateMachine*) self), _rygel_seekable_response_on_contents_read_gasync_ready_callback, self);
-}
-
-
-static void _rygel_seekable_response_on_input_stream_closed_gasync_ready_callback (GObject* source_object, GAsyncResult* res, gpointer self) {
-	rygel_seekable_response_on_input_stream_closed (self, source_object, res);
-}
-
-
-static void rygel_seekable_response_on_contents_read (RygelSeekableResponse* self, GObject* source_object, GAsyncResult* _result_) {
-	GError * _inner_error_;
-	GFileInputStream* input_stream;
-	gssize bytes_read = 0L;
-	g_return_if_fail (self != NULL);
-	g_return_if_fail (_result_ != NULL);
-	_inner_error_ = NULL;
-	input_stream = _g_object_ref0 (G_FILE_INPUT_STREAM (source_object));
-	{
-		gssize _tmp0_;
-		_tmp0_ = g_input_stream_read_finish ((GInputStream*) input_stream, _result_, &_inner_error_);
-		if (_inner_error_ != NULL) {
-			goto __catch27_g_error;
-			goto __finally27;
-		}
-		bytes_read = _tmp0_;
-	}
-	goto __finally27;
-	__catch27_g_error:
-	{
-		GError * err;
-		err = _inner_error_;
-		_inner_error_ = NULL;
-		{
-			char* _tmp1_;
-			g_warning ("rygel-seekable-response.vala:113: Failed to read contents from URI: %s: %s\n", _tmp1_ = g_file_get_uri (self->priv->file), err->message);
-			_g_free0 (_tmp1_);
-			rygel_http_response_end ((RygelHTTPResponse*) self, FALSE, (guint) SOUP_STATUS_NOT_FOUND);
-			_g_error_free0 (err);
-			_g_object_unref0 (input_stream);
-			return;
-		}
-	}
-	__finally27:
-	if (_inner_error_ != NULL) {
-		_g_object_unref0 (input_stream);
-		g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
-		g_clear_error (&_inner_error_);
-		return;
-	}
-	if (bytes_read > 0) {
-		rygel_http_response_push_data ((RygelHTTPResponse*) self, self->priv->buffer, (gsize) bytes_read);
-	} else {
-		g_input_stream_close_async ((GInputStream*) input_stream, self->priv->priority, rygel_state_machine_get_cancellable ((RygelStateMachine*) self), _rygel_seekable_response_on_input_stream_closed_gasync_ready_callback, self);
-	}
-	_g_object_unref0 (input_stream);
-}
-
-
-static void rygel_seekable_response_on_input_stream_closed (RygelSeekableResponse* self, GObject* source_object, GAsyncResult* _result_) {
-	GError * _inner_error_;
-	GFileInputStream* input_stream;
-	g_return_if_fail (self != NULL);
-	g_return_if_fail (_result_ != NULL);
-	_inner_error_ = NULL;
-	input_stream = _g_object_ref0 (G_FILE_INPUT_STREAM (source_object));
-	{
-		g_input_stream_close_finish ((GInputStream*) input_stream, _result_, &_inner_error_);
-		if (_inner_error_ != NULL) {
-			goto __catch28_g_error;
-			goto __finally28;
-		}
-	}
-	goto __finally28;
-	__catch28_g_error:
-	{
-		GError * err;
-		err = _inner_error_;
-		_inner_error_ = NULL;
-		{
-			char* _tmp0_;
-			g_warning ("rygel-seekable-response.vala:136: Failed to close stream to URI %s: %s\n", _tmp0_ = g_file_get_uri (self->priv->file), err->message);
-			_g_free0 (_tmp0_);
-			_g_error_free0 (err);
-		}
-	}
-	__finally28:
-	if (_inner_error_ != NULL) {
-		_g_object_unref0 (input_stream);
-		g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
-		g_clear_error (&_inner_error_);
-		return;
-	}
-	rygel_http_response_end ((RygelHTTPResponse*) self, FALSE, (guint) SOUP_STATUS_NONE);
-	_g_object_unref0 (input_stream);
-}
-
-
-static void rygel_seekable_response_on_wrote_chunk (RygelSeekableResponse* self, SoupMessage* msg) {
-	g_return_if_fail (self != NULL);
-	g_return_if_fail (msg != NULL);
-	g_input_stream_read_async ((GInputStream*) self->priv->input_stream, self->priv->buffer, RYGEL_SEEKABLE_RESPONSE_BUFFER_LENGTH, self->priv->priority, rygel_state_machine_get_cancellable ((RygelStateMachine*) self), _rygel_seekable_response_on_contents_read_gasync_ready_callback, self);
-}
-
-
-static gint rygel_seekable_response_get_requested_priority (RygelSeekableResponse* self) {
-	gint result;
-	char* mode;
-	gboolean _tmp0_ = FALSE;
-	g_return_val_if_fail (self != NULL, 0);
-	mode = g_strdup (soup_message_headers_get (((RygelHTTPResponse*) self)->msg->request_headers, "transferMode.dlna.org"));
-	if (mode == NULL) {
-		_tmp0_ = TRUE;
-	} else {
-		_tmp0_ = _vala_strcmp0 (mode, "Interactive") == 0;
-	}
-	if (_tmp0_) {
-		result = G_PRIORITY_DEFAULT;
-		_g_free0 (mode);
-		return result;
-	} else {
-		if (_vala_strcmp0 (mode, "Streaming") == 0) {
-			result = G_PRIORITY_HIGH;
-			_g_free0 (mode);
-			return result;
-		} else {
-			if (_vala_strcmp0 (mode, "Background") == 0) {
-				result = G_PRIORITY_LOW;
-				_g_free0 (mode);
-				return result;
-			} else {
-				result = G_PRIORITY_DEFAULT;
-				_g_free0 (mode);
-				return result;
-			}
-		}
-	}
-	_g_free0 (mode);
-}
-
-
-static void rygel_seekable_response_class_init (RygelSeekableResponseClass * klass) {
-	rygel_seekable_response_parent_class = g_type_class_peek_parent (klass);
-	g_type_class_add_private (klass, sizeof (RygelSeekableResponsePrivate));
-	RYGEL_HTTP_RESPONSE_CLASS (klass)->run = rygel_seekable_response_real_run;
-	G_OBJECT_CLASS (klass)->finalize = rygel_seekable_response_finalize;
-}
-
-
-static void rygel_seekable_response_instance_init (RygelSeekableResponse * self) {
-	self->priv = RYGEL_SEEKABLE_RESPONSE_GET_PRIVATE (self);
-}
-
-
-static void rygel_seekable_response_finalize (GObject* obj) {
-	RygelSeekableResponse * self;
-	self = RYGEL_SEEKABLE_RESPONSE (obj);
-	_g_object_unref0 (self->priv->seek);
-	_g_object_unref0 (self->priv->file);
-	_g_object_unref0 (self->priv->input_stream);
-	self->priv->buffer = (g_free (self->priv->buffer), NULL);
-	G_OBJECT_CLASS (rygel_seekable_response_parent_class)->finalize (obj);
-}
-
-
-GType rygel_seekable_response_get_type (void) {
-	static GType rygel_seekable_response_type_id = 0;
-	if (rygel_seekable_response_type_id == 0) {
-		static const GTypeInfo g_define_type_info = { sizeof (RygelSeekableResponseClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) rygel_seekable_response_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (RygelSeekableResponse), 0, (GInstanceInitFunc) rygel_seekable_response_instance_init, NULL };
-		rygel_seekable_response_type_id = g_type_register_static (RYGEL_TYPE_HTTP_RESPONSE, "RygelSeekableResponse", &g_define_type_info, 0);
-	}
-	return rygel_seekable_response_type_id;
-}
-
-
-static int _vala_strcmp0 (const char * str1, const char * str2) {
-	if (str1 == NULL) {
-		return -(str1 != str2);
-	}
-	if (str2 == NULL) {
-		return str1 != str2;
-	}
-	return strcmp (str1, str2);
-}
-
-
-
-
--- a/src/rygel/rygel-seekable-response.vala
+++ /dev/null
@@ -1,166 +0,0 @@
-/*
- * Copyright (C) 2008 Zeeshan Ali (Khattak) <zeeshanak@gnome.org>.
- * Copyright (C) 2008 Nokia Corporation.
- *
- * Author: Zeeshan Ali (Khattak) <zeeshanak@gnome.org>
- *                               <zeeshan.ali@nokia.com>
- *
- * This file is part of Rygel.
- *
- * Rygel is free software; you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * Rygel is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this program; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
- */
-
-using GUPnP;
-
-internal class Rygel.SeekableResponse : Rygel.HTTPResponse {
-    private const size_t BUFFER_LENGTH = 4096;
-
-    private HTTPSeek seek;
-    private File file;
-    private FileInputStream input_stream;
-
-    private char[] buffer;
-    private size_t total_length;
-
-    int priority;
-
-    public SeekableResponse (Soup.Server  server,
-                             Soup.Message msg,
-                             string       uri,
-                             HTTPSeek?    seek,
-                             size_t       file_length,
-                             Cancellable? cancellable) {
-        base (server, msg, seek != null, cancellable);
-
-        this.seek = seek;
-        this.total_length = file_length;
-        this.priority = this.get_requested_priority ();
-
-        if (seek != null) {
-            this.total_length = (size_t) seek.length;
-        } else {
-            this.total_length = file_length;
-        }
-
-        msg.wrote_chunk += on_wrote_chunk;
-
-        this.buffer = new char[SeekableResponse.BUFFER_LENGTH];
-        this.file = File.new_for_uri (uri);
-    }
-
-    public override void run () {
-        this.cancellable = cancellable;
-
-        this.file.read_async (this.priority, cancellable, this.on_file_read);
-    }
-
-    private void on_file_read (GLib.Object?     source_object,
-                               GLib.AsyncResult result) {
-        try {
-           this.input_stream = this.file.read_finish (result);
-        } catch (Error err) {
-            warning ("Failed to read from URI: %s: %s\n",
-                     file.get_uri (),
-                     err.message);
-            this.end (false, Soup.KnownStatusCode.NOT_FOUND);
-            return;
-        }
-
-        if (seek != null) {
-            try {
-                this.input_stream.seek (seek.start,
-                                        SeekType.SET,
-                                        this.cancellable);
-            } catch (Error err) {
-                warning ("Failed to seek to %s-%s on URI %s: %s\n",
-                         seek.start.to_string (),
-                         seek.stop.to_string (),
-                         file.get_uri (),
-                         err.message);
-                this.end (false,
-                          Soup.KnownStatusCode.REQUESTED_RANGE_NOT_SATISFIABLE);
-                return;
-            }
-        }
-
-        this.input_stream.read_async (this.buffer,
-                                      SeekableResponse.BUFFER_LENGTH,
-                                      this.priority,
-                                      this.cancellable,
-                                      on_contents_read);
-    }
-
-    private void on_contents_read (GLib.Object?     source_object,
-                                   GLib.AsyncResult result) {
-        FileInputStream input_stream = (FileInputStream) source_object;
-        ssize_t bytes_read;
-
-        try {
-           bytes_read = input_stream.read_finish (result);
-        } catch (Error err) {
-            warning ("Failed to read contents from URI: %s: %s\n",
-                     this.file.get_uri (),
-                     err.message);
-            this.end (false, Soup.KnownStatusCode.NOT_FOUND);
-            return;
-        }
-
-        if (bytes_read > 0) {
-            this.push_data (this.buffer, bytes_read);
-        } else {
-            input_stream.close_async (this.priority,
-                                      this.cancellable,
-                                      on_input_stream_closed);
-        }
-    }
-
-    private void on_input_stream_closed (GLib.Object?     source_object,
-                                         GLib.AsyncResult result) {
-        FileInputStream input_stream = (FileInputStream) source_object;
-
-        try  {
-            input_stream.close_finish (result);
-        } catch (Error err) {
-            warning ("Failed to close stream to URI %s: %s\n",
-                     this.file.get_uri (),
-                     err.message);
-        }
-
-        this.end (false, Soup.KnownStatusCode.NONE);
-    }
-
-    private void on_wrote_chunk (Soup.Message msg) {
-        this.input_stream.read_async (this.buffer,
-                                      SeekableResponse.BUFFER_LENGTH,
-                                      this.priority,
-                                      this.cancellable,
-                                      this.on_contents_read);
-    }
-
-    private int get_requested_priority () {
-        var mode = this.msg.request_headers.get ("transferMode.dlna.org");
-
-        if (mode == null || mode == "Interactive") {
-            return Priority.DEFAULT;
-        } else if (mode == "Streaming") {
-            return Priority.HIGH;
-        } else if (mode == "Background") {
-            return Priority.LOW;
-        } else {
-            return Priority.DEFAULT;
-        }
-    }
-}
-
--- a/src/rygel/rygel-simple-async-result.c
+++ /dev/null
@@ -1,242 +0,0 @@
-/* rygel-simple-async-result.c generated by valac, the Vala compiler
- * generated from rygel-simple-async-result.vala, do not modify */
-
-/*
- * Copyright (C) 2009 Zeeshan Ali <zeenix@gmail.com>.
- *
- * Author: Zeeshan Ali <zeenix@gmail.com>
- *
- * This file is part of Rygel.
- *
- * Rygel is free software; you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * Rygel is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this program; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
- */
-
-#include <glib.h>
-#include <glib-object.h>
-#include <gio/gio.h>
-
-
-#define RYGEL_TYPE_SIMPLE_ASYNC_RESULT (rygel_simple_async_result_get_type ())
-#define RYGEL_SIMPLE_ASYNC_RESULT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_SIMPLE_ASYNC_RESULT, RygelSimpleAsyncResult))
-#define RYGEL_SIMPLE_ASYNC_RESULT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_SIMPLE_ASYNC_RESULT, RygelSimpleAsyncResultClass))
-#define RYGEL_IS_SIMPLE_ASYNC_RESULT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_SIMPLE_ASYNC_RESULT))
-#define RYGEL_IS_SIMPLE_ASYNC_RESULT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_SIMPLE_ASYNC_RESULT))
-#define RYGEL_SIMPLE_ASYNC_RESULT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_SIMPLE_ASYNC_RESULT, RygelSimpleAsyncResultClass))
-
-typedef struct _RygelSimpleAsyncResult RygelSimpleAsyncResult;
-typedef struct _RygelSimpleAsyncResultClass RygelSimpleAsyncResultClass;
-typedef struct _RygelSimpleAsyncResultPrivate RygelSimpleAsyncResultPrivate;
-#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
-#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
-
-struct _RygelSimpleAsyncResult {
-	GObject parent_instance;
-	RygelSimpleAsyncResultPrivate * priv;
-	GObject* source_object;
-	GAsyncReadyCallback callback;
-	gpointer callback_target;
-	GDestroyNotify callback_target_destroy_notify;
-	gpointer data;
-	GError* error;
-};
-
-struct _RygelSimpleAsyncResultClass {
-	GObjectClass parent_class;
-};
-
-struct _RygelSimpleAsyncResultPrivate {
-	GType g_type;
-	GBoxedCopyFunc g_dup_func;
-	GDestroyNotify g_destroy_func;
-};
-
-
-static gpointer rygel_simple_async_result_parent_class = NULL;
-static GAsyncResultIface* rygel_simple_async_result_g_async_result_parent_iface = NULL;
-
-GType rygel_simple_async_result_get_type (void);
-#define RYGEL_SIMPLE_ASYNC_RESULT_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), RYGEL_TYPE_SIMPLE_ASYNC_RESULT, RygelSimpleAsyncResultPrivate))
-enum  {
-	RYGEL_SIMPLE_ASYNC_RESULT_DUMMY_PROPERTY,
-	RYGEL_SIMPLE_ASYNC_RESULT_G_TYPE,
-	RYGEL_SIMPLE_ASYNC_RESULT_G_DUP_FUNC,
-	RYGEL_SIMPLE_ASYNC_RESULT_G_DESTROY_FUNC
-};
-RygelSimpleAsyncResult* rygel_simple_async_result_new (GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GObject* source_object, GAsyncReadyCallback callback, void* callback_target);
-RygelSimpleAsyncResult* rygel_simple_async_result_construct (GType object_type, GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GObject* source_object, GAsyncReadyCallback callback, void* callback_target);
-static GObject* rygel_simple_async_result_real_get_source_object (GAsyncResult* base);
-static void* rygel_simple_async_result_real_get_user_data (GAsyncResult* base);
-void rygel_simple_async_result_complete (RygelSimpleAsyncResult* self);
-static gboolean rygel_simple_async_result_idle_func (RygelSimpleAsyncResult* self);
-static gboolean _rygel_simple_async_result_idle_func_gsource_func (gpointer self);
-void rygel_simple_async_result_complete_in_idle (RygelSimpleAsyncResult* self);
-static void rygel_simple_async_result_finalize (GObject* obj);
-static void rygel_simple_async_result_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
-static void rygel_simple_async_result_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);
-
-
-
-static gpointer _g_object_ref0 (gpointer self) {
-	return self ? g_object_ref (self) : NULL;
-}
-
-
-RygelSimpleAsyncResult* rygel_simple_async_result_construct (GType object_type, GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GObject* source_object, GAsyncReadyCallback callback, void* callback_target) {
-	RygelSimpleAsyncResult * self;
-	GObject* _tmp0_;
-	GAsyncReadyCallback _tmp1_;
-	g_return_val_if_fail (source_object != NULL, NULL);
-	self = (RygelSimpleAsyncResult*) g_object_new (object_type, NULL);
-	self->priv->g_type = g_type;
-	self->priv->g_dup_func = g_dup_func;
-	self->priv->g_destroy_func = g_destroy_func;
-	self->source_object = (_tmp0_ = _g_object_ref0 (source_object), _g_object_unref0 (self->source_object), _tmp0_);
-	self->callback = (_tmp1_ = callback, ((self->callback_target_destroy_notify == NULL) ? NULL : self->callback_target_destroy_notify (self->callback_target), self->callback = NULL, self->callback_target = NULL, self->callback_target_destroy_notify = NULL), self->callback_target = callback_target, self->callback_target_destroy_notify = NULL, _tmp1_);
-	return self;
-}
-
-
-RygelSimpleAsyncResult* rygel_simple_async_result_new (GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GObject* source_object, GAsyncReadyCallback callback, void* callback_target) {
-	return rygel_simple_async_result_construct (RYGEL_TYPE_SIMPLE_ASYNC_RESULT, g_type, g_dup_func, g_destroy_func, source_object, callback, callback_target);
-}
-
-
-static GObject* rygel_simple_async_result_real_get_source_object (GAsyncResult* base) {
-	RygelSimpleAsyncResult * self;
-	GObject* result;
-	self = (RygelSimpleAsyncResult*) base;
-	result = self->source_object;
-	return result;
-}
-
-
-static void* rygel_simple_async_result_real_get_user_data (GAsyncResult* base) {
-	RygelSimpleAsyncResult * self;
-	void* result;
-	self = (RygelSimpleAsyncResult*) base;
-	result = NULL;
-	return result;
-}
-
-
-void rygel_simple_async_result_complete (RygelSimpleAsyncResult* self) {
-	g_return_if_fail (self != NULL);
-	self->callback (self->source_object, (GAsyncResult*) self, self->callback_target);
-}
-
-
-static gboolean _rygel_simple_async_result_idle_func_gsource_func (gpointer self) {
-	return rygel_simple_async_result_idle_func (self);
-}
-
-
-void rygel_simple_async_result_complete_in_idle (RygelSimpleAsyncResult* self) {
-	g_return_if_fail (self != NULL);
-	g_idle_add_full (G_PRIORITY_DEFAULT, _rygel_simple_async_result_idle_func_gsource_func, g_object_ref (self), g_object_unref);
-}
-
-
-static gboolean rygel_simple_async_result_idle_func (RygelSimpleAsyncResult* self) {
-	gboolean result;
-	g_return_val_if_fail (self != NULL, FALSE);
-	rygel_simple_async_result_complete (self);
-	result = FALSE;
-	return result;
-}
-
-
-static void rygel_simple_async_result_class_init (RygelSimpleAsyncResultClass * klass) {
-	rygel_simple_async_result_parent_class = g_type_class_peek_parent (klass);
-	g_type_class_add_private (klass, sizeof (RygelSimpleAsyncResultPrivate));
-	G_OBJECT_CLASS (klass)->get_property = rygel_simple_async_result_get_property;
-	G_OBJECT_CLASS (klass)->set_property = rygel_simple_async_result_set_property;
-	G_OBJECT_CLASS (klass)->finalize = rygel_simple_async_result_finalize;
-	g_object_class_install_property (G_OBJECT_CLASS (klass), RYGEL_SIMPLE_ASYNC_RESULT_G_TYPE, g_param_spec_gtype ("g-type", "type", "type", G_TYPE_NONE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
-	g_object_class_install_property (G_OBJECT_CLASS (klass), RYGEL_SIMPLE_ASYNC_RESULT_G_DUP_FUNC, g_param_spec_pointer ("g-dup-func", "dup func", "dup func", G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
-	g_object_class_install_property (G_OBJECT_CLASS (klass), RYGEL_SIMPLE_ASYNC_RESULT_G_DESTROY_FUNC, g_param_spec_pointer ("g-destroy-func", "destroy func", "destroy func", G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
-}
-
-
-static void rygel_simple_async_result_g_async_result_interface_init (GAsyncResultIface * iface) {
-	rygel_simple_async_result_g_async_result_parent_iface = g_type_interface_peek_parent (iface);
-	iface->get_source_object = rygel_simple_async_result_real_get_source_object;
-	iface->get_user_data = rygel_simple_async_result_real_get_user_data;
-}
-
-
-static void rygel_simple_async_result_instance_init (RygelSimpleAsyncResult * self) {
-	self->priv = RYGEL_SIMPLE_ASYNC_RESULT_GET_PRIVATE (self);
-}
-
-
-static void rygel_simple_async_result_finalize (GObject* obj) {
-	RygelSimpleAsyncResult * self;
-	self = RYGEL_SIMPLE_ASYNC_RESULT (obj);
-	_g_object_unref0 (self->source_object);
-	(self->callback_target_destroy_notify == NULL) ? NULL : self->callback_target_destroy_notify (self->callback_target);
-	self->callback = NULL;
-	self->callback_target = NULL;
-	self->callback_target_destroy_notify = NULL;
-	((self->data == NULL) || (self->priv->g_destroy_func == NULL)) ? NULL : (self->data = (self->priv->g_destroy_func (self->data), NULL));
-	_g_error_free0 (self->error);
-	G_OBJECT_CLASS (rygel_simple_async_result_parent_class)->finalize (obj);
-}
-
-
-GType rygel_simple_async_result_get_type (void) {
-	static GType rygel_simple_async_result_type_id = 0;
-	if (rygel_simple_async_result_type_id == 0) {
-		static const GTypeInfo g_define_type_info = { sizeof (RygelSimpleAsyncResultClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) rygel_simple_async_result_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (RygelSimpleAsyncResult), 0, (GInstanceInitFunc) rygel_simple_async_result_instance_init, NULL };
-		static const GInterfaceInfo g_async_result_info = { (GInterfaceInitFunc) rygel_simple_async_result_g_async_result_interface_init, (GInterfaceFinalizeFunc) NULL, NULL};
-		rygel_simple_async_result_type_id = g_type_register_static (G_TYPE_OBJECT, "RygelSimpleAsyncResult", &g_define_type_info, 0);
-		g_type_add_interface_static (rygel_simple_async_result_type_id, G_TYPE_ASYNC_RESULT, &g_async_result_info);
-	}
-	return rygel_simple_async_result_type_id;
-}
-
-
-static void rygel_simple_async_result_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
-	RygelSimpleAsyncResult * self;
-	self = RYGEL_SIMPLE_ASYNC_RESULT (object);
-	switch (property_id) {
-		default:
-		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
-		break;
-	}
-}
-
-
-static void rygel_simple_async_result_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
-	RygelSimpleAsyncResult * self;
-	self = RYGEL_SIMPLE_ASYNC_RESULT (object);
-	switch (property_id) {
-		default:
-		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
-		break;
-		case RYGEL_SIMPLE_ASYNC_RESULT_G_TYPE:
-		self->priv->g_type = g_value_get_gtype (value);
-		break;
-		case RYGEL_SIMPLE_ASYNC_RESULT_G_DUP_FUNC:
-		self->priv->g_dup_func = g_value_get_pointer (value);
-		break;
-		case RYGEL_SIMPLE_ASYNC_RESULT_G_DESTROY_FUNC:
-		self->priv->g_destroy_func = g_value_get_pointer (value);
-		break;
-	}
-}
-
-
-
-
--- a/src/rygel/rygel-simple-container.c
+++ /dev/null
@@ -1,463 +0,0 @@
-/* rygel-simple-container.c generated by valac, the Vala compiler
- * generated from rygel-simple-container.vala, do not modify */
-
-/*
- * Copyright (C) 2009 Zeeshan Ali (Khattak) <zeeshanak@gnome.org>.
- * Copyright (C) 2009 Nokia Corporation.
- *
- * Author: Zeeshan Ali (Khattak) <zeeshanak@gnome.org>
- *                               <zeeshan.ali@nokia.com>
- *
- * This file is part of Rygel.
- *
- * Rygel is free software; you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * Rygel is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this program; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
- */
-
-#include <glib.h>
-#include <glib-object.h>
-#include <stdlib.h>
-#include <string.h>
-#include <gee.h>
-#include <gio/gio.h>
-
-
-#define RYGEL_TYPE_MEDIA_OBJECT (rygel_media_object_get_type ())
-#define RYGEL_MEDIA_OBJECT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_MEDIA_OBJECT, RygelMediaObject))
-#define RYGEL_MEDIA_OBJECT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_MEDIA_OBJECT, RygelMediaObjectClass))
-#define RYGEL_IS_MEDIA_OBJECT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_MEDIA_OBJECT))
-#define RYGEL_IS_MEDIA_OBJECT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_MEDIA_OBJECT))
-#define RYGEL_MEDIA_OBJECT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_MEDIA_OBJECT, RygelMediaObjectClass))
-
-typedef struct _RygelMediaObject RygelMediaObject;
-typedef struct _RygelMediaObjectClass RygelMediaObjectClass;
-typedef struct _RygelMediaObjectPrivate RygelMediaObjectPrivate;
-
-#define RYGEL_TYPE_MEDIA_CONTAINER (rygel_media_container_get_type ())
-#define RYGEL_MEDIA_CONTAINER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_MEDIA_CONTAINER, RygelMediaContainer))
-#define RYGEL_MEDIA_CONTAINER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_MEDIA_CONTAINER, RygelMediaContainerClass))
-#define RYGEL_IS_MEDIA_CONTAINER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_MEDIA_CONTAINER))
-#define RYGEL_IS_MEDIA_CONTAINER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_MEDIA_CONTAINER))
-#define RYGEL_MEDIA_CONTAINER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_MEDIA_CONTAINER, RygelMediaContainerClass))
-
-typedef struct _RygelMediaContainer RygelMediaContainer;
-typedef struct _RygelMediaContainerClass RygelMediaContainerClass;
-typedef struct _RygelMediaContainerPrivate RygelMediaContainerPrivate;
-
-#define RYGEL_TYPE_SIMPLE_CONTAINER (rygel_simple_container_get_type ())
-#define RYGEL_SIMPLE_CONTAINER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_SIMPLE_CONTAINER, RygelSimpleContainer))
-#define RYGEL_SIMPLE_CONTAINER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_SIMPLE_CONTAINER, RygelSimpleContainerClass))
-#define RYGEL_IS_SIMPLE_CONTAINER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_SIMPLE_CONTAINER))
-#define RYGEL_IS_SIMPLE_CONTAINER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_SIMPLE_CONTAINER))
-#define RYGEL_SIMPLE_CONTAINER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_SIMPLE_CONTAINER, RygelSimpleContainerClass))
-
-typedef struct _RygelSimpleContainer RygelSimpleContainer;
-typedef struct _RygelSimpleContainerClass RygelSimpleContainerClass;
-typedef struct _RygelSimpleContainerPrivate RygelSimpleContainerPrivate;
-
-#define RYGEL_TYPE_MEDIA_OBJECT_SEARCH (rygel_media_object_search_get_type ())
-#define RYGEL_MEDIA_OBJECT_SEARCH(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_MEDIA_OBJECT_SEARCH, RygelMediaObjectSearch))
-#define RYGEL_MEDIA_OBJECT_SEARCH_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_MEDIA_OBJECT_SEARCH, RygelMediaObjectSearchClass))
-#define RYGEL_IS_MEDIA_OBJECT_SEARCH(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_MEDIA_OBJECT_SEARCH))
-#define RYGEL_IS_MEDIA_OBJECT_SEARCH_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_MEDIA_OBJECT_SEARCH))
-#define RYGEL_MEDIA_OBJECT_SEARCH_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_MEDIA_OBJECT_SEARCH, RygelMediaObjectSearchClass))
-
-typedef struct _RygelMediaObjectSearch RygelMediaObjectSearch;
-typedef struct _RygelMediaObjectSearchClass RygelMediaObjectSearchClass;
-#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
-
-#define RYGEL_TYPE_SIMPLE_ASYNC_RESULT (rygel_simple_async_result_get_type ())
-#define RYGEL_SIMPLE_ASYNC_RESULT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_SIMPLE_ASYNC_RESULT, RygelSimpleAsyncResult))
-#define RYGEL_SIMPLE_ASYNC_RESULT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_SIMPLE_ASYNC_RESULT, RygelSimpleAsyncResultClass))
-#define RYGEL_IS_SIMPLE_ASYNC_RESULT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_SIMPLE_ASYNC_RESULT))
-#define RYGEL_IS_SIMPLE_ASYNC_RESULT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_SIMPLE_ASYNC_RESULT))
-#define RYGEL_SIMPLE_ASYNC_RESULT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_SIMPLE_ASYNC_RESULT, RygelSimpleAsyncResultClass))
-
-typedef struct _RygelSimpleAsyncResult RygelSimpleAsyncResult;
-typedef struct _RygelSimpleAsyncResultClass RygelSimpleAsyncResultClass;
-typedef struct _RygelSimpleAsyncResultPrivate RygelSimpleAsyncResultPrivate;
-
-#define RYGEL_TYPE_STATE_MACHINE (rygel_state_machine_get_type ())
-#define RYGEL_STATE_MACHINE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_STATE_MACHINE, RygelStateMachine))
-#define RYGEL_IS_STATE_MACHINE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_STATE_MACHINE))
-#define RYGEL_STATE_MACHINE_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), RYGEL_TYPE_STATE_MACHINE, RygelStateMachineIface))
-
-typedef struct _RygelStateMachine RygelStateMachine;
-typedef struct _RygelStateMachineIface RygelStateMachineIface;
-typedef struct _RygelMediaObjectSearchPrivate RygelMediaObjectSearchPrivate;
-#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
-
-struct _RygelMediaObject {
-	GObject parent_instance;
-	RygelMediaObjectPrivate * priv;
-	char* id;
-	char* title;
-	guint64 modified;
-	GeeArrayList* uris;
-	RygelMediaContainer* parent;
-	RygelMediaContainer* parent_ref;
-};
-
-struct _RygelMediaObjectClass {
-	GObjectClass parent_class;
-};
-
-struct _RygelMediaContainer {
-	RygelMediaObject parent_instance;
-	RygelMediaContainerPrivate * priv;
-	guint child_count;
-	guint32 update_id;
-};
-
-struct _RygelMediaContainerClass {
-	RygelMediaObjectClass parent_class;
-	void (*get_children) (RygelMediaContainer* self, guint offset, guint max_count, GCancellable* cancellable, GAsyncReadyCallback callback, void* callback_target);
-	GeeList* (*get_children_finish) (RygelMediaContainer* self, GAsyncResult* res, GError** error);
-	void (*find_object) (RygelMediaContainer* self, const char* id, GCancellable* cancellable, GAsyncReadyCallback callback, void* callback_target);
-	RygelMediaObject* (*find_object_finish) (RygelMediaContainer* self, GAsyncResult* res, GError** error);
-};
-
-struct _RygelSimpleContainer {
-	RygelMediaContainer parent_instance;
-	RygelSimpleContainerPrivate * priv;
-	GeeArrayList* children;
-};
-
-struct _RygelSimpleContainerClass {
-	RygelMediaContainerClass parent_class;
-};
-
-struct _RygelSimpleContainerPrivate {
-	GeeArrayList* searches;
-};
-
-struct _RygelSimpleAsyncResult {
-	GObject parent_instance;
-	RygelSimpleAsyncResultPrivate * priv;
-	GObject* source_object;
-	GAsyncReadyCallback callback;
-	gpointer callback_target;
-	GDestroyNotify callback_target_destroy_notify;
-	gpointer data;
-	GError* error;
-};
-
-struct _RygelSimpleAsyncResultClass {
-	GObjectClass parent_class;
-};
-
-struct _RygelStateMachineIface {
-	GTypeInterface parent_iface;
-	void (*run) (RygelStateMachine* self);
-	GCancellable* (*get_cancellable) (RygelStateMachine* self);
-	void (*set_cancellable) (RygelStateMachine* self, GCancellable* value);
-};
-
-struct _RygelMediaObjectSearch {
-	GObject parent_instance;
-	RygelMediaObjectSearchPrivate * priv;
-	char* id;
-	gpointer data;
-	RygelMediaObject* media_object;
-	GError* error;
-};
-
-struct _RygelMediaObjectSearchClass {
-	GObjectClass parent_class;
-};
-
-
-static gpointer rygel_simple_container_parent_class = NULL;
-
-GType rygel_media_object_get_type (void);
-GType rygel_media_container_get_type (void);
-GType rygel_simple_container_get_type (void);
-GType rygel_media_object_search_get_type (void);
-#define RYGEL_SIMPLE_CONTAINER_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), RYGEL_TYPE_SIMPLE_CONTAINER, RygelSimpleContainerPrivate))
-enum  {
-	RYGEL_SIMPLE_CONTAINER_DUMMY_PROPERTY
-};
-RygelMediaContainer* rygel_media_container_construct (GType object_type, const char* id, RygelMediaContainer* parent, const char* title, guint child_count);
-RygelSimpleContainer* rygel_simple_container_new (const char* id, RygelMediaContainer* parent, const char* title);
-RygelSimpleContainer* rygel_simple_container_construct (GType object_type, const char* id, RygelMediaContainer* parent, const char* title);
-RygelSimpleContainer* rygel_simple_container_new_root (const char* title);
-RygelSimpleContainer* rygel_simple_container_construct_root (GType object_type, const char* title);
-void rygel_simple_container_add_child (RygelSimpleContainer* self, RygelMediaObject* child);
-void rygel_simple_container_remove_child (RygelSimpleContainer* self, RygelMediaObject* child);
-RygelSimpleAsyncResult* rygel_simple_async_result_new (GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GObject* source_object, GAsyncReadyCallback callback, void* callback_target);
-RygelSimpleAsyncResult* rygel_simple_async_result_construct (GType object_type, GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GObject* source_object, GAsyncReadyCallback callback, void* callback_target);
-GType rygel_simple_async_result_get_type (void);
-void rygel_simple_async_result_complete_in_idle (RygelSimpleAsyncResult* self);
-static void rygel_simple_container_real_get_children (RygelMediaContainer* base, guint offset, guint max_count, GCancellable* cancellable, GAsyncReadyCallback callback, void* callback_target);
-static GeeList* rygel_simple_container_real_get_children_finish (RygelMediaContainer* base, GAsyncResult* res, GError** error);
-RygelMediaObjectSearch* rygel_media_object_search_new (GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, const char* id, GeeArrayList* containers, gconstpointer data, GCancellable* cancellable);
-RygelMediaObjectSearch* rygel_media_object_search_construct (GType object_type, GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, const char* id, GeeArrayList* containers, gconstpointer data, GCancellable* cancellable);
-GType rygel_state_machine_get_type (void);
-static void rygel_simple_container_on_object_search_completed (RygelSimpleContainer* self, RygelStateMachine* state_machine);
-static void _rygel_simple_container_on_object_search_completed_rygel_state_machine_completed (RygelStateMachine* _sender, gpointer self);
-void rygel_state_machine_run (RygelStateMachine* self);
-static void rygel_simple_container_real_find_object (RygelMediaContainer* base, const char* id, GCancellable* cancellable, GAsyncReadyCallback callback, void* callback_target);
-static RygelMediaObject* rygel_simple_container_real_find_object_finish (RygelMediaContainer* base, GAsyncResult* res, GError** error);
-void rygel_simple_async_result_complete (RygelSimpleAsyncResult* self);
-static void rygel_simple_container_finalize (GObject* obj);
-static int _vala_strcmp0 (const char * str1, const char * str2);
-
-
-
-RygelSimpleContainer* rygel_simple_container_construct (GType object_type, const char* id, RygelMediaContainer* parent, const char* title) {
-	RygelSimpleContainer * self;
-	GeeArrayList* _tmp0_;
-	GeeArrayList* _tmp1_;
-	g_return_val_if_fail (id != NULL, NULL);
-	g_return_val_if_fail (title != NULL, NULL);
-	self = (RygelSimpleContainer*) rygel_media_container_construct (object_type, id, parent, title, (guint) 0);
-	self->children = (_tmp0_ = gee_array_list_new (RYGEL_TYPE_MEDIA_OBJECT, (GBoxedCopyFunc) g_object_ref, g_object_unref, g_direct_equal), _g_object_unref0 (self->children), _tmp0_);
-	self->priv->searches = (_tmp1_ = gee_array_list_new (RYGEL_TYPE_MEDIA_OBJECT_SEARCH, (GBoxedCopyFunc) g_object_ref, g_object_unref, g_direct_equal), _g_object_unref0 (self->priv->searches), _tmp1_);
-	return self;
-}
-
-
-RygelSimpleContainer* rygel_simple_container_new (const char* id, RygelMediaContainer* parent, const char* title) {
-	return rygel_simple_container_construct (RYGEL_TYPE_SIMPLE_CONTAINER, id, parent, title);
-}
-
-
-RygelSimpleContainer* rygel_simple_container_construct_root (GType object_type, const char* title) {
-	RygelSimpleContainer * self;
-	g_return_val_if_fail (title != NULL, NULL);
-	self = (RygelSimpleContainer*) rygel_simple_container_construct (object_type, "0", NULL, title);
-	return self;
-}
-
-
-RygelSimpleContainer* rygel_simple_container_new_root (const char* title) {
-	return rygel_simple_container_construct_root (RYGEL_TYPE_SIMPLE_CONTAINER, title);
-}
-
-
-void rygel_simple_container_add_child (RygelSimpleContainer* self, RygelMediaObject* child) {
-	g_return_if_fail (self != NULL);
-	g_return_if_fail (child != NULL);
-	gee_abstract_collection_add ((GeeAbstractCollection*) self->children, child);
-	((RygelMediaContainer*) self)->child_count++;
-}
-
-
-void rygel_simple_container_remove_child (RygelSimpleContainer* self, RygelMediaObject* child) {
-	g_return_if_fail (self != NULL);
-	g_return_if_fail (child != NULL);
-	gee_abstract_collection_remove ((GeeAbstractCollection*) self->children, child);
-	((RygelMediaContainer*) self)->child_count--;
-}
-
-
-static gpointer _g_object_ref0 (gpointer self) {
-	return self ? g_object_ref (self) : NULL;
-}
-
-
-static void rygel_simple_container_real_get_children (RygelMediaContainer* base, guint offset, guint max_count, GCancellable* cancellable, GAsyncReadyCallback callback, void* callback_target) {
-	RygelSimpleContainer * self;
-	guint stop;
-	GeeList* media_objects;
-	RygelSimpleAsyncResult* res;
-	GeeList* _tmp0_;
-	self = (RygelSimpleContainer*) base;
-	stop = offset + max_count;
-	stop = CLAMP (stop, (guint) 0, ((RygelMediaContainer*) self)->child_count);
-	media_objects = gee_abstract_list_slice ((GeeAbstractList*) self->children, (gint) offset, (gint) stop);
-	res = rygel_simple_async_result_new (GEE_TYPE_LIST, (GBoxedCopyFunc) g_object_ref, g_object_unref, (GObject*) self, callback, callback_target);
-	res->data = (_tmp0_ = _g_object_ref0 (media_objects), _g_object_unref0 (res->data), _tmp0_);
-	rygel_simple_async_result_complete_in_idle (res);
-	_g_object_unref0 (media_objects);
-	_g_object_unref0 (res);
-}
-
-
-static GeeList* rygel_simple_container_real_get_children_finish (RygelMediaContainer* base, GAsyncResult* res, GError** error) {
-	RygelSimpleContainer * self;
-	GeeList* result;
-	RygelSimpleAsyncResult* simple_res;
-	self = (RygelSimpleContainer*) base;
-	g_return_val_if_fail (res != NULL, NULL);
-	simple_res = _g_object_ref0 (RYGEL_SIMPLE_ASYNC_RESULT (res));
-	result = _g_object_ref0 ((GeeList*) simple_res->data);
-	_g_object_unref0 (simple_res);
-	return result;
-}
-
-
-static void _rygel_simple_container_on_object_search_completed_rygel_state_machine_completed (RygelStateMachine* _sender, gpointer self) {
-	rygel_simple_container_on_object_search_completed (self, _sender);
-}
-
-
-static void rygel_simple_container_real_find_object (RygelMediaContainer* base, const char* id, GCancellable* cancellable, GAsyncReadyCallback callback, void* callback_target) {
-	RygelSimpleContainer * self;
-	RygelSimpleAsyncResult* res;
-	RygelMediaObject* child;
-	self = (RygelSimpleContainer*) base;
-	g_return_if_fail (id != NULL);
-	res = rygel_simple_async_result_new (RYGEL_TYPE_MEDIA_OBJECT, (GBoxedCopyFunc) g_object_ref, g_object_unref, (GObject*) self, callback, callback_target);
-	child = NULL;
-	{
-		GeeIterator* _tmp_it;
-		_tmp_it = gee_abstract_collection_iterator ((GeeAbstractCollection*) self->children);
-		while (TRUE) {
-			RygelMediaObject* tmp;
-			if (!gee_iterator_next (_tmp_it)) {
-				break;
-			}
-			tmp = (RygelMediaObject*) gee_iterator_get (_tmp_it);
-			if (_vala_strcmp0 (id, tmp->id) == 0) {
-				RygelMediaObject* _tmp0_;
-				child = (_tmp0_ = _g_object_ref0 (tmp), _g_object_unref0 (child), _tmp0_);
-				_g_object_unref0 (tmp);
-				break;
-			}
-			_g_object_unref0 (tmp);
-		}
-		_g_object_unref0 (_tmp_it);
-	}
-	if (child != NULL) {
-		RygelMediaObject* _tmp1_;
-		res->data = (_tmp1_ = _g_object_ref0 (child), _g_object_unref0 (res->data), _tmp1_);
-		rygel_simple_async_result_complete_in_idle (res);
-	} else {
-		GeeArrayList* containers;
-		RygelMediaObjectSearch* search;
-		containers = gee_array_list_new (RYGEL_TYPE_MEDIA_CONTAINER, (GBoxedCopyFunc) g_object_ref, g_object_unref, g_direct_equal);
-		{
-			GeeIterator* _tmp_it;
-			_tmp_it = gee_abstract_collection_iterator ((GeeAbstractCollection*) self->children);
-			while (TRUE) {
-				RygelMediaObject* tmp;
-				if (!gee_iterator_next (_tmp_it)) {
-					break;
-				}
-				tmp = (RygelMediaObject*) gee_iterator_get (_tmp_it);
-				if (RYGEL_IS_MEDIA_CONTAINER (tmp)) {
-					RygelMediaObject* _tmp2_;
-					gee_abstract_collection_add ((GeeAbstractCollection*) containers, (_tmp2_ = tmp, RYGEL_IS_MEDIA_CONTAINER (_tmp2_) ? ((RygelMediaContainer*) _tmp2_) : NULL));
-				}
-				_g_object_unref0 (tmp);
-			}
-			_g_object_unref0 (_tmp_it);
-		}
-		search = rygel_media_object_search_new (RYGEL_TYPE_SIMPLE_ASYNC_RESULT, (GBoxedCopyFunc) g_object_ref, g_object_unref, id, containers, res, cancellable);
-		g_signal_connect_object ((RygelStateMachine*) search, "completed", (GCallback) _rygel_simple_container_on_object_search_completed_rygel_state_machine_completed, self, 0);
-		gee_abstract_collection_add ((GeeAbstractCollection*) self->priv->searches, search);
-		rygel_state_machine_run ((RygelStateMachine*) search);
-		_g_object_unref0 (containers);
-		_g_object_unref0 (search);
-	}
-	_g_object_unref0 (res);
-	_g_object_unref0 (child);
-}
-
-
-static gpointer _g_error_copy0 (gpointer self) {
-	return self ? g_error_copy (self) : NULL;
-}
-
-
-static RygelMediaObject* rygel_simple_container_real_find_object_finish (RygelMediaContainer* base, GAsyncResult* res, GError** error) {
-	RygelSimpleContainer * self;
-	RygelMediaObject* result;
-	GError * _inner_error_;
-	RygelSimpleAsyncResult* simple_res;
-	self = (RygelSimpleContainer*) base;
-	g_return_val_if_fail (res != NULL, NULL);
-	_inner_error_ = NULL;
-	simple_res = _g_object_ref0 (RYGEL_SIMPLE_ASYNC_RESULT (res));
-	if (simple_res->error != NULL) {
-		_inner_error_ = _g_error_copy0 (simple_res->error);
-		if (_inner_error_ != NULL) {
-			g_propagate_error (error, _inner_error_);
-			_g_object_unref0 (simple_res);
-			return NULL;
-		}
-	} else {
-		result = _g_object_ref0 ((RygelMediaObject*) simple_res->data);
-		_g_object_unref0 (simple_res);
-		return result;
-	}
-	_g_object_unref0 (simple_res);
-}
-
-
-static void rygel_simple_container_on_object_search_completed (RygelSimpleContainer* self, RygelStateMachine* state_machine) {
-	RygelStateMachine* _tmp0_;
-	RygelMediaObjectSearch* search;
-	RygelMediaObject* _tmp1_;
-	GError* _tmp2_;
-	g_return_if_fail (self != NULL);
-	g_return_if_fail (state_machine != NULL);
-	search = _g_object_ref0 ((_tmp0_ = state_machine, RYGEL_IS_MEDIA_OBJECT_SEARCH (_tmp0_) ? ((RygelMediaObjectSearch*) _tmp0_) : NULL));
-	((RygelSimpleAsyncResult*) search->data)->data = (_tmp1_ = _g_object_ref0 (search->media_object), _g_object_unref0 (((RygelSimpleAsyncResult*) search->data)->data), _tmp1_);
-	((RygelSimpleAsyncResult*) search->data)->error = (_tmp2_ = _g_error_copy0 (search->error), _g_error_free0 (((RygelSimpleAsyncResult*) search->data)->error), _tmp2_);
-	rygel_simple_async_result_complete ((RygelSimpleAsyncResult*) search->data);
-	gee_abstract_collection_remove ((GeeAbstractCollection*) self->priv->searches, search);
-	_g_object_unref0 (search);
-}
-
-
-static void rygel_simple_container_class_init (RygelSimpleContainerClass * klass) {
-	rygel_simple_container_parent_class = g_type_class_peek_parent (klass);
-	g_type_class_add_private (klass, sizeof (RygelSimpleContainerPrivate));
-	RYGEL_MEDIA_CONTAINER_CLASS (klass)->get_children = rygel_simple_container_real_get_children;
-	RYGEL_MEDIA_CONTAINER_CLASS (klass)->get_children_finish = rygel_simple_container_real_get_children_finish;
-	RYGEL_MEDIA_CONTAINER_CLASS (klass)->find_object = rygel_simple_container_real_find_object;
-	RYGEL_MEDIA_CONTAINER_CLASS (klass)->find_object_finish = rygel_simple_container_real_find_object_finish;
-	G_OBJECT_CLASS (klass)->finalize = rygel_simple_container_finalize;
-}
-
-
-static void rygel_simple_container_instance_init (RygelSimpleContainer * self) {
-	self->priv = RYGEL_SIMPLE_CONTAINER_GET_PRIVATE (self);
-}
-
-
-static void rygel_simple_container_finalize (GObject* obj) {
-	RygelSimpleContainer * self;
-	self = RYGEL_SIMPLE_CONTAINER (obj);
-	_g_object_unref0 (self->children);
-	_g_object_unref0 (self->priv->searches);
-	G_OBJECT_CLASS (rygel_simple_container_parent_class)->finalize (obj);
-}
-
-
-GType rygel_simple_container_get_type (void) {
-	static GType rygel_simple_container_type_id = 0;
-	if (rygel_simple_container_type_id == 0) {
-		static const GTypeInfo g_define_type_info = { sizeof (RygelSimpleContainerClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) rygel_simple_container_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (RygelSimpleContainer), 0, (GInstanceInitFunc) rygel_simple_container_instance_init, NULL };
-		rygel_simple_container_type_id = g_type_register_static (RYGEL_TYPE_MEDIA_CONTAINER, "RygelSimpleContainer", &g_define_type_info, 0);
-	}
-	return rygel_simple_container_type_id;
-}
-
-
-static int _vala_strcmp0 (const char * str1, const char * str2) {
-	if (str1 == NULL) {
-		return -(str1 != str2);
-	}
-	if (str2 == NULL) {
-		return str1 != str2;
-	}
-	return strcmp (str1, str2);
-}
-
-
-
-
--- a/src/rygel/rygel-state-machine.c
+++ /dev/null
@@ -1,93 +0,0 @@
-/* rygel-state-machine.c generated by valac, the Vala compiler
- * generated from rygel-state-machine.vala, do not modify */
-
-/*
- * Copyright (C) 2008, 2009 Nokia Corporation.
- *
- * Author: Zeeshan Ali (Khattak) <zeeshanak@gnome.org>
- *                               <zeeshan.ali@nokia.com>
- *
- * This file is part of Rygel.
- *
- * Rygel is free software; you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * Rygel is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this program; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
- */
-
-#include <glib.h>
-#include <glib-object.h>
-#include <gio/gio.h>
-
-
-#define RYGEL_TYPE_STATE_MACHINE (rygel_state_machine_get_type ())
-#define RYGEL_STATE_MACHINE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_STATE_MACHINE, RygelStateMachine))
-#define RYGEL_IS_STATE_MACHINE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_STATE_MACHINE))
-#define RYGEL_STATE_MACHINE_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), RYGEL_TYPE_STATE_MACHINE, RygelStateMachineIface))
-
-typedef struct _RygelStateMachine RygelStateMachine;
-typedef struct _RygelStateMachineIface RygelStateMachineIface;
-
-struct _RygelStateMachineIface {
-	GTypeInterface parent_iface;
-	void (*run) (RygelStateMachine* self);
-	GCancellable* (*get_cancellable) (RygelStateMachine* self);
-	void (*set_cancellable) (RygelStateMachine* self, GCancellable* value);
-};
-
-
-
-GType rygel_state_machine_get_type (void);
-void rygel_state_machine_run (RygelStateMachine* self);
-GCancellable* rygel_state_machine_get_cancellable (RygelStateMachine* self);
-void rygel_state_machine_set_cancellable (RygelStateMachine* self, GCancellable* value);
-
-
-
-void rygel_state_machine_run (RygelStateMachine* self) {
-	RYGEL_STATE_MACHINE_GET_INTERFACE (self)->run (self);
-}
-
-
-GCancellable* rygel_state_machine_get_cancellable (RygelStateMachine* self) {
-	return RYGEL_STATE_MACHINE_GET_INTERFACE (self)->get_cancellable (self);
-}
-
-
-void rygel_state_machine_set_cancellable (RygelStateMachine* self, GCancellable* value) {
-	RYGEL_STATE_MACHINE_GET_INTERFACE (self)->set_cancellable (self, value);
-}
-
-
-static void rygel_state_machine_base_init (RygelStateMachineIface * iface) {
-	static gboolean initialized = FALSE;
-	if (!initialized) {
-		initialized = TRUE;
-		g_object_interface_install_property (iface, g_param_spec_object ("cancellable", "cancellable", "cancellable", G_TYPE_CANCELLABLE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
-		g_signal_new ("completed", RYGEL_TYPE_STATE_MACHINE, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, 0);
-	}
-}
-
-
-GType rygel_state_machine_get_type (void) {
-	static GType rygel_state_machine_type_id = 0;
-	if (rygel_state_machine_type_id == 0) {
-		static const GTypeInfo g_define_type_info = { sizeof (RygelStateMachineIface), (GBaseInitFunc) rygel_state_machine_base_init, (GBaseFinalizeFunc) NULL, (GClassInitFunc) NULL, (GClassFinalizeFunc) NULL, NULL, 0, 0, (GInstanceInitFunc) NULL, NULL };
-		rygel_state_machine_type_id = g_type_register_static (G_TYPE_INTERFACE, "RygelStateMachine", &g_define_type_info, 0);
-		g_type_interface_add_prerequisite (rygel_state_machine_type_id, G_TYPE_OBJECT);
-	}
-	return rygel_state_machine_type_id;
-}
-
-
-
-
--- a/src/rygel/rygel-thumbnail.c
+++ /dev/null
@@ -1,189 +0,0 @@
-/* rygel-thumbnail.c generated by valac, the Vala compiler
- * generated from rygel-thumbnail.vala, do not modify */
-
-/*
- * Copyright (C) 2008 Zeeshan Ali <zeenix@gmail.com>.
- *
- * Author: Zeeshan Ali <zeenix@gmail.com>
- *
- * This file is part of Rygel.
- *
- * Rygel is free software; you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * Rygel is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this program; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
- */
-
-#include <glib.h>
-#include <glib-object.h>
-#include <stdlib.h>
-#include <string.h>
-#include <libgupnp-av/gupnp-av.h>
-
-
-#define RYGEL_TYPE_ICON_INFO (rygel_icon_info_get_type ())
-#define RYGEL_ICON_INFO(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_ICON_INFO, RygelIconInfo))
-#define RYGEL_ICON_INFO_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_ICON_INFO, RygelIconInfoClass))
-#define RYGEL_IS_ICON_INFO(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_ICON_INFO))
-#define RYGEL_IS_ICON_INFO_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_ICON_INFO))
-#define RYGEL_ICON_INFO_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_ICON_INFO, RygelIconInfoClass))
-
-typedef struct _RygelIconInfo RygelIconInfo;
-typedef struct _RygelIconInfoClass RygelIconInfoClass;
-typedef struct _RygelIconInfoPrivate RygelIconInfoPrivate;
-
-#define RYGEL_TYPE_THUMBNAIL (rygel_thumbnail_get_type ())
-#define RYGEL_THUMBNAIL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_THUMBNAIL, RygelThumbnail))
-#define RYGEL_THUMBNAIL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_THUMBNAIL, RygelThumbnailClass))
-#define RYGEL_IS_THUMBNAIL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_THUMBNAIL))
-#define RYGEL_IS_THUMBNAIL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_THUMBNAIL))
-#define RYGEL_THUMBNAIL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_THUMBNAIL, RygelThumbnailClass))
-
-typedef struct _RygelThumbnail RygelThumbnail;
-typedef struct _RygelThumbnailClass RygelThumbnailClass;
-typedef struct _RygelThumbnailPrivate RygelThumbnailPrivate;
-#define _g_free0(var) (var = (g_free (var), NULL))
-#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
-
-struct _RygelIconInfo {
-	GTypeInstance parent_instance;
-	volatile int ref_count;
-	RygelIconInfoPrivate * priv;
-	char* mime_type;
-	char* path;
-	glong size;
-	gint width;
-	gint height;
-	gint depth;
-};
-
-struct _RygelIconInfoClass {
-	GTypeClass parent_class;
-	void (*finalize) (RygelIconInfo *self);
-};
-
-struct _RygelThumbnail {
-	RygelIconInfo parent_instance;
-	RygelThumbnailPrivate * priv;
-	char* uri;
-	char* dlna_profile;
-};
-
-struct _RygelThumbnailClass {
-	RygelIconInfoClass parent_class;
-};
-
-
-static gpointer rygel_thumbnail_parent_class = NULL;
-
-gpointer rygel_icon_info_ref (gpointer instance);
-void rygel_icon_info_unref (gpointer instance);
-GParamSpec* rygel_param_spec_icon_info (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
-void rygel_value_set_icon_info (GValue* value, gpointer v_object);
-gpointer rygel_value_get_icon_info (const GValue* value);
-GType rygel_icon_info_get_type (void);
-GType rygel_thumbnail_get_type (void);
-enum  {
-	RYGEL_THUMBNAIL_DUMMY_PROPERTY
-};
-RygelIconInfo* rygel_icon_info_new (const char* mime_type);
-RygelIconInfo* rygel_icon_info_construct (GType object_type, const char* mime_type);
-RygelThumbnail* rygel_thumbnail_new (const char* mime_type, const char* dlna_profile);
-RygelThumbnail* rygel_thumbnail_construct (GType object_type, const char* mime_type, const char* dlna_profile);
-static GUPnPProtocolInfo* rygel_thumbnail_get_protocol_info (RygelThumbnail* self, const char* protocol);
-GUPnPDIDLLiteResource* rygel_thumbnail_add_resource (RygelThumbnail* self, GUPnPDIDLLiteItem* didl_item, const char* protocol);
-static void rygel_thumbnail_finalize (RygelIconInfo* obj);
-
-
-
-RygelThumbnail* rygel_thumbnail_construct (GType object_type, const char* mime_type, const char* dlna_profile) {
-	RygelThumbnail* self;
-	char* _tmp0_;
-	g_return_val_if_fail (mime_type != NULL, NULL);
-	g_return_val_if_fail (dlna_profile != NULL, NULL);
-	self = (RygelThumbnail*) rygel_icon_info_construct (object_type, mime_type);
-	self->dlna_profile = (_tmp0_ = g_strdup (dlna_profile), _g_free0 (self->dlna_profile), _tmp0_);
-	return self;
-}
-
-
-RygelThumbnail* rygel_thumbnail_new (const char* mime_type, const char* dlna_profile) {
-	return rygel_thumbnail_construct (RYGEL_TYPE_THUMBNAIL, mime_type, dlna_profile);
-}
-
-
-GUPnPDIDLLiteResource* rygel_thumbnail_add_resource (RygelThumbnail* self, GUPnPDIDLLiteItem* didl_item, const char* protocol) {
-	GUPnPDIDLLiteResource* result;
-	GUPnPDIDLLiteResource* res;
-	GUPnPProtocolInfo* _tmp0_;
-	g_return_val_if_fail (self != NULL, NULL);
-	g_return_val_if_fail (didl_item != NULL, NULL);
-	g_return_val_if_fail (protocol != NULL, NULL);
-	res = gupnp_didl_lite_object_add_resource ((GUPnPDIDLLiteObject*) didl_item);
-	gupnp_didl_lite_resource_set_uri (res, self->uri);
-	gupnp_didl_lite_resource_set_size (res, ((RygelIconInfo*) self)->size);
-	gupnp_didl_lite_resource_set_width (res, ((RygelIconInfo*) self)->width);
-	gupnp_didl_lite_resource_set_height (res, ((RygelIconInfo*) self)->height);
-	gupnp_didl_lite_resource_set_color_depth (res, ((RygelIconInfo*) self)->depth);
-	gupnp_didl_lite_resource_set_protocol_info (res, _tmp0_ = rygel_thumbnail_get_protocol_info (self, protocol));
-	_g_object_unref0 (_tmp0_);
-	result = res;
-	return result;
-}
-
-
-static GUPnPProtocolInfo* rygel_thumbnail_get_protocol_info (RygelThumbnail* self, const char* protocol) {
-	GUPnPProtocolInfo* result;
-	GUPnPProtocolInfo* protocol_info;
-	g_return_val_if_fail (self != NULL, NULL);
-	g_return_val_if_fail (protocol != NULL, NULL);
-	protocol_info = gupnp_protocol_info_new ();
-	gupnp_protocol_info_set_mime_type (protocol_info, ((RygelIconInfo*) self)->mime_type);
-	gupnp_protocol_info_set_dlna_profile (protocol_info, self->dlna_profile);
-	gupnp_protocol_info_set_protocol (protocol_info, protocol);
-	gupnp_protocol_info_set_dlna_flags (protocol_info, gupnp_protocol_info_get_dlna_flags (protocol_info) | (GUPNP_DLNA_FLAGS_INTERACTIVE_TRANSFER_MODE | GUPNP_DLNA_FLAGS_BACKGROUND_TRANSFER_MODE));
-	result = protocol_info;
-	return result;
-}
-
-
-static void rygel_thumbnail_class_init (RygelThumbnailClass * klass) {
-	rygel_thumbnail_parent_class = g_type_class_peek_parent (klass);
-	RYGEL_ICON_INFO_CLASS (klass)->finalize = rygel_thumbnail_finalize;
-}
-
-
-static void rygel_thumbnail_instance_init (RygelThumbnail * self) {
-}
-
-
-static void rygel_thumbnail_finalize (RygelIconInfo* obj) {
-	RygelThumbnail * self;
-	self = RYGEL_THUMBNAIL (obj);
-	_g_free0 (self->uri);
-	_g_free0 (self->dlna_profile);
-	RYGEL_ICON_INFO_CLASS (rygel_thumbnail_parent_class)->finalize (obj);
-}
-
-
-GType rygel_thumbnail_get_type (void) {
-	static GType rygel_thumbnail_type_id = 0;
-	if (rygel_thumbnail_type_id == 0) {
-		static const GTypeInfo g_define_type_info = { sizeof (RygelThumbnailClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) rygel_thumbnail_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (RygelThumbnail), 0, (GInstanceInitFunc) rygel_thumbnail_instance_init, NULL };
-		rygel_thumbnail_type_id = g_type_register_static (RYGEL_TYPE_ICON_INFO, "RygelThumbnail", &g_define_type_info, 0);
-	}
-	return rygel_thumbnail_type_id;
-}
-
-
-
-
--- a/src/rygel/rygel-thumbnailer.c
+++ /dev/null
@@ -1,363 +0,0 @@
-/* rygel-thumbnailer.c generated by valac, the Vala compiler
- * generated from rygel-thumbnailer.vala, do not modify */
-
-/*
- * Copyright (C) 2008 Zeeshan Ali <zeenix@gmail.com>.
- *
- * Author: Zeeshan Ali <zeenix@gmail.com>
- *
- * This file is part of Rygel.
- *
- * Rygel is free software; you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * Rygel is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this program; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
- */
-
-#include <glib.h>
-#include <glib-object.h>
-#include <stdlib.h>
-#include <string.h>
-#include <gio/gio.h>
-
-
-#define RYGEL_TYPE_THUMBNAILER (rygel_thumbnailer_get_type ())
-#define RYGEL_THUMBNAILER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_THUMBNAILER, RygelThumbnailer))
-#define RYGEL_THUMBNAILER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_THUMBNAILER, RygelThumbnailerClass))
-#define RYGEL_IS_THUMBNAILER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_THUMBNAILER))
-#define RYGEL_IS_THUMBNAILER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_THUMBNAILER))
-#define RYGEL_THUMBNAILER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_THUMBNAILER, RygelThumbnailerClass))
-
-typedef struct _RygelThumbnailer RygelThumbnailer;
-typedef struct _RygelThumbnailerClass RygelThumbnailerClass;
-typedef struct _RygelThumbnailerPrivate RygelThumbnailerPrivate;
-
-#define RYGEL_TYPE_ICON_INFO (rygel_icon_info_get_type ())
-#define RYGEL_ICON_INFO(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_ICON_INFO, RygelIconInfo))
-#define RYGEL_ICON_INFO_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_ICON_INFO, RygelIconInfoClass))
-#define RYGEL_IS_ICON_INFO(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_ICON_INFO))
-#define RYGEL_IS_ICON_INFO_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_ICON_INFO))
-#define RYGEL_ICON_INFO_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_ICON_INFO, RygelIconInfoClass))
-
-typedef struct _RygelIconInfo RygelIconInfo;
-typedef struct _RygelIconInfoClass RygelIconInfoClass;
-
-#define RYGEL_TYPE_THUMBNAIL (rygel_thumbnail_get_type ())
-#define RYGEL_THUMBNAIL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_THUMBNAIL, RygelThumbnail))
-#define RYGEL_THUMBNAIL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_THUMBNAIL, RygelThumbnailClass))
-#define RYGEL_IS_THUMBNAIL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_THUMBNAIL))
-#define RYGEL_IS_THUMBNAIL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_THUMBNAIL))
-#define RYGEL_THUMBNAIL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_THUMBNAIL, RygelThumbnailClass))
-
-typedef struct _RygelThumbnail RygelThumbnail;
-typedef struct _RygelThumbnailClass RygelThumbnailClass;
-#define _g_free0(var) (var = (g_free (var), NULL))
-#define _rygel_icon_info_unref0(var) ((var == NULL) ? NULL : (var = (rygel_icon_info_unref (var), NULL)))
-#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
-typedef struct _RygelIconInfoPrivate RygelIconInfoPrivate;
-typedef struct _RygelThumbnailPrivate RygelThumbnailPrivate;
-#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
-
-typedef enum  {
-	THUMBNAILER_ERROR_NO_DIR,
-	THUMBNAILER_ERROR_NO_THUMBNAIL
-} ThumbnailerError;
-#define THUMBNAILER_ERROR thumbnailer_error_quark ()
-struct _RygelThumbnailer {
-	GObject parent_instance;
-	RygelThumbnailerPrivate * priv;
-	char* directory;
-};
-
-struct _RygelThumbnailerClass {
-	GObjectClass parent_class;
-};
-
-struct _RygelThumbnailerPrivate {
-	RygelThumbnail* template;
-	char* extension;
-};
-
-struct _RygelIconInfo {
-	GTypeInstance parent_instance;
-	volatile int ref_count;
-	RygelIconInfoPrivate * priv;
-	char* mime_type;
-	char* path;
-	glong size;
-	gint width;
-	gint height;
-	gint depth;
-};
-
-struct _RygelIconInfoClass {
-	GTypeClass parent_class;
-	void (*finalize) (RygelIconInfo *self);
-};
-
-struct _RygelThumbnail {
-	RygelIconInfo parent_instance;
-	RygelThumbnailPrivate * priv;
-	char* uri;
-	char* dlna_profile;
-};
-
-struct _RygelThumbnailClass {
-	RygelIconInfoClass parent_class;
-};
-
-
-static RygelThumbnailer* rygel_thumbnailer_thumbnailer;
-static RygelThumbnailer* rygel_thumbnailer_thumbnailer = NULL;
-static gboolean rygel_thumbnailer_first_time;
-static gboolean rygel_thumbnailer_first_time = TRUE;
-static gpointer rygel_thumbnailer_parent_class = NULL;
-
-GQuark thumbnailer_error_quark (void);
-GType rygel_thumbnailer_get_type (void);
-gpointer rygel_icon_info_ref (gpointer instance);
-void rygel_icon_info_unref (gpointer instance);
-GParamSpec* rygel_param_spec_icon_info (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
-void rygel_value_set_icon_info (GValue* value, gpointer v_object);
-gpointer rygel_value_get_icon_info (const GValue* value);
-GType rygel_icon_info_get_type (void);
-GType rygel_thumbnail_get_type (void);
-#define RYGEL_THUMBNAILER_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), RYGEL_TYPE_THUMBNAILER, RygelThumbnailerPrivate))
-enum  {
-	RYGEL_THUMBNAILER_DUMMY_PROPERTY
-};
-RygelThumbnail* rygel_thumbnail_new (const char* mime_type, const char* dlna_profile);
-RygelThumbnail* rygel_thumbnail_construct (GType object_type, const char* mime_type, const char* dlna_profile);
-static RygelThumbnailer* rygel_thumbnailer_new (GError** error);
-static RygelThumbnailer* rygel_thumbnailer_construct (GType object_type, GError** error);
-RygelThumbnailer* rygel_thumbnailer_get_default (void);
-RygelThumbnail* rygel_thumbnailer_get_thumbnail (RygelThumbnailer* self, const char* uri, GError** error);
-static void rygel_thumbnailer_finalize (GObject* obj);
-
-
-
-GQuark thumbnailer_error_quark (void) {
-	return g_quark_from_static_string ("thumbnailer_error-quark");
-}
-
-
-static RygelThumbnailer* rygel_thumbnailer_construct (GType object_type, GError** error) {
-	GError * _inner_error_;
-	RygelThumbnailer * self;
-	char* dir;
-	GFile* file;
-	RygelThumbnail* _tmp0_;
-	char* _tmp7_;
-	_inner_error_ = NULL;
-	self = (RygelThumbnailer*) g_object_new (object_type, NULL);
-	dir = g_build_filename (g_get_home_dir (), ".thumbnails", "cropped", NULL);
-	file = g_file_new_for_path (dir);
-	self->priv->template = (_tmp0_ = rygel_thumbnail_new ("image/jpeg", "JPEG_TN"), _rygel_icon_info_unref0 (self->priv->template), _tmp0_);
-	if (!g_file_query_exists (file, NULL)) {
-		char* _tmp1_;
-		GFile* _tmp2_;
-		dir = (_tmp1_ = g_build_filename (g_get_home_dir (), ".thumbnails", "normal", NULL), _g_free0 (dir), _tmp1_);
-		file = (_tmp2_ = g_file_new_for_path (dir), _g_object_unref0 (file), _tmp2_);
-		if (!g_file_query_exists (file, NULL)) {
-			_inner_error_ = g_error_new_literal (THUMBNAILER_ERROR, THUMBNAILER_ERROR_NO_DIR, "Failed to find thumbnails directory");
-			if (_inner_error_ != NULL) {
-				if (_inner_error_->domain == THUMBNAILER_ERROR) {
-					g_propagate_error (error, _inner_error_);
-					_g_free0 (dir);
-					_g_object_unref0 (file);
-					return;
-				} else {
-					_g_free0 (dir);
-					_g_object_unref0 (file);
-					g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
-					g_clear_error (&_inner_error_);
-					return NULL;
-				}
-			}
-		} else {
-			char* _tmp3_;
-			char* _tmp4_;
-			char* _tmp5_;
-			((RygelIconInfo*) self->priv->template)->mime_type = (_tmp3_ = g_strdup ("image/png"), _g_free0 (((RygelIconInfo*) self->priv->template)->mime_type), _tmp3_);
-			self->priv->template->dlna_profile = (_tmp4_ = g_strdup ("PNG_TN"), _g_free0 (self->priv->template->dlna_profile), _tmp4_);
-			((RygelIconInfo*) self->priv->template)->width = 128;
-			((RygelIconInfo*) self->priv->template)->height = 128;
-			((RygelIconInfo*) self->priv->template)->depth = 32;
-			self->priv->extension = (_tmp5_ = g_strdup (".png"), _g_free0 (self->priv->extension), _tmp5_);
-		}
-	} else {
-		char* _tmp6_;
-		((RygelIconInfo*) self->priv->template)->width = 124;
-		((RygelIconInfo*) self->priv->template)->height = 124;
-		((RygelIconInfo*) self->priv->template)->depth = 24;
-		self->priv->extension = (_tmp6_ = g_strdup (".jpeg"), _g_free0 (self->priv->extension), _tmp6_);
-	}
-	self->directory = (_tmp7_ = g_strdup (dir), _g_free0 (self->directory), _tmp7_);
-	_g_free0 (dir);
-	_g_object_unref0 (file);
-	return self;
-}
-
-
-static RygelThumbnailer* rygel_thumbnailer_new (GError** error) {
-	return rygel_thumbnailer_construct (RYGEL_TYPE_THUMBNAILER, error);
-}
-
-
-static gpointer _g_object_ref0 (gpointer self) {
-	return self ? g_object_ref (self) : NULL;
-}
-
-
-RygelThumbnailer* rygel_thumbnailer_get_default (void) {
-	RygelThumbnailer* result;
-	GError * _inner_error_;
-	_inner_error_ = NULL;
-	if (rygel_thumbnailer_first_time) {
-		{
-			RygelThumbnailer* _tmp0_;
-			RygelThumbnailer* _tmp1_;
-			_tmp0_ = rygel_thumbnailer_new (&_inner_error_);
-			if (_inner_error_ != NULL) {
-				if (_inner_error_->domain == THUMBNAILER_ERROR) {
-					goto __catch34_thumbnailer_error;
-				}
-				goto __finally34;
-			}
-			rygel_thumbnailer_thumbnailer = (_tmp1_ = _tmp0_, _g_object_unref0 (rygel_thumbnailer_thumbnailer), _tmp1_);
-		}
-		goto __finally34;
-		__catch34_thumbnailer_error:
-		{
-			GError * err;
-			err = _inner_error_;
-			_inner_error_ = NULL;
-			{
-				g_warning ("rygel-thumbnailer.vala:81: No thumbnailer available: %s", err->message);
-				_g_error_free0 (err);
-			}
-		}
-		__finally34:
-		if (_inner_error_ != NULL) {
-			g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
-			g_clear_error (&_inner_error_);
-			return NULL;
-		}
-		rygel_thumbnailer_first_time = FALSE;
-	}
-	result = _g_object_ref0 (rygel_thumbnailer_thumbnailer);
-	return result;
-}
-
-
-RygelThumbnail* rygel_thumbnailer_get_thumbnail (RygelThumbnailer* self, const char* uri, GError** error) {
-	RygelThumbnail* result;
-	GError * _inner_error_;
-	RygelThumbnail* thumbnail;
-	char* _tmp0_;
-	char* _tmp1_;
-	char* path;
-	char* full_path;
-	GFile* file;
-	GFileInfo* info;
-	RygelThumbnail* _tmp2_;
-	char* _tmp3_;
-	char* _tmp4_;
-	char* _tmp5_;
-	g_return_val_if_fail (self != NULL, NULL);
-	g_return_val_if_fail (uri != NULL, NULL);
-	_inner_error_ = NULL;
-	thumbnail = NULL;
-	path = (_tmp1_ = g_strconcat (_tmp0_ = g_compute_checksum_for_string (G_CHECKSUM_MD5, uri, -1), self->priv->extension, NULL), _g_free0 (_tmp0_), _tmp1_);
-	full_path = g_build_filename (self->directory, path, NULL);
-	file = g_file_new_for_path (full_path);
-	info = g_file_query_info (file, G_FILE_ATTRIBUTE_ACCESS_CAN_READ "," G_FILE_ATTRIBUTE_STANDARD_SIZE, G_FILE_QUERY_INFO_NONE, NULL, &_inner_error_);
-	if (_inner_error_ != NULL) {
-		g_propagate_error (error, _inner_error_);
-		_rygel_icon_info_unref0 (thumbnail);
-		_g_free0 (path);
-		_g_free0 (full_path);
-		_g_object_unref0 (file);
-		return NULL;
-	}
-	if (!g_file_info_get_attribute_boolean (info, G_FILE_ATTRIBUTE_ACCESS_CAN_READ)) {
-		_inner_error_ = g_error_new_literal (THUMBNAILER_ERROR, THUMBNAILER_ERROR_NO_THUMBNAIL, "No thumbnail available");
-		if (_inner_error_ != NULL) {
-			g_propagate_error (error, _inner_error_);
-			_rygel_icon_info_unref0 (thumbnail);
-			_g_free0 (path);
-			_g_free0 (full_path);
-			_g_object_unref0 (file);
-			_g_object_unref0 (info);
-			return NULL;
-		}
-	}
-	thumbnail = (_tmp2_ = rygel_thumbnail_new ("image/jpeg", "JPEG_TN"), _rygel_icon_info_unref0 (thumbnail), _tmp2_);
-	((RygelIconInfo*) thumbnail)->width = ((RygelIconInfo*) self->priv->template)->width;
-	((RygelIconInfo*) thumbnail)->height = ((RygelIconInfo*) self->priv->template)->height;
-	((RygelIconInfo*) thumbnail)->depth = ((RygelIconInfo*) self->priv->template)->depth;
-	((RygelIconInfo*) thumbnail)->path = (_tmp3_ = g_strdup (path), _g_free0 (((RygelIconInfo*) thumbnail)->path), _tmp3_);
-	_tmp4_ = g_filename_to_uri (full_path, NULL, &_inner_error_);
-	if (_inner_error_ != NULL) {
-		g_propagate_error (error, _inner_error_);
-		_rygel_icon_info_unref0 (thumbnail);
-		_g_free0 (path);
-		_g_free0 (full_path);
-		_g_object_unref0 (file);
-		_g_object_unref0 (info);
-		return NULL;
-	}
-	thumbnail->uri = (_tmp5_ = _tmp4_, _g_free0 (thumbnail->uri), _tmp5_);
-	((RygelIconInfo*) thumbnail)->size = (glong) g_file_info_get_attribute_uint64 (info, G_FILE_ATTRIBUTE_STANDARD_SIZE);
-	result = thumbnail;
-	_g_free0 (path);
-	_g_free0 (full_path);
-	_g_object_unref0 (file);
-	_g_object_unref0 (info);
-	return result;
-}
-
-
-static void rygel_thumbnailer_class_init (RygelThumbnailerClass * klass) {
-	rygel_thumbnailer_parent_class = g_type_class_peek_parent (klass);
-	g_type_class_add_private (klass, sizeof (RygelThumbnailerPrivate));
-	G_OBJECT_CLASS (klass)->finalize = rygel_thumbnailer_finalize;
-}
-
-
-static void rygel_thumbnailer_instance_init (RygelThumbnailer * self) {
-	self->priv = RYGEL_THUMBNAILER_GET_PRIVATE (self);
-}
-
-
-static void rygel_thumbnailer_finalize (GObject* obj) {
-	RygelThumbnailer * self;
-	self = RYGEL_THUMBNAILER (obj);
-	_g_free0 (self->directory);
-	_rygel_icon_info_unref0 (self->priv->template);
-	_g_free0 (self->priv->extension);
-	G_OBJECT_CLASS (rygel_thumbnailer_parent_class)->finalize (obj);
-}
-
-
-GType rygel_thumbnailer_get_type (void) {
-	static GType rygel_thumbnailer_type_id = 0;
-	if (rygel_thumbnailer_type_id == 0) {
-		static const GTypeInfo g_define_type_info = { sizeof (RygelThumbnailerClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) rygel_thumbnailer_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (RygelThumbnailer), 0, (GInstanceInitFunc) rygel_thumbnailer_instance_init, NULL };
-		rygel_thumbnailer_type_id = g_type_register_static (G_TYPE_OBJECT, "RygelThumbnailer", &g_define_type_info, 0);
-	}
-	return rygel_thumbnailer_type_id;
-}
-
-
-
-
--- a/src/rygel/rygel-transcode-manager.c
+++ /dev/null
@@ -1,543 +0,0 @@
-/* rygel-transcode-manager.c generated by valac, the Vala compiler
- * generated from rygel-transcode-manager.vala, do not modify */
-
-/*
- * Copyright (C) 2009 Nokia Corporation.
- *
- * Author: Zeeshan Ali (Khattak) <zeeshanak@gnome.org>
- *                               <zeeshan.ali@nokia.com>
- *
- * This file is part of Rygel.
- *
- * Rygel is free software; you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * Rygel is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this program; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
- */
-
-#include <glib.h>
-#include <glib-object.h>
-#include <stdlib.h>
-#include <string.h>
-#include <libgupnp-av/gupnp-av.h>
-#include <gee.h>
-#include <libsoup/soup.h>
-
-
-#define RYGEL_TYPE_TRANSCODE_MANAGER (rygel_transcode_manager_get_type ())
-#define RYGEL_TRANSCODE_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_TRANSCODE_MANAGER, RygelTranscodeManager))
-#define RYGEL_TRANSCODE_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_TRANSCODE_MANAGER, RygelTranscodeManagerClass))
-#define RYGEL_IS_TRANSCODE_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_TRANSCODE_MANAGER))
-#define RYGEL_IS_TRANSCODE_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_TRANSCODE_MANAGER))
-#define RYGEL_TRANSCODE_MANAGER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_TRANSCODE_MANAGER, RygelTranscodeManagerClass))
-
-typedef struct _RygelTranscodeManager RygelTranscodeManager;
-typedef struct _RygelTranscodeManagerClass RygelTranscodeManagerClass;
-typedef struct _RygelTranscodeManagerPrivate RygelTranscodeManagerPrivate;
-
-#define RYGEL_TYPE_MEDIA_OBJECT (rygel_media_object_get_type ())
-#define RYGEL_MEDIA_OBJECT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_MEDIA_OBJECT, RygelMediaObject))
-#define RYGEL_MEDIA_OBJECT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_MEDIA_OBJECT, RygelMediaObjectClass))
-#define RYGEL_IS_MEDIA_OBJECT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_MEDIA_OBJECT))
-#define RYGEL_IS_MEDIA_OBJECT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_MEDIA_OBJECT))
-#define RYGEL_MEDIA_OBJECT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_MEDIA_OBJECT, RygelMediaObjectClass))
-
-typedef struct _RygelMediaObject RygelMediaObject;
-typedef struct _RygelMediaObjectClass RygelMediaObjectClass;
-
-#define RYGEL_TYPE_MEDIA_ITEM (rygel_media_item_get_type ())
-#define RYGEL_MEDIA_ITEM(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_MEDIA_ITEM, RygelMediaItem))
-#define RYGEL_MEDIA_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_MEDIA_ITEM, RygelMediaItemClass))
-#define RYGEL_IS_MEDIA_ITEM(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_MEDIA_ITEM))
-#define RYGEL_IS_MEDIA_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_MEDIA_ITEM))
-#define RYGEL_MEDIA_ITEM_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_MEDIA_ITEM, RygelMediaItemClass))
-
-typedef struct _RygelMediaItem RygelMediaItem;
-typedef struct _RygelMediaItemClass RygelMediaItemClass;
-
-#define RYGEL_TYPE_TRANSCODER (rygel_transcoder_get_type ())
-#define RYGEL_TRANSCODER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_TRANSCODER, RygelTranscoder))
-#define RYGEL_TRANSCODER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_TRANSCODER, RygelTranscoderClass))
-#define RYGEL_IS_TRANSCODER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_TRANSCODER))
-#define RYGEL_IS_TRANSCODER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_TRANSCODER))
-#define RYGEL_TRANSCODER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_TRANSCODER, RygelTranscoderClass))
-
-typedef struct _RygelTranscoder RygelTranscoder;
-typedef struct _RygelTranscoderClass RygelTranscoderClass;
-#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
-
-#define RYGEL_TYPE_META_CONFIG (rygel_meta_config_get_type ())
-#define RYGEL_META_CONFIG(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_META_CONFIG, RygelMetaConfig))
-#define RYGEL_META_CONFIG_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_META_CONFIG, RygelMetaConfigClass))
-#define RYGEL_IS_META_CONFIG(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_META_CONFIG))
-#define RYGEL_IS_META_CONFIG_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_META_CONFIG))
-#define RYGEL_META_CONFIG_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_META_CONFIG, RygelMetaConfigClass))
-
-typedef struct _RygelMetaConfig RygelMetaConfig;
-typedef struct _RygelMetaConfigClass RygelMetaConfigClass;
-
-#define RYGEL_TYPE_CONFIGURATION (rygel_configuration_get_type ())
-#define RYGEL_CONFIGURATION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_CONFIGURATION, RygelConfiguration))
-#define RYGEL_IS_CONFIGURATION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_CONFIGURATION))
-#define RYGEL_CONFIGURATION_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), RYGEL_TYPE_CONFIGURATION, RygelConfigurationIface))
-
-typedef struct _RygelConfiguration RygelConfiguration;
-typedef struct _RygelConfigurationIface RygelConfigurationIface;
-
-#define RYGEL_TYPE_LOG_LEVEL (rygel_log_level_get_type ())
-
-#define TYPE_ENDIANNESS (endianness_get_type ())
-
-#define RYGEL_TYPE_L16_TRANSCODER (rygel_l16_transcoder_get_type ())
-#define RYGEL_L16_TRANSCODER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_L16_TRANSCODER, RygelL16Transcoder))
-#define RYGEL_L16_TRANSCODER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_L16_TRANSCODER, RygelL16TranscoderClass))
-#define RYGEL_IS_L16_TRANSCODER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_L16_TRANSCODER))
-#define RYGEL_IS_L16_TRANSCODER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_L16_TRANSCODER))
-#define RYGEL_L16_TRANSCODER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_L16_TRANSCODER, RygelL16TranscoderClass))
-
-typedef struct _RygelL16Transcoder RygelL16Transcoder;
-typedef struct _RygelL16TranscoderClass RygelL16TranscoderClass;
-
-#define RYGEL_TYPE_MP3_LAYER (rygel_mp3_layer_get_type ())
-
-#define RYGEL_TYPE_MP3_TRANSCODER (rygel_mp3_transcoder_get_type ())
-#define RYGEL_MP3_TRANSCODER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_MP3_TRANSCODER, RygelMP3Transcoder))
-#define RYGEL_MP3_TRANSCODER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_MP3_TRANSCODER, RygelMP3TranscoderClass))
-#define RYGEL_IS_MP3_TRANSCODER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_MP3_TRANSCODER))
-#define RYGEL_IS_MP3_TRANSCODER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_MP3_TRANSCODER))
-#define RYGEL_MP3_TRANSCODER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_MP3_TRANSCODER, RygelMP3TranscoderClass))
-
-typedef struct _RygelMP3Transcoder RygelMP3Transcoder;
-typedef struct _RygelMP3TranscoderClass RygelMP3TranscoderClass;
-
-#define RYGEL_TYPE_MP2_TS_PROFILE (rygel_mp2_ts_profile_get_type ())
-
-#define RYGEL_TYPE_MP2_TS_TRANSCODER (rygel_mp2_ts_transcoder_get_type ())
-#define RYGEL_MP2_TS_TRANSCODER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_MP2_TS_TRANSCODER, RygelMP2TSTranscoder))
-#define RYGEL_MP2_TS_TRANSCODER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_MP2_TS_TRANSCODER, RygelMP2TSTranscoderClass))
-#define RYGEL_IS_MP2_TS_TRANSCODER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_MP2_TS_TRANSCODER))
-#define RYGEL_IS_MP2_TS_TRANSCODER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_MP2_TS_TRANSCODER))
-#define RYGEL_MP2_TS_TRANSCODER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_MP2_TS_TRANSCODER, RygelMP2TSTranscoderClass))
-
-typedef struct _RygelMP2TSTranscoder RygelMP2TSTranscoder;
-typedef struct _RygelMP2TSTranscoderClass RygelMP2TSTranscoderClass;
-#define __g_list_free_g_object_unref0(var) ((var == NULL) ? NULL : (var = (_g_list_free_g_object_unref (var), NULL)))
-#define _g_free0(var) (var = (g_free (var), NULL))
-
-struct _RygelTranscodeManager {
-	GObject parent_instance;
-	RygelTranscodeManagerPrivate * priv;
-};
-
-struct _RygelTranscodeManagerClass {
-	GObjectClass parent_class;
-	char* (*create_uri_for_item) (RygelTranscodeManager* self, RygelMediaItem* item, gint thumbnail_index, const char* transcode_target, char** protocol);
-	void (*add_resources) (RygelTranscodeManager* self, GUPnPDIDLLiteItem* didl_item, RygelMediaItem* item, GError** error);
-	char* (*get_protocol) (RygelTranscodeManager* self);
-	char* (*get_protocol_info) (RygelTranscodeManager* self);
-};
-
-struct _RygelTranscodeManagerPrivate {
-	GeeArrayList* transcoders;
-};
-
-typedef enum  {
-	RYGEL_LOG_LEVEL_INVALID = 0,
-	RYGEL_LOG_LEVEL_CRITICAL = 1,
-	RYGEL_LOG_LEVEL_ERROR = 2,
-	RYGEL_LOG_LEVEL_WARNING = 3,
-	RYGEL_LOG_LEVEL_INFO = 4,
-	RYGEL_LOG_LEVEL_DEFAULT = 4,
-	RYGEL_LOG_LEVEL_DEBUG = 5
-} RygelLogLevel;
-
-struct _RygelConfigurationIface {
-	GTypeInterface parent_iface;
-	gboolean (*get_upnp_enabled) (RygelConfiguration* self, GError** error);
-	char* (*get_interface) (RygelConfiguration* self, GError** error);
-	gint (*get_port) (RygelConfiguration* self, GError** error);
-	gboolean (*get_transcoding) (RygelConfiguration* self, GError** error);
-	gboolean (*get_mp3_transcoder) (RygelConfiguration* self, GError** error);
-	gboolean (*get_mp2ts_transcoder) (RygelConfiguration* self, GError** error);
-	gboolean (*get_lpcm_transcoder) (RygelConfiguration* self, GError** error);
-	RygelLogLevel (*get_log_level) (RygelConfiguration* self, GError** error);
-	gboolean (*get_enabled) (RygelConfiguration* self, const char* section, GError** error);
-	char* (*get_title) (RygelConfiguration* self, const char* section, GError** error);
-	char* (*get_string) (RygelConfiguration* self, const char* section, const char* key, GError** error);
-	GeeArrayList* (*get_string_list) (RygelConfiguration* self, const char* section, const char* key, GError** error);
-	gint (*get_int) (RygelConfiguration* self, const char* section, const char* key, gint min, gint max, GError** error);
-	GeeArrayList* (*get_int_list) (RygelConfiguration* self, const char* section, const char* key, GError** error);
-	gboolean (*get_bool) (RygelConfiguration* self, const char* section, const char* key, GError** error);
-};
-
-typedef enum  {
-	ENDIANNESS_LITTLE = G_LITTLE_ENDIAN,
-	ENDIANNESS_BIG = G_BIG_ENDIAN
-} Endianness;
-
-typedef enum  {
-	RYGEL_MP3_LAYER_TWO = 1,
-	RYGEL_MP3_LAYER_THREE = 2
-} RygelMP3Layer;
-
-typedef enum  {
-	RYGEL_MP2_TS_PROFILE_SD = 0,
-	RYGEL_MP2_TS_PROFILE_HD
-} RygelMP2TSProfile;
-
-typedef enum  {
-	RYGEL_HTTP_REQUEST_ERROR_UNACCEPTABLE = SOUP_STATUS_NOT_ACCEPTABLE,
-	RYGEL_HTTP_REQUEST_ERROR_BAD_REQUEST = SOUP_STATUS_BAD_REQUEST,
-	RYGEL_HTTP_REQUEST_ERROR_NOT_FOUND = SOUP_STATUS_NOT_FOUND
-} RygelHTTPRequestError;
-#define RYGEL_HTTP_REQUEST_ERROR rygel_http_request_error_quark ()
-
-static gpointer rygel_transcode_manager_parent_class = NULL;
-
-GType rygel_transcode_manager_get_type (void);
-GType rygel_media_object_get_type (void);
-GType rygel_media_item_get_type (void);
-GType rygel_transcoder_get_type (void);
-#define RYGEL_TRANSCODE_MANAGER_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), RYGEL_TYPE_TRANSCODE_MANAGER, RygelTranscodeManagerPrivate))
-enum  {
-	RYGEL_TRANSCODE_MANAGER_DUMMY_PROPERTY
-};
-GType rygel_meta_config_get_type (void);
-RygelMetaConfig* rygel_meta_config_get_default (void);
-GType rygel_log_level_get_type (void);
-GType rygel_configuration_get_type (void);
-gboolean rygel_configuration_get_transcoding (RygelConfiguration* self, GError** error);
-gboolean rygel_configuration_get_lpcm_transcoder (RygelConfiguration* self, GError** error);
-GType endianness_get_type (void);
-RygelL16Transcoder* rygel_l16_transcoder_new (Endianness endianness);
-RygelL16Transcoder* rygel_l16_transcoder_construct (GType object_type, Endianness endianness);
-GType rygel_l16_transcoder_get_type (void);
-gboolean rygel_configuration_get_mp3_transcoder (RygelConfiguration* self, GError** error);
-GType rygel_mp3_layer_get_type (void);
-RygelMP3Transcoder* rygel_mp3_transcoder_new (RygelMP3Layer layer);
-RygelMP3Transcoder* rygel_mp3_transcoder_construct (GType object_type, RygelMP3Layer layer);
-GType rygel_mp3_transcoder_get_type (void);
-gboolean rygel_configuration_get_mp2ts_transcoder (RygelConfiguration* self, GError** error);
-GType rygel_mp2_ts_profile_get_type (void);
-RygelMP2TSTranscoder* rygel_mp2_ts_transcoder_new (RygelMP2TSProfile profile);
-RygelMP2TSTranscoder* rygel_mp2_ts_transcoder_construct (GType object_type, RygelMP2TSProfile profile);
-GType rygel_mp2_ts_transcoder_get_type (void);
-RygelTranscodeManager* rygel_transcode_manager_construct (GType object_type, GError** error);
-char* rygel_transcode_manager_create_uri_for_item (RygelTranscodeManager* self, RygelMediaItem* item, gint thumbnail_index, const char* transcode_target, char** protocol);
-static char* rygel_transcode_manager_real_create_uri_for_item (RygelTranscodeManager* self, RygelMediaItem* item, gint thumbnail_index, const char* transcode_target, char** protocol);
-guint rygel_transcoder_get_distance (RygelTranscoder* self, RygelMediaItem* item);
-gint rygel_media_item_compare_transcoders (RygelMediaItem* self, void* a, void* b);
-static gint _rygel_media_item_compare_transcoders_gcompare_data_func (void* a, void* b, gpointer self);
-GUPnPDIDLLiteResource* rygel_transcoder_add_resource (RygelTranscoder* self, GUPnPDIDLLiteItem* didl_item, RygelMediaItem* item, RygelTranscodeManager* manager, GError** error);
-static void _g_list_free_g_object_unref (GList* self);
-void rygel_transcode_manager_add_resources (RygelTranscodeManager* self, GUPnPDIDLLiteItem* didl_item, RygelMediaItem* item, GError** error);
-static void rygel_transcode_manager_real_add_resources (RygelTranscodeManager* self, GUPnPDIDLLiteItem* didl_item, RygelMediaItem* item, GError** error);
-gboolean rygel_transcoder_can_handle (RygelTranscoder* self, const char* target);
-GQuark rygel_http_request_error_quark (void);
-RygelTranscoder* rygel_transcode_manager_get_transcoder (RygelTranscodeManager* self, const char* target, GError** error);
-char* rygel_transcode_manager_get_protocol (RygelTranscodeManager* self);
-static char* rygel_transcode_manager_real_get_protocol (RygelTranscodeManager* self);
-const char* rygel_transcoder_get_mime_type (RygelTranscoder* self);
-const char* rygel_transcoder_get_dlna_profile (RygelTranscoder* self);
-char* rygel_transcode_manager_get_protocol_info (RygelTranscodeManager* self);
-static char* rygel_transcode_manager_real_get_protocol_info (RygelTranscodeManager* self);
-static void rygel_transcode_manager_finalize (GObject* obj);
-static int _vala_strcmp0 (const char * str1, const char * str2);
-
-
-
-RygelTranscodeManager* rygel_transcode_manager_construct (GType object_type, GError** error) {
-	GError * _inner_error_;
-	RygelTranscodeManager * self;
-	GeeArrayList* _tmp0_;
-	RygelMetaConfig* config;
-	gboolean _tmp1_;
-	_inner_error_ = NULL;
-	self = (RygelTranscodeManager*) g_object_new (object_type, NULL);
-	self->priv->transcoders = (_tmp0_ = gee_array_list_new (RYGEL_TYPE_TRANSCODER, (GBoxedCopyFunc) g_object_ref, g_object_unref, g_direct_equal), _g_object_unref0 (self->priv->transcoders), _tmp0_);
-	config = rygel_meta_config_get_default ();
-	_tmp1_ = rygel_configuration_get_transcoding ((RygelConfiguration*) config, &_inner_error_);
-	if (_inner_error_ != NULL) {
-		g_propagate_error (error, _inner_error_);
-		_g_object_unref0 (config);
-		return;
-	}
-	if (_tmp1_) {
-		gboolean _tmp2_;
-		gboolean _tmp4_;
-		gboolean _tmp6_;
-		_tmp2_ = rygel_configuration_get_lpcm_transcoder ((RygelConfiguration*) config, &_inner_error_);
-		if (_inner_error_ != NULL) {
-			g_propagate_error (error, _inner_error_);
-			_g_object_unref0 (config);
-			return;
-		}
-		if (_tmp2_) {
-			RygelL16Transcoder* _tmp3_;
-			gee_abstract_collection_add ((GeeAbstractCollection*) self->priv->transcoders, (RygelTranscoder*) (_tmp3_ = rygel_l16_transcoder_new (ENDIANNESS_BIG)));
-			_g_object_unref0 (_tmp3_);
-		}
-		_tmp4_ = rygel_configuration_get_mp3_transcoder ((RygelConfiguration*) config, &_inner_error_);
-		if (_inner_error_ != NULL) {
-			g_propagate_error (error, _inner_error_);
-			_g_object_unref0 (config);
-			return;
-		}
-		if (_tmp4_) {
-			RygelMP3Transcoder* _tmp5_;
-			gee_abstract_collection_add ((GeeAbstractCollection*) self->priv->transcoders, (RygelTranscoder*) (_tmp5_ = rygel_mp3_transcoder_new (RYGEL_MP3_LAYER_THREE)));
-			_g_object_unref0 (_tmp5_);
-		}
-		_tmp6_ = rygel_configuration_get_mp2ts_transcoder ((RygelConfiguration*) config, &_inner_error_);
-		if (_inner_error_ != NULL) {
-			g_propagate_error (error, _inner_error_);
-			_g_object_unref0 (config);
-			return;
-		}
-		if (_tmp6_) {
-			RygelMP2TSTranscoder* _tmp7_;
-			RygelMP2TSTranscoder* _tmp8_;
-			gee_abstract_collection_add ((GeeAbstractCollection*) self->priv->transcoders, (RygelTranscoder*) (_tmp7_ = rygel_mp2_ts_transcoder_new (RYGEL_MP2_TS_PROFILE_SD)));
-			_g_object_unref0 (_tmp7_);
-			gee_abstract_collection_add ((GeeAbstractCollection*) self->priv->transcoders, (RygelTranscoder*) (_tmp8_ = rygel_mp2_ts_transcoder_new (RYGEL_MP2_TS_PROFILE_HD)));
-			_g_object_unref0 (_tmp8_);
-		}
-	}
-	_g_object_unref0 (config);
-	return self;
-}
-
-
-static char* rygel_transcode_manager_real_create_uri_for_item (RygelTranscodeManager* self, RygelMediaItem* item, gint thumbnail_index, const char* transcode_target, char** protocol) {
-	g_return_val_if_fail (self != NULL, NULL);
-	g_critical ("Type `%s' does not implement abstract method `rygel_transcode_manager_create_uri_for_item'", g_type_name (G_TYPE_FROM_INSTANCE (self)));
-	return NULL;
-}
-
-
-char* rygel_transcode_manager_create_uri_for_item (RygelTranscodeManager* self, RygelMediaItem* item, gint thumbnail_index, const char* transcode_target, char** protocol) {
-	return RYGEL_TRANSCODE_MANAGER_GET_CLASS (self)->create_uri_for_item (self, item, thumbnail_index, transcode_target, protocol);
-}
-
-
-static gpointer _g_object_ref0 (gpointer self) {
-	return self ? g_object_ref (self) : NULL;
-}
-
-
-static gint _rygel_media_item_compare_transcoders_gcompare_data_func (void* a, void* b, gpointer self) {
-	return rygel_media_item_compare_transcoders (self, a, b);
-}
-
-
-static void _g_list_free_g_object_unref (GList* self) {
-	g_list_foreach (self, (GFunc) g_object_unref, NULL);
-	g_list_free (self);
-}
-
-
-static void rygel_transcode_manager_real_add_resources (RygelTranscodeManager* self, GUPnPDIDLLiteItem* didl_item, RygelMediaItem* item, GError** error) {
-	GError * _inner_error_;
-	GList* list;
-	g_return_if_fail (self != NULL);
-	g_return_if_fail (didl_item != NULL);
-	g_return_if_fail (item != NULL);
-	_inner_error_ = NULL;
-	list = NULL;
-	{
-		GeeIterator* _transcoder_it;
-		_transcoder_it = gee_abstract_collection_iterator ((GeeAbstractCollection*) self->priv->transcoders);
-		while (TRUE) {
-			RygelTranscoder* transcoder;
-			if (!gee_iterator_next (_transcoder_it)) {
-				break;
-			}
-			transcoder = (RygelTranscoder*) gee_iterator_get (_transcoder_it);
-			if (rygel_transcoder_get_distance (transcoder, item) != G_MAXUINT) {
-				list = g_list_append (list, _g_object_ref0 (transcoder));
-			}
-			_g_object_unref0 (transcoder);
-		}
-		_g_object_unref0 (_transcoder_it);
-	}
-	list = g_list_sort_with_data (list, _rygel_media_item_compare_transcoders_gcompare_data_func, item);
-	{
-		GList* transcoder_collection;
-		GList* transcoder_it;
-		transcoder_collection = list;
-		for (transcoder_it = transcoder_collection; transcoder_it != NULL; transcoder_it = transcoder_it->next) {
-			RygelTranscoder* transcoder;
-			transcoder = _g_object_ref0 ((RygelTranscoder*) transcoder_it->data);
-			{
-				GUPnPDIDLLiteResource* _tmp0_;
-				_tmp0_ = rygel_transcoder_add_resource (transcoder, didl_item, item, self, &_inner_error_);
-				if (_inner_error_ != NULL) {
-					g_propagate_error (error, _inner_error_);
-					_g_object_unref0 (transcoder);
-					__g_list_free_g_object_unref0 (list);
-					return;
-				}
-				_g_object_unref0 (_tmp0_);
-				_g_object_unref0 (transcoder);
-			}
-		}
-	}
-	__g_list_free_g_object_unref0 (list);
-}
-
-
-void rygel_transcode_manager_add_resources (RygelTranscodeManager* self, GUPnPDIDLLiteItem* didl_item, RygelMediaItem* item, GError** error) {
-	RYGEL_TRANSCODE_MANAGER_GET_CLASS (self)->add_resources (self, didl_item, item, error);
-}
-
-
-RygelTranscoder* rygel_transcode_manager_get_transcoder (RygelTranscodeManager* self, const char* target, GError** error) {
-	RygelTranscoder* result;
-	GError * _inner_error_;
-	RygelTranscoder* transcoder;
-	g_return_val_if_fail (self != NULL, NULL);
-	g_return_val_if_fail (target != NULL, NULL);
-	_inner_error_ = NULL;
-	transcoder = NULL;
-	{
-		GeeIterator* _iter_it;
-		_iter_it = gee_abstract_collection_iterator ((GeeAbstractCollection*) self->priv->transcoders);
-		while (TRUE) {
-			RygelTranscoder* iter;
-			if (!gee_iterator_next (_iter_it)) {
-				break;
-			}
-			iter = (RygelTranscoder*) gee_iterator_get (_iter_it);
-			if (rygel_transcoder_can_handle (iter, target)) {
-				RygelTranscoder* _tmp0_;
-				transcoder = (_tmp0_ = _g_object_ref0 (iter), _g_object_unref0 (transcoder), _tmp0_);
-			}
-			_g_object_unref0 (iter);
-		}
-		_g_object_unref0 (_iter_it);
-	}
-	if (transcoder == NULL) {
-		_inner_error_ = g_error_new (RYGEL_HTTP_REQUEST_ERROR, RYGEL_HTTP_REQUEST_ERROR_NOT_FOUND, "No transcoder available for target format '%s'", target);
-		if (_inner_error_ != NULL) {
-			g_propagate_error (error, _inner_error_);
-			_g_object_unref0 (transcoder);
-			return NULL;
-		}
-	}
-	result = transcoder;
-	return result;
-}
-
-
-static char* rygel_transcode_manager_real_get_protocol (RygelTranscodeManager* self) {
-	g_return_val_if_fail (self != NULL, NULL);
-	g_critical ("Type `%s' does not implement abstract method `rygel_transcode_manager_get_protocol'", g_type_name (G_TYPE_FROM_INSTANCE (self)));
-	return NULL;
-}
-
-
-char* rygel_transcode_manager_get_protocol (RygelTranscodeManager* self) {
-	return RYGEL_TRANSCODE_MANAGER_GET_CLASS (self)->get_protocol (self);
-}
-
-
-static char* rygel_transcode_manager_real_get_protocol_info (RygelTranscodeManager* self) {
-	char* result;
-	char* protocol_info;
-	g_return_val_if_fail (self != NULL, NULL);
-	protocol_info = g_strdup ("");
-	{
-		GeeIterator* _transcoder_it;
-		_transcoder_it = gee_abstract_collection_iterator ((GeeAbstractCollection*) self->priv->transcoders);
-		while (TRUE) {
-			RygelTranscoder* transcoder;
-			char* _tmp6_;
-			char* _tmp5_;
-			char* _tmp4_;
-			char* _tmp3_;
-			char* _tmp2_;
-			char* _tmp1_;
-			if (!gee_iterator_next (_transcoder_it)) {
-				break;
-			}
-			transcoder = (RygelTranscoder*) gee_iterator_get (_transcoder_it);
-			if (_vala_strcmp0 (protocol_info, "") != 0) {
-				char* _tmp0_;
-				protocol_info = (_tmp0_ = g_strconcat (protocol_info, ",", NULL), _g_free0 (protocol_info), _tmp0_);
-			}
-			protocol_info = (_tmp6_ = g_strconcat (protocol_info, _tmp5_ = g_strconcat (_tmp4_ = g_strconcat (_tmp3_ = g_strconcat (_tmp2_ = g_strconcat (_tmp1_ = rygel_transcode_manager_get_protocol (self), ":*:", NULL), rygel_transcoder_get_mime_type (transcoder), NULL), ":DLNA.ORG_PN=", NULL), rygel_transcoder_get_dlna_profile (transcoder), NULL), NULL), _g_free0 (protocol_info), _tmp6_);
-			_g_free0 (_tmp5_);
-			_g_free0 (_tmp4_);
-			_g_free0 (_tmp3_);
-			_g_free0 (_tmp2_);
-			_g_free0 (_tmp1_);
-			_g_object_unref0 (transcoder);
-		}
-		_g_object_unref0 (_transcoder_it);
-	}
-	result = protocol_info;
-	return result;
-}
-
-
-char* rygel_transcode_manager_get_protocol_info (RygelTranscodeManager* self) {
-	return RYGEL_TRANSCODE_MANAGER_GET_CLASS (self)->get_protocol_info (self);
-}
-
-
-static void rygel_transcode_manager_class_init (RygelTranscodeManagerClass * klass) {
-	rygel_transcode_manager_parent_class = g_type_class_peek_parent (klass);
-	g_type_class_add_private (klass, sizeof (RygelTranscodeManagerPrivate));
-	RYGEL_TRANSCODE_MANAGER_CLASS (klass)->create_uri_for_item = rygel_transcode_manager_real_create_uri_for_item;
-	RYGEL_TRANSCODE_MANAGER_CLASS (klass)->add_resources = rygel_transcode_manager_real_add_resources;
-	RYGEL_TRANSCODE_MANAGER_CLASS (klass)->get_protocol = rygel_transcode_manager_real_get_protocol;
-	RYGEL_TRANSCODE_MANAGER_CLASS (klass)->get_protocol_info = rygel_transcode_manager_real_get_protocol_info;
-	G_OBJECT_CLASS (klass)->finalize = rygel_transcode_manager_finalize;
-}
-
-
-static void rygel_transcode_manager_instance_init (RygelTranscodeManager * self) {
-	self->priv = RYGEL_TRANSCODE_MANAGER_GET_PRIVATE (self);
-}
-
-
-static void rygel_transcode_manager_finalize (GObject* obj) {
-	RygelTranscodeManager * self;
-	self = RYGEL_TRANSCODE_MANAGER (obj);
-	_g_object_unref0 (self->priv->transcoders);
-	G_OBJECT_CLASS (rygel_transcode_manager_parent_class)->finalize (obj);
-}
-
-
-GType rygel_transcode_manager_get_type (void) {
-	static GType rygel_transcode_manager_type_id = 0;
-	if (rygel_transcode_manager_type_id == 0) {
-		static const GTypeInfo g_define_type_info = { sizeof (RygelTranscodeManagerClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) rygel_transcode_manager_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (RygelTranscodeManager), 0, (GInstanceInitFunc) rygel_transcode_manager_instance_init, NULL };
-		rygel_transcode_manager_type_id = g_type_register_static (G_TYPE_OBJECT, "RygelTranscodeManager", &g_define_type_info, G_TYPE_FLAG_ABSTRACT);
-	}
-	return rygel_transcode_manager_type_id;
-}
-
-
-static int _vala_strcmp0 (const char * str1, const char * str2) {
-	if (str1 == NULL) {
-		return -(str1 != str2);
-	}
-	if (str2 == NULL) {
-		return str1 != str2;
-	}
-	return strcmp (str1, str2);
-}
-
-
-
-
--- a/src/rygel/rygel-transcode-manager.vala
+++ /dev/null
@@ -1,112 +0,0 @@
-/*
- * Copyright (C) 2009 Nokia Corporation.
- *
- * Author: Zeeshan Ali (Khattak) <zeeshanak@gnome.org>
- *                               <zeeshan.ali@nokia.com>
- *
- * This file is part of Rygel.
- *
- * Rygel is free software; you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * Rygel is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this program; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
- */
-
-using GUPnP;
-using Gee;
-using Gst;
-
-/**
- * Responsible for management of all transcoders:
- *    - gets the appropriate transcoder given a transcoding target.
- *    - provide all possible transcoding resources for items.
- */
-internal abstract class Rygel.TranscodeManager : GLib.Object {
-    private ArrayList<Transcoder> transcoders;
-
-    public TranscodeManager () throws GLib.Error {
-        transcoders = new ArrayList<Transcoder> ();
-
-        var config = MetaConfig.get_default ();
-
-        if (config.get_transcoding ()) {
-            if (config.get_lpcm_transcoder ()) {
-                transcoders.add (new L16Transcoder (Endianness.BIG));
-            }
-            if (config.get_mp3_transcoder ()) {
-                transcoders.add (new MP3Transcoder (MP3Layer.THREE));
-            }
-            if (config.get_mp2ts_transcoder ()) {
-                transcoders.add (new MP2TSTranscoder(MP2TSProfile.SD));
-                transcoders.add (new MP2TSTranscoder(MP2TSProfile.HD));
-            }
-        }
-    }
-
-    public abstract string create_uri_for_item (MediaItem  item,
-                                                int        thumbnail_index,
-                                                string?    transcode_target,
-                                                out string protocol);
-
-    public virtual void add_resources (DIDLLiteItem didl_item,
-                                       MediaItem    item)
-                                       throws Error {
-        var list = new GLib.List<Transcoder> ();
-
-        foreach (var transcoder in this.transcoders) {
-            if (transcoder.get_distance (item) != uint.MAX) {
-                list.append (transcoder);
-            }
-        }
-
-        list.sort_with_data (item.compare_transcoders);
-        foreach (var transcoder in list) {
-            transcoder.add_resource (didl_item, item, this);
-        }
-    }
-
-    public Transcoder get_transcoder (string  target) throws Error {
-        Transcoder transcoder = null;
-
-        foreach (var iter in this.transcoders) {
-            if (iter.can_handle (target)) {
-                transcoder = iter;
-            }
-        }
-
-        if (transcoder == null) {
-            throw new HTTPRequestError.NOT_FOUND (
-                            "No transcoder available for target format '%s'",
-                            target);
-        }
-
-        return transcoder;
-    }
-
-    internal abstract string get_protocol ();
-
-    internal virtual string get_protocol_info () {
-        string protocol_info = "";
-
-        foreach (var transcoder in this.transcoders) {
-            if (protocol_info != "")   // No comma before the first one
-                protocol_info += ",";
-
-            protocol_info += this.get_protocol () +
-                             ":*:" + transcoder.mime_type +
-                             ":DLNA.ORG_PN=" + transcoder.dlna_profile;
-        }
-
-        return protocol_info;
-    }
-}
-
--- a/src/rygel/rygel-transcoder.c
+++ /dev/null
@@ -1,476 +0,0 @@
-/* rygel-transcoder.c generated by valac, the Vala compiler
- * generated from rygel-transcoder.vala, do not modify */
-
-/*
- * Copyright (C) 2009 Nokia Corporation.
- *
- * Author: Zeeshan Ali (Khattak) <zeeshanak@gnome.org>
- *                               <zeeshan.ali@nokia.com>
- *
- * This file is part of Rygel.
- *
- * Rygel is free software; you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * Rygel is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this program; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
- */
-
-#include <glib.h>
-#include <glib-object.h>
-#include <gst/gst.h>
-#include <libgupnp-av/gupnp-av.h>
-#include <stdlib.h>
-#include <string.h>
-#include <gee.h>
-#include <gio/gio.h>
-
-
-#define RYGEL_TYPE_TRANSCODER (rygel_transcoder_get_type ())
-#define RYGEL_TRANSCODER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_TRANSCODER, RygelTranscoder))
-#define RYGEL_TRANSCODER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_TRANSCODER, RygelTranscoderClass))
-#define RYGEL_IS_TRANSCODER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_TRANSCODER))
-#define RYGEL_IS_TRANSCODER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_TRANSCODER))
-#define RYGEL_TRANSCODER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_TRANSCODER, RygelTranscoderClass))
-
-typedef struct _RygelTranscoder RygelTranscoder;
-typedef struct _RygelTranscoderClass RygelTranscoderClass;
-typedef struct _RygelTranscoderPrivate RygelTranscoderPrivate;
-
-#define RYGEL_TYPE_MEDIA_OBJECT (rygel_media_object_get_type ())
-#define RYGEL_MEDIA_OBJECT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_MEDIA_OBJECT, RygelMediaObject))
-#define RYGEL_MEDIA_OBJECT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_MEDIA_OBJECT, RygelMediaObjectClass))
-#define RYGEL_IS_MEDIA_OBJECT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_MEDIA_OBJECT))
-#define RYGEL_IS_MEDIA_OBJECT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_MEDIA_OBJECT))
-#define RYGEL_MEDIA_OBJECT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_MEDIA_OBJECT, RygelMediaObjectClass))
-
-typedef struct _RygelMediaObject RygelMediaObject;
-typedef struct _RygelMediaObjectClass RygelMediaObjectClass;
-
-#define RYGEL_TYPE_MEDIA_ITEM (rygel_media_item_get_type ())
-#define RYGEL_MEDIA_ITEM(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_MEDIA_ITEM, RygelMediaItem))
-#define RYGEL_MEDIA_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_MEDIA_ITEM, RygelMediaItemClass))
-#define RYGEL_IS_MEDIA_ITEM(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_MEDIA_ITEM))
-#define RYGEL_IS_MEDIA_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_MEDIA_ITEM))
-#define RYGEL_MEDIA_ITEM_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_MEDIA_ITEM, RygelMediaItemClass))
-
-typedef struct _RygelMediaItem RygelMediaItem;
-typedef struct _RygelMediaItemClass RygelMediaItemClass;
-
-#define RYGEL_TYPE_TRANSCODE_MANAGER (rygel_transcode_manager_get_type ())
-#define RYGEL_TRANSCODE_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_TRANSCODE_MANAGER, RygelTranscodeManager))
-#define RYGEL_TRANSCODE_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_TRANSCODE_MANAGER, RygelTranscodeManagerClass))
-#define RYGEL_IS_TRANSCODE_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_TRANSCODE_MANAGER))
-#define RYGEL_IS_TRANSCODE_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_TRANSCODE_MANAGER))
-#define RYGEL_TRANSCODE_MANAGER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_TRANSCODE_MANAGER, RygelTranscodeManagerClass))
-
-typedef struct _RygelTranscodeManager RygelTranscodeManager;
-typedef struct _RygelTranscodeManagerClass RygelTranscodeManagerClass;
-#define _g_free0(var) (var = (g_free (var), NULL))
-typedef struct _RygelMediaObjectPrivate RygelMediaObjectPrivate;
-
-#define RYGEL_TYPE_MEDIA_CONTAINER (rygel_media_container_get_type ())
-#define RYGEL_MEDIA_CONTAINER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_MEDIA_CONTAINER, RygelMediaContainer))
-#define RYGEL_MEDIA_CONTAINER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_MEDIA_CONTAINER, RygelMediaContainerClass))
-#define RYGEL_IS_MEDIA_CONTAINER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_MEDIA_CONTAINER))
-#define RYGEL_IS_MEDIA_CONTAINER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_MEDIA_CONTAINER))
-#define RYGEL_MEDIA_CONTAINER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_MEDIA_CONTAINER, RygelMediaContainerClass))
-
-typedef struct _RygelMediaContainer RygelMediaContainer;
-typedef struct _RygelMediaContainerClass RygelMediaContainerClass;
-typedef struct _RygelMediaItemPrivate RygelMediaItemPrivate;
-
-#define RYGEL_TYPE_ICON_INFO (rygel_icon_info_get_type ())
-#define RYGEL_ICON_INFO(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_ICON_INFO, RygelIconInfo))
-#define RYGEL_ICON_INFO_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_ICON_INFO, RygelIconInfoClass))
-#define RYGEL_IS_ICON_INFO(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_ICON_INFO))
-#define RYGEL_IS_ICON_INFO_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_ICON_INFO))
-#define RYGEL_ICON_INFO_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_ICON_INFO, RygelIconInfoClass))
-
-typedef struct _RygelIconInfo RygelIconInfo;
-typedef struct _RygelIconInfoClass RygelIconInfoClass;
-
-#define RYGEL_TYPE_THUMBNAIL (rygel_thumbnail_get_type ())
-#define RYGEL_THUMBNAIL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_THUMBNAIL, RygelThumbnail))
-#define RYGEL_THUMBNAIL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_THUMBNAIL, RygelThumbnailClass))
-#define RYGEL_IS_THUMBNAIL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_THUMBNAIL))
-#define RYGEL_IS_THUMBNAIL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_THUMBNAIL))
-#define RYGEL_THUMBNAIL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_THUMBNAIL, RygelThumbnailClass))
-
-typedef struct _RygelThumbnail RygelThumbnail;
-typedef struct _RygelThumbnailClass RygelThumbnailClass;
-#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
-
-struct _RygelTranscoder {
-	GObject parent_instance;
-	RygelTranscoderPrivate * priv;
-};
-
-struct _RygelTranscoderClass {
-	GObjectClass parent_class;
-	GstElement* (*create_source) (RygelTranscoder* self, RygelMediaItem* item, GstElement* src, GError** error);
-	GUPnPDIDLLiteResource* (*add_resource) (RygelTranscoder* self, GUPnPDIDLLiteItem* didl_item, RygelMediaItem* item, RygelTranscodeManager* manager, GError** error);
-	guint (*get_distance) (RygelTranscoder* self, RygelMediaItem* item);
-};
-
-struct _RygelTranscoderPrivate {
-	char* _mime_type;
-	char* _dlna_profile;
-	char* _upnp_class;
-};
-
-struct _RygelMediaObject {
-	GObject parent_instance;
-	RygelMediaObjectPrivate * priv;
-	char* id;
-	char* title;
-	guint64 modified;
-	GeeArrayList* uris;
-	RygelMediaContainer* parent;
-	RygelMediaContainer* parent_ref;
-};
-
-struct _RygelMediaObjectClass {
-	GObjectClass parent_class;
-};
-
-struct _RygelMediaItem {
-	RygelMediaObject parent_instance;
-	RygelMediaItemPrivate * priv;
-	char* author;
-	char* album;
-	char* date;
-	char* upnp_class;
-	char* mime_type;
-	char* dlna_profile;
-	glong size;
-	glong duration;
-	gint bitrate;
-	gint sample_freq;
-	gint bits_per_sample;
-	gint n_audio_channels;
-	gint track_number;
-	gint width;
-	gint height;
-	gint pixel_width;
-	gint pixel_height;
-	gint color_depth;
-	GeeArrayList* thumbnails;
-};
-
-struct _RygelMediaItemClass {
-	RygelMediaObjectClass parent_class;
-	GstElement* (*create_stream_source) (RygelMediaItem* self);
-	gboolean (*should_stream) (RygelMediaItem* self);
-};
-
-
-static gpointer rygel_transcoder_parent_class = NULL;
-
-GType rygel_transcoder_get_type (void);
-GType rygel_media_object_get_type (void);
-GType rygel_media_item_get_type (void);
-GType rygel_transcode_manager_get_type (void);
-#define RYGEL_TRANSCODER_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), RYGEL_TYPE_TRANSCODER, RygelTranscoderPrivate))
-enum  {
-	RYGEL_TRANSCODER_DUMMY_PROPERTY,
-	RYGEL_TRANSCODER_MIME_TYPE,
-	RYGEL_TRANSCODER_DLNA_PROFILE,
-	RYGEL_TRANSCODER_UPNP_CLASS
-};
-void rygel_transcoder_set_mime_type (RygelTranscoder* self, const char* value);
-void rygel_transcoder_set_dlna_profile (RygelTranscoder* self, const char* value);
-void rygel_transcoder_set_upnp_class (RygelTranscoder* self, const char* value);
-RygelTranscoder* rygel_transcoder_construct (GType object_type, const char* mime_type, const char* dlna_profile, const char* upnp_class);
-GstElement* rygel_transcoder_create_source (RygelTranscoder* self, RygelMediaItem* item, GstElement* src, GError** error);
-static GstElement* rygel_transcoder_real_create_source (RygelTranscoder* self, RygelMediaItem* item, GstElement* src, GError** error);
-gboolean rygel_transcoder_mime_type_is_a (RygelTranscoder* self, const char* mime_type1, const char* mime_type2);
-GType rygel_media_container_get_type (void);
-gpointer rygel_icon_info_ref (gpointer instance);
-void rygel_icon_info_unref (gpointer instance);
-GParamSpec* rygel_param_spec_icon_info (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
-void rygel_value_set_icon_info (GValue* value, gpointer v_object);
-gpointer rygel_value_get_icon_info (const GValue* value);
-GType rygel_icon_info_get_type (void);
-GType rygel_thumbnail_get_type (void);
-const char* rygel_transcoder_get_mime_type (RygelTranscoder* self);
-char* rygel_transcode_manager_create_uri_for_item (RygelTranscodeManager* self, RygelMediaItem* item, gint thumbnail_index, const char* transcode_target, char** protocol);
-const char* rygel_transcoder_get_dlna_profile (RygelTranscoder* self);
-GUPnPDIDLLiteResource* rygel_media_item_add_resource (RygelMediaItem* self, GUPnPDIDLLiteItem* didl_item, const char* uri, const char* protocol, GError** error);
-GUPnPDIDLLiteResource* rygel_transcoder_add_resource (RygelTranscoder* self, GUPnPDIDLLiteItem* didl_item, RygelMediaItem* item, RygelTranscodeManager* manager, GError** error);
-static GUPnPDIDLLiteResource* rygel_transcoder_real_add_resource (RygelTranscoder* self, GUPnPDIDLLiteItem* didl_item, RygelMediaItem* item, RygelTranscodeManager* manager, GError** error);
-gboolean rygel_transcoder_can_handle (RygelTranscoder* self, const char* target);
-guint rygel_transcoder_get_distance (RygelTranscoder* self, RygelMediaItem* item);
-static guint rygel_transcoder_real_get_distance (RygelTranscoder* self, RygelMediaItem* item);
-const char* rygel_transcoder_get_upnp_class (RygelTranscoder* self);
-static void rygel_transcoder_finalize (GObject* obj);
-static void rygel_transcoder_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
-static void rygel_transcoder_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);
-static int _vala_strcmp0 (const char * str1, const char * str2);
-
-
-
-RygelTranscoder* rygel_transcoder_construct (GType object_type, const char* mime_type, const char* dlna_profile, const char* upnp_class) {
-	RygelTranscoder * self;
-	g_return_val_if_fail (mime_type != NULL, NULL);
-	g_return_val_if_fail (dlna_profile != NULL, NULL);
-	g_return_val_if_fail (upnp_class != NULL, NULL);
-	self = (RygelTranscoder*) g_object_new (object_type, NULL);
-	rygel_transcoder_set_mime_type (self, mime_type);
-	rygel_transcoder_set_dlna_profile (self, dlna_profile);
-	rygel_transcoder_set_upnp_class (self, upnp_class);
-	return self;
-}
-
-
-static GstElement* rygel_transcoder_real_create_source (RygelTranscoder* self, RygelMediaItem* item, GstElement* src, GError** error) {
-	g_return_val_if_fail (self != NULL, NULL);
-	g_critical ("Type `%s' does not implement abstract method `rygel_transcoder_create_source'", g_type_name (G_TYPE_FROM_INSTANCE (self)));
-	return NULL;
-}
-
-
-GstElement* rygel_transcoder_create_source (RygelTranscoder* self, RygelMediaItem* item, GstElement* src, GError** error) {
-	return RYGEL_TRANSCODER_GET_CLASS (self)->create_source (self, item, src, error);
-}
-
-
-static gpointer _g_object_ref0 (gpointer self) {
-	return self ? g_object_ref (self) : NULL;
-}
-
-
-static GUPnPDIDLLiteResource* rygel_transcoder_real_add_resource (RygelTranscoder* self, GUPnPDIDLLiteItem* didl_item, RygelMediaItem* item, RygelTranscodeManager* manager, GError** error) {
-	GUPnPDIDLLiteResource* result;
-	GError * _inner_error_;
-	char* protocol;
-	char* _tmp2_;
-	char* _tmp1_;
-	char* _tmp0_ = NULL;
-	char* uri;
-	GUPnPDIDLLiteResource* res;
-	GUPnPProtocolInfo* protocol_info;
-	g_return_val_if_fail (self != NULL, NULL);
-	g_return_val_if_fail (didl_item != NULL, NULL);
-	g_return_val_if_fail (item != NULL, NULL);
-	g_return_val_if_fail (manager != NULL, NULL);
-	_inner_error_ = NULL;
-	if (rygel_transcoder_mime_type_is_a (self, item->mime_type, self->priv->_mime_type)) {
-		result = NULL;
-		return result;
-	}
-	protocol = NULL;
-	uri = (_tmp1_ = rygel_transcode_manager_create_uri_for_item (manager, item, -1, self->priv->_dlna_profile, &_tmp0_), protocol = (_tmp2_ = _tmp0_, _g_free0 (protocol), _tmp2_), _tmp1_);
-	res = rygel_media_item_add_resource (item, didl_item, uri, protocol, &_inner_error_);
-	if (_inner_error_ != NULL) {
-		g_propagate_error (error, _inner_error_);
-		_g_free0 (protocol);
-		_g_free0 (uri);
-		return NULL;
-	}
-	gupnp_didl_lite_resource_set_size (res, (glong) (-1));
-	protocol_info = _g_object_ref0 (gupnp_didl_lite_resource_get_protocol_info (res));
-	gupnp_protocol_info_set_mime_type (protocol_info, self->priv->_mime_type);
-	gupnp_protocol_info_set_dlna_profile (protocol_info, self->priv->_dlna_profile);
-	gupnp_protocol_info_set_dlna_conversion (protocol_info, GUPNP_DLNA_CONVERSION_TRANSCODED);
-	gupnp_protocol_info_set_dlna_flags (protocol_info, GUPNP_DLNA_FLAGS_STREAMING_TRANSFER_MODE);
-	gupnp_protocol_info_set_dlna_operation (protocol_info, GUPNP_DLNA_OPERATION_TIMESEEK);
-	result = res;
-	_g_free0 (protocol);
-	_g_free0 (uri);
-	_g_object_unref0 (protocol_info);
-	return result;
-}
-
-
-GUPnPDIDLLiteResource* rygel_transcoder_add_resource (RygelTranscoder* self, GUPnPDIDLLiteItem* didl_item, RygelMediaItem* item, RygelTranscodeManager* manager, GError** error) {
-	return RYGEL_TRANSCODER_GET_CLASS (self)->add_resource (self, didl_item, item, manager, error);
-}
-
-
-gboolean rygel_transcoder_can_handle (RygelTranscoder* self, const char* target) {
-	gboolean result;
-	g_return_val_if_fail (self != NULL, FALSE);
-	g_return_val_if_fail (target != NULL, FALSE);
-	result = _vala_strcmp0 (target, self->priv->_dlna_profile) == 0;
-	return result;
-}
-
-
-static guint rygel_transcoder_real_get_distance (RygelTranscoder* self, RygelMediaItem* item) {
-	g_return_val_if_fail (self != NULL, 0U);
-	g_critical ("Type `%s' does not implement abstract method `rygel_transcoder_get_distance'", g_type_name (G_TYPE_FROM_INSTANCE (self)));
-	return 0U;
-}
-
-
-guint rygel_transcoder_get_distance (RygelTranscoder* self, RygelMediaItem* item) {
-	return RYGEL_TRANSCODER_GET_CLASS (self)->get_distance (self, item);
-}
-
-
-gboolean rygel_transcoder_mime_type_is_a (RygelTranscoder* self, const char* mime_type1, const char* mime_type2) {
-	gboolean result;
-	char* content_type1;
-	char* content_type2;
-	g_return_val_if_fail (self != NULL, FALSE);
-	g_return_val_if_fail (mime_type1 != NULL, FALSE);
-	g_return_val_if_fail (mime_type2 != NULL, FALSE);
-	content_type1 = g_strdup (g_content_type_from_mime_type (mime_type1));
-	content_type2 = g_strdup (g_content_type_from_mime_type (mime_type2));
-	result = g_content_type_is_a (content_type1, content_type2);
-	_g_free0 (content_type1);
-	_g_free0 (content_type2);
-	return result;
-}
-
-
-const char* rygel_transcoder_get_mime_type (RygelTranscoder* self) {
-	const char* result;
-	g_return_val_if_fail (self != NULL, NULL);
-	result = self->priv->_mime_type;
-	return result;
-}
-
-
-void rygel_transcoder_set_mime_type (RygelTranscoder* self, const char* value) {
-	char* _tmp0_;
-	g_return_if_fail (self != NULL);
-	self->priv->_mime_type = (_tmp0_ = g_strdup (value), _g_free0 (self->priv->_mime_type), _tmp0_);
-	g_object_notify ((GObject *) self, "mime-type");
-}
-
-
-const char* rygel_transcoder_get_dlna_profile (RygelTranscoder* self) {
-	const char* result;
-	g_return_val_if_fail (self != NULL, NULL);
-	result = self->priv->_dlna_profile;
-	return result;
-}
-
-
-void rygel_transcoder_set_dlna_profile (RygelTranscoder* self, const char* value) {
-	char* _tmp0_;
-	g_return_if_fail (self != NULL);
-	self->priv->_dlna_profile = (_tmp0_ = g_strdup (value), _g_free0 (self->priv->_dlna_profile), _tmp0_);
-	g_object_notify ((GObject *) self, "dlna-profile");
-}
-
-
-const char* rygel_transcoder_get_upnp_class (RygelTranscoder* self) {
-	const char* result;
-	g_return_val_if_fail (self != NULL, NULL);
-	result = self->priv->_upnp_class;
-	return result;
-}
-
-
-void rygel_transcoder_set_upnp_class (RygelTranscoder* self, const char* value) {
-	char* _tmp0_;
-	g_return_if_fail (self != NULL);
-	self->priv->_upnp_class = (_tmp0_ = g_strdup (value), _g_free0 (self->priv->_upnp_class), _tmp0_);
-	g_object_notify ((GObject *) self, "upnp-class");
-}
-
-
-static void rygel_transcoder_class_init (RygelTranscoderClass * klass) {
-	rygel_transcoder_parent_class = g_type_class_peek_parent (klass);
-	g_type_class_add_private (klass, sizeof (RygelTranscoderPrivate));
-	RYGEL_TRANSCODER_CLASS (klass)->create_source = rygel_transcoder_real_create_source;
-	RYGEL_TRANSCODER_CLASS (klass)->add_resource = rygel_transcoder_real_add_resource;
-	RYGEL_TRANSCODER_CLASS (klass)->get_distance = rygel_transcoder_real_get_distance;
-	G_OBJECT_CLASS (klass)->get_property = rygel_transcoder_get_property;
-	G_OBJECT_CLASS (klass)->set_property = rygel_transcoder_set_property;
-	G_OBJECT_CLASS (klass)->finalize = rygel_transcoder_finalize;
-	g_object_class_install_property (G_OBJECT_CLASS (klass), RYGEL_TRANSCODER_MIME_TYPE, g_param_spec_string ("mime-type", "mime-type", "mime-type", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
-	g_object_class_install_property (G_OBJECT_CLASS (klass), RYGEL_TRANSCODER_DLNA_PROFILE, g_param_spec_string ("dlna-profile", "dlna-profile", "dlna-profile", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
-	g_object_class_install_property (G_OBJECT_CLASS (klass), RYGEL_TRANSCODER_UPNP_CLASS, g_param_spec_string ("upnp-class", "upnp-class", "upnp-class", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
-}
-
-
-static void rygel_transcoder_instance_init (RygelTranscoder * self) {
-	self->priv = RYGEL_TRANSCODER_GET_PRIVATE (self);
-}
-
-
-static void rygel_transcoder_finalize (GObject* obj) {
-	RygelTranscoder * self;
-	self = RYGEL_TRANSCODER (obj);
-	_g_free0 (self->priv->_mime_type);
-	_g_free0 (self->priv->_dlna_profile);
-	_g_free0 (self->priv->_upnp_class);
-	G_OBJECT_CLASS (rygel_transcoder_parent_class)->finalize (obj);
-}
-
-
-GType rygel_transcoder_get_type (void) {
-	static GType rygel_transcoder_type_id = 0;
-	if (rygel_transcoder_type_id == 0) {
-		static const GTypeInfo g_define_type_info = { sizeof (RygelTranscoderClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) rygel_transcoder_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (RygelTranscoder), 0, (GInstanceInitFunc) rygel_transcoder_instance_init, NULL };
-		rygel_transcoder_type_id = g_type_register_static (G_TYPE_OBJECT, "RygelTranscoder", &g_define_type_info, G_TYPE_FLAG_ABSTRACT);
-	}
-	return rygel_transcoder_type_id;
-}
-
-
-static void rygel_transcoder_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
-	RygelTranscoder * self;
-	self = RYGEL_TRANSCODER (object);
-	switch (property_id) {
-		case RYGEL_TRANSCODER_MIME_TYPE:
-		g_value_set_string (value, rygel_transcoder_get_mime_type (self));
-		break;
-		case RYGEL_TRANSCODER_DLNA_PROFILE:
-		g_value_set_string (value, rygel_transcoder_get_dlna_profile (self));
-		break;
-		case RYGEL_TRANSCODER_UPNP_CLASS:
-		g_value_set_string (value, rygel_transcoder_get_upnp_class (self));
-		break;
-		default:
-		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
-		break;
-	}
-}
-
-
-static void rygel_transcoder_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
-	RygelTranscoder * self;
-	self = RYGEL_TRANSCODER (object);
-	switch (property_id) {
-		case RYGEL_TRANSCODER_MIME_TYPE:
-		rygel_transcoder_set_mime_type (self, g_value_get_string (value));
-		break;
-		case RYGEL_TRANSCODER_DLNA_PROFILE:
-		rygel_transcoder_set_dlna_profile (self, g_value_get_string (value));
-		break;
-		case RYGEL_TRANSCODER_UPNP_CLASS:
-		rygel_transcoder_set_upnp_class (self, g_value_get_string (value));
-		break;
-		default:
-		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
-		break;
-	}
-}
-
-
-static int _vala_strcmp0 (const char * str1, const char * str2) {
-	if (str1 == NULL) {
-		return -(str1 != str2);
-	}
-	if (str2 == NULL) {
-		return str1 != str2;
-	}
-	return strcmp (str1, str2);
-}
-
-
-
-
--- a/src/rygel/rygel-transcoder.vala
+++ /dev/null
@@ -1,108 +0,0 @@
-/*
- * Copyright (C) 2009 Nokia Corporation.
- *
- * Author: Zeeshan Ali (Khattak) <zeeshanak@gnome.org>
- *                               <zeeshan.ali@nokia.com>
- *
- * This file is part of Rygel.
- *
- * Rygel is free software; you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * Rygel is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this program; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
- */
-
-using Gst;
-using GUPnP;
-using Gee;
-
-/**
- * The base Transcoder class. Each implementation derives from it and must
- * at least implement create_source method.
- */
-internal abstract class Rygel.Transcoder : GLib.Object {
-    public string mime_type { get; protected set; }
-    public string dlna_profile { get; protected set; }
-
-    // Primary UPnP item class that this transcoder is meant for, doesn't
-    // necessarily mean it cant be used for other classes.
-    public string upnp_class { get; protected set; }
-
-    public Transcoder (string mime_type,
-                       string dlna_profile,
-                       string upnp_class) {
-        this.mime_type = mime_type;
-        this.dlna_profile = dlna_profile;
-        this.upnp_class = upnp_class;
-    }
-
-    /**
-     * Creates a transcoding source.
-     *
-     * @param src the media item to create the transcoding source for
-     * @param src the original (non-transcoding) source
-     *
-     * @return      the new transcoding source
-     */
-    public abstract Element create_source (MediaItem item,
-                                           Element   src) throws Error;
-
-    public virtual DIDLLiteResource? add_resource (DIDLLiteItem     didl_item,
-                                                   MediaItem        item,
-                                                   TranscodeManager manager)
-                                                   throws Error {
-        if (this.mime_type_is_a (item.mime_type, this.mime_type)) {
-            return null;
-        }
-
-        string protocol;
-        var uri = manager.create_uri_for_item (item,
-                                               -1,
-                                               this.dlna_profile,
-                                               out protocol);
-        var res = item.add_resource (didl_item, uri, protocol);
-        res.size = -1;
-
-        var protocol_info = res.protocol_info;
-        protocol_info.mime_type = this.mime_type;
-        protocol_info.dlna_profile = this.dlna_profile;
-        protocol_info.dlna_conversion = DLNAConversion.TRANSCODED;
-        protocol_info.dlna_flags = DLNAFlags.STREAMING_TRANSFER_MODE;
-        protocol_info.dlna_operation = DLNAOperation.TIMESEEK;
-
-        return res;
-    }
-
-    public bool can_handle (string target) {
-        return target == this.dlna_profile;
-    }
-
-    /**
-     * Gets the numeric value that gives an gives an estimate of how hard
-     * would it be to trancode @item to target profile of this transcoder.
-     *
-     * @param item the media item to calculate the distance for
-     *
-     * @return      the distance from the @item, uint.MIN if providing such a
-     *              value is impossible or uint.MAX if it doesn't make any
-     *              sense to use this transcoder for @item
-     */
-    public abstract uint get_distance (MediaItem item);
-
-    protected bool mime_type_is_a (string mime_type1, string mime_type2) {
-        string content_type1 = g_content_type_from_mime_type (mime_type1);
-        string content_type2 = g_content_type_from_mime_type (mime_type2);
-
-        return g_content_type_is_a (content_type1, content_type2);
-    }
-}
-
--- a/src/rygel/rygel-user-config.c
+++ /dev/null
@@ -1,1006 +0,0 @@
-/* rygel-user-config.c generated by valac, the Vala compiler
- * generated from rygel-user-config.vala, do not modify */
-
-/*
- * Copyright (C) 2008,2009 Nokia Corporation.
- * Copyright (C) 2008,2009 Zeeshan Ali (Khattak) <zeeshanak@gnome.org>.
- *
- * Author: Zeeshan Ali (Khattak) <zeeshanak@gnome.org>
- *                               <zeeshan.ali@nokia.com>
- *
- * This file is part of Rygel.
- *
- * Rygel is free software; you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * Rygel is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this program; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
- */
-
-#include <glib.h>
-#include <glib-object.h>
-#include <stdlib.h>
-#include <string.h>
-#include <gee.h>
-#include <dbus/dbus-glib-lowlevel.h>
-#include <dbus/dbus-glib.h>
-#include <glib/gstdio.h>
-#include <gio/gio.h>
-
-
-#define RYGEL_TYPE_CONFIGURATION (rygel_configuration_get_type ())
-#define RYGEL_CONFIGURATION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_CONFIGURATION, RygelConfiguration))
-#define RYGEL_IS_CONFIGURATION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_CONFIGURATION))
-#define RYGEL_CONFIGURATION_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), RYGEL_TYPE_CONFIGURATION, RygelConfigurationIface))
-
-typedef struct _RygelConfiguration RygelConfiguration;
-typedef struct _RygelConfigurationIface RygelConfigurationIface;
-
-#define RYGEL_TYPE_LOG_LEVEL (rygel_log_level_get_type ())
-
-#define RYGEL_TYPE_USER_CONFIG (rygel_user_config_get_type ())
-#define RYGEL_USER_CONFIG(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_USER_CONFIG, RygelUserConfig))
-#define RYGEL_USER_CONFIG_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_USER_CONFIG, RygelUserConfigClass))
-#define RYGEL_IS_USER_CONFIG(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_USER_CONFIG))
-#define RYGEL_IS_USER_CONFIG_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_USER_CONFIG))
-#define RYGEL_USER_CONFIG_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_USER_CONFIG, RygelUserConfigClass))
-
-typedef struct _RygelUserConfig RygelUserConfig;
-typedef struct _RygelUserConfigClass RygelUserConfigClass;
-typedef struct _RygelUserConfigPrivate RygelUserConfigPrivate;
-#define _g_key_file_free0(var) ((var == NULL) ? NULL : (var = (g_key_file_free (var), NULL)))
-#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
-#define _g_free0(var) (var = (g_free (var), NULL))
-#define _dbus_g_connection_unref0(var) ((var == NULL) ? NULL : (var = (dbus_g_connection_unref (var), NULL)))
-#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
-
-typedef enum  {
-	RYGEL_LOG_LEVEL_INVALID = 0,
-	RYGEL_LOG_LEVEL_CRITICAL = 1,
-	RYGEL_LOG_LEVEL_ERROR = 2,
-	RYGEL_LOG_LEVEL_WARNING = 3,
-	RYGEL_LOG_LEVEL_INFO = 4,
-	RYGEL_LOG_LEVEL_DEFAULT = 4,
-	RYGEL_LOG_LEVEL_DEBUG = 5
-} RygelLogLevel;
-
-struct _RygelConfigurationIface {
-	GTypeInterface parent_iface;
-	gboolean (*get_upnp_enabled) (RygelConfiguration* self, GError** error);
-	char* (*get_interface) (RygelConfiguration* self, GError** error);
-	gint (*get_port) (RygelConfiguration* self, GError** error);
-	gboolean (*get_transcoding) (RygelConfiguration* self, GError** error);
-	gboolean (*get_mp3_transcoder) (RygelConfiguration* self, GError** error);
-	gboolean (*get_mp2ts_transcoder) (RygelConfiguration* self, GError** error);
-	gboolean (*get_lpcm_transcoder) (RygelConfiguration* self, GError** error);
-	RygelLogLevel (*get_log_level) (RygelConfiguration* self, GError** error);
-	gboolean (*get_enabled) (RygelConfiguration* self, const char* section, GError** error);
-	char* (*get_title) (RygelConfiguration* self, const char* section, GError** error);
-	char* (*get_string) (RygelConfiguration* self, const char* section, const char* key, GError** error);
-	GeeArrayList* (*get_string_list) (RygelConfiguration* self, const char* section, const char* key, GError** error);
-	gint (*get_int) (RygelConfiguration* self, const char* section, const char* key, gint min, gint max, GError** error);
-	GeeArrayList* (*get_int_list) (RygelConfiguration* self, const char* section, const char* key, GError** error);
-	gboolean (*get_bool) (RygelConfiguration* self, const char* section, const char* key, GError** error);
-};
-
-struct _RygelUserConfig {
-	GObject parent_instance;
-	RygelUserConfigPrivate * priv;
-	GKeyFile* key_file;
-};
-
-struct _RygelUserConfigClass {
-	GObjectClass parent_class;
-};
-
-struct _RygelUserConfigPrivate {
-	gboolean read_only;
-	DBusGProxy* dbus_obj;
-	DBusGProxy* rygel_obj;
-};
-
-typedef enum  {
-	RYGEL_CONFIGURATION_ERROR_NO_VALUE_SET,
-	RYGEL_CONFIGURATION_ERROR_VALUE_OUT_OF_RANGE
-} RygelConfigurationError;
-#define RYGEL_CONFIGURATION_ERROR rygel_configuration_error_quark ()
-
-static RygelUserConfig* rygel_user_config_config;
-static RygelUserConfig* rygel_user_config_config = NULL;
-static gpointer rygel_user_config_parent_class = NULL;
-static RygelConfigurationIface* rygel_user_config_rygel_configuration_parent_iface = NULL;
-
-GType rygel_log_level_get_type (void);
-GType rygel_configuration_get_type (void);
-GType rygel_user_config_get_type (void);
-#define RYGEL_USER_CONFIG_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), RYGEL_TYPE_USER_CONFIG, RygelUserConfigPrivate))
-enum  {
-	RYGEL_USER_CONFIG_DUMMY_PROPERTY
-};
-#define RYGEL_USER_CONFIG_CONFIG_FILE "rygel.conf"
-#define RYGEL_USER_CONFIG_IFACE_KEY "interface"
-#define RYGEL_USER_CONFIG_PORT_KEY "port"
-#define RYGEL_USER_CONFIG_ENABLED_KEY "enabled"
-#define RYGEL_USER_CONFIG_TITLE_KEY "title"
-#define RYGEL_USER_CONFIG_TRANSCODING_KEY "enable-transcoding"
-#define RYGEL_USER_CONFIG_MP3_TRANSCODER_KEY "enable-mp3-transcoder"
-#define RYGEL_USER_CONFIG_MP2TS_TRANSCODER_KEY "enable-mp2ts-transcoder"
-#define RYGEL_USER_CONFIG_LPCM_TRANSCODER_KEY "enable-lpcm-transcoder"
-#define RYGEL_USER_CONFIG_LOG_LEVEL_KEY "log-level"
-#define RYGEL_USER_CONFIG_DBUS_SERVICE "org.freedesktop.DBus"
-#define RYGEL_USER_CONFIG_DBUS_PATH "/org/freedesktop/DBus"
-#define RYGEL_USER_CONFIG_DBUS_INTERFACE "org.freedesktop.DBus"
-#define RYGEL_USER_CONFIG_RYGEL_SERVICE "org.gnome.Rygel1"
-#define RYGEL_USER_CONFIG_RYGEL_PATH "/org/gnome/Rygel1"
-#define RYGEL_USER_CONFIG_RYGEL_INTERFACE "org.gnome.Rygel1"
-gboolean rygel_configuration_get_bool (RygelConfiguration* self, const char* section, const char* key, GError** error);
-static gboolean rygel_user_config_real_get_upnp_enabled (RygelConfiguration* base, GError** error);
-gboolean rygel_configuration_get_upnp_enabled (RygelConfiguration* self, GError** error);
-static void rygel_user_config_enable_upnp (RygelUserConfig* self, gboolean enable);
-void rygel_user_config_set_upnp_enabled (RygelUserConfig* self, gboolean value);
-char* rygel_configuration_get_string (RygelConfiguration* self, const char* section, const char* key, GError** error);
-static char* rygel_user_config_real_get_interface (RygelConfiguration* base, GError** error);
-void rygel_user_config_set_string (RygelUserConfig* self, const char* section, const char* key, const char* value);
-void rygel_user_config_set_interface (RygelUserConfig* self, const char* value);
-gint rygel_configuration_get_int (RygelConfiguration* self, const char* section, const char* key, gint min, gint max, GError** error);
-static gint rygel_user_config_real_get_port (RygelConfiguration* base, GError** error);
-void rygel_user_config_set_int (RygelUserConfig* self, const char* section, const char* key, gint value);
-void rygel_user_config_set_port (RygelUserConfig* self, gint value);
-static gboolean rygel_user_config_real_get_transcoding (RygelConfiguration* base, GError** error);
-void rygel_user_config_set_bool (RygelUserConfig* self, const char* section, const char* key, gboolean value);
-void rygel_user_config_set_transcoding (RygelUserConfig* self, gboolean value);
-static gboolean rygel_user_config_real_get_mp3_transcoder (RygelConfiguration* base, GError** error);
-void rygel_user_config_set_mp3_transcoder (RygelUserConfig* self, gboolean value);
-static gboolean rygel_user_config_real_get_mp2ts_transcoder (RygelConfiguration* base, GError** error);
-void rygel_user_config_set_mp2ts_transcoder (RygelUserConfig* self, gboolean value);
-static gboolean rygel_user_config_real_get_lpcm_transcoder (RygelConfiguration* base, GError** error);
-void rygel_user_config_set_lpcm_transcoder (RygelUserConfig* self, gboolean value);
-static RygelLogLevel rygel_user_config_real_get_log_level (RygelConfiguration* base, GError** error);
-RygelUserConfig* rygel_user_config_new (gboolean read_only, GError** error);
-RygelUserConfig* rygel_user_config_construct (GType object_type, gboolean read_only, GError** error);
-RygelUserConfig* rygel_user_config_get_default (GError** error);
-void rygel_user_config_save (RygelUserConfig* self);
-static gboolean rygel_user_config_real_get_enabled (RygelConfiguration* base, const char* section, GError** error);
-static char* rygel_user_config_real_get_title (RygelConfiguration* base, const char* section, GError** error);
-GQuark rygel_configuration_error_quark (void);
-static char* rygel_user_config_real_get_string (RygelConfiguration* base, const char* section, const char* key, GError** error);
-static GeeArrayList* rygel_user_config_real_get_string_list (RygelConfiguration* base, const char* section, const char* key, GError** error);
-static gint rygel_user_config_real_get_int (RygelConfiguration* base, const char* section, const char* key, gint min, gint max, GError** error);
-static GeeArrayList* rygel_user_config_real_get_int_list (RygelConfiguration* base, const char* section, const char* key, GError** error);
-static gboolean rygel_user_config_real_get_bool (RygelConfiguration* base, const char* section, const char* key, GError** error);
-void rygel_user_config_set_string_list (RygelUserConfig* self, const char* section, const char* key, GeeArrayList* str_list);
-void _dynamic_StartServiceByName0 (DBusGProxy* self, const char* param1, guint32 param2, guint32* param3, GError** error);
-void _dynamic_Shutdown1 (DBusGProxy* self, GError** error);
-static void rygel_user_config_finalize (GObject* obj);
-static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
-static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);
-static int _vala_strcmp0 (const char * str1, const char * str2);
-
-
-
-static gboolean rygel_user_config_real_get_upnp_enabled (RygelConfiguration* base, GError** error) {
-	RygelUserConfig * self;
-	gboolean result;
-	GError * _inner_error_;
-	gboolean _tmp0_;
-	self = (RygelUserConfig*) base;
-	_inner_error_ = NULL;
-	_tmp0_ = rygel_configuration_get_bool ((RygelConfiguration*) self, "general", RYGEL_USER_CONFIG_ENABLED_KEY, &_inner_error_);
-	if (_inner_error_ != NULL) {
-		g_propagate_error (error, _inner_error_);
-		return FALSE;
-	}
-	result = _tmp0_;
-	return result;
-}
-
-
-void rygel_user_config_set_upnp_enabled (RygelUserConfig* self, gboolean value) {
-	GError * _inner_error_;
-	gboolean _tmp0_;
-	g_return_if_fail (self != NULL);
-	_inner_error_ = NULL;
-	_tmp0_ = rygel_configuration_get_upnp_enabled ((RygelConfiguration*) self, &_inner_error_);
-	if (_inner_error_ != NULL) {
-		g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
-		g_clear_error (&_inner_error_);
-		return;
-	}
-	if (value != _tmp0_) {
-		rygel_user_config_enable_upnp (self, value);
-	}
-}
-
-
-static char* rygel_user_config_real_get_interface (RygelConfiguration* base, GError** error) {
-	RygelUserConfig * self;
-	char* result;
-	GError * _inner_error_;
-	char* _tmp0_;
-	self = (RygelUserConfig*) base;
-	_inner_error_ = NULL;
-	_tmp0_ = rygel_configuration_get_string ((RygelConfiguration*) self, "general", RYGEL_USER_CONFIG_IFACE_KEY, &_inner_error_);
-	if (_inner_error_ != NULL) {
-		g_propagate_error (error, _inner_error_);
-		return NULL;
-	}
-	result = _tmp0_;
-	return result;
-}
-
-
-void rygel_user_config_set_interface (RygelUserConfig* self, const char* value) {
-	g_return_if_fail (self != NULL);
-	g_return_if_fail (value != NULL);
-	rygel_user_config_set_string (self, "general", RYGEL_USER_CONFIG_IFACE_KEY, value);
-}
-
-
-static gint rygel_user_config_real_get_port (RygelConfiguration* base, GError** error) {
-	RygelUserConfig * self;
-	gint result;
-	GError * _inner_error_;
-	gint _tmp0_;
-	self = (RygelUserConfig*) base;
-	_inner_error_ = NULL;
-	_tmp0_ = rygel_configuration_get_int ((RygelConfiguration*) self, "general", RYGEL_USER_CONFIG_PORT_KEY, (gint) 0U, (gint) G_MAXUINT16, &_inner_error_);
-	if (_inner_error_ != NULL) {
-		g_propagate_error (error, _inner_error_);
-		return 0;
-	}
-	result = _tmp0_;
-	return result;
-}
-
-
-void rygel_user_config_set_port (RygelUserConfig* self, gint value) {
-	g_return_if_fail (self != NULL);
-	rygel_user_config_set_int (self, "general", RYGEL_USER_CONFIG_PORT_KEY, value);
-}
-
-
-static gboolean rygel_user_config_real_get_transcoding (RygelConfiguration* base, GError** error) {
-	RygelUserConfig * self;
-	gboolean result;
-	GError * _inner_error_;
-	gboolean _tmp0_;
-	self = (RygelUserConfig*) base;
-	_inner_error_ = NULL;
-	_tmp0_ = rygel_configuration_get_bool ((RygelConfiguration*) self, "general", RYGEL_USER_CONFIG_TRANSCODING_KEY, &_inner_error_);
-	if (_inner_error_ != NULL) {
-		g_propagate_error (error, _inner_error_);
-		return FALSE;
-	}
-	result = _tmp0_;
-	return result;
-}
-
-
-void rygel_user_config_set_transcoding (RygelUserConfig* self, gboolean value) {
-	g_return_if_fail (self != NULL);
-	rygel_user_config_set_bool (self, "general", RYGEL_USER_CONFIG_TRANSCODING_KEY, value);
-}
-
-
-static gboolean rygel_user_config_real_get_mp3_transcoder (RygelConfiguration* base, GError** error) {
-	RygelUserConfig * self;
-	gboolean result;
-	GError * _inner_error_;
-	gboolean _tmp0_;
-	self = (RygelUserConfig*) base;
-	_inner_error_ = NULL;
-	_tmp0_ = rygel_configuration_get_bool ((RygelConfiguration*) self, "general", RYGEL_USER_CONFIG_MP3_TRANSCODER_KEY, &_inner_error_);
-	if (_inner_error_ != NULL) {
-		g_propagate_error (error, _inner_error_);
-		return FALSE;
-	}
-	result = _tmp0_;
-	return result;
-}
-
-
-void rygel_user_config_set_mp3_transcoder (RygelUserConfig* self, gboolean value) {
-	g_return_if_fail (self != NULL);
-	rygel_user_config_set_bool (self, "general", RYGEL_USER_CONFIG_MP3_TRANSCODER_KEY, value);
-}
-
-
-static gboolean rygel_user_config_real_get_mp2ts_transcoder (RygelConfiguration* base, GError** error) {
-	RygelUserConfig * self;
-	gboolean result;
-	GError * _inner_error_;
-	gboolean _tmp0_;
-	self = (RygelUserConfig*) base;
-	_inner_error_ = NULL;
-	_tmp0_ = rygel_configuration_get_bool ((RygelConfiguration*) self, "general", RYGEL_USER_CONFIG_MP2TS_TRANSCODER_KEY, &_inner_error_);
-	if (_inner_error_ != NULL) {
-		g_propagate_error (error, _inner_error_);
-		return FALSE;
-	}
-	result = _tmp0_;
-	return result;
-}
-
-
-void rygel_user_config_set_mp2ts_transcoder (RygelUserConfig* self, gboolean value) {
-	g_return_if_fail (self != NULL);
-	rygel_user_config_set_bool (self, "general", RYGEL_USER_CONFIG_MP2TS_TRANSCODER_KEY, value);
-}
-
-
-static gboolean rygel_user_config_real_get_lpcm_transcoder (RygelConfiguration* base, GError** error) {
-	RygelUserConfig * self;
-	gboolean result;
-	GError * _inner_error_;
-	gboolean _tmp0_;
-	self = (RygelUserConfig*) base;
-	_inner_error_ = NULL;
-	_tmp0_ = rygel_configuration_get_bool ((RygelConfiguration*) self, "general", RYGEL_USER_CONFIG_LPCM_TRANSCODER_KEY, &_inner_error_);
-	if (_inner_error_ != NULL) {
-		g_propagate_error (error, _inner_error_);
-		return FALSE;
-	}
-	result = _tmp0_;
-	return result;
-}
-
-
-void rygel_user_config_set_lpcm_transcoder (RygelUserConfig* self, gboolean value) {
-	g_return_if_fail (self != NULL);
-	rygel_user_config_set_bool (self, "general", RYGEL_USER_CONFIG_LPCM_TRANSCODER_KEY, value);
-}
-
-
-static RygelLogLevel rygel_user_config_real_get_log_level (RygelConfiguration* base, GError** error) {
-	RygelUserConfig * self;
-	RygelLogLevel result;
-	GError * _inner_error_;
-	gint _tmp0_;
-	self = (RygelUserConfig*) base;
-	_inner_error_ = NULL;
-	_tmp0_ = rygel_configuration_get_int ((RygelConfiguration*) self, "general", RYGEL_USER_CONFIG_LOG_LEVEL_KEY, (gint) RYGEL_LOG_LEVEL_INVALID, (gint) RYGEL_LOG_LEVEL_DEBUG, &_inner_error_);
-	if (_inner_error_ != NULL) {
-		g_propagate_error (error, _inner_error_);
-		return 0;
-	}
-	result = (RygelLogLevel) _tmp0_;
-	return result;
-}
-
-
-static gpointer _g_object_ref0 (gpointer self) {
-	return self ? g_object_ref (self) : NULL;
-}
-
-
-RygelUserConfig* rygel_user_config_get_default (GError** error) {
-	RygelUserConfig* result;
-	GError * _inner_error_;
-	_inner_error_ = NULL;
-	if (rygel_user_config_config == NULL) {
-		RygelUserConfig* _tmp0_;
-		RygelUserConfig* _tmp1_;
-		_tmp0_ = rygel_user_config_new (TRUE, &_inner_error_);
-		if (_inner_error_ != NULL) {
-			g_propagate_error (error, _inner_error_);
-			return NULL;
-		}
-		rygel_user_config_config = (_tmp1_ = _tmp0_, _g_object_unref0 (rygel_user_config_config), _tmp1_);
-	}
-	result = _g_object_ref0 (rygel_user_config_config);
-	return result;
-}
-
-
-RygelUserConfig* rygel_user_config_construct (GType object_type, gboolean read_only, GError** error) {
-	GError * _inner_error_;
-	RygelUserConfig * self;
-	GKeyFile* _tmp0_;
-	char** _tmp1_;
-	gint dirs_size;
-	gint dirs_length1;
-	char** dirs;
-	char* _tmp2_;
-	char* _tmp3_;
-	char* path;
-	char* _tmp6_;
-	gboolean _tmp5_;
-	char* _tmp4_ = NULL;
-	_inner_error_ = NULL;
-	self = (RygelUserConfig*) g_object_new (object_type, NULL);
-	self->priv->read_only = read_only;
-	self->key_file = (_tmp0_ = g_key_file_new (), _g_key_file_free0 (self->key_file), _tmp0_);
-	dirs = (_tmp1_ = g_new0 (char*, 2 + 1), dirs_length1 = 2, dirs_size = dirs_length1, _tmp1_);
-	dirs[0] = (_tmp2_ = g_strdup (g_get_user_config_dir ()), _g_free0 (dirs[0]), _tmp2_);
-	dirs[1] = (_tmp3_ = g_strdup (SYS_CONFIG_DIR), _g_free0 (dirs[1]), _tmp3_);
-	path = NULL;
-	_tmp5_ = g_key_file_load_from_dirs (self->key_file, RYGEL_USER_CONFIG_CONFIG_FILE, dirs, &_tmp4_, G_KEY_FILE_KEEP_COMMENTS | G_KEY_FILE_KEEP_TRANSLATIONS, &_inner_error_);
-	path = (_tmp6_ = _tmp4_, _g_free0 (path), _tmp6_);
-	_tmp5_;
-	if (_inner_error_ != NULL) {
-		g_propagate_error (error, _inner_error_);
-		dirs = (_vala_array_free (dirs, dirs_length1, (GDestroyNotify) g_free), NULL);
-		_g_free0 (path);
-		return;
-	}
-	g_debug ("rygel-user-config.vala:148: Loaded user configuration from file '%s'", path);
-	{
-		DBusGConnection* connection;
-		DBusGProxy* _tmp7_;
-		DBusGProxy* _tmp8_;
-		connection = dbus_g_bus_get (DBUS_BUS_SESSION, &_inner_error_);
-		if (_inner_error_ != NULL) {
-			if (_inner_error_->domain == DBUS_GERROR) {
-				goto __catch0_dbus_gerror;
-			}
-			goto __finally0;
-		}
-		self->priv->rygel_obj = (_tmp7_ = dbus_g_proxy_new_for_name (connection, RYGEL_USER_CONFIG_RYGEL_SERVICE, RYGEL_USER_CONFIG_RYGEL_PATH, RYGEL_USER_CONFIG_RYGEL_INTERFACE), _g_object_unref0 (self->priv->rygel_obj), _tmp7_);
-		self->priv->dbus_obj = (_tmp8_ = dbus_g_proxy_new_for_name (connection, RYGEL_USER_CONFIG_DBUS_SERVICE, RYGEL_USER_CONFIG_DBUS_PATH, RYGEL_USER_CONFIG_DBUS_INTERFACE), _g_object_unref0 (self->priv->dbus_obj), _tmp8_);
-		_dbus_g_connection_unref0 (connection);
-	}
-	goto __finally0;
-	__catch0_dbus_gerror:
-	{
-		GError * err;
-		err = _inner_error_;
-		_inner_error_ = NULL;
-		{
-			g_debug ("rygel-user-config.vala:162: Failed to connect to session bus: %s", err->message);
-			_g_error_free0 (err);
-		}
-	}
-	__finally0:
-	if (_inner_error_ != NULL) {
-		g_propagate_error (error, _inner_error_);
-		dirs = (_vala_array_free (dirs, dirs_length1, (GDestroyNotify) g_free), NULL);
-		_g_free0 (path);
-		return;
-	}
-	dirs = (_vala_array_free (dirs, dirs_length1, (GDestroyNotify) g_free), NULL);
-	_g_free0 (path);
-	return self;
-}
-
-
-RygelUserConfig* rygel_user_config_new (gboolean read_only, GError** error) {
-	return rygel_user_config_construct (RYGEL_TYPE_USER_CONFIG, read_only, error);
-}
-
-
-void rygel_user_config_save (RygelUserConfig* self) {
-	GError * _inner_error_;
-	char* path;
-	gsize length = 0UL;
-	char* data;
-	g_return_if_fail (self != NULL);
-	_inner_error_ = NULL;
-	g_return_if_fail (!self->priv->read_only);
-	path = g_build_filename (g_get_user_config_dir (), RYGEL_USER_CONFIG_CONFIG_FILE, NULL);
-	data = g_key_file_to_data (self->key_file, &length, NULL);
-	{
-		g_file_set_contents (path, data, (glong) length, &_inner_error_);
-		if (_inner_error_ != NULL) {
-			if (_inner_error_->domain == G_FILE_ERROR) {
-				goto __catch1_g_file_error;
-			}
-			goto __finally1;
-		}
-	}
-	goto __finally1;
-	__catch1_g_file_error:
-	{
-		GError * err;
-		err = _inner_error_;
-		_inner_error_ = NULL;
-		{
-			g_critical ("rygel-user-config.vala:179: Failed to save configuration data to file '%s': %s", path, err->message);
-			_g_error_free0 (err);
-		}
-	}
-	__finally1:
-	if (_inner_error_ != NULL) {
-		_g_free0 (path);
-		_g_free0 (data);
-		g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
-		g_clear_error (&_inner_error_);
-		return;
-	}
-	_g_free0 (path);
-	_g_free0 (data);
-}
-
-
-static gboolean rygel_user_config_real_get_enabled (RygelConfiguration* base, const char* section, GError** error) {
-	RygelUserConfig * self;
-	gboolean result;
-	GError * _inner_error_;
-	gboolean _tmp0_;
-	self = (RygelUserConfig*) base;
-	g_return_val_if_fail (section != NULL, FALSE);
-	_inner_error_ = NULL;
-	_tmp0_ = rygel_configuration_get_bool ((RygelConfiguration*) self, section, RYGEL_USER_CONFIG_ENABLED_KEY, &_inner_error_);
-	if (_inner_error_ != NULL) {
-		g_propagate_error (error, _inner_error_);
-		return FALSE;
-	}
-	result = _tmp0_;
-	return result;
-}
-
-
-static char* rygel_user_config_real_get_title (RygelConfiguration* base, const char* section, GError** error) {
-	RygelUserConfig * self;
-	char* result;
-	GError * _inner_error_;
-	char* _tmp0_;
-	self = (RygelUserConfig*) base;
-	g_return_val_if_fail (section != NULL, NULL);
-	_inner_error_ = NULL;
-	_tmp0_ = rygel_configuration_get_string ((RygelConfiguration*) self, section, RYGEL_USER_CONFIG_TITLE_KEY, &_inner_error_);
-	if (_inner_error_ != NULL) {
-		g_propagate_error (error, _inner_error_);
-		return NULL;
-	}
-	result = _tmp0_;
-	return result;
-}
-
-
-static char* rygel_user_config_real_get_string (RygelConfiguration* base, const char* section, const char* key, GError** error) {
-	RygelUserConfig * self;
-	char* result;
-	GError * _inner_error_;
-	char* val;
-	gboolean _tmp0_ = FALSE;
-	self = (RygelUserConfig*) base;
-	g_return_val_if_fail (section != NULL, NULL);
-	g_return_val_if_fail (key != NULL, NULL);
-	_inner_error_ = NULL;
-	val = g_key_file_get_string (self->key_file, section, key, &_inner_error_);
-	if (_inner_error_ != NULL) {
-		g_propagate_error (error, _inner_error_);
-		return NULL;
-	}
-	if (val == NULL) {
-		_tmp0_ = TRUE;
-	} else {
-		_tmp0_ = _vala_strcmp0 (val, "") == 0;
-	}
-	if (_tmp0_) {
-		_inner_error_ = g_error_new (RYGEL_CONFIGURATION_ERROR, RYGEL_CONFIGURATION_ERROR_NO_VALUE_SET, "No value available for '%s'", key);
-		if (_inner_error_ != NULL) {
-			g_propagate_error (error, _inner_error_);
-			_g_free0 (val);
-			return NULL;
-		}
-	}
-	result = val;
-	return result;
-}
-
-
-static GeeArrayList* rygel_user_config_real_get_string_list (RygelConfiguration* base, const char* section, const char* key, GError** error) {
-	RygelUserConfig * self;
-	GeeArrayList* result;
-	GError * _inner_error_;
-	GeeArrayList* str_list;
-	char** _tmp1_;
-	gint strings_size;
-	gint strings_length1;
-	gsize _tmp0_;
-	char** strings;
-	self = (RygelUserConfig*) base;
-	g_return_val_if_fail (section != NULL, NULL);
-	g_return_val_if_fail (key != NULL, NULL);
-	_inner_error_ = NULL;
-	str_list = gee_array_list_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, g_direct_equal);
-	strings = (_tmp1_ = g_key_file_get_string_list (self->key_file, section, key, &_tmp0_, &_inner_error_), strings_length1 = _tmp0_, strings_size = strings_length1, _tmp1_);
-	if (_inner_error_ != NULL) {
-		g_propagate_error (error, _inner_error_);
-		_g_object_unref0 (str_list);
-		return NULL;
-	}
-	{
-		char** str_collection;
-		int str_collection_length1;
-		int str_it;
-		str_collection = strings;
-		str_collection_length1 = strings_length1;
-		for (str_it = 0; str_it < strings_length1; str_it = str_it + 1) {
-			char* str;
-			str = g_strdup (str_collection[str_it]);
-			{
-				gee_abstract_collection_add ((GeeAbstractCollection*) str_list, str);
-				_g_free0 (str);
-			}
-		}
-	}
-	result = str_list;
-	strings = (_vala_array_free (strings, strings_length1, (GDestroyNotify) g_free), NULL);
-	return result;
-}
-
-
-static gint rygel_user_config_real_get_int (RygelConfiguration* base, const char* section, const char* key, gint min, gint max, GError** error) {
-	RygelUserConfig * self;
-	gint result;
-	GError * _inner_error_;
-	gint val;
-	gboolean _tmp0_ = FALSE;
-	gboolean _tmp1_ = FALSE;
-	self = (RygelUserConfig*) base;
-	g_return_val_if_fail (section != NULL, 0);
-	g_return_val_if_fail (key != NULL, 0);
-	_inner_error_ = NULL;
-	val = g_key_file_get_integer (self->key_file, section, key, &_inner_error_);
-	if (_inner_error_ != NULL) {
-		g_propagate_error (error, _inner_error_);
-		return 0;
-	}
-	if (val == 0) {
-		_tmp1_ = TRUE;
-	} else {
-		_tmp1_ = val < min;
-	}
-	if (_tmp1_) {
-		_tmp0_ = TRUE;
-	} else {
-		_tmp0_ = val > max;
-	}
-	if (_tmp0_) {
-		_inner_error_ = g_error_new (RYGEL_CONFIGURATION_ERROR, RYGEL_CONFIGURATION_ERROR_VALUE_OUT_OF_RANGE, "Value of '%s' out of range", key);
-		if (_inner_error_ != NULL) {
-			g_propagate_error (error, _inner_error_);
-			return 0;
-		}
-	}
-	result = val;
-	return result;
-}
-
-
-static GeeArrayList* rygel_user_config_real_get_int_list (RygelConfiguration* base, const char* section, const char* key, GError** error) {
-	RygelUserConfig * self;
-	GeeArrayList* result;
-	GError * _inner_error_;
-	GeeArrayList* int_list;
-	gint* _tmp1_;
-	gint ints_size;
-	gint ints_length1;
-	gsize _tmp0_;
-	gint* ints;
-	self = (RygelUserConfig*) base;
-	g_return_val_if_fail (section != NULL, NULL);
-	g_return_val_if_fail (key != NULL, NULL);
-	_inner_error_ = NULL;
-	int_list = gee_array_list_new (G_TYPE_INT, NULL, NULL, g_direct_equal);
-	ints = (_tmp1_ = g_key_file_get_integer_list (self->key_file, section, key, &_tmp0_, &_inner_error_), ints_length1 = _tmp0_, ints_size = ints_length1, _tmp1_);
-	if (_inner_error_ != NULL) {
-		g_propagate_error (error, _inner_error_);
-		_g_object_unref0 (int_list);
-		return NULL;
-	}
-	{
-		gint* num_collection;
-		int num_collection_length1;
-		int num_it;
-		num_collection = ints;
-		num_collection_length1 = ints_length1;
-		for (num_it = 0; num_it < ints_length1; num_it = num_it + 1) {
-			gint num;
-			num = num_collection[num_it];
-			{
-				gee_abstract_collection_add ((GeeAbstractCollection*) int_list, GINT_TO_POINTER (num));
-			}
-		}
-	}
-	result = int_list;
-	ints = (g_free (ints), NULL);
-	return result;
-}
-
-
-static gboolean rygel_user_config_real_get_bool (RygelConfiguration* base, const char* section, const char* key, GError** error) {
-	RygelUserConfig * self;
-	gboolean result;
-	GError * _inner_error_;
-	gboolean _tmp0_;
-	self = (RygelUserConfig*) base;
-	g_return_val_if_fail (section != NULL, FALSE);
-	g_return_val_if_fail (key != NULL, FALSE);
-	_inner_error_ = NULL;
-	_tmp0_ = g_key_file_get_boolean (self->key_file, section, key, &_inner_error_);
-	if (_inner_error_ != NULL) {
-		g_propagate_error (error, _inner_error_);
-		return FALSE;
-	}
-	result = _tmp0_;
-	return result;
-}
-
-
-void rygel_user_config_set_string (RygelUserConfig* self, const char* section, const char* key, const char* value) {
-	g_return_if_fail (self != NULL);
-	g_return_if_fail (section != NULL);
-	g_return_if_fail (key != NULL);
-	g_return_if_fail (value != NULL);
-	g_key_file_set_string (self->key_file, section, key, value);
-}
-
-
-void rygel_user_config_set_string_list (RygelUserConfig* self, const char* section, const char* key, GeeArrayList* str_list) {
-	char** _tmp1_;
-	gint strings_size;
-	gint strings_length1;
-	gint _tmp0_;
-	char** strings;
-	gint i;
-	g_return_if_fail (self != NULL);
-	g_return_if_fail (section != NULL);
-	g_return_if_fail (key != NULL);
-	g_return_if_fail (str_list != NULL);
-	strings = (_tmp1_ = g_new0 (char*, (_tmp0_ = gee_collection_get_size ((GeeCollection*) str_list)) + 1), strings_length1 = _tmp0_, strings_size = strings_length1, _tmp1_);
-	i = 0;
-	{
-		GeeIterator* _str_it;
-		_str_it = gee_abstract_collection_iterator ((GeeAbstractCollection*) str_list);
-		while (TRUE) {
-			char* str;
-			if (!gee_iterator_next (_str_it)) {
-				break;
-			}
-			str = (char*) gee_iterator_get (_str_it);
-			if (_vala_strcmp0 (str, "") != 0) {
-				char* _tmp3_;
-				char* *_tmp2_;
-				_tmp2_ = &strings[i++];
-				(*_tmp2_) = (_tmp3_ = g_strdup (str), _g_free0 ((*_tmp2_)), _tmp3_);
-			}
-			_g_free0 (str);
-		}
-		_g_object_unref0 (_str_it);
-	}
-	g_key_file_set_string_list (self->key_file, section, key, strings, strings_length1);
-	strings = (_vala_array_free (strings, strings_length1, (GDestroyNotify) g_free), NULL);
-}
-
-
-void rygel_user_config_set_int (RygelUserConfig* self, const char* section, const char* key, gint value) {
-	g_return_if_fail (self != NULL);
-	g_return_if_fail (section != NULL);
-	g_return_if_fail (key != NULL);
-	g_key_file_set_integer (self->key_file, section, key, value);
-}
-
-
-void rygel_user_config_set_bool (RygelUserConfig* self, const char* section, const char* key, gboolean value) {
-	g_return_if_fail (self != NULL);
-	g_return_if_fail (section != NULL);
-	g_return_if_fail (key != NULL);
-	g_key_file_set_boolean (self->key_file, section, key, value);
-}
-
-
-void _dynamic_StartServiceByName0 (DBusGProxy* self, const char* param1, guint32 param2, guint32* param3, GError** error) {
-	dbus_g_proxy_call (self, "StartServiceByName", error, G_TYPE_STRING, param1, G_TYPE_UINT, param2, G_TYPE_INVALID, G_TYPE_UINT, param3, G_TYPE_INVALID);
-	if (*error) {
-		return;
-	}
-}
-
-
-void _dynamic_Shutdown1 (DBusGProxy* self, GError** error) {
-	dbus_g_proxy_call (self, "Shutdown", error, G_TYPE_INVALID, G_TYPE_INVALID);
-	if (*error) {
-		return;
-	}
-}
-
-
-static void rygel_user_config_enable_upnp (RygelUserConfig* self, gboolean enable) {
-	GError * _inner_error_;
-	char* dest_path;
-	GFile* dest;
-	g_return_if_fail (self != NULL);
-	_inner_error_ = NULL;
-	dest_path = g_build_filename (g_get_user_config_dir (), "autostart", "rygel.desktop", NULL);
-	dest = g_file_new_for_path (dest_path);
-	{
-		if (enable) {
-			guint32 res = 0U;
-			char* source_path;
-			if (self->priv->dbus_obj != NULL) {
-				_dynamic_StartServiceByName0 (self->priv->dbus_obj, RYGEL_USER_CONFIG_RYGEL_SERVICE, (guint32) 0, &res, &_inner_error_);
-				if (_inner_error_ != NULL) {
-					goto __catch2_g_error;
-					goto __finally2;
-				}
-			}
-			source_path = g_build_filename (DESKTOP_DIR, "rygel.desktop", NULL);
-			{
-				g_file_make_symbolic_link (dest, source_path, NULL, &_inner_error_);
-				if (_inner_error_ != NULL) {
-					if (g_error_matches (_inner_error_, G_IO_ERROR, G_IO_ERROR_EXISTS)) {
-						goto __catch3_g_io_error_exists;
-					}
-					goto __finally3;
-				}
-			}
-			goto __finally3;
-			__catch3_g_io_error_exists:
-			{
-				GError * err;
-				err = _inner_error_;
-				_inner_error_ = NULL;
-				{
-					_g_error_free0 (err);
-				}
-			}
-			__finally3:
-			if (_inner_error_ != NULL) {
-				_g_free0 (source_path);
-				goto __catch2_g_error;
-				goto __finally2;
-			}
-			rygel_user_config_set_bool (self, "general", RYGEL_USER_CONFIG_ENABLED_KEY, TRUE);
-			_g_free0 (source_path);
-		} else {
-			if (self->priv->rygel_obj != NULL) {
-				_dynamic_Shutdown1 (self->priv->rygel_obj, &_inner_error_);
-				if (_inner_error_ != NULL) {
-					goto __catch2_g_error;
-					goto __finally2;
-				}
-			}
-			{
-				g_file_delete (dest, NULL, &_inner_error_);
-				if (_inner_error_ != NULL) {
-					if (g_error_matches (_inner_error_, G_IO_ERROR, G_IO_ERROR_NOT_FOUND)) {
-						goto __catch4_g_io_error_not_found;
-					}
-					goto __finally4;
-				}
-			}
-			goto __finally4;
-			__catch4_g_io_error_not_found:
-			{
-				GError * err;
-				err = _inner_error_;
-				_inner_error_ = NULL;
-				{
-					_g_error_free0 (err);
-				}
-			}
-			__finally4:
-			if (_inner_error_ != NULL) {
-				goto __catch2_g_error;
-				goto __finally2;
-			}
-			rygel_user_config_set_bool (self, "general", RYGEL_USER_CONFIG_ENABLED_KEY, FALSE);
-		}
-	}
-	goto __finally2;
-	__catch2_g_error:
-	{
-		GError * err;
-		err = _inner_error_;
-		_inner_error_ = NULL;
-		{
-			const char* _tmp0_;
-			_tmp0_ = NULL;
-			if (enable) {
-				_tmp0_ = "start";
-			} else {
-				_tmp0_ = "stop";
-			}
-			g_warning ("rygel-user-config.vala:325: Failed to %s Rygel service: %s\n", _tmp0_, err->message);
-			_g_error_free0 (err);
-		}
-	}
-	__finally2:
-	if (_inner_error_ != NULL) {
-		_g_free0 (dest_path);
-		_g_object_unref0 (dest);
-		g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
-		g_clear_error (&_inner_error_);
-		return;
-	}
-	_g_free0 (dest_path);
-	_g_object_unref0 (dest);
-}
-
-
-static void rygel_user_config_class_init (RygelUserConfigClass * klass) {
-	rygel_user_config_parent_class = g_type_class_peek_parent (klass);
-	g_type_class_add_private (klass, sizeof (RygelUserConfigPrivate));
-	G_OBJECT_CLASS (klass)->finalize = rygel_user_config_finalize;
-}
-
-
-static void rygel_user_config_rygel_configuration_interface_init (RygelConfigurationIface * iface) {
-	rygel_user_config_rygel_configuration_parent_iface = g_type_interface_peek_parent (iface);
-	iface->get_upnp_enabled = rygel_user_config_real_get_upnp_enabled;
-	iface->get_interface = rygel_user_config_real_get_interface;
-	iface->get_port = rygel_user_config_real_get_port;
-	iface->get_transcoding = rygel_user_config_real_get_transcoding;
-	iface->get_mp3_transcoder = rygel_user_config_real_get_mp3_transcoder;
-	iface->get_mp2ts_transcoder = rygel_user_config_real_get_mp2ts_transcoder;
-	iface->get_lpcm_transcoder = rygel_user_config_real_get_lpcm_transcoder;
-	iface->get_log_level = rygel_user_config_real_get_log_level;
-	iface->get_enabled = rygel_user_config_real_get_enabled;
-	iface->get_title = rygel_user_config_real_get_title;
-	iface->get_string = rygel_user_config_real_get_string;
-	iface->get_string_list = rygel_user_config_real_get_string_list;
-	iface->get_int = rygel_user_config_real_get_int;
-	iface->get_int_list = rygel_user_config_real_get_int_list;
-	iface->get_bool = rygel_user_config_real_get_bool;
-}
-
-
-static void rygel_user_config_instance_init (RygelUserConfig * self) {
-	self->priv = RYGEL_USER_CONFIG_GET_PRIVATE (self);
-}
-
-
-static void rygel_user_config_finalize (GObject* obj) {
-	RygelUserConfig * self;
-	self = RYGEL_USER_CONFIG (obj);
-	_g_key_file_free0 (self->key_file);
-	_g_object_unref0 (self->priv->dbus_obj);
-	_g_object_unref0 (self->priv->rygel_obj);
-	G_OBJECT_CLASS (rygel_user_config_parent_class)->finalize (obj);
-}
-
-
-GType rygel_user_config_get_type (void) {
-	static GType rygel_user_config_type_id = 0;
-	if (rygel_user_config_type_id == 0) {
-		static const GTypeInfo g_define_type_info = { sizeof (RygelUserConfigClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) rygel_user_config_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (RygelUserConfig), 0, (GInstanceInitFunc) rygel_user_config_instance_init, NULL };
-		static const GInterfaceInfo rygel_configuration_info = { (GInterfaceInitFunc) rygel_user_config_rygel_configuration_interface_init, (GInterfaceFinalizeFunc) NULL, NULL};
-		rygel_user_config_type_id = g_type_register_static (G_TYPE_OBJECT, "RygelUserConfig", &g_define_type_info, 0);
-		g_type_add_interface_static (rygel_user_config_type_id, RYGEL_TYPE_CONFIGURATION, &rygel_configuration_info);
-	}
-	return rygel_user_config_type_id;
-}
-
-
-static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
-	if ((array != NULL) && (destroy_func != NULL)) {
-		int i;
-		for (i = 0; i < array_length; i = i + 1) {
-			if (((gpointer*) array)[i] != NULL) {
-				destroy_func (((gpointer*) array)[i]);
-			}
-		}
-	}
-}
-
-
-static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
-	_vala_array_destroy (array, array_length, destroy_func);
-	g_free (array);
-}
-
-
-static int _vala_strcmp0 (const char * str1, const char * str2) {
-	if (str1 == NULL) {
-		return -(str1 != str2);
-	}
-	if (str2 == NULL) {
-		return str1 != str2;
-	}
-	return strcmp (str1, str2);
-}
-
-
-
-
--- a/src/rygel/rygel.h
+++ /dev/null
@@ -1,895 +0,0 @@
-/* rygel.h generated by valac, the Vala compiler, do not modify */
-
-
-#ifndef __RYGEL_H__
-#define __RYGEL_H__
-
-#include <glib.h>
-#include <glib-object.h>
-#include <stdlib.h>
-#include <string.h>
-#include <gee.h>
-#include <libgupnp/gupnp.h>
-#include <gio/gio.h>
-#include <gst/gst.h>
-#include <dbus/dbus-glib-lowlevel.h>
-#include <dbus/dbus-glib.h>
-
-G_BEGIN_DECLS
-
-
-#define RYGEL_TYPE_CONFIGURATION (rygel_configuration_get_type ())
-#define RYGEL_CONFIGURATION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_CONFIGURATION, RygelConfiguration))
-#define RYGEL_IS_CONFIGURATION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_CONFIGURATION))
-#define RYGEL_CONFIGURATION_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), RYGEL_TYPE_CONFIGURATION, RygelConfigurationIface))
-
-typedef struct _RygelConfiguration RygelConfiguration;
-typedef struct _RygelConfigurationIface RygelConfigurationIface;
-
-#define RYGEL_TYPE_LOG_LEVEL (rygel_log_level_get_type ())
-
-#define RYGEL_TYPE_USER_CONFIG (rygel_user_config_get_type ())
-#define RYGEL_USER_CONFIG(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_USER_CONFIG, RygelUserConfig))
-#define RYGEL_USER_CONFIG_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_USER_CONFIG, RygelUserConfigClass))
-#define RYGEL_IS_USER_CONFIG(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_USER_CONFIG))
-#define RYGEL_IS_USER_CONFIG_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_USER_CONFIG))
-#define RYGEL_USER_CONFIG_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_USER_CONFIG, RygelUserConfigClass))
-
-typedef struct _RygelUserConfig RygelUserConfig;
-typedef struct _RygelUserConfigClass RygelUserConfigClass;
-typedef struct _RygelUserConfigPrivate RygelUserConfigPrivate;
-
-#define RYGEL_TYPE_META_CONFIG (rygel_meta_config_get_type ())
-#define RYGEL_META_CONFIG(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_META_CONFIG, RygelMetaConfig))
-#define RYGEL_META_CONFIG_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_META_CONFIG, RygelMetaConfigClass))
-#define RYGEL_IS_META_CONFIG(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_META_CONFIG))
-#define RYGEL_IS_META_CONFIG_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_META_CONFIG))
-#define RYGEL_META_CONFIG_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_META_CONFIG, RygelMetaConfigClass))
-
-typedef struct _RygelMetaConfig RygelMetaConfig;
-typedef struct _RygelMetaConfigClass RygelMetaConfigClass;
-typedef struct _RygelMetaConfigPrivate RygelMetaConfigPrivate;
-
-#define RYGEL_TYPE_CMDLINE_CONFIG (rygel_cmdline_config_get_type ())
-#define RYGEL_CMDLINE_CONFIG(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_CMDLINE_CONFIG, RygelCmdlineConfig))
-#define RYGEL_CMDLINE_CONFIG_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_CMDLINE_CONFIG, RygelCmdlineConfigClass))
-#define RYGEL_IS_CMDLINE_CONFIG(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_CMDLINE_CONFIG))
-#define RYGEL_IS_CMDLINE_CONFIG_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_CMDLINE_CONFIG))
-#define RYGEL_CMDLINE_CONFIG_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_CMDLINE_CONFIG, RygelCmdlineConfigClass))
-
-typedef struct _RygelCmdlineConfig RygelCmdlineConfig;
-typedef struct _RygelCmdlineConfigClass RygelCmdlineConfigClass;
-typedef struct _RygelCmdlineConfigPrivate RygelCmdlineConfigPrivate;
-
-#define RYGEL_TYPE_CONTENT_DIRECTORY (rygel_content_directory_get_type ())
-#define RYGEL_CONTENT_DIRECTORY(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_CONTENT_DIRECTORY, RygelContentDirectory))
-#define RYGEL_CONTENT_DIRECTORY_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_CONTENT_DIRECTORY, RygelContentDirectoryClass))
-#define RYGEL_IS_CONTENT_DIRECTORY(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_CONTENT_DIRECTORY))
-#define RYGEL_IS_CONTENT_DIRECTORY_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_CONTENT_DIRECTORY))
-#define RYGEL_CONTENT_DIRECTORY_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_CONTENT_DIRECTORY, RygelContentDirectoryClass))
-
-typedef struct _RygelContentDirectory RygelContentDirectory;
-typedef struct _RygelContentDirectoryClass RygelContentDirectoryClass;
-typedef struct _RygelContentDirectoryPrivate RygelContentDirectoryPrivate;
-
-#define RYGEL_TYPE_MEDIA_OBJECT (rygel_media_object_get_type ())
-#define RYGEL_MEDIA_OBJECT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_MEDIA_OBJECT, RygelMediaObject))
-#define RYGEL_MEDIA_OBJECT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_MEDIA_OBJECT, RygelMediaObjectClass))
-#define RYGEL_IS_MEDIA_OBJECT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_MEDIA_OBJECT))
-#define RYGEL_IS_MEDIA_OBJECT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_MEDIA_OBJECT))
-#define RYGEL_MEDIA_OBJECT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_MEDIA_OBJECT, RygelMediaObjectClass))
-
-typedef struct _RygelMediaObject RygelMediaObject;
-typedef struct _RygelMediaObjectClass RygelMediaObjectClass;
-
-#define RYGEL_TYPE_MEDIA_CONTAINER (rygel_media_container_get_type ())
-#define RYGEL_MEDIA_CONTAINER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_MEDIA_CONTAINER, RygelMediaContainer))
-#define RYGEL_MEDIA_CONTAINER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_MEDIA_CONTAINER, RygelMediaContainerClass))
-#define RYGEL_IS_MEDIA_CONTAINER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_MEDIA_CONTAINER))
-#define RYGEL_IS_MEDIA_CONTAINER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_MEDIA_CONTAINER))
-#define RYGEL_MEDIA_CONTAINER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_MEDIA_CONTAINER, RygelMediaContainerClass))
-
-typedef struct _RygelMediaContainer RygelMediaContainer;
-typedef struct _RygelMediaContainerClass RygelMediaContainerClass;
-
-#define RYGEL_TYPE_TRANSCODE_MANAGER (rygel_transcode_manager_get_type ())
-#define RYGEL_TRANSCODE_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_TRANSCODE_MANAGER, RygelTranscodeManager))
-#define RYGEL_TRANSCODE_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_TRANSCODE_MANAGER, RygelTranscodeManagerClass))
-#define RYGEL_IS_TRANSCODE_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_TRANSCODE_MANAGER))
-#define RYGEL_IS_TRANSCODE_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_TRANSCODE_MANAGER))
-#define RYGEL_TRANSCODE_MANAGER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_TRANSCODE_MANAGER, RygelTranscodeManagerClass))
-
-typedef struct _RygelTranscodeManager RygelTranscodeManager;
-typedef struct _RygelTranscodeManagerClass RygelTranscodeManagerClass;
-
-#define RYGEL_TYPE_HTTP_SERVER (rygel_http_server_get_type ())
-#define RYGEL_HTTP_SERVER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_HTTP_SERVER, RygelHTTPServer))
-#define RYGEL_HTTP_SERVER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_HTTP_SERVER, RygelHTTPServerClass))
-#define RYGEL_IS_HTTP_SERVER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_HTTP_SERVER))
-#define RYGEL_IS_HTTP_SERVER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_HTTP_SERVER))
-#define RYGEL_HTTP_SERVER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_HTTP_SERVER, RygelHTTPServerClass))
-
-typedef struct _RygelHTTPServer RygelHTTPServer;
-typedef struct _RygelHTTPServerClass RygelHTTPServerClass;
-
-#define RYGEL_TYPE_CONNECTION_MANAGER (rygel_connection_manager_get_type ())
-#define RYGEL_CONNECTION_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_CONNECTION_MANAGER, RygelConnectionManager))
-#define RYGEL_CONNECTION_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_CONNECTION_MANAGER, RygelConnectionManagerClass))
-#define RYGEL_IS_CONNECTION_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_CONNECTION_MANAGER))
-#define RYGEL_IS_CONNECTION_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_CONNECTION_MANAGER))
-#define RYGEL_CONNECTION_MANAGER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_CONNECTION_MANAGER, RygelConnectionManagerClass))
-
-typedef struct _RygelConnectionManager RygelConnectionManager;
-typedef struct _RygelConnectionManagerClass RygelConnectionManagerClass;
-typedef struct _RygelConnectionManagerPrivate RygelConnectionManagerPrivate;
-
-#define RYGEL_TYPE_STATE_MACHINE (rygel_state_machine_get_type ())
-#define RYGEL_STATE_MACHINE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_STATE_MACHINE, RygelStateMachine))
-#define RYGEL_IS_STATE_MACHINE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_STATE_MACHINE))
-#define RYGEL_STATE_MACHINE_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), RYGEL_TYPE_STATE_MACHINE, RygelStateMachineIface))
-
-typedef struct _RygelStateMachine RygelStateMachine;
-typedef struct _RygelStateMachineIface RygelStateMachineIface;
-
-#define RYGEL_TYPE_RESOURCE_INFO (rygel_resource_info_get_type ())
-#define RYGEL_RESOURCE_INFO(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_RESOURCE_INFO, RygelResourceInfo))
-#define RYGEL_RESOURCE_INFO_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_RESOURCE_INFO, RygelResourceInfoClass))
-#define RYGEL_IS_RESOURCE_INFO(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_RESOURCE_INFO))
-#define RYGEL_IS_RESOURCE_INFO_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_RESOURCE_INFO))
-#define RYGEL_RESOURCE_INFO_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_RESOURCE_INFO, RygelResourceInfoClass))
-
-typedef struct _RygelResourceInfo RygelResourceInfo;
-typedef struct _RygelResourceInfoClass RygelResourceInfoClass;
-typedef struct _RygelResourceInfoPrivate RygelResourceInfoPrivate;
-
-#define RYGEL_TYPE_ICON_INFO (rygel_icon_info_get_type ())
-#define RYGEL_ICON_INFO(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_ICON_INFO, RygelIconInfo))
-#define RYGEL_ICON_INFO_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_ICON_INFO, RygelIconInfoClass))
-#define RYGEL_IS_ICON_INFO(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_ICON_INFO))
-#define RYGEL_IS_ICON_INFO_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_ICON_INFO))
-#define RYGEL_ICON_INFO_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_ICON_INFO, RygelIconInfoClass))
-
-typedef struct _RygelIconInfo RygelIconInfo;
-typedef struct _RygelIconInfoClass RygelIconInfoClass;
-typedef struct _RygelIconInfoPrivate RygelIconInfoPrivate;
-
-#define RYGEL_TYPE_PLUGIN (rygel_plugin_get_type ())
-#define RYGEL_PLUGIN(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_PLUGIN, RygelPlugin))
-#define RYGEL_PLUGIN_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_PLUGIN, RygelPluginClass))
-#define RYGEL_IS_PLUGIN(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_PLUGIN))
-#define RYGEL_IS_PLUGIN_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_PLUGIN))
-#define RYGEL_PLUGIN_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_PLUGIN, RygelPluginClass))
-
-typedef struct _RygelPlugin RygelPlugin;
-typedef struct _RygelPluginClass RygelPluginClass;
-typedef struct _RygelPluginPrivate RygelPluginPrivate;
-
-#define RYGEL_TYPE_PLUGIN_LOADER (rygel_plugin_loader_get_type ())
-#define RYGEL_PLUGIN_LOADER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_PLUGIN_LOADER, RygelPluginLoader))
-#define RYGEL_PLUGIN_LOADER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_PLUGIN_LOADER, RygelPluginLoaderClass))
-#define RYGEL_IS_PLUGIN_LOADER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_PLUGIN_LOADER))
-#define RYGEL_IS_PLUGIN_LOADER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_PLUGIN_LOADER))
-#define RYGEL_PLUGIN_LOADER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_PLUGIN_LOADER, RygelPluginLoaderClass))
-
-typedef struct _RygelPluginLoader RygelPluginLoader;
-typedef struct _RygelPluginLoaderClass RygelPluginLoaderClass;
-typedef struct _RygelPluginLoaderPrivate RygelPluginLoaderPrivate;
-typedef struct _RygelMediaObjectPrivate RygelMediaObjectPrivate;
-typedef struct _RygelMediaContainerPrivate RygelMediaContainerPrivate;
-
-#define RYGEL_TYPE_SIMPLE_CONTAINER (rygel_simple_container_get_type ())
-#define RYGEL_SIMPLE_CONTAINER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_SIMPLE_CONTAINER, RygelSimpleContainer))
-#define RYGEL_SIMPLE_CONTAINER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_SIMPLE_CONTAINER, RygelSimpleContainerClass))
-#define RYGEL_IS_SIMPLE_CONTAINER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_SIMPLE_CONTAINER))
-#define RYGEL_IS_SIMPLE_CONTAINER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_SIMPLE_CONTAINER))
-#define RYGEL_SIMPLE_CONTAINER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_SIMPLE_CONTAINER, RygelSimpleContainerClass))
-
-typedef struct _RygelSimpleContainer RygelSimpleContainer;
-typedef struct _RygelSimpleContainerClass RygelSimpleContainerClass;
-typedef struct _RygelSimpleContainerPrivate RygelSimpleContainerPrivate;
-
-#define RYGEL_TYPE_SIMPLE_ASYNC_RESULT (rygel_simple_async_result_get_type ())
-#define RYGEL_SIMPLE_ASYNC_RESULT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_SIMPLE_ASYNC_RESULT, RygelSimpleAsyncResult))
-#define RYGEL_SIMPLE_ASYNC_RESULT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_SIMPLE_ASYNC_RESULT, RygelSimpleAsyncResultClass))
-#define RYGEL_IS_SIMPLE_ASYNC_RESULT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_SIMPLE_ASYNC_RESULT))
-#define RYGEL_IS_SIMPLE_ASYNC_RESULT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_SIMPLE_ASYNC_RESULT))
-#define RYGEL_SIMPLE_ASYNC_RESULT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_SIMPLE_ASYNC_RESULT, RygelSimpleAsyncResultClass))
-
-typedef struct _RygelSimpleAsyncResult RygelSimpleAsyncResult;
-typedef struct _RygelSimpleAsyncResultClass RygelSimpleAsyncResultClass;
-typedef struct _RygelSimpleAsyncResultPrivate RygelSimpleAsyncResultPrivate;
-
-#define RYGEL_TYPE_MEDIA_ITEM (rygel_media_item_get_type ())
-#define RYGEL_MEDIA_ITEM(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_MEDIA_ITEM, RygelMediaItem))
-#define RYGEL_MEDIA_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_MEDIA_ITEM, RygelMediaItemClass))
-#define RYGEL_IS_MEDIA_ITEM(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_MEDIA_ITEM))
-#define RYGEL_IS_MEDIA_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_MEDIA_ITEM))
-#define RYGEL_MEDIA_ITEM_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_MEDIA_ITEM, RygelMediaItemClass))
-
-typedef struct _RygelMediaItem RygelMediaItem;
-typedef struct _RygelMediaItemClass RygelMediaItemClass;
-typedef struct _RygelMediaItemPrivate RygelMediaItemPrivate;
-
-#define RYGEL_TYPE_THUMBNAIL (rygel_thumbnail_get_type ())
-#define RYGEL_THUMBNAIL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_THUMBNAIL, RygelThumbnail))
-#define RYGEL_THUMBNAIL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_THUMBNAIL, RygelThumbnailClass))
-#define RYGEL_IS_THUMBNAIL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_THUMBNAIL))
-#define RYGEL_IS_THUMBNAIL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_THUMBNAIL))
-#define RYGEL_THUMBNAIL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_THUMBNAIL, RygelThumbnailClass))
-
-typedef struct _RygelThumbnail RygelThumbnail;
-typedef struct _RygelThumbnailClass RygelThumbnailClass;
-typedef struct _RygelThumbnailPrivate RygelThumbnailPrivate;
-
-#define RYGEL_TYPE_MEDIA_DB_OBJECT_TYPE (rygel_media_db_object_type_get_type ())
-
-#define RYGEL_TYPE_MEDIA_DB (rygel_media_db_get_type ())
-#define RYGEL_MEDIA_DB(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_MEDIA_DB, RygelMediaDB))
-#define RYGEL_MEDIA_DB_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_MEDIA_DB, RygelMediaDBClass))
-#define RYGEL_IS_MEDIA_DB(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_MEDIA_DB))
-#define RYGEL_IS_MEDIA_DB_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_MEDIA_DB))
-#define RYGEL_MEDIA_DB_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_MEDIA_DB, RygelMediaDBClass))
-
-typedef struct _RygelMediaDB RygelMediaDB;
-typedef struct _RygelMediaDBClass RygelMediaDBClass;
-typedef struct _RygelMediaDBPrivate RygelMediaDBPrivate;
-
-#define RYGEL_TYPE_MEDIA_DB_OBJECT_FACTORY (rygel_media_db_object_factory_get_type ())
-#define RYGEL_MEDIA_DB_OBJECT_FACTORY(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_MEDIA_DB_OBJECT_FACTORY, RygelMediaDBObjectFactory))
-#define RYGEL_MEDIA_DB_OBJECT_FACTORY_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_MEDIA_DB_OBJECT_FACTORY, RygelMediaDBObjectFactoryClass))
-#define RYGEL_IS_MEDIA_DB_OBJECT_FACTORY(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_MEDIA_DB_OBJECT_FACTORY))
-#define RYGEL_IS_MEDIA_DB_OBJECT_FACTORY_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_MEDIA_DB_OBJECT_FACTORY))
-#define RYGEL_MEDIA_DB_OBJECT_FACTORY_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_MEDIA_DB_OBJECT_FACTORY, RygelMediaDBObjectFactoryClass))
-
-typedef struct _RygelMediaDBObjectFactory RygelMediaDBObjectFactory;
-typedef struct _RygelMediaDBObjectFactoryClass RygelMediaDBObjectFactoryClass;
-
-#define RYGEL_TYPE_METADATA_EXTRACTOR (rygel_metadata_extractor_get_type ())
-#define RYGEL_METADATA_EXTRACTOR(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_METADATA_EXTRACTOR, RygelMetadataExtractor))
-#define RYGEL_METADATA_EXTRACTOR_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_METADATA_EXTRACTOR, RygelMetadataExtractorClass))
-#define RYGEL_IS_METADATA_EXTRACTOR(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_METADATA_EXTRACTOR))
-#define RYGEL_IS_METADATA_EXTRACTOR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_METADATA_EXTRACTOR))
-#define RYGEL_METADATA_EXTRACTOR_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_METADATA_EXTRACTOR, RygelMetadataExtractorClass))
-
-typedef struct _RygelMetadataExtractor RygelMetadataExtractor;
-typedef struct _RygelMetadataExtractorClass RygelMetadataExtractorClass;
-typedef struct _RygelMetadataExtractorPrivate RygelMetadataExtractorPrivate;
-
-#define RYGEL_TYPE_MEDIA_DB_CONTAINER (rygel_media_db_container_get_type ())
-#define RYGEL_MEDIA_DB_CONTAINER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_MEDIA_DB_CONTAINER, RygelMediaDBContainer))
-#define RYGEL_MEDIA_DB_CONTAINER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_MEDIA_DB_CONTAINER, RygelMediaDBContainerClass))
-#define RYGEL_IS_MEDIA_DB_CONTAINER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_MEDIA_DB_CONTAINER))
-#define RYGEL_IS_MEDIA_DB_CONTAINER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_MEDIA_DB_CONTAINER))
-#define RYGEL_MEDIA_DB_CONTAINER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_MEDIA_DB_CONTAINER, RygelMediaDBContainerClass))
-
-typedef struct _RygelMediaDBContainer RygelMediaDBContainer;
-typedef struct _RygelMediaDBContainerClass RygelMediaDBContainerClass;
-typedef struct _RygelMediaDBContainerPrivate RygelMediaDBContainerPrivate;
-typedef struct _RygelMediaDBObjectFactoryPrivate RygelMediaDBObjectFactoryPrivate;
-
-#define RYGEL_TYPE_LOG_HANDLER (rygel_log_handler_get_type ())
-#define RYGEL_LOG_HANDLER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_LOG_HANDLER, RygelLogHandler))
-#define RYGEL_LOG_HANDLER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_LOG_HANDLER, RygelLogHandlerClass))
-#define RYGEL_IS_LOG_HANDLER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_LOG_HANDLER))
-#define RYGEL_IS_LOG_HANDLER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_LOG_HANDLER))
-#define RYGEL_LOG_HANDLER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_LOG_HANDLER, RygelLogHandlerClass))
-
-typedef struct _RygelLogHandler RygelLogHandler;
-typedef struct _RygelLogHandlerClass RygelLogHandlerClass;
-typedef struct _RygelLogHandlerPrivate RygelLogHandlerPrivate;
-
-#define RYGEL_TYPE_DBUS_SERVICE (rygel_dbus_service_get_type ())
-#define RYGEL_DBUS_SERVICE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_DBUS_SERVICE, RygelDBusService))
-#define RYGEL_DBUS_SERVICE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_DBUS_SERVICE, RygelDBusServiceClass))
-#define RYGEL_IS_DBUS_SERVICE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_DBUS_SERVICE))
-#define RYGEL_IS_DBUS_SERVICE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_DBUS_SERVICE))
-#define RYGEL_DBUS_SERVICE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_DBUS_SERVICE, RygelDBusServiceClass))
-
-typedef struct _RygelDBusService RygelDBusService;
-typedef struct _RygelDBusServiceClass RygelDBusServiceClass;
-typedef struct _RygelDBusServicePrivate RygelDBusServicePrivate;
-
-#define RYGEL_TYPE_MAIN (rygel_main_get_type ())
-#define RYGEL_MAIN(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_MAIN, RygelMain))
-#define RYGEL_MAIN_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_MAIN, RygelMainClass))
-#define RYGEL_IS_MAIN(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_MAIN))
-#define RYGEL_IS_MAIN_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_MAIN))
-#define RYGEL_MAIN_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_MAIN, RygelMainClass))
-
-typedef struct _RygelMain RygelMain;
-typedef struct _RygelMainClass RygelMainClass;
-
-#define RYGEL_TYPE_ROOT_DEVICE (rygel_root_device_get_type ())
-#define RYGEL_ROOT_DEVICE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_ROOT_DEVICE, RygelRootDevice))
-#define RYGEL_ROOT_DEVICE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_ROOT_DEVICE, RygelRootDeviceClass))
-#define RYGEL_IS_ROOT_DEVICE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_ROOT_DEVICE))
-#define RYGEL_IS_ROOT_DEVICE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_ROOT_DEVICE))
-#define RYGEL_ROOT_DEVICE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_ROOT_DEVICE, RygelRootDeviceClass))
-
-typedef struct _RygelRootDevice RygelRootDevice;
-typedef struct _RygelRootDeviceClass RygelRootDeviceClass;
-typedef struct _RygelRootDevicePrivate RygelRootDevicePrivate;
-
-#define RYGEL_TYPE_ROOT_DEVICE_FACTORY (rygel_root_device_factory_get_type ())
-#define RYGEL_ROOT_DEVICE_FACTORY(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_ROOT_DEVICE_FACTORY, RygelRootDeviceFactory))
-#define RYGEL_ROOT_DEVICE_FACTORY_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_ROOT_DEVICE_FACTORY, RygelRootDeviceFactoryClass))
-#define RYGEL_IS_ROOT_DEVICE_FACTORY(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_ROOT_DEVICE_FACTORY))
-#define RYGEL_IS_ROOT_DEVICE_FACTORY_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_ROOT_DEVICE_FACTORY))
-#define RYGEL_ROOT_DEVICE_FACTORY_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_ROOT_DEVICE_FACTORY, RygelRootDeviceFactoryClass))
-
-typedef struct _RygelRootDeviceFactory RygelRootDeviceFactory;
-typedef struct _RygelRootDeviceFactoryClass RygelRootDeviceFactoryClass;
-typedef struct _RygelRootDeviceFactoryPrivate RygelRootDeviceFactoryPrivate;
-typedef struct _RygelMainPrivate RygelMainPrivate;
-
-typedef enum  {
-	RYGEL_CONFIGURATION_ERROR_NO_VALUE_SET,
-	RYGEL_CONFIGURATION_ERROR_VALUE_OUT_OF_RANGE
-} RygelConfigurationError;
-#define RYGEL_CONFIGURATION_ERROR rygel_configuration_error_quark ()
-typedef enum  {
-	RYGEL_LOG_LEVEL_INVALID = 0,
-	RYGEL_LOG_LEVEL_CRITICAL = 1,
-	RYGEL_LOG_LEVEL_ERROR = 2,
-	RYGEL_LOG_LEVEL_WARNING = 3,
-	RYGEL_LOG_LEVEL_INFO = 4,
-	RYGEL_LOG_LEVEL_DEFAULT = 4,
-	RYGEL_LOG_LEVEL_DEBUG = 5
-} RygelLogLevel;
-
-struct _RygelConfigurationIface {
-	GTypeInterface parent_iface;
-	gboolean (*get_upnp_enabled) (RygelConfiguration* self, GError** error);
-	char* (*get_interface) (RygelConfiguration* self, GError** error);
-	gint (*get_port) (RygelConfiguration* self, GError** error);
-	gboolean (*get_transcoding) (RygelConfiguration* self, GError** error);
-	gboolean (*get_mp3_transcoder) (RygelConfiguration* self, GError** error);
-	gboolean (*get_mp2ts_transcoder) (RygelConfiguration* self, GError** error);
-	gboolean (*get_lpcm_transcoder) (RygelConfiguration* self, GError** error);
-	RygelLogLevel (*get_log_level) (RygelConfiguration* self, GError** error);
-	gboolean (*get_enabled) (RygelConfiguration* self, const char* section, GError** error);
-	char* (*get_title) (RygelConfiguration* self, const char* section, GError** error);
-	char* (*get_string) (RygelConfiguration* self, const char* section, const char* key, GError** error);
-	GeeArrayList* (*get_string_list) (RygelConfiguration* self, const char* section, const char* key, GError** error);
-	gint (*get_int) (RygelConfiguration* self, const char* section, const char* key, gint min, gint max, GError** error);
-	GeeArrayList* (*get_int_list) (RygelConfiguration* self, const char* section, const char* key, GError** error);
-	gboolean (*get_bool) (RygelConfiguration* self, const char* section, const char* key, GError** error);
-};
-
-struct _RygelUserConfig {
-	GObject parent_instance;
-	RygelUserConfigPrivate * priv;
-	GKeyFile* key_file;
-};
-
-struct _RygelUserConfigClass {
-	GObjectClass parent_class;
-};
-
-struct _RygelMetaConfig {
-	GObject parent_instance;
-	RygelMetaConfigPrivate * priv;
-};
-
-struct _RygelMetaConfigClass {
-	GObjectClass parent_class;
-};
-
-typedef enum  {
-	RYGEL_CMDLINE_CONFIG_ERROR_VERSION_ONLY
-} RygelCmdlineConfigError;
-#define RYGEL_CMDLINE_CONFIG_ERROR rygel_cmdline_config_error_quark ()
-struct _RygelCmdlineConfig {
-	GObject parent_instance;
-	RygelCmdlineConfigPrivate * priv;
-};
-
-struct _RygelCmdlineConfigClass {
-	GObjectClass parent_class;
-};
-
-typedef enum  {
-	RYGEL_CONTENT_DIRECTORY_ERROR_NO_SUCH_OBJECT = 701,
-	RYGEL_CONTENT_DIRECTORY_ERROR_INVALID_ARGS = 402
-} RygelContentDirectoryError;
-#define RYGEL_CONTENT_DIRECTORY_ERROR rygel_content_directory_error_quark ()
-struct _RygelContentDirectory {
-	GUPnPService parent_instance;
-	RygelContentDirectoryPrivate * priv;
-	char* feature_list;
-	char* search_caps;
-	char* sort_caps;
-	RygelHTTPServer* http_server;
-	RygelMediaContainer* root_container;
-	GCancellable* cancellable;
-	guint32 system_update_id;
-};
-
-struct _RygelContentDirectoryClass {
-	GUPnPServiceClass parent_class;
-	RygelMediaContainer* (*create_root_container) (RygelContentDirectory* self);
-	void (*browse_cb) (RygelContentDirectory* self, RygelContentDirectory* content_dir, GUPnPServiceAction* action);
-};
-
-struct _RygelConnectionManager {
-	GUPnPService parent_instance;
-	RygelConnectionManagerPrivate * priv;
-	char* sink_protocol_info;
-	char* connection_ids;
-};
-
-struct _RygelConnectionManagerClass {
-	GUPnPServiceClass parent_class;
-};
-
-struct _RygelStateMachineIface {
-	GTypeInterface parent_iface;
-	void (*run) (RygelStateMachine* self);
-	GCancellable* (*get_cancellable) (RygelStateMachine* self);
-	void (*set_cancellable) (RygelStateMachine* self, GCancellable* value);
-};
-
-struct _RygelResourceInfo {
-	GTypeInstance parent_instance;
-	volatile int ref_count;
-	RygelResourceInfoPrivate * priv;
-	char* upnp_type;
-	char* upnp_id;
-	char* description_path;
-	GType type;
-};
-
-struct _RygelResourceInfoClass {
-	GTypeClass parent_class;
-	void (*finalize) (RygelResourceInfo *self);
-};
-
-struct _RygelIconInfo {
-	GTypeInstance parent_instance;
-	volatile int ref_count;
-	RygelIconInfoPrivate * priv;
-	char* mime_type;
-	char* path;
-	glong size;
-	gint width;
-	gint height;
-	gint depth;
-};
-
-struct _RygelIconInfoClass {
-	GTypeClass parent_class;
-	void (*finalize) (RygelIconInfo *self);
-};
-
-struct _RygelPlugin {
-	GUPnPResourceFactory parent_instance;
-	RygelPluginPrivate * priv;
-	char* name;
-	char* title;
-	char* desc_path;
-	GeeArrayList* resource_infos;
-	GeeArrayList* icon_infos;
-};
-
-struct _RygelPluginClass {
-	GUPnPResourceFactoryClass parent_class;
-};
-
-struct _RygelPluginLoader {
-	GObject parent_instance;
-	RygelPluginLoaderPrivate * priv;
-};
-
-struct _RygelPluginLoaderClass {
-	GObjectClass parent_class;
-};
-
-struct _RygelMediaObject {
-	GObject parent_instance;
-	RygelMediaObjectPrivate * priv;
-	char* id;
-	char* title;
-	guint64 modified;
-	GeeArrayList* uris;
-	RygelMediaContainer* parent;
-	RygelMediaContainer* parent_ref;
-};
-
-struct _RygelMediaObjectClass {
-	GObjectClass parent_class;
-};
-
-struct _RygelMediaContainer {
-	RygelMediaObject parent_instance;
-	RygelMediaContainerPrivate * priv;
-	guint child_count;
-	guint32 update_id;
-};
-
-struct _RygelMediaContainerClass {
-	RygelMediaObjectClass parent_class;
-	void (*get_children) (RygelMediaContainer* self, guint offset, guint max_count, GCancellable* cancellable, GAsyncReadyCallback callback, void* callback_target);
-	GeeList* (*get_children_finish) (RygelMediaContainer* self, GAsyncResult* res, GError** error);
-	void (*find_object) (RygelMediaContainer* self, const char* id, GCancellable* cancellable, GAsyncReadyCallback callback, void* callback_target);
-	RygelMediaObject* (*find_object_finish) (RygelMediaContainer* self, GAsyncResult* res, GError** error);
-};
-
-struct _RygelSimpleContainer {
-	RygelMediaContainer parent_instance;
-	RygelSimpleContainerPrivate * priv;
-	GeeArrayList* children;
-};
-
-struct _RygelSimpleContainerClass {
-	RygelMediaContainerClass parent_class;
-};
-
-struct _RygelSimpleAsyncResult {
-	GObject parent_instance;
-	RygelSimpleAsyncResultPrivate * priv;
-	GObject* source_object;
-	GAsyncReadyCallback callback;
-	gpointer callback_target;
-	GDestroyNotify callback_target_destroy_notify;
-	gpointer data;
-	GError* error;
-};
-
-struct _RygelSimpleAsyncResultClass {
-	GObjectClass parent_class;
-};
-
-struct _RygelMediaItem {
-	RygelMediaObject parent_instance;
-	RygelMediaItemPrivate * priv;
-	char* author;
-	char* album;
-	char* date;
-	char* upnp_class;
-	char* mime_type;
-	char* dlna_profile;
-	glong size;
-	glong duration;
-	gint bitrate;
-	gint sample_freq;
-	gint bits_per_sample;
-	gint n_audio_channels;
-	gint track_number;
-	gint width;
-	gint height;
-	gint pixel_width;
-	gint pixel_height;
-	gint color_depth;
-	GeeArrayList* thumbnails;
-};
-
-struct _RygelMediaItemClass {
-	RygelMediaObjectClass parent_class;
-	GstElement* (*create_stream_source) (RygelMediaItem* self);
-	gboolean (*should_stream) (RygelMediaItem* self);
-};
-
-struct _RygelThumbnail {
-	RygelIconInfo parent_instance;
-	RygelThumbnailPrivate * priv;
-	char* uri;
-	char* dlna_profile;
-};
-
-struct _RygelThumbnailClass {
-	RygelIconInfoClass parent_class;
-};
-
-typedef enum  {
-	RYGEL_MEDIA_DB_ERROR_SQLITE_ERROR,
-	RYGEL_MEDIA_DB_ERROR_GENERAL_ERROR,
-	RYGEL_MEDIA_DB_ERROR_INVALID_TYPE
-} RygelMediaDBError;
-#define RYGEL_MEDIA_DB_ERROR rygel_media_db_error_quark ()
-typedef enum  {
-	RYGEL_MEDIA_DB_OBJECT_TYPE_CONTAINER,
-	RYGEL_MEDIA_DB_OBJECT_TYPE_ITEM
-} RygelMediaDBObjectType;
-
-struct _RygelMediaDB {
-	GObject parent_instance;
-	RygelMediaDBPrivate * priv;
-};
-
-struct _RygelMediaDBClass {
-	GObjectClass parent_class;
-};
-
-struct _RygelMetadataExtractor {
-	GObject parent_instance;
-	RygelMetadataExtractorPrivate * priv;
-};
-
-struct _RygelMetadataExtractorClass {
-	GObjectClass parent_class;
-};
-
-struct _RygelMediaDBContainer {
-	RygelMediaContainer parent_instance;
-	RygelMediaDBContainerPrivate * priv;
-	RygelMediaDB* media_db;
-};
-
-struct _RygelMediaDBContainerClass {
-	RygelMediaContainerClass parent_class;
-};
-
-struct _RygelMediaDBObjectFactory {
-	GObject parent_instance;
-	RygelMediaDBObjectFactoryPrivate * priv;
-};
-
-struct _RygelMediaDBObjectFactoryClass {
-	GObjectClass parent_class;
-	RygelMediaContainer* (*get_container) (RygelMediaDBObjectFactory* self, RygelMediaDB* media_db, const char* id, const char* title, guint child_count);
-	RygelMediaItem* (*get_item) (RygelMediaDBObjectFactory* self, RygelMediaDB* media_db, RygelMediaContainer* parent, const char* id, const char* title, const char* upnp_class);
-};
-
-struct _RygelLogHandler {
-	GObject parent_instance;
-	RygelLogHandlerPrivate * priv;
-	GLogLevelFlags levels;
-};
-
-struct _RygelLogHandlerClass {
-	GObjectClass parent_class;
-};
-
-struct _RygelDBusService {
-	GObject parent_instance;
-	RygelDBusServicePrivate * priv;
-};
-
-struct _RygelDBusServiceClass {
-	GObjectClass parent_class;
-};
-
-struct _RygelRootDevice {
-	GUPnPRootDevice parent_instance;
-	RygelRootDevicePrivate * priv;
-	GeeArrayList* services;
-};
-
-struct _RygelRootDeviceClass {
-	GUPnPRootDeviceClass parent_class;
-};
-
-typedef enum  {
-	ROOT_DEVICE_FACTORY_ERROR_XML_PARSE,
-	ROOT_DEVICE_FACTORY_ERROR_PLUGIN_DISABLED
-} RootDeviceFactoryError;
-#define ROOT_DEVICE_FACTORY_ERROR root_device_factory_error_quark ()
-struct _RygelRootDeviceFactory {
-	GTypeInstance parent_instance;
-	volatile int ref_count;
-	RygelRootDeviceFactoryPrivate * priv;
-	GUPnPContext* context;
-};
-
-struct _RygelRootDeviceFactoryClass {
-	GTypeClass parent_class;
-	void (*finalize) (RygelRootDeviceFactory *self);
-};
-
-struct _RygelMain {
-	GObject parent_instance;
-	RygelMainPrivate * priv;
-};
-
-struct _RygelMainClass {
-	GObjectClass parent_class;
-};
-
-
-GQuark rygel_configuration_error_quark (void);
-GType rygel_log_level_get_type (void);
-GType rygel_configuration_get_type (void);
-gboolean rygel_configuration_get_upnp_enabled (RygelConfiguration* self, GError** error);
-char* rygel_configuration_get_interface (RygelConfiguration* self, GError** error);
-gint rygel_configuration_get_port (RygelConfiguration* self, GError** error);
-gboolean rygel_configuration_get_transcoding (RygelConfiguration* self, GError** error);
-gboolean rygel_configuration_get_mp3_transcoder (RygelConfiguration* self, GError** error);
-gboolean rygel_configuration_get_mp2ts_transcoder (RygelConfiguration* self, GError** error);
-gboolean rygel_configuration_get_lpcm_transcoder (RygelConfiguration* self, GError** error);
-RygelLogLevel rygel_configuration_get_log_level (RygelConfiguration* self, GError** error);
-gboolean rygel_configuration_get_enabled (RygelConfiguration* self, const char* section, GError** error);
-char* rygel_configuration_get_title (RygelConfiguration* self, const char* section, GError** error);
-char* rygel_configuration_get_string (RygelConfiguration* self, const char* section, const char* key, GError** error);
-GeeArrayList* rygel_configuration_get_string_list (RygelConfiguration* self, const char* section, const char* key, GError** error);
-gint rygel_configuration_get_int (RygelConfiguration* self, const char* section, const char* key, gint min, gint max, GError** error);
-GeeArrayList* rygel_configuration_get_int_list (RygelConfiguration* self, const char* section, const char* key, GError** error);
-gboolean rygel_configuration_get_bool (RygelConfiguration* self, const char* section, const char* key, GError** error);
-GType rygel_user_config_get_type (void);
-#define RYGEL_USER_CONFIG_CONFIG_FILE "rygel.conf"
-#define RYGEL_USER_CONFIG_IFACE_KEY "interface"
-#define RYGEL_USER_CONFIG_PORT_KEY "port"
-#define RYGEL_USER_CONFIG_ENABLED_KEY "enabled"
-#define RYGEL_USER_CONFIG_TITLE_KEY "title"
-#define RYGEL_USER_CONFIG_TRANSCODING_KEY "enable-transcoding"
-#define RYGEL_USER_CONFIG_MP3_TRANSCODER_KEY "enable-mp3-transcoder"
-#define RYGEL_USER_CONFIG_MP2TS_TRANSCODER_KEY "enable-mp2ts-transcoder"
-#define RYGEL_USER_CONFIG_LPCM_TRANSCODER_KEY "enable-lpcm-transcoder"
-#define RYGEL_USER_CONFIG_LOG_LEVEL_KEY "log-level"
-void rygel_user_config_set_upnp_enabled (RygelUserConfig* self, gboolean value);
-void rygel_user_config_set_interface (RygelUserConfig* self, const char* value);
-void rygel_user_config_set_port (RygelUserConfig* self, gint value);
-void rygel_user_config_set_transcoding (RygelUserConfig* self, gboolean value);
-void rygel_user_config_set_mp3_transcoder (RygelUserConfig* self, gboolean value);
-void rygel_user_config_set_mp2ts_transcoder (RygelUserConfig* self, gboolean value);
-void rygel_user_config_set_lpcm_transcoder (RygelUserConfig* self, gboolean value);
-RygelUserConfig* rygel_user_config_get_default (GError** error);
-RygelUserConfig* rygel_user_config_new (gboolean read_only, GError** error);
-RygelUserConfig* rygel_user_config_construct (GType object_type, gboolean read_only, GError** error);
-void rygel_user_config_save (RygelUserConfig* self);
-void rygel_user_config_set_string (RygelUserConfig* self, const char* section, const char* key, const char* value);
-void rygel_user_config_set_string_list (RygelUserConfig* self, const char* section, const char* key, GeeArrayList* str_list);
-void rygel_user_config_set_int (RygelUserConfig* self, const char* section, const char* key, gint value);
-void rygel_user_config_set_bool (RygelUserConfig* self, const char* section, const char* key, gboolean value);
-GType rygel_meta_config_get_type (void);
-RygelMetaConfig* rygel_meta_config_get_default (void);
-RygelMetaConfig* rygel_meta_config_new (void);
-RygelMetaConfig* rygel_meta_config_construct (GType object_type);
-GQuark rygel_cmdline_config_error_quark (void);
-GType rygel_cmdline_config_get_type (void);
-RygelCmdlineConfig* rygel_cmdline_config_get_default (void);
-void rygel_cmdline_config_parse_args (char*** args, int* args_length1, GError** error);
-RygelCmdlineConfig* rygel_cmdline_config_new (void);
-RygelCmdlineConfig* rygel_cmdline_config_construct (GType object_type);
-GQuark rygel_content_directory_error_quark (void);
-GType rygel_content_directory_get_type (void);
-GType rygel_media_object_get_type (void);
-GType rygel_media_container_get_type (void);
-GType rygel_transcode_manager_get_type (void);
-GType rygel_http_server_get_type (void);
-#define RYGEL_CONTENT_DIRECTORY_UPNP_ID "urn:upnp-org:serviceId:ContentDirectory"
-#define RYGEL_CONTENT_DIRECTORY_UPNP_TYPE "urn:schemas-upnp-org:service:ContentDirectory:2"
-#define RYGEL_CONTENT_DIRECTORY_DESCRIPTION_PATH "xml/ContentDirectory.xml"
-RygelMediaContainer* rygel_content_directory_create_root_container (RygelContentDirectory* self);
-RygelContentDirectory* rygel_content_directory_new (void);
-RygelContentDirectory* rygel_content_directory_construct (GType object_type);
-GType rygel_connection_manager_get_type (void);
-#define RYGEL_CONNECTION_MANAGER_UPNP_ID "urn:upnp-org:serviceId:ConnectionManager"
-#define RYGEL_CONNECTION_MANAGER_UPNP_TYPE "urn:schemas-upnp-org:service:ConnectionManager:2"
-#define RYGEL_CONNECTION_MANAGER_DESCRIPTION_PATH "xml/ConnectionManager.xml"
-RygelConnectionManager* rygel_connection_manager_new (void);
-RygelConnectionManager* rygel_connection_manager_construct (GType object_type);
-char* rygel_connection_manager_get_source_protocol_info (RygelConnectionManager* self);
-GType rygel_state_machine_get_type (void);
-void rygel_state_machine_run (RygelStateMachine* self);
-GCancellable* rygel_state_machine_get_cancellable (RygelStateMachine* self);
-void rygel_state_machine_set_cancellable (RygelStateMachine* self, GCancellable* value);
-gpointer rygel_resource_info_ref (gpointer instance);
-void rygel_resource_info_unref (gpointer instance);
-GParamSpec* rygel_param_spec_resource_info (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
-void rygel_value_set_resource_info (GValue* value, gpointer v_object);
-gpointer rygel_value_get_resource_info (const GValue* value);
-GType rygel_resource_info_get_type (void);
-RygelResourceInfo* rygel_resource_info_new (const char* upnp_id, const char* upnp_type, const char* description_path, GType type);
-RygelResourceInfo* rygel_resource_info_construct (GType object_type, const char* upnp_id, const char* upnp_type, const char* description_path, GType type);
-gpointer rygel_icon_info_ref (gpointer instance);
-void rygel_icon_info_unref (gpointer instance);
-GParamSpec* rygel_param_spec_icon_info (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
-void rygel_value_set_icon_info (GValue* value, gpointer v_object);
-gpointer rygel_value_get_icon_info (const GValue* value);
-GType rygel_icon_info_get_type (void);
-RygelIconInfo* rygel_icon_info_new (const char* mime_type);
-RygelIconInfo* rygel_icon_info_construct (GType object_type, const char* mime_type);
-GType rygel_plugin_get_type (void);
-RygelPlugin* rygel_plugin_new (const char* desc_path, const char* name, const char* title);
-RygelPlugin* rygel_plugin_construct (GType object_type, const char* desc_path, const char* name, const char* title);
-RygelPlugin* rygel_plugin_new_MediaServer (const char* name, const char* title);
-RygelPlugin* rygel_plugin_construct_MediaServer (GType object_type, const char* name, const char* title);
-void rygel_plugin_add_resource (RygelPlugin* self, RygelResourceInfo* resource_info);
-void rygel_plugin_add_icon (RygelPlugin* self, RygelIconInfo* icon_info);
-gboolean rygel_plugin_get_available (RygelPlugin* self);
-void rygel_plugin_set_available (RygelPlugin* self, gboolean value);
-GType rygel_plugin_loader_get_type (void);
-RygelPluginLoader* rygel_plugin_loader_new (void);
-RygelPluginLoader* rygel_plugin_loader_construct (GType object_type);
-void rygel_plugin_loader_load_plugins (RygelPluginLoader* self);
-void rygel_plugin_loader_add_plugin (RygelPluginLoader* self, RygelPlugin* plugin);
-RygelPlugin* rygel_plugin_loader_get_plugin_by_name (RygelPluginLoader* self, const char* name);
-GeeCollection* rygel_plugin_loader_list_plugins (RygelPluginLoader* self);
-RygelMediaObject* rygel_media_object_construct (GType object_type);
-RygelMediaContainer* rygel_media_container_construct (GType object_type, const char* id, RygelMediaContainer* parent, const char* title, guint child_count);
-RygelMediaContainer* rygel_media_container_construct_root (GType object_type, const char* title, guint child_count);
-void rygel_media_container_get_children (RygelMediaContainer* self, guint offset, guint max_count, GCancellable* cancellable, GAsyncReadyCallback callback, void* callback_target);
-GeeList* rygel_media_container_get_children_finish (RygelMediaContainer* self, GAsyncResult* res, GError** error);
-void rygel_media_container_find_object (RygelMediaContainer* self, const char* id, GCancellable* cancellable, GAsyncReadyCallback callback, void* callback_target);
-RygelMediaObject* rygel_media_container_find_object_finish (RygelMediaContainer* self, GAsyncResult* res, GError** error);
-void rygel_media_container_updated (RygelMediaContainer* self);
-GType rygel_simple_container_get_type (void);
-RygelSimpleContainer* rygel_simple_container_new (const char* id, RygelMediaContainer* parent, const char* title);
-RygelSimpleContainer* rygel_simple_container_construct (GType object_type, const char* id, RygelMediaContainer* parent, const char* title);
-RygelSimpleContainer* rygel_simple_container_new_root (const char* title);
-RygelSimpleContainer* rygel_simple_container_construct_root (GType object_type, const char* title);
-void rygel_simple_container_add_child (RygelSimpleContainer* self, RygelMediaObject* child);
-void rygel_simple_container_remove_child (RygelSimpleContainer* self, RygelMediaObject* child);
-GType rygel_simple_async_result_get_type (void);
-RygelSimpleAsyncResult* rygel_simple_async_result_new (GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GObject* source_object, GAsyncReadyCallback callback, void* callback_target);
-RygelSimpleAsyncResult* rygel_simple_async_result_construct (GType object_type, GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GObject* source_object, GAsyncReadyCallback callback, void* callback_target);
-void rygel_simple_async_result_complete (RygelSimpleAsyncResult* self);
-void rygel_simple_async_result_complete_in_idle (RygelSimpleAsyncResult* self);
-GType rygel_media_item_get_type (void);
-GType rygel_thumbnail_get_type (void);
-#define RYGEL_MEDIA_ITEM_IMAGE_CLASS "object.item.imageItem"
-#define RYGEL_MEDIA_ITEM_VIDEO_CLASS "object.item.videoItem"
-#define RYGEL_MEDIA_ITEM_AUDIO_CLASS "object.item.audioItem"
-#define RYGEL_MEDIA_ITEM_MUSIC_CLASS "object.item.audioItem.musicTrack"
-RygelMediaItem* rygel_media_item_new (const char* id, RygelMediaContainer* parent, const char* title, const char* upnp_class);
-RygelMediaItem* rygel_media_item_construct (GType object_type, const char* id, RygelMediaContainer* parent, const char* title, const char* upnp_class);
-GstElement* rygel_media_item_create_stream_source (RygelMediaItem* self);
-gboolean rygel_media_item_should_stream (RygelMediaItem* self);
-void rygel_media_item_add_uri (RygelMediaItem* self, const char* uri, RygelThumbnail* thumbnail);
-RygelThumbnail* rygel_thumbnail_new (const char* mime_type, const char* dlna_profile);
-RygelThumbnail* rygel_thumbnail_construct (GType object_type, const char* mime_type, const char* dlna_profile);
-GQuark rygel_media_db_error_quark (void);
-GType rygel_media_db_object_type_get_type (void);
-GType rygel_media_db_get_type (void);
-RygelMediaDB* rygel_media_db_create (const char* name, GError** error);
-GType rygel_media_db_object_factory_get_type (void);
-RygelMediaDB* rygel_media_db_create_with_factory (const char* name, RygelMediaDBObjectFactory* factory, GError** error);
-void rygel_media_db_remove_by_id (RygelMediaDB* self, const char* id, GError** error);
-void rygel_media_db_remove_object (RygelMediaDB* self, RygelMediaObject* obj, GError** error);
-void rygel_media_db_save_object (RygelMediaDB* self, RygelMediaObject* obj, GError** error);
-void rygel_media_db_save_container (RygelMediaDB* self, RygelMediaContainer* container, GError** error);
-void rygel_media_db_save_item (RygelMediaDB* self, RygelMediaItem* item, GError** error);
-void rygel_media_db_update_object (RygelMediaDB* self, RygelMediaObject* obj, GError** error);
-RygelMediaObject* rygel_media_db_get_object (RygelMediaDB* self, const char* object_id, GError** error);
-RygelMediaItem* rygel_media_db_get_item (RygelMediaDB* self, const char* item_id, GError** error);
-RygelMediaContainer* rygel_media_db_get_container (RygelMediaDB* self, const char* container_id, GError** error);
-GeeArrayList* rygel_media_db_get_child_ids (RygelMediaDB* self, const char* container_id, GError** error);
-gint rygel_media_db_get_child_count (RygelMediaDB* self, const char* container_id, GError** error);
-gboolean rygel_media_db_exists (RygelMediaDB* self, const char* object_id, gint64* timestamp, GError** error);
-GeeArrayList* rygel_media_db_get_children (RygelMediaDB* self, const char* container_id, glong offset, glong max_count);
-GType rygel_metadata_extractor_get_type (void);
-#define RYGEL_METADATA_EXTRACTOR_TAG_RYGEL_SIZE "rygel-size"
-#define RYGEL_METADATA_EXTRACTOR_TAG_RYGEL_DURATION "rygel-duration"
-#define RYGEL_METADATA_EXTRACTOR_TAG_RYGEL_MIME "rygel-mime"
-#define RYGEL_METADATA_EXTRACTOR_TAG_RYGEL_CHANNELS "rygel-channels"
-#define RYGEL_METADATA_EXTRACTOR_TAG_RYGEL_RATE "rygel-rate"
-#define RYGEL_METADATA_EXTRACTOR_TAG_RYGEL_WIDTH "rygel-width"
-#define RYGEL_METADATA_EXTRACTOR_TAG_RYGEL_HEIGHT "rygel-height"
-#define RYGEL_METADATA_EXTRACTOR_TAG_RYGEL_DEPTH "rygel-depth"
-#define RYGEL_METADATA_EXTRACTOR_TAG_RYGEL_MTIME "rygel-mtime"
-RygelMetadataExtractor* rygel_metadata_extractor_new (void);
-RygelMetadataExtractor* rygel_metadata_extractor_construct (GType object_type);
-void rygel_metadata_extractor_extract (RygelMetadataExtractor* self, GFile* file);
-GType rygel_media_db_container_get_type (void);
-RygelMediaDBContainer* rygel_media_db_container_new (RygelMediaDB* media_db, const char* id, const char* title);
-RygelMediaDBContainer* rygel_media_db_container_construct (GType object_type, RygelMediaDB* media_db, const char* id, const char* title);
-RygelMediaContainer* rygel_media_db_object_factory_get_container (RygelMediaDBObjectFactory* self, RygelMediaDB* media_db, const char* id, const char* title, guint child_count);
-RygelMediaItem* rygel_media_db_object_factory_get_item (RygelMediaDBObjectFactory* self, RygelMediaDB* media_db, RygelMediaContainer* parent, const char* id, const char* title, const char* upnp_class);
-RygelMediaDBObjectFactory* rygel_media_db_object_factory_new (void);
-RygelMediaDBObjectFactory* rygel_media_db_object_factory_construct (GType object_type);
-GType rygel_log_handler_get_type (void);
-RygelLogHandler* rygel_log_handler_get_default (void);
-GType rygel_dbus_service_get_type (void);
-GType rygel_main_get_type (void);
-RygelDBusService* rygel_dbus_service_new (RygelMain* main, GError** error);
-RygelDBusService* rygel_dbus_service_construct (GType object_type, RygelMain* main, GError** error);
-void rygel_dbus_service_Shutdown (RygelDBusService* self);
-GType rygel_root_device_get_type (void);
-RygelRootDevice* rygel_root_device_new (GUPnPContext* context, RygelPlugin* plugin, GUPnPXMLDoc* description_doc, const char* description_path, const char* description_dir);
-RygelRootDevice* rygel_root_device_construct (GType object_type, GUPnPContext* context, RygelPlugin* plugin, GUPnPXMLDoc* description_doc, const char* description_path, const char* description_dir);
-GQuark root_device_factory_error_quark (void);
-gpointer rygel_root_device_factory_ref (gpointer instance);
-void rygel_root_device_factory_unref (gpointer instance);
-GParamSpec* rygel_param_spec_root_device_factory (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
-void rygel_value_set_root_device_factory (GValue* value, gpointer v_object);
-gpointer rygel_value_get_root_device_factory (const GValue* value);
-GType rygel_root_device_factory_get_type (void);
-RygelRootDeviceFactory* rygel_root_device_factory_new (GUPnPContext* context, GError** error);
-RygelRootDeviceFactory* rygel_root_device_factory_construct (GType object_type, GUPnPContext* context, GError** error);
-RygelRootDevice* rygel_root_device_factory_create (RygelRootDeviceFactory* self, RygelPlugin* plugin, GError** error);
-void rygel_main_exit (RygelMain* self, gint exit_code);
-
-
-G_END_DECLS
-
-#endif
--- a/src/ui/Makefile.in
+++ b/src/ui/Makefile.in
@@ -42,7 +42,8 @@ DIST_COMMON = $(srcdir)/Makefile.am $(sr
 	rygel-preferences-section.c rygel-tracker-pref-section.c \
 	rygel_preferences_vala.stamp
 ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
-am__aclocal_m4_deps = $(top_srcdir)/m4/libtool.m4 \
+am__aclocal_m4_deps = $(top_srcdir)/m4/glib-gettext.m4 \
+	$(top_srcdir)/m4/isc-posix.m4 $(top_srcdir)/m4/libtool.m4 \
 	$(top_srcdir)/m4/ltoptions.m4 $(top_srcdir)/m4/ltsugar.m4 \
 	$(top_srcdir)/m4/ltversion.m4 $(top_srcdir)/m4/lt~obsolete.m4 \
 	$(top_srcdir)/configure.ac
@@ -65,7 +66,6 @@ am__DEPENDENCIES_1 =
 rygel_preferences_DEPENDENCIES = $(am__DEPENDENCIES_1) \
 	$(am__DEPENDENCIES_1) $(am__DEPENDENCIES_1) \
 	$(am__DEPENDENCIES_1) $(am__DEPENDENCIES_1) \
-	$(am__DEPENDENCIES_1) $(am__DEPENDENCIES_1) \
 	$(am__DEPENDENCIES_1)
 AM_V_lt = $(am__v_lt_$(V))
 am__v_lt_ = $(am__v_lt_$(AM_DEFAULT_VERBOSITY))
@@ -148,8 +148,6 @@ GMSGFMT = @GMSGFMT@
 GREP = @GREP@
 GTK_CFLAGS = @GTK_CFLAGS@
 GTK_LIBS = @GTK_LIBS@
-GUPNP_VALA_CFLAGS = @GUPNP_VALA_CFLAGS@
-GUPNP_VALA_LIBS = @GUPNP_VALA_LIBS@
 HAVE_GTK = @HAVE_GTK@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
@@ -164,8 +162,8 @@ LIBDBUS_GLIB_CFLAGS = @LIBDBUS_GLIB_CFLA
 LIBDBUS_GLIB_LIBS = @LIBDBUS_GLIB_LIBS@
 LIBGIO_CFLAGS = @LIBGIO_CFLAGS@
 LIBGIO_LIBS = @LIBGIO_LIBS@
-LIBGSTREAMER_CFLAGS = @LIBGSTREAMER_CFLAGS@
-LIBGSTREAMER_LIBS = @LIBGSTREAMER_LIBS@
+LIBGLIB_CFLAGS = @LIBGLIB_CFLAGS@
+LIBGLIB_LIBS = @LIBGLIB_LIBS@
 LIBGUPNP_AV_CFLAGS = @LIBGUPNP_AV_CFLAGS@
 LIBGUPNP_AV_LIBS = @LIBGUPNP_AV_LIBS@
 LIBGUPNP_CFLAGS = @LIBGUPNP_CFLAGS@
@@ -177,6 +175,8 @@ LIBSOUP_LIBS = @LIBSOUP_LIBS@
 LIBSQLITE3_CFLAGS = @LIBSQLITE3_CFLAGS@
 LIBSQLITE3_LIBS = @LIBSQLITE3_LIBS@
 LIBTOOL = @LIBTOOL@
+LIBVLC_CFLAGS = @LIBVLC_CFLAGS@
+LIBVLC_LIBS = @LIBVLC_LIBS@
 LIPO = @LIPO@
 LN_S = @LN_S@
 LTLIBOBJS = @LTLIBOBJS@
@@ -197,6 +197,7 @@ PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
 PACKAGE_NAME = @PACKAGE_NAME@
 PACKAGE_STRING = @PACKAGE_STRING@
 PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_URL = @PACKAGE_URL@
 PACKAGE_VERSION = @PACKAGE_VERSION@
 PATH_SEPARATOR = @PATH_SEPARATOR@
 PKG_CONFIG = @PKG_CONFIG@
@@ -210,8 +211,6 @@ SET_MAKE = @SET_MAKE@
 SHELL = @SHELL@
 STRIP = @STRIP@
 USE_NLS = @USE_NLS@
-UUID_CFLAGS = @UUID_CFLAGS@
-UUID_LIBS = @UUID_LIBS@
 VALAC = @VALAC@
 VAPIDIR = @VAPIDIR@
 VERSION = @VERSION@
--- a/src/ui/rygel-general-pref-section.c
+++ /dev/null
@@ -1,485 +0,0 @@
-/* rygel-general-pref-section.c generated by valac, the Vala compiler
- * generated from rygel-general-pref-section.vala, do not modify */
-
-/*
- * Copyright (C) 2009 Nokia Corporation.
- *
- * Author: Zeeshan Ali (Khattak) <zeeshanak@gnome.org>
- *                               <zeeshan.ali@nokia.com>
- *
- * This file is part of Rygel.
- *
- * Rygel is free software; you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * Rygel is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this program; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
- */
-
-#include <glib.h>
-#include <glib-object.h>
-#include <rygel.h>
-#include <stdlib.h>
-#include <string.h>
-#include <gtk/gtk.h>
-#include <libgupnp/gupnp.h>
-#include <float.h>
-#include <math.h>
-#include <libgssdp/gssdp.h>
-
-
-#define RYGEL_TYPE_PREFERENCES_SECTION (rygel_preferences_section_get_type ())
-#define RYGEL_PREFERENCES_SECTION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_PREFERENCES_SECTION, RygelPreferencesSection))
-#define RYGEL_PREFERENCES_SECTION_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_PREFERENCES_SECTION, RygelPreferencesSectionClass))
-#define RYGEL_IS_PREFERENCES_SECTION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_PREFERENCES_SECTION))
-#define RYGEL_IS_PREFERENCES_SECTION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_PREFERENCES_SECTION))
-#define RYGEL_PREFERENCES_SECTION_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_PREFERENCES_SECTION, RygelPreferencesSectionClass))
-
-typedef struct _RygelPreferencesSection RygelPreferencesSection;
-typedef struct _RygelPreferencesSectionClass RygelPreferencesSectionClass;
-typedef struct _RygelPreferencesSectionPrivate RygelPreferencesSectionPrivate;
-
-#define RYGEL_TYPE_GENERAL_PREF_SECTION (rygel_general_pref_section_get_type ())
-#define RYGEL_GENERAL_PREF_SECTION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_GENERAL_PREF_SECTION, RygelGeneralPrefSection))
-#define RYGEL_GENERAL_PREF_SECTION_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_GENERAL_PREF_SECTION, RygelGeneralPrefSectionClass))
-#define RYGEL_IS_GENERAL_PREF_SECTION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_GENERAL_PREF_SECTION))
-#define RYGEL_IS_GENERAL_PREF_SECTION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_GENERAL_PREF_SECTION))
-#define RYGEL_GENERAL_PREF_SECTION_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_GENERAL_PREF_SECTION, RygelGeneralPrefSectionClass))
-
-typedef struct _RygelGeneralPrefSection RygelGeneralPrefSection;
-typedef struct _RygelGeneralPrefSectionClass RygelGeneralPrefSectionClass;
-typedef struct _RygelGeneralPrefSectionPrivate RygelGeneralPrefSectionPrivate;
-#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
-#define _g_free0(var) (var = (g_free (var), NULL))
-#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
-
-struct _RygelPreferencesSection {
-	GObject parent_instance;
-	RygelPreferencesSectionPrivate * priv;
-	RygelUserConfig* config;
-	char* name;
-};
-
-struct _RygelPreferencesSectionClass {
-	GObjectClass parent_class;
-	void (*save) (RygelPreferencesSection* self);
-};
-
-struct _RygelGeneralPrefSection {
-	RygelPreferencesSection parent_instance;
-	RygelGeneralPrefSectionPrivate * priv;
-};
-
-struct _RygelGeneralPrefSectionClass {
-	RygelPreferencesSectionClass parent_class;
-};
-
-struct _RygelGeneralPrefSectionPrivate {
-	GtkComboBoxEntry* iface_entry;
-	GtkSpinButton* port_spin;
-	GtkCheckButton* upnp_check;
-	GtkCheckButton* trans_check;
-	GtkCheckButton* mp3_check;
-	GtkCheckButton* mp2ts_check;
-	GtkCheckButton* lpcm_check;
-	GUPnPContextManager* context_manager;
-};
-
-
-static gpointer rygel_general_pref_section_parent_class = NULL;
-
-GType rygel_preferences_section_get_type (void);
-GType rygel_general_pref_section_get_type (void);
-#define RYGEL_GENERAL_PREF_SECTION_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), RYGEL_TYPE_GENERAL_PREF_SECTION, RygelGeneralPrefSectionPrivate))
-enum  {
-	RYGEL_GENERAL_PREF_SECTION_DUMMY_PROPERTY
-};
-#define RYGEL_GENERAL_PREF_SECTION_UPNP_CHECKBUTTON "upnp-checkbutton"
-#define RYGEL_GENERAL_PREF_SECTION_IFACE_ENTRY "iface-entry"
-#define RYGEL_GENERAL_PREF_SECTION_PORT_SPINBUTTON "port-spinbutton"
-#define RYGEL_GENERAL_PREF_SECTION_TRANS_CHECKBUTTON "transcoding-checkbutton"
-#define RYGEL_GENERAL_PREF_SECTION_MP3_CHECKBUTTON "mp3-checkbutton"
-#define RYGEL_GENERAL_PREF_SECTION_MP2TS_CHECKBUTTON "mp2ts-checkbutton"
-#define RYGEL_GENERAL_PREF_SECTION_LPCM_CHECKBUTTON "lpcm-checkbutton"
-RygelPreferencesSection* rygel_preferences_section_construct (GType object_type, RygelUserConfig* config, const char* name);
-static void rygel_general_pref_section_on_trans_check_toggled (RygelGeneralPrefSection* self, GtkCheckButton* trans_check);
-static void _rygel_general_pref_section_on_trans_check_toggled_gtk_toggle_button_toggled (GtkCheckButton* _sender, gpointer self);
-static void rygel_general_pref_section_on_context_available (RygelGeneralPrefSection* self, GUPnPContextManager* manager, GUPnPContext* context);
-static void _rygel_general_pref_section_on_context_available_gupnp_context_manager_context_available (GUPnPContextManager* _sender, GUPnPContext* p0, gpointer self);
-static void rygel_general_pref_section_on_context_unavailable (RygelGeneralPrefSection* self, GUPnPContextManager* manager, GUPnPContext* context);
-static void _rygel_general_pref_section_on_context_unavailable_gupnp_context_manager_context_unavailable (GUPnPContextManager* _sender, GUPnPContext* p0, gpointer self);
-RygelGeneralPrefSection* rygel_general_pref_section_new (GtkBuilder* builder, RygelUserConfig* config, GError** error);
-RygelGeneralPrefSection* rygel_general_pref_section_construct (GType object_type, GtkBuilder* builder, RygelUserConfig* config, GError** error);
-static void rygel_general_pref_section_real_save (RygelPreferencesSection* base);
-static gboolean rygel_general_pref_section_find_interface (RygelGeneralPrefSection* self, const char* iface, GtkTreeIter* iter);
-static void rygel_general_pref_section_finalize (GObject* obj);
-static int _vala_strcmp0 (const char * str1, const char * str2);
-
-
-
-static gpointer _g_object_ref0 (gpointer self) {
-	return self ? g_object_ref (self) : NULL;
-}
-
-
-static void _rygel_general_pref_section_on_trans_check_toggled_gtk_toggle_button_toggled (GtkCheckButton* _sender, gpointer self) {
-	rygel_general_pref_section_on_trans_check_toggled (self, _sender);
-}
-
-
-static void _rygel_general_pref_section_on_context_available_gupnp_context_manager_context_available (GUPnPContextManager* _sender, GUPnPContext* p0, gpointer self) {
-	rygel_general_pref_section_on_context_available (self, _sender, p0);
-}
-
-
-static void _rygel_general_pref_section_on_context_unavailable_gupnp_context_manager_context_unavailable (GUPnPContextManager* _sender, GUPnPContext* p0, gpointer self) {
-	rygel_general_pref_section_on_context_unavailable (self, _sender, p0);
-}
-
-
-RygelGeneralPrefSection* rygel_general_pref_section_construct (GType object_type, GtkBuilder* builder, RygelUserConfig* config, GError** error) {
-	GError * _inner_error_;
-	RygelGeneralPrefSection * self;
-	GtkCheckButton* _tmp0_;
-	GtkComboBoxEntry* _tmp1_;
-	GtkSpinButton* _tmp2_;
-	GtkCheckButton* _tmp3_;
-	GtkCheckButton* _tmp4_;
-	GtkCheckButton* _tmp5_;
-	GtkCheckButton* _tmp6_;
-	GUPnPContextManager* _tmp7_;
-	g_return_val_if_fail (builder != NULL, NULL);
-	g_return_val_if_fail (config != NULL, NULL);
-	_inner_error_ = NULL;
-	self = (RygelGeneralPrefSection*) rygel_preferences_section_construct (object_type, config, "general");
-	self->priv->upnp_check = (_tmp0_ = _g_object_ref0 (GTK_CHECK_BUTTON (gtk_builder_get_object (builder, RYGEL_GENERAL_PREF_SECTION_UPNP_CHECKBUTTON))), _g_object_unref0 (self->priv->upnp_check), _tmp0_);
-	g_assert (self->priv->upnp_check != NULL);
-	self->priv->iface_entry = (_tmp1_ = _g_object_ref0 (GTK_COMBO_BOX_ENTRY (gtk_builder_get_object (builder, RYGEL_GENERAL_PREF_SECTION_IFACE_ENTRY))), _g_object_unref0 (self->priv->iface_entry), _tmp1_);
-	g_assert (self->priv->iface_entry != NULL);
-	self->priv->port_spin = (_tmp2_ = _g_object_ref0 (GTK_SPIN_BUTTON (gtk_builder_get_object (builder, RYGEL_GENERAL_PREF_SECTION_PORT_SPINBUTTON))), _g_object_unref0 (self->priv->port_spin), _tmp2_);
-	g_assert (self->priv->port_spin != NULL);
-	self->priv->trans_check = (_tmp3_ = _g_object_ref0 (GTK_CHECK_BUTTON (gtk_builder_get_object (builder, RYGEL_GENERAL_PREF_SECTION_TRANS_CHECKBUTTON))), _g_object_unref0 (self->priv->trans_check), _tmp3_);
-	g_assert (self->priv->trans_check != NULL);
-	self->priv->mp3_check = (_tmp4_ = _g_object_ref0 (GTK_CHECK_BUTTON (gtk_builder_get_object (builder, RYGEL_GENERAL_PREF_SECTION_MP3_CHECKBUTTON))), _g_object_unref0 (self->priv->mp3_check), _tmp4_);
-	g_assert (self->priv->mp3_check != NULL);
-	self->priv->mp2ts_check = (_tmp5_ = _g_object_ref0 (GTK_CHECK_BUTTON (gtk_builder_get_object (builder, RYGEL_GENERAL_PREF_SECTION_MP2TS_CHECKBUTTON))), _g_object_unref0 (self->priv->mp2ts_check), _tmp5_);
-	g_assert (self->priv->mp2ts_check != NULL);
-	self->priv->lpcm_check = (_tmp6_ = _g_object_ref0 (GTK_CHECK_BUTTON (gtk_builder_get_object (builder, RYGEL_GENERAL_PREF_SECTION_LPCM_CHECKBUTTON))), _g_object_unref0 (self->priv->lpcm_check), _tmp6_);
-	g_assert (self->priv->lpcm_check != NULL);
-	self->priv->context_manager = (_tmp7_ = gupnp_context_manager_new (NULL, (guint) 0), _g_object_unref0 (self->priv->context_manager), _tmp7_);
-	gtk_combo_box_entry_set_text_column (self->priv->iface_entry, 0);
-	{
-		char* _tmp8_;
-		char* _tmp9_;
-		_tmp8_ = rygel_configuration_get_interface ((RygelConfiguration*) config, &_inner_error_);
-		if (_inner_error_ != NULL) {
-			goto __catch1_g_error;
-			goto __finally1;
-		}
-		gtk_combo_box_append_text ((GtkComboBox*) self->priv->iface_entry, _tmp9_ = _tmp8_);
-		_g_free0 (_tmp9_);
-		gtk_combo_box_set_active ((GtkComboBox*) self->priv->iface_entry, 0);
-	}
-	goto __finally1;
-	__catch1_g_error:
-	{
-		GError * err;
-		err = _inner_error_;
-		_inner_error_ = NULL;
-		{
-			_g_error_free0 (err);
-		}
-	}
-	__finally1:
-	if (_inner_error_ != NULL) {
-		g_propagate_error (error, _inner_error_);
-		return;
-	}
-	{
-		gint _tmp10_;
-		_tmp10_ = rygel_configuration_get_port ((RygelConfiguration*) config, &_inner_error_);
-		if (_inner_error_ != NULL) {
-			goto __catch2_g_error;
-			goto __finally2;
-		}
-		gtk_spin_button_set_value (self->priv->port_spin, (double) _tmp10_);
-	}
-	goto __finally2;
-	__catch2_g_error:
-	{
-		GError * err;
-		err = _inner_error_;
-		_inner_error_ = NULL;
-		{
-			_g_error_free0 (err);
-		}
-	}
-	__finally2:
-	if (_inner_error_ != NULL) {
-		g_propagate_error (error, _inner_error_);
-		return;
-	}
-	{
-		gboolean _tmp11_;
-		_tmp11_ = rygel_configuration_get_upnp_enabled ((RygelConfiguration*) ((RygelPreferencesSection*) self)->config, &_inner_error_);
-		if (_inner_error_ != NULL) {
-			goto __catch3_g_error;
-			goto __finally3;
-		}
-		gtk_toggle_button_set_active ((GtkToggleButton*) self->priv->upnp_check, _tmp11_);
-	}
-	goto __finally3;
-	__catch3_g_error:
-	{
-		GError * err;
-		err = _inner_error_;
-		_inner_error_ = NULL;
-		{
-			_g_error_free0 (err);
-		}
-	}
-	__finally3:
-	if (_inner_error_ != NULL) {
-		g_propagate_error (error, _inner_error_);
-		return;
-	}
-	{
-		gboolean _tmp12_;
-		_tmp12_ = rygel_configuration_get_transcoding ((RygelConfiguration*) ((RygelPreferencesSection*) self)->config, &_inner_error_);
-		if (_inner_error_ != NULL) {
-			goto __catch4_g_error;
-			goto __finally4;
-		}
-		gtk_toggle_button_set_active ((GtkToggleButton*) self->priv->trans_check, _tmp12_);
-	}
-	goto __finally4;
-	__catch4_g_error:
-	{
-		GError * err;
-		err = _inner_error_;
-		_inner_error_ = NULL;
-		{
-			_g_error_free0 (err);
-		}
-	}
-	__finally4:
-	if (_inner_error_ != NULL) {
-		g_propagate_error (error, _inner_error_);
-		return;
-	}
-	{
-		gboolean _tmp13_;
-		_tmp13_ = rygel_configuration_get_mp3_transcoder ((RygelConfiguration*) ((RygelPreferencesSection*) self)->config, &_inner_error_);
-		if (_inner_error_ != NULL) {
-			goto __catch5_g_error;
-			goto __finally5;
-		}
-		gtk_toggle_button_set_active ((GtkToggleButton*) self->priv->mp3_check, _tmp13_);
-	}
-	goto __finally5;
-	__catch5_g_error:
-	{
-		GError * err;
-		err = _inner_error_;
-		_inner_error_ = NULL;
-		{
-			_g_error_free0 (err);
-		}
-	}
-	__finally5:
-	if (_inner_error_ != NULL) {
-		g_propagate_error (error, _inner_error_);
-		return;
-	}
-	{
-		gboolean _tmp14_;
-		_tmp14_ = rygel_configuration_get_mp2ts_transcoder ((RygelConfiguration*) ((RygelPreferencesSection*) self)->config, &_inner_error_);
-		if (_inner_error_ != NULL) {
-			goto __catch6_g_error;
-			goto __finally6;
-		}
-		gtk_toggle_button_set_active ((GtkToggleButton*) self->priv->mp2ts_check, _tmp14_);
-	}
-	goto __finally6;
-	__catch6_g_error:
-	{
-		GError * err;
-		err = _inner_error_;
-		_inner_error_ = NULL;
-		{
-			_g_error_free0 (err);
-		}
-	}
-	__finally6:
-	if (_inner_error_ != NULL) {
-		g_propagate_error (error, _inner_error_);
-		return;
-	}
-	{
-		gboolean _tmp15_;
-		_tmp15_ = rygel_configuration_get_lpcm_transcoder ((RygelConfiguration*) ((RygelPreferencesSection*) self)->config, &_inner_error_);
-		if (_inner_error_ != NULL) {
-			goto __catch7_g_error;
-			goto __finally7;
-		}
-		gtk_toggle_button_set_active ((GtkToggleButton*) self->priv->lpcm_check, _tmp15_);
-	}
-	goto __finally7;
-	__catch7_g_error:
-	{
-		GError * err;
-		err = _inner_error_;
-		_inner_error_ = NULL;
-		{
-			_g_error_free0 (err);
-		}
-	}
-	__finally7:
-	if (_inner_error_ != NULL) {
-		g_propagate_error (error, _inner_error_);
-		return;
-	}
-	g_signal_connect_object ((GtkToggleButton*) self->priv->trans_check, "toggled", (GCallback) _rygel_general_pref_section_on_trans_check_toggled_gtk_toggle_button_toggled, self, 0);
-	g_signal_connect_object (self->priv->context_manager, "context-available", (GCallback) _rygel_general_pref_section_on_context_available_gupnp_context_manager_context_available, self, 0);
-	g_signal_connect_object (self->priv->context_manager, "context-unavailable", (GCallback) _rygel_general_pref_section_on_context_unavailable_gupnp_context_manager_context_unavailable, self, 0);
-	rygel_general_pref_section_on_trans_check_toggled (self, self->priv->trans_check);
-	return self;
-}
-
-
-RygelGeneralPrefSection* rygel_general_pref_section_new (GtkBuilder* builder, RygelUserConfig* config, GError** error) {
-	return rygel_general_pref_section_construct (RYGEL_TYPE_GENERAL_PREF_SECTION, builder, config, error);
-}
-
-
-static void rygel_general_pref_section_real_save (RygelPreferencesSection* base) {
-	RygelGeneralPrefSection * self;
-	self = (RygelGeneralPrefSection*) base;
-	rygel_user_config_set_interface (((RygelPreferencesSection*) self)->config, gtk_combo_box_get_active_text ((GtkComboBox*) self->priv->iface_entry));
-	rygel_user_config_set_port (((RygelPreferencesSection*) self)->config, (gint) gtk_spin_button_get_value (self->priv->port_spin));
-	rygel_user_config_set_upnp_enabled (((RygelPreferencesSection*) self)->config, gtk_toggle_button_get_active ((GtkToggleButton*) self->priv->upnp_check));
-	rygel_user_config_set_transcoding (((RygelPreferencesSection*) self)->config, gtk_toggle_button_get_active ((GtkToggleButton*) self->priv->trans_check));
-	rygel_user_config_set_mp3_transcoder (((RygelPreferencesSection*) self)->config, gtk_toggle_button_get_active ((GtkToggleButton*) self->priv->mp3_check));
-	rygel_user_config_set_mp2ts_transcoder (((RygelPreferencesSection*) self)->config, gtk_toggle_button_get_active ((GtkToggleButton*) self->priv->mp2ts_check));
-	rygel_user_config_set_lpcm_transcoder (((RygelPreferencesSection*) self)->config, gtk_toggle_button_get_active ((GtkToggleButton*) self->priv->lpcm_check));
-}
-
-
-static void rygel_general_pref_section_on_trans_check_toggled (RygelGeneralPrefSection* self, GtkCheckButton* trans_check) {
-	gboolean _tmp0_;
-	gboolean _tmp1_;
-	g_return_if_fail (self != NULL);
-	g_return_if_fail (trans_check != NULL);
-	g_object_set ((GtkWidget*) self->priv->mp3_check, "sensitive", (g_object_set ((GtkWidget*) self->priv->mp2ts_check, "sensitive", (g_object_set ((GtkWidget*) self->priv->lpcm_check, "sensitive", gtk_toggle_button_get_active ((GtkToggleButton*) trans_check), NULL), (g_object_get ((GtkWidget*) self->priv->lpcm_check, "sensitive", &_tmp0_, NULL), _tmp0_)), NULL), (g_object_get ((GtkWidget*) self->priv->mp2ts_check, "sensitive", &_tmp1_, NULL), _tmp1_)), NULL);
-}
-
-
-static void rygel_general_pref_section_on_context_available (RygelGeneralPrefSection* self, GUPnPContextManager* manager, GUPnPContext* context) {
-	GtkTreeIter iter = {0};
-	g_return_if_fail (self != NULL);
-	g_return_if_fail (manager != NULL);
-	g_return_if_fail (context != NULL);
-	if (!rygel_general_pref_section_find_interface (self, gssdp_client_get_interface ((GSSDPClient*) context), &iter)) {
-		gtk_combo_box_append_text ((GtkComboBox*) self->priv->iface_entry, gssdp_client_get_interface ((GSSDPClient*) context));
-	}
-}
-
-
-static void rygel_general_pref_section_on_context_unavailable (RygelGeneralPrefSection* self, GUPnPContextManager* manager, GUPnPContext* context) {
-	GtkTreeIter iter = {0};
-	g_return_if_fail (self != NULL);
-	g_return_if_fail (manager != NULL);
-	g_return_if_fail (context != NULL);
-	if (rygel_general_pref_section_find_interface (self, gssdp_client_get_interface ((GSSDPClient*) context), &iter)) {
-		GtkTreeModel* _tmp0_;
-		GtkListStore* list_store;
-		list_store = _g_object_ref0 ((_tmp0_ = gtk_combo_box_get_model ((GtkComboBox*) self->priv->iface_entry), GTK_IS_LIST_STORE (_tmp0_) ? ((GtkListStore*) _tmp0_) : NULL));
-		gtk_list_store_remove (list_store, &iter);
-		_g_object_unref0 (list_store);
-	}
-}
-
-
-static gboolean rygel_general_pref_section_find_interface (RygelGeneralPrefSection* self, const char* iface, GtkTreeIter* iter) {
-	gboolean result;
-	GtkTreeModel* model;
-	gboolean more;
-	g_return_val_if_fail (self != NULL, FALSE);
-	g_return_val_if_fail (iface != NULL, FALSE);
-	model = _g_object_ref0 (gtk_combo_box_get_model ((GtkComboBox*) self->priv->iface_entry));
-	more = gtk_tree_model_get_iter_first (model, iter);
-	while (TRUE) {
-		if (!more) {
-			break;
-		}
-		gtk_tree_model_get (model, iter, 0, &((RygelPreferencesSection*) self)->name, -1, -1);
-		if (_vala_strcmp0 (((RygelPreferencesSection*) self)->name, iface) == 0) {
-			break;
-		}
-		more = gtk_tree_model_iter_next (model, iter);
-	}
-	result = more;
-	_g_object_unref0 (model);
-	return result;
-}
-
-
-static void rygel_general_pref_section_class_init (RygelGeneralPrefSectionClass * klass) {
-	rygel_general_pref_section_parent_class = g_type_class_peek_parent (klass);
-	g_type_class_add_private (klass, sizeof (RygelGeneralPrefSectionPrivate));
-	RYGEL_PREFERENCES_SECTION_CLASS (klass)->save = rygel_general_pref_section_real_save;
-	G_OBJECT_CLASS (klass)->finalize = rygel_general_pref_section_finalize;
-}
-
-
-static void rygel_general_pref_section_instance_init (RygelGeneralPrefSection * self) {
-	self->priv = RYGEL_GENERAL_PREF_SECTION_GET_PRIVATE (self);
-}
-
-
-static void rygel_general_pref_section_finalize (GObject* obj) {
-	RygelGeneralPrefSection * self;
-	self = RYGEL_GENERAL_PREF_SECTION (obj);
-	_g_object_unref0 (self->priv->iface_entry);
-	_g_object_unref0 (self->priv->port_spin);
-	_g_object_unref0 (self->priv->upnp_check);
-	_g_object_unref0 (self->priv->trans_check);
-	_g_object_unref0 (self->priv->mp3_check);
-	_g_object_unref0 (self->priv->mp2ts_check);
-	_g_object_unref0 (self->priv->lpcm_check);
-	_g_object_unref0 (self->priv->context_manager);
-	G_OBJECT_CLASS (rygel_general_pref_section_parent_class)->finalize (obj);
-}
-
-
-GType rygel_general_pref_section_get_type (void) {
-	static GType rygel_general_pref_section_type_id = 0;
-	if (rygel_general_pref_section_type_id == 0) {
-		static const GTypeInfo g_define_type_info = { sizeof (RygelGeneralPrefSectionClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) rygel_general_pref_section_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (RygelGeneralPrefSection), 0, (GInstanceInitFunc) rygel_general_pref_section_instance_init, NULL };
-		rygel_general_pref_section_type_id = g_type_register_static (RYGEL_TYPE_PREFERENCES_SECTION, "RygelGeneralPrefSection", &g_define_type_info, 0);
-	}
-	return rygel_general_pref_section_type_id;
-}
-
-
-static int _vala_strcmp0 (const char * str1, const char * str2) {
-	if (str1 == NULL) {
-		return -(str1 != str2);
-	}
-	if (str2 == NULL) {
-		return str1 != str2;
-	}
-	return strcmp (str1, str2);
-}
-
-
-
-
--- a/src/ui/rygel-media-export-pref-section.c
+++ /dev/null
@@ -1,435 +0,0 @@
-/* rygel-media-export-pref-section.c generated by valac, the Vala compiler
- * generated from rygel-media-export-pref-section.vala, do not modify */
-
-/*
- * Copyright (C) 2009 Nokia Corporation.
- *
- * Author: Zeeshan Ali (Khattak) <zeeshanak@gnome.org>
- *                               <zeeshan.ali@nokia.com>
- *
- * This file is part of Rygel.
- *
- * Rygel is free software; you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * Rygel is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this program; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
- */
-
-#include <glib.h>
-#include <glib-object.h>
-#include <rygel.h>
-#include <stdlib.h>
-#include <string.h>
-#include <gee.h>
-#include <gtk/gtk.h>
-#include <gio/gio.h>
-
-
-#define RYGEL_TYPE_PREFERENCES_SECTION (rygel_preferences_section_get_type ())
-#define RYGEL_PREFERENCES_SECTION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_PREFERENCES_SECTION, RygelPreferencesSection))
-#define RYGEL_PREFERENCES_SECTION_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_PREFERENCES_SECTION, RygelPreferencesSectionClass))
-#define RYGEL_IS_PREFERENCES_SECTION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_PREFERENCES_SECTION))
-#define RYGEL_IS_PREFERENCES_SECTION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_PREFERENCES_SECTION))
-#define RYGEL_PREFERENCES_SECTION_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_PREFERENCES_SECTION, RygelPreferencesSectionClass))
-
-typedef struct _RygelPreferencesSection RygelPreferencesSection;
-typedef struct _RygelPreferencesSectionClass RygelPreferencesSectionClass;
-typedef struct _RygelPreferencesSectionPrivate RygelPreferencesSectionPrivate;
-
-#define RYGEL_TYPE_PLUGIN_PREF_SECTION (rygel_plugin_pref_section_get_type ())
-#define RYGEL_PLUGIN_PREF_SECTION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_PLUGIN_PREF_SECTION, RygelPluginPrefSection))
-#define RYGEL_PLUGIN_PREF_SECTION_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_PLUGIN_PREF_SECTION, RygelPluginPrefSectionClass))
-#define RYGEL_IS_PLUGIN_PREF_SECTION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_PLUGIN_PREF_SECTION))
-#define RYGEL_IS_PLUGIN_PREF_SECTION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_PLUGIN_PREF_SECTION))
-#define RYGEL_PLUGIN_PREF_SECTION_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_PLUGIN_PREF_SECTION, RygelPluginPrefSectionClass))
-
-typedef struct _RygelPluginPrefSection RygelPluginPrefSection;
-typedef struct _RygelPluginPrefSectionClass RygelPluginPrefSectionClass;
-typedef struct _RygelPluginPrefSectionPrivate RygelPluginPrefSectionPrivate;
-
-#define RYGEL_TYPE_MEDIA_EXPORT_PREF_SECTION (rygel_media_export_pref_section_get_type ())
-#define RYGEL_MEDIA_EXPORT_PREF_SECTION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_MEDIA_EXPORT_PREF_SECTION, RygelMediaExportPrefSection))
-#define RYGEL_MEDIA_EXPORT_PREF_SECTION_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_MEDIA_EXPORT_PREF_SECTION, RygelMediaExportPrefSectionClass))
-#define RYGEL_IS_MEDIA_EXPORT_PREF_SECTION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_MEDIA_EXPORT_PREF_SECTION))
-#define RYGEL_IS_MEDIA_EXPORT_PREF_SECTION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_MEDIA_EXPORT_PREF_SECTION))
-#define RYGEL_MEDIA_EXPORT_PREF_SECTION_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_MEDIA_EXPORT_PREF_SECTION, RygelMediaExportPrefSectionClass))
-
-typedef struct _RygelMediaExportPrefSection RygelMediaExportPrefSection;
-typedef struct _RygelMediaExportPrefSectionClass RygelMediaExportPrefSectionClass;
-typedef struct _RygelMediaExportPrefSectionPrivate RygelMediaExportPrefSectionPrivate;
-#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
-#define _g_free0(var) (var = (g_free (var), NULL))
-#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
-#define __g_slist_free_g_object_unref0(var) ((var == NULL) ? NULL : (var = (_g_slist_free_g_object_unref (var), NULL)))
-#define _gtk_tree_row_reference_free0(var) ((var == NULL) ? NULL : (var = (gtk_tree_row_reference_free (var), NULL)))
-#define _gtk_tree_path_free0(var) ((var == NULL) ? NULL : (var = (gtk_tree_path_free (var), NULL)))
-#define __g_list_free_gtk_tree_path_free0(var) ((var == NULL) ? NULL : (var = (_g_list_free_gtk_tree_path_free (var), NULL)))
-
-struct _RygelPreferencesSection {
-	GObject parent_instance;
-	RygelPreferencesSectionPrivate * priv;
-	RygelUserConfig* config;
-	char* name;
-};
-
-struct _RygelPreferencesSectionClass {
-	GObjectClass parent_class;
-	void (*save) (RygelPreferencesSection* self);
-};
-
-struct _RygelPluginPrefSection {
-	RygelPreferencesSection parent_instance;
-	RygelPluginPrefSectionPrivate * priv;
-	GeeArrayList* widgets;
-};
-
-struct _RygelPluginPrefSectionClass {
-	RygelPreferencesSectionClass parent_class;
-};
-
-struct _RygelMediaExportPrefSection {
-	RygelPluginPrefSection parent_instance;
-	RygelMediaExportPrefSectionPrivate * priv;
-};
-
-struct _RygelMediaExportPrefSectionClass {
-	RygelPluginPrefSectionClass parent_class;
-};
-
-struct _RygelMediaExportPrefSectionPrivate {
-	GtkTreeView* treeview;
-	GtkListStore* liststore;
-	GtkFileChooserDialog* dialog;
-};
-
-
-static gpointer rygel_media_export_pref_section_parent_class = NULL;
-
-GType rygel_preferences_section_get_type (void);
-GType rygel_plugin_pref_section_get_type (void);
-GType rygel_media_export_pref_section_get_type (void);
-#define RYGEL_MEDIA_EXPORT_PREF_SECTION_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), RYGEL_TYPE_MEDIA_EXPORT_PREF_SECTION, RygelMediaExportPrefSectionPrivate))
-enum  {
-	RYGEL_MEDIA_EXPORT_PREF_SECTION_DUMMY_PROPERTY
-};
-#define RYGEL_MEDIA_EXPORT_PREF_SECTION_NAME "MediaExport"
-#define RYGEL_MEDIA_EXPORT_PREF_SECTION_URIS_KEY "uris"
-#define RYGEL_MEDIA_EXPORT_PREF_SECTION_URIS_LABEL RYGEL_MEDIA_EXPORT_PREF_SECTION_URIS_KEY "-label"
-#define RYGEL_MEDIA_EXPORT_PREF_SECTION_URIS_TEXTVIEW RYGEL_MEDIA_EXPORT_PREF_SECTION_URIS_KEY "-treeview"
-#define RYGEL_MEDIA_EXPORT_PREF_SECTION_URIS_LISTSTORE RYGEL_MEDIA_EXPORT_PREF_SECTION_URIS_KEY "-liststore"
-#define RYGEL_MEDIA_EXPORT_PREF_SECTION_URIS_DIALOG RYGEL_MEDIA_EXPORT_PREF_SECTION_URIS_KEY "-dialog"
-#define RYGEL_MEDIA_EXPORT_PREF_SECTION_ADD_BUTTON "add-button"
-#define RYGEL_MEDIA_EXPORT_PREF_SECTION_REMOVE_BUTTON "remove-button"
-#define RYGEL_MEDIA_EXPORT_PREF_SECTION_CLEAR_BUTTON "clear-button"
-RygelPluginPrefSection* rygel_plugin_pref_section_new (GtkBuilder* builder, RygelUserConfig* config, const char* name);
-RygelPluginPrefSection* rygel_plugin_pref_section_construct (GType object_type, GtkBuilder* builder, RygelUserConfig* config, const char* name);
-static void rygel_media_export_pref_section_on_add_button_clicked (RygelMediaExportPrefSection* self, GtkButton* button);
-static void _rygel_media_export_pref_section_on_add_button_clicked_gtk_button_clicked (GtkButton* _sender, gpointer self);
-static void rygel_media_export_pref_section_on_remove_button_clicked (RygelMediaExportPrefSection* self, GtkButton* button);
-static void _rygel_media_export_pref_section_on_remove_button_clicked_gtk_button_clicked (GtkButton* _sender, gpointer self);
-static void rygel_media_export_pref_section_on_clear_button_clicked (RygelMediaExportPrefSection* self, GtkButton* button);
-static void _rygel_media_export_pref_section_on_clear_button_clicked_gtk_button_clicked (GtkButton* _sender, gpointer self);
-void rygel_plugin_pref_section_reset_widgets_sensitivity (RygelPluginPrefSection* self);
-RygelMediaExportPrefSection* rygel_media_export_pref_section_new (GtkBuilder* builder, RygelUserConfig* config);
-RygelMediaExportPrefSection* rygel_media_export_pref_section_construct (GType object_type, GtkBuilder* builder, RygelUserConfig* config);
-void rygel_preferences_section_save (RygelPreferencesSection* self);
-static void rygel_media_export_pref_section_real_save (RygelPreferencesSection* base);
-static void _g_slist_free_g_object_unref (GSList* self);
-static void _g_list_free_gtk_tree_path_free (GList* self);
-static void rygel_media_export_pref_section_finalize (GObject* obj);
-
-
-
-static gpointer _g_object_ref0 (gpointer self) {
-	return self ? g_object_ref (self) : NULL;
-}
-
-
-static void _rygel_media_export_pref_section_on_add_button_clicked_gtk_button_clicked (GtkButton* _sender, gpointer self) {
-	rygel_media_export_pref_section_on_add_button_clicked (self, _sender);
-}
-
-
-static void _rygel_media_export_pref_section_on_remove_button_clicked_gtk_button_clicked (GtkButton* _sender, gpointer self) {
-	rygel_media_export_pref_section_on_remove_button_clicked (self, _sender);
-}
-
-
-static void _rygel_media_export_pref_section_on_clear_button_clicked_gtk_button_clicked (GtkButton* _sender, gpointer self) {
-	rygel_media_export_pref_section_on_clear_button_clicked (self, _sender);
-}
-
-
-RygelMediaExportPrefSection* rygel_media_export_pref_section_construct (GType object_type, GtkBuilder* builder, RygelUserConfig* config) {
-	GError * _inner_error_;
-	RygelMediaExportPrefSection * self;
-	GtkTreeView* _tmp0_;
-	GtkListStore* _tmp1_;
-	GtkFileChooserDialog* _tmp2_;
-	GtkCellRendererText* _tmp3_;
-	GtkButton* button;
-	GtkButton* _tmp4_;
-	GtkButton* _tmp5_;
-	GtkLabel* label;
-	g_return_val_if_fail (builder != NULL, NULL);
-	g_return_val_if_fail (config != NULL, NULL);
-	_inner_error_ = NULL;
-	self = (RygelMediaExportPrefSection*) rygel_plugin_pref_section_construct (object_type, builder, config, RYGEL_MEDIA_EXPORT_PREF_SECTION_NAME);
-	self->priv->treeview = (_tmp0_ = _g_object_ref0 (GTK_TREE_VIEW (gtk_builder_get_object (builder, RYGEL_MEDIA_EXPORT_PREF_SECTION_URIS_TEXTVIEW))), _g_object_unref0 (self->priv->treeview), _tmp0_);
-	g_assert (self->priv->treeview != NULL);
-	self->priv->liststore = (_tmp1_ = _g_object_ref0 (GTK_LIST_STORE (gtk_builder_get_object (builder, RYGEL_MEDIA_EXPORT_PREF_SECTION_URIS_LISTSTORE))), _g_object_unref0 (self->priv->liststore), _tmp1_);
-	g_assert (self->priv->liststore != NULL);
-	self->priv->dialog = (_tmp2_ = _g_object_ref0 (GTK_FILE_CHOOSER_DIALOG (gtk_builder_get_object (builder, RYGEL_MEDIA_EXPORT_PREF_SECTION_URIS_DIALOG))), _g_object_unref0 (self->priv->dialog), _tmp2_);
-	g_assert (self->priv->dialog != NULL);
-	gtk_tree_view_insert_column_with_attributes (self->priv->treeview, -1, "paths", (GtkCellRenderer*) (_tmp3_ = g_object_ref_sink ((GtkCellRendererText*) gtk_cell_renderer_text_new ())), "text", 0, NULL, NULL);
-	_g_object_unref0 (_tmp3_);
-	gee_abstract_collection_add ((GeeAbstractCollection*) ((RygelPluginPrefSection*) self)->widgets, (GtkWidget*) self->priv->treeview);
-	{
-		GeeArrayList* uris;
-		uris = rygel_configuration_get_string_list ((RygelConfiguration*) config, ((RygelPreferencesSection*) self)->name, RYGEL_MEDIA_EXPORT_PREF_SECTION_URIS_KEY, &_inner_error_);
-		if (_inner_error_ != NULL) {
-			goto __catch10_g_error;
-			goto __finally10;
-		}
-		{
-			GeeIterator* _uri_it;
-			_uri_it = gee_abstract_collection_iterator ((GeeAbstractCollection*) uris);
-			while (TRUE) {
-				char* uri;
-				GtkTreeIter iter = {0};
-				if (!gee_iterator_next (_uri_it)) {
-					break;
-				}
-				uri = (char*) gee_iterator_get (_uri_it);
-				gtk_list_store_append (self->priv->liststore, &iter);
-				gtk_list_store_set (self->priv->liststore, &iter, 0, uri, -1, -1);
-				_g_free0 (uri);
-			}
-			_g_object_unref0 (_uri_it);
-		}
-		_g_object_unref0 (uris);
-	}
-	goto __finally10;
-	__catch10_g_error:
-	{
-		GError * err;
-		err = _inner_error_;
-		_inner_error_ = NULL;
-		{
-			_g_error_free0 (err);
-		}
-	}
-	__finally10:
-	if (_inner_error_ != NULL) {
-		g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
-		g_clear_error (&_inner_error_);
-		return NULL;
-	}
-	gtk_file_chooser_set_current_folder ((GtkFileChooser*) self->priv->dialog, g_get_home_dir ());
-	gtk_file_chooser_set_show_hidden ((GtkFileChooser*) self->priv->dialog, FALSE);
-	button = _g_object_ref0 (GTK_BUTTON (gtk_builder_get_object (builder, RYGEL_MEDIA_EXPORT_PREF_SECTION_ADD_BUTTON)));
-	g_signal_connect_object (button, "clicked", (GCallback) _rygel_media_export_pref_section_on_add_button_clicked_gtk_button_clicked, self, 0);
-	gee_abstract_collection_add ((GeeAbstractCollection*) ((RygelPluginPrefSection*) self)->widgets, (GtkWidget*) button);
-	button = (_tmp4_ = _g_object_ref0 (GTK_BUTTON (gtk_builder_get_object (builder, RYGEL_MEDIA_EXPORT_PREF_SECTION_REMOVE_BUTTON))), _g_object_unref0 (button), _tmp4_);
-	g_signal_connect_object (button, "clicked", (GCallback) _rygel_media_export_pref_section_on_remove_button_clicked_gtk_button_clicked, self, 0);
-	gee_abstract_collection_add ((GeeAbstractCollection*) ((RygelPluginPrefSection*) self)->widgets, (GtkWidget*) button);
-	button = (_tmp5_ = _g_object_ref0 (GTK_BUTTON (gtk_builder_get_object (builder, RYGEL_MEDIA_EXPORT_PREF_SECTION_CLEAR_BUTTON))), _g_object_unref0 (button), _tmp5_);
-	g_signal_connect_object (button, "clicked", (GCallback) _rygel_media_export_pref_section_on_clear_button_clicked_gtk_button_clicked, self, 0);
-	gee_abstract_collection_add ((GeeAbstractCollection*) ((RygelPluginPrefSection*) self)->widgets, (GtkWidget*) button);
-	label = _g_object_ref0 (GTK_LABEL (gtk_builder_get_object (builder, RYGEL_MEDIA_EXPORT_PREF_SECTION_URIS_LABEL)));
-	g_assert (label != NULL);
-	gee_abstract_collection_add ((GeeAbstractCollection*) ((RygelPluginPrefSection*) self)->widgets, (GtkWidget*) label);
-	rygel_plugin_pref_section_reset_widgets_sensitivity ((RygelPluginPrefSection*) self);
-	_g_object_unref0 (button);
-	_g_object_unref0 (label);
-	return self;
-}
-
-
-RygelMediaExportPrefSection* rygel_media_export_pref_section_new (GtkBuilder* builder, RygelUserConfig* config) {
-	return rygel_media_export_pref_section_construct (RYGEL_TYPE_MEDIA_EXPORT_PREF_SECTION, builder, config);
-}
-
-
-static void rygel_media_export_pref_section_real_save (RygelPreferencesSection* base) {
-	RygelMediaExportPrefSection * self;
-	GtkTreeIter iter = {0};
-	GeeArrayList* uri_list;
-	self = (RygelMediaExportPrefSection*) base;
-	RYGEL_PREFERENCES_SECTION_CLASS (rygel_media_export_pref_section_parent_class)->save ((RygelPreferencesSection*) RYGEL_PLUGIN_PREF_SECTION (self));
-	uri_list = gee_array_list_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, g_direct_equal);
-	if (gtk_tree_model_get_iter_first ((GtkTreeModel*) self->priv->liststore, &iter)) {
-		{
-			gboolean _tmp0_;
-			_tmp0_ = TRUE;
-			while (TRUE) {
-				char* uri;
-				if (!_tmp0_) {
-					if (!gtk_tree_model_iter_next ((GtkTreeModel*) self->priv->liststore, &iter)) {
-						break;
-					}
-				}
-				_tmp0_ = FALSE;
-				uri = NULL;
-				gtk_tree_model_get ((GtkTreeModel*) self->priv->liststore, &iter, 0, &uri, -1, -1);
-				gee_abstract_collection_add ((GeeAbstractCollection*) uri_list, uri);
-				_g_free0 (uri);
-			}
-		}
-	}
-	rygel_user_config_set_string_list (((RygelPreferencesSection*) self)->config, ((RygelPreferencesSection*) self)->name, RYGEL_MEDIA_EXPORT_PREF_SECTION_URIS_KEY, uri_list);
-	_g_object_unref0 (uri_list);
-}
-
-
-static void _g_slist_free_g_object_unref (GSList* self) {
-	g_slist_foreach (self, (GFunc) g_object_unref, NULL);
-	g_slist_free (self);
-}
-
-
-static void rygel_media_export_pref_section_on_add_button_clicked (RygelMediaExportPrefSection* self, GtkButton* button) {
-	g_return_if_fail (self != NULL);
-	g_return_if_fail (button != NULL);
-	if (gtk_dialog_run ((GtkDialog*) self->priv->dialog) == GTK_RESPONSE_OK) {
-		GtkTreeIter iter = {0};
-		GSList* dirs;
-		dirs = gtk_file_chooser_get_files ((GtkFileChooser*) self->priv->dialog);
-		{
-			GSList* dir_collection;
-			GSList* dir_it;
-			dir_collection = dirs;
-			for (dir_it = dir_collection; dir_it != NULL; dir_it = dir_it->next) {
-				GFile* dir;
-				dir = _g_object_ref0 ((GFile*) dir_it->data);
-				{
-					char* path;
-					path = g_file_get_path (dir);
-					if (path == NULL) {
-						char* _tmp0_;
-						path = (_tmp0_ = g_file_get_uri (dir), _g_free0 (path), _tmp0_);
-					}
-					gtk_list_store_append (self->priv->liststore, &iter);
-					gtk_list_store_set (self->priv->liststore, &iter, 0, path, -1, -1);
-					_g_object_unref0 (dir);
-					_g_free0 (path);
-				}
-			}
-		}
-		__g_slist_free_g_object_unref0 (dirs);
-	}
-	gtk_widget_hide ((GtkWidget*) self->priv->dialog);
-}
-
-
-static gpointer _gtk_tree_path_copy0 (gpointer self) {
-	return self ? gtk_tree_path_copy (self) : NULL;
-}
-
-
-static void _g_list_free_gtk_tree_path_free (GList* self) {
-	g_list_foreach (self, (GFunc) gtk_tree_path_free, NULL);
-	g_list_free (self);
-}
-
-
-static void rygel_media_export_pref_section_on_remove_button_clicked (RygelMediaExportPrefSection* self, GtkButton* button) {
-	GtkTreeSelection* selection;
-	GList* rows;
-	GeeArrayList* row_refs;
-	g_return_if_fail (self != NULL);
-	g_return_if_fail (button != NULL);
-	selection = _g_object_ref0 (gtk_tree_view_get_selection (self->priv->treeview));
-	rows = gtk_tree_selection_get_selected_rows (selection, NULL);
-	row_refs = gee_array_list_new (GTK_TYPE_TREE_ROW_REFERENCE, (GBoxedCopyFunc) gtk_tree_row_reference_copy, gtk_tree_row_reference_free, g_direct_equal);
-	{
-		GList* row_collection;
-		GList* row_it;
-		row_collection = rows;
-		for (row_it = row_collection; row_it != NULL; row_it = row_it->next) {
-			GtkTreePath* row;
-			row = _gtk_tree_path_copy0 ((GtkTreePath*) row_it->data);
-			{
-				GtkTreeRowReference* _tmp0_;
-				gee_abstract_collection_add ((GeeAbstractCollection*) row_refs, _tmp0_ = gtk_tree_row_reference_new ((GtkTreeModel*) self->priv->liststore, row));
-				_gtk_tree_row_reference_free0 (_tmp0_);
-				_gtk_tree_path_free0 (row);
-			}
-		}
-	}
-	{
-		GeeIterator* _row_ref_it;
-		_row_ref_it = gee_abstract_collection_iterator ((GeeAbstractCollection*) row_refs);
-		while (TRUE) {
-			GtkTreeRowReference* row_ref;
-			GtkTreeIter iter = {0};
-			GtkTreePath* path;
-			if (!gee_iterator_next (_row_ref_it)) {
-				break;
-			}
-			row_ref = (GtkTreeRowReference*) gee_iterator_get (_row_ref_it);
-			path = gtk_tree_row_reference_get_path (row_ref);
-			gtk_tree_model_get_iter ((GtkTreeModel*) self->priv->liststore, &iter, path);
-			gtk_list_store_remove (self->priv->liststore, &iter);
-			_gtk_tree_row_reference_free0 (row_ref);
-			_gtk_tree_path_free0 (path);
-		}
-		_g_object_unref0 (_row_ref_it);
-	}
-	_g_object_unref0 (selection);
-	__g_list_free_gtk_tree_path_free0 (rows);
-	_g_object_unref0 (row_refs);
-}
-
-
-static void rygel_media_export_pref_section_on_clear_button_clicked (RygelMediaExportPrefSection* self, GtkButton* button) {
-	g_return_if_fail (self != NULL);
-	g_return_if_fail (button != NULL);
-	gtk_list_store_clear (self->priv->liststore);
-}
-
-
-static void rygel_media_export_pref_section_class_init (RygelMediaExportPrefSectionClass * klass) {
-	rygel_media_export_pref_section_parent_class = g_type_class_peek_parent (klass);
-	g_type_class_add_private (klass, sizeof (RygelMediaExportPrefSectionPrivate));
-	RYGEL_PREFERENCES_SECTION_CLASS (klass)->save = rygel_media_export_pref_section_real_save;
-	G_OBJECT_CLASS (klass)->finalize = rygel_media_export_pref_section_finalize;
-}
-
-
-static void rygel_media_export_pref_section_instance_init (RygelMediaExportPrefSection * self) {
-	self->priv = RYGEL_MEDIA_EXPORT_PREF_SECTION_GET_PRIVATE (self);
-}
-
-
-static void rygel_media_export_pref_section_finalize (GObject* obj) {
-	RygelMediaExportPrefSection * self;
-	self = RYGEL_MEDIA_EXPORT_PREF_SECTION (obj);
-	_g_object_unref0 (self->priv->treeview);
-	_g_object_unref0 (self->priv->liststore);
-	_g_object_unref0 (self->priv->dialog);
-	G_OBJECT_CLASS (rygel_media_export_pref_section_parent_class)->finalize (obj);
-}
-
-
-GType rygel_media_export_pref_section_get_type (void) {
-	static GType rygel_media_export_pref_section_type_id = 0;
-	if (rygel_media_export_pref_section_type_id == 0) {
-		static const GTypeInfo g_define_type_info = { sizeof (RygelMediaExportPrefSectionClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) rygel_media_export_pref_section_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (RygelMediaExportPrefSection), 0, (GInstanceInitFunc) rygel_media_export_pref_section_instance_init, NULL };
-		rygel_media_export_pref_section_type_id = g_type_register_static (RYGEL_TYPE_PLUGIN_PREF_SECTION, "RygelMediaExportPrefSection", &g_define_type_info, 0);
-	}
-	return rygel_media_export_pref_section_type_id;
-}
-
-
-
-
--- a/src/ui/rygel-plugin-pref-section.c
+++ /dev/null
@@ -1,340 +0,0 @@
-/* rygel-plugin-pref-section.c generated by valac, the Vala compiler
- * generated from rygel-plugin-pref-section.vala, do not modify */
-
-/*
- * Copyright (C) 2009 Nokia Corporation.
- *
- * Author: Zeeshan Ali (Khattak) <zeeshanak@gnome.org>
- *                               <zeeshan.ali@nokia.com>
- *
- * This file is part of Rygel.
- *
- * Rygel is free software; you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * Rygel is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this program; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
- */
-
-#include <glib.h>
-#include <glib-object.h>
-#include <rygel.h>
-#include <stdlib.h>
-#include <string.h>
-#include <gee.h>
-#include <gtk/gtk.h>
-
-
-#define RYGEL_TYPE_PREFERENCES_SECTION (rygel_preferences_section_get_type ())
-#define RYGEL_PREFERENCES_SECTION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_PREFERENCES_SECTION, RygelPreferencesSection))
-#define RYGEL_PREFERENCES_SECTION_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_PREFERENCES_SECTION, RygelPreferencesSectionClass))
-#define RYGEL_IS_PREFERENCES_SECTION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_PREFERENCES_SECTION))
-#define RYGEL_IS_PREFERENCES_SECTION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_PREFERENCES_SECTION))
-#define RYGEL_PREFERENCES_SECTION_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_PREFERENCES_SECTION, RygelPreferencesSectionClass))
-
-typedef struct _RygelPreferencesSection RygelPreferencesSection;
-typedef struct _RygelPreferencesSectionClass RygelPreferencesSectionClass;
-typedef struct _RygelPreferencesSectionPrivate RygelPreferencesSectionPrivate;
-
-#define RYGEL_TYPE_PLUGIN_PREF_SECTION (rygel_plugin_pref_section_get_type ())
-#define RYGEL_PLUGIN_PREF_SECTION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_PLUGIN_PREF_SECTION, RygelPluginPrefSection))
-#define RYGEL_PLUGIN_PREF_SECTION_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_PLUGIN_PREF_SECTION, RygelPluginPrefSectionClass))
-#define RYGEL_IS_PLUGIN_PREF_SECTION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_PLUGIN_PREF_SECTION))
-#define RYGEL_IS_PLUGIN_PREF_SECTION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_PLUGIN_PREF_SECTION))
-#define RYGEL_PLUGIN_PREF_SECTION_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_PLUGIN_PREF_SECTION, RygelPluginPrefSectionClass))
-
-typedef struct _RygelPluginPrefSection RygelPluginPrefSection;
-typedef struct _RygelPluginPrefSectionClass RygelPluginPrefSectionClass;
-typedef struct _RygelPluginPrefSectionPrivate RygelPluginPrefSectionPrivate;
-#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
-#define _g_free0(var) (var = (g_free (var), NULL))
-#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
-#define _g_regex_unref0(var) ((var == NULL) ? NULL : (var = (g_regex_unref (var), NULL)))
-
-struct _RygelPreferencesSection {
-	GObject parent_instance;
-	RygelPreferencesSectionPrivate * priv;
-	RygelUserConfig* config;
-	char* name;
-};
-
-struct _RygelPreferencesSectionClass {
-	GObjectClass parent_class;
-	void (*save) (RygelPreferencesSection* self);
-};
-
-struct _RygelPluginPrefSection {
-	RygelPreferencesSection parent_instance;
-	RygelPluginPrefSectionPrivate * priv;
-	GeeArrayList* widgets;
-};
-
-struct _RygelPluginPrefSectionClass {
-	RygelPreferencesSectionClass parent_class;
-};
-
-struct _RygelPluginPrefSectionPrivate {
-	GtkCheckButton* enabled_check;
-	GtkEntry* title_entry;
-};
-
-
-static gpointer rygel_plugin_pref_section_parent_class = NULL;
-
-GType rygel_preferences_section_get_type (void);
-GType rygel_plugin_pref_section_get_type (void);
-#define RYGEL_PLUGIN_PREF_SECTION_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), RYGEL_TYPE_PLUGIN_PREF_SECTION, RygelPluginPrefSectionPrivate))
-enum  {
-	RYGEL_PLUGIN_PREF_SECTION_DUMMY_PROPERTY
-};
-#define RYGEL_PLUGIN_PREF_SECTION_ENABLED_CHECK "-enabled-checkbutton"
-#define RYGEL_PLUGIN_PREF_SECTION_TITLE_LABEL "-title-label"
-#define RYGEL_PLUGIN_PREF_SECTION_TITLE_ENTRY "-title-entry"
-RygelPreferencesSection* rygel_preferences_section_construct (GType object_type, RygelUserConfig* config, const char* name);
-static void rygel_plugin_pref_section_on_enabled_check_toggled (RygelPluginPrefSection* self, GtkCheckButton* enabled_check);
-static void _rygel_plugin_pref_section_on_enabled_check_toggled_gtk_toggle_button_toggled (GtkCheckButton* _sender, gpointer self);
-RygelPluginPrefSection* rygel_plugin_pref_section_new (GtkBuilder* builder, RygelUserConfig* config, const char* name);
-RygelPluginPrefSection* rygel_plugin_pref_section_construct (GType object_type, GtkBuilder* builder, RygelUserConfig* config, const char* name);
-static void rygel_plugin_pref_section_real_save (RygelPreferencesSection* base);
-void rygel_plugin_pref_section_reset_widgets_sensitivity (RygelPluginPrefSection* self);
-static void rygel_plugin_pref_section_finalize (GObject* obj);
-
-
-
-static gpointer _g_object_ref0 (gpointer self) {
-	return self ? g_object_ref (self) : NULL;
-}
-
-
-static char* string_replace (const char* self, const char* old, const char* replacement) {
-	char* result;
-	GError * _inner_error_;
-	g_return_val_if_fail (self != NULL, NULL);
-	g_return_val_if_fail (old != NULL, NULL);
-	g_return_val_if_fail (replacement != NULL, NULL);
-	_inner_error_ = NULL;
-	{
-		char* _tmp0_;
-		GRegex* _tmp1_;
-		GRegex* regex;
-		char* _tmp2_;
-		regex = (_tmp1_ = g_regex_new (_tmp0_ = g_regex_escape_string (old, -1), 0, 0, &_inner_error_), _g_free0 (_tmp0_), _tmp1_);
-		if (_inner_error_ != NULL) {
-			if (_inner_error_->domain == G_REGEX_ERROR) {
-				goto __catch9_g_regex_error;
-			}
-			goto __finally9;
-		}
-		_tmp2_ = g_regex_replace_literal (regex, self, (glong) (-1), 0, replacement, 0, &_inner_error_);
-		if (_inner_error_ != NULL) {
-			_g_regex_unref0 (regex);
-			if (_inner_error_->domain == G_REGEX_ERROR) {
-				goto __catch9_g_regex_error;
-			}
-			goto __finally9;
-		}
-		result = _tmp2_;
-		_g_regex_unref0 (regex);
-		return result;
-	}
-	goto __finally9;
-	__catch9_g_regex_error:
-	{
-		GError * e;
-		e = _inner_error_;
-		_inner_error_ = NULL;
-		{
-			g_assert_not_reached ();
-			_g_error_free0 (e);
-		}
-	}
-	__finally9:
-	if (_inner_error_ != NULL) {
-		g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
-		g_clear_error (&_inner_error_);
-		return NULL;
-	}
-}
-
-
-static void _rygel_plugin_pref_section_on_enabled_check_toggled_gtk_toggle_button_toggled (GtkCheckButton* _sender, gpointer self) {
-	rygel_plugin_pref_section_on_enabled_check_toggled (self, _sender);
-}
-
-
-RygelPluginPrefSection* rygel_plugin_pref_section_construct (GType object_type, GtkBuilder* builder, RygelUserConfig* config, const char* name) {
-	GError * _inner_error_;
-	RygelPluginPrefSection * self;
-	GeeArrayList* _tmp0_;
-	GtkCheckButton* _tmp3_;
-	char* _tmp2_;
-	char* _tmp1_;
-	GtkEntry* _tmp6_;
-	char* _tmp5_;
-	char* _tmp4_;
-	char* _tmp8_;
-	char* _tmp7_;
-	GtkLabel* _tmp9_;
-	GtkLabel* title_label;
-	gboolean _tmp10_;
-	char* title;
-	char* _tmp14_;
-	char* _tmp15_;
-	char* _tmp16_;
-	g_return_val_if_fail (builder != NULL, NULL);
-	g_return_val_if_fail (config != NULL, NULL);
-	g_return_val_if_fail (name != NULL, NULL);
-	_inner_error_ = NULL;
-	self = (RygelPluginPrefSection*) rygel_preferences_section_construct (object_type, config, name);
-	self->widgets = (_tmp0_ = gee_array_list_new (GTK_TYPE_WIDGET, (GBoxedCopyFunc) g_object_ref, g_object_unref, g_direct_equal), _g_object_unref0 (self->widgets), _tmp0_);
-	self->priv->enabled_check = (_tmp3_ = _g_object_ref0 (GTK_CHECK_BUTTON (gtk_builder_get_object (builder, _tmp2_ = g_strconcat (_tmp1_ = g_utf8_strdown (name, -1), RYGEL_PLUGIN_PREF_SECTION_ENABLED_CHECK, NULL)))), _g_object_unref0 (self->priv->enabled_check), _tmp3_);
-	_g_free0 (_tmp2_);
-	_g_free0 (_tmp1_);
-	g_assert (self->priv->enabled_check != NULL);
-	self->priv->title_entry = (_tmp6_ = _g_object_ref0 (GTK_ENTRY (gtk_builder_get_object (builder, _tmp5_ = g_strconcat (_tmp4_ = g_utf8_strdown (name, -1), RYGEL_PLUGIN_PREF_SECTION_TITLE_ENTRY, NULL)))), _g_object_unref0 (self->priv->title_entry), _tmp6_);
-	_g_free0 (_tmp5_);
-	_g_free0 (_tmp4_);
-	g_assert (self->priv->title_entry != NULL);
-	title_label = (_tmp9_ = _g_object_ref0 (GTK_LABEL (gtk_builder_get_object (builder, _tmp8_ = g_strconcat (_tmp7_ = g_utf8_strdown (name, -1), RYGEL_PLUGIN_PREF_SECTION_TITLE_LABEL, NULL)))), _g_free0 (_tmp8_), _g_free0 (_tmp7_), _tmp9_);
-	g_assert (title_label != NULL);
-	gee_abstract_collection_add ((GeeAbstractCollection*) self->widgets, (GtkWidget*) title_label);
-	_tmp10_ = rygel_configuration_get_enabled ((RygelConfiguration*) config, name, &_inner_error_);
-	if (_inner_error_ != NULL) {
-		_g_object_unref0 (title_label);
-		g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
-		g_clear_error (&_inner_error_);
-		return NULL;
-	}
-	gtk_toggle_button_set_active ((GtkToggleButton*) self->priv->enabled_check, _tmp10_);
-	title = NULL;
-	{
-		char* _tmp11_;
-		char* _tmp12_;
-		_tmp11_ = rygel_configuration_get_title ((RygelConfiguration*) config, name, &_inner_error_);
-		if (_inner_error_ != NULL) {
-			goto __catch8_g_error;
-			goto __finally8;
-		}
-		title = (_tmp12_ = _tmp11_, _g_free0 (title), _tmp12_);
-	}
-	goto __finally8;
-	__catch8_g_error:
-	{
-		GError * err;
-		err = _inner_error_;
-		_inner_error_ = NULL;
-		{
-			char* _tmp13_;
-			title = (_tmp13_ = g_strdup (name), _g_free0 (title), _tmp13_);
-			_g_error_free0 (err);
-		}
-	}
-	__finally8:
-	if (_inner_error_ != NULL) {
-		_g_object_unref0 (title_label);
-		_g_free0 (title);
-		g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
-		g_clear_error (&_inner_error_);
-		return NULL;
-	}
-	title = (_tmp14_ = string_replace (title, "@REALNAME@", "%n"), _g_free0 (title), _tmp14_);
-	title = (_tmp15_ = string_replace (title, "@USERNAME@", "%u"), _g_free0 (title), _tmp15_);
-	title = (_tmp16_ = string_replace (title, "@HOSTNAME@", "%h"), _g_free0 (title), _tmp16_);
-	gtk_entry_set_text (self->priv->title_entry, title);
-	g_signal_connect_object ((GtkToggleButton*) self->priv->enabled_check, "toggled", (GCallback) _rygel_plugin_pref_section_on_enabled_check_toggled_gtk_toggle_button_toggled, self, 0);
-	_g_object_unref0 (title_label);
-	_g_free0 (title);
-	return self;
-}
-
-
-RygelPluginPrefSection* rygel_plugin_pref_section_new (GtkBuilder* builder, RygelUserConfig* config, const char* name) {
-	return rygel_plugin_pref_section_construct (RYGEL_TYPE_PLUGIN_PREF_SECTION, builder, config, name);
-}
-
-
-static void rygel_plugin_pref_section_real_save (RygelPreferencesSection* base) {
-	RygelPluginPrefSection * self;
-	char* title;
-	char* _tmp0_;
-	char* _tmp1_;
-	self = (RygelPluginPrefSection*) base;
-	rygel_user_config_set_bool (((RygelPreferencesSection*) self)->config, ((RygelPreferencesSection*) self)->name, RYGEL_USER_CONFIG_ENABLED_KEY, gtk_toggle_button_get_active ((GtkToggleButton*) self->priv->enabled_check));
-	title = string_replace (gtk_entry_get_text (self->priv->title_entry), "%n", "@REALNAME@");
-	title = (_tmp0_ = string_replace (title, "%u", "@USERNAME@"), _g_free0 (title), _tmp0_);
-	title = (_tmp1_ = string_replace (title, "%h", "@HOSTNAME@"), _g_free0 (title), _tmp1_);
-	rygel_user_config_set_string (((RygelPreferencesSection*) self)->config, ((RygelPreferencesSection*) self)->name, RYGEL_USER_CONFIG_TITLE_KEY, title);
-	_g_free0 (title);
-}
-
-
-void rygel_plugin_pref_section_reset_widgets_sensitivity (RygelPluginPrefSection* self) {
-	g_return_if_fail (self != NULL);
-	g_object_set ((GtkWidget*) self->priv->title_entry, "sensitive", gtk_toggle_button_get_active ((GtkToggleButton*) self->priv->enabled_check), NULL);
-	{
-		GeeIterator* _widget_it;
-		_widget_it = gee_abstract_collection_iterator ((GeeAbstractCollection*) self->widgets);
-		while (TRUE) {
-			GtkWidget* widget;
-			if (!gee_iterator_next (_widget_it)) {
-				break;
-			}
-			widget = (GtkWidget*) gee_iterator_get (_widget_it);
-			g_object_set (widget, "sensitive", gtk_toggle_button_get_active ((GtkToggleButton*) self->priv->enabled_check), NULL);
-			_g_object_unref0 (widget);
-		}
-		_g_object_unref0 (_widget_it);
-	}
-}
-
-
-static void rygel_plugin_pref_section_on_enabled_check_toggled (RygelPluginPrefSection* self, GtkCheckButton* enabled_check) {
-	g_return_if_fail (self != NULL);
-	g_return_if_fail (enabled_check != NULL);
-	rygel_plugin_pref_section_reset_widgets_sensitivity (self);
-}
-
-
-static void rygel_plugin_pref_section_class_init (RygelPluginPrefSectionClass * klass) {
-	rygel_plugin_pref_section_parent_class = g_type_class_peek_parent (klass);
-	g_type_class_add_private (klass, sizeof (RygelPluginPrefSectionPrivate));
-	RYGEL_PREFERENCES_SECTION_CLASS (klass)->save = rygel_plugin_pref_section_real_save;
-	G_OBJECT_CLASS (klass)->finalize = rygel_plugin_pref_section_finalize;
-}
-
-
-static void rygel_plugin_pref_section_instance_init (RygelPluginPrefSection * self) {
-	self->priv = RYGEL_PLUGIN_PREF_SECTION_GET_PRIVATE (self);
-}
-
-
-static void rygel_plugin_pref_section_finalize (GObject* obj) {
-	RygelPluginPrefSection * self;
-	self = RYGEL_PLUGIN_PREF_SECTION (obj);
-	_g_object_unref0 (self->priv->enabled_check);
-	_g_object_unref0 (self->priv->title_entry);
-	_g_object_unref0 (self->widgets);
-	G_OBJECT_CLASS (rygel_plugin_pref_section_parent_class)->finalize (obj);
-}
-
-
-GType rygel_plugin_pref_section_get_type (void) {
-	static GType rygel_plugin_pref_section_type_id = 0;
-	if (rygel_plugin_pref_section_type_id == 0) {
-		static const GTypeInfo g_define_type_info = { sizeof (RygelPluginPrefSectionClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) rygel_plugin_pref_section_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (RygelPluginPrefSection), 0, (GInstanceInitFunc) rygel_plugin_pref_section_instance_init, NULL };
-		rygel_plugin_pref_section_type_id = g_type_register_static (RYGEL_TYPE_PREFERENCES_SECTION, "RygelPluginPrefSection", &g_define_type_info, 0);
-	}
-	return rygel_plugin_pref_section_type_id;
-}
-
-
-
-
--- a/src/ui/rygel-preferences-dialog.c
+++ /dev/null
@@ -1,298 +0,0 @@
-/* rygel-preferences-dialog.c generated by valac, the Vala compiler
- * generated from rygel-preferences-dialog.vala, do not modify */
-
-/*
- * Copyright (C) 2009 Nokia Corporation.
- *
- * Author: Zeeshan Ali (Khattak) <zeeshanak@gnome.org>
- *                               <zeeshan.ali@nokia.com>
- *
- * This file is part of Rygel.
- *
- * Rygel is free software; you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * Rygel is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this program; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
- */
-
-#include <glib.h>
-#include <glib-object.h>
-#include <rygel.h>
-#include <gtk/gtk.h>
-#include <gee.h>
-#include <stdlib.h>
-#include <string.h>
-
-
-#define RYGEL_TYPE_PREFERENCES_DIALOG (rygel_preferences_dialog_get_type ())
-#define RYGEL_PREFERENCES_DIALOG(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_PREFERENCES_DIALOG, RygelPreferencesDialog))
-#define RYGEL_PREFERENCES_DIALOG_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_PREFERENCES_DIALOG, RygelPreferencesDialogClass))
-#define RYGEL_IS_PREFERENCES_DIALOG(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_PREFERENCES_DIALOG))
-#define RYGEL_IS_PREFERENCES_DIALOG_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_PREFERENCES_DIALOG))
-#define RYGEL_PREFERENCES_DIALOG_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_PREFERENCES_DIALOG, RygelPreferencesDialogClass))
-
-typedef struct _RygelPreferencesDialog RygelPreferencesDialog;
-typedef struct _RygelPreferencesDialogClass RygelPreferencesDialogClass;
-typedef struct _RygelPreferencesDialogPrivate RygelPreferencesDialogPrivate;
-
-#define RYGEL_TYPE_PREFERENCES_SECTION (rygel_preferences_section_get_type ())
-#define RYGEL_PREFERENCES_SECTION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_PREFERENCES_SECTION, RygelPreferencesSection))
-#define RYGEL_PREFERENCES_SECTION_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_PREFERENCES_SECTION, RygelPreferencesSectionClass))
-#define RYGEL_IS_PREFERENCES_SECTION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_PREFERENCES_SECTION))
-#define RYGEL_IS_PREFERENCES_SECTION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_PREFERENCES_SECTION))
-#define RYGEL_PREFERENCES_SECTION_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_PREFERENCES_SECTION, RygelPreferencesSectionClass))
-
-typedef struct _RygelPreferencesSection RygelPreferencesSection;
-typedef struct _RygelPreferencesSectionClass RygelPreferencesSectionClass;
-#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
-
-#define RYGEL_TYPE_GENERAL_PREF_SECTION (rygel_general_pref_section_get_type ())
-#define RYGEL_GENERAL_PREF_SECTION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_GENERAL_PREF_SECTION, RygelGeneralPrefSection))
-#define RYGEL_GENERAL_PREF_SECTION_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_GENERAL_PREF_SECTION, RygelGeneralPrefSectionClass))
-#define RYGEL_IS_GENERAL_PREF_SECTION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_GENERAL_PREF_SECTION))
-#define RYGEL_IS_GENERAL_PREF_SECTION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_GENERAL_PREF_SECTION))
-#define RYGEL_GENERAL_PREF_SECTION_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_GENERAL_PREF_SECTION, RygelGeneralPrefSectionClass))
-
-typedef struct _RygelGeneralPrefSection RygelGeneralPrefSection;
-typedef struct _RygelGeneralPrefSectionClass RygelGeneralPrefSectionClass;
-
-#define RYGEL_TYPE_PLUGIN_PREF_SECTION (rygel_plugin_pref_section_get_type ())
-#define RYGEL_PLUGIN_PREF_SECTION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_PLUGIN_PREF_SECTION, RygelPluginPrefSection))
-#define RYGEL_PLUGIN_PREF_SECTION_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_PLUGIN_PREF_SECTION, RygelPluginPrefSectionClass))
-#define RYGEL_IS_PLUGIN_PREF_SECTION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_PLUGIN_PREF_SECTION))
-#define RYGEL_IS_PLUGIN_PREF_SECTION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_PLUGIN_PREF_SECTION))
-#define RYGEL_PLUGIN_PREF_SECTION_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_PLUGIN_PREF_SECTION, RygelPluginPrefSectionClass))
-
-typedef struct _RygelPluginPrefSection RygelPluginPrefSection;
-typedef struct _RygelPluginPrefSectionClass RygelPluginPrefSectionClass;
-
-#define RYGEL_TYPE_TRACKER_PREF_SECTION (rygel_tracker_pref_section_get_type ())
-#define RYGEL_TRACKER_PREF_SECTION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_TRACKER_PREF_SECTION, RygelTrackerPrefSection))
-#define RYGEL_TRACKER_PREF_SECTION_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_TRACKER_PREF_SECTION, RygelTrackerPrefSectionClass))
-#define RYGEL_IS_TRACKER_PREF_SECTION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_TRACKER_PREF_SECTION))
-#define RYGEL_IS_TRACKER_PREF_SECTION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_TRACKER_PREF_SECTION))
-#define RYGEL_TRACKER_PREF_SECTION_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_TRACKER_PREF_SECTION, RygelTrackerPrefSectionClass))
-
-typedef struct _RygelTrackerPrefSection RygelTrackerPrefSection;
-typedef struct _RygelTrackerPrefSectionClass RygelTrackerPrefSectionClass;
-
-#define RYGEL_TYPE_MEDIA_EXPORT_PREF_SECTION (rygel_media_export_pref_section_get_type ())
-#define RYGEL_MEDIA_EXPORT_PREF_SECTION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_MEDIA_EXPORT_PREF_SECTION, RygelMediaExportPrefSection))
-#define RYGEL_MEDIA_EXPORT_PREF_SECTION_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_MEDIA_EXPORT_PREF_SECTION, RygelMediaExportPrefSectionClass))
-#define RYGEL_IS_MEDIA_EXPORT_PREF_SECTION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_MEDIA_EXPORT_PREF_SECTION))
-#define RYGEL_IS_MEDIA_EXPORT_PREF_SECTION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_MEDIA_EXPORT_PREF_SECTION))
-#define RYGEL_MEDIA_EXPORT_PREF_SECTION_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_MEDIA_EXPORT_PREF_SECTION, RygelMediaExportPrefSectionClass))
-
-typedef struct _RygelMediaExportPrefSection RygelMediaExportPrefSection;
-typedef struct _RygelMediaExportPrefSectionClass RygelMediaExportPrefSectionClass;
-#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
-
-struct _RygelPreferencesDialog {
-	GObject parent_instance;
-	RygelPreferencesDialogPrivate * priv;
-};
-
-struct _RygelPreferencesDialogClass {
-	GObjectClass parent_class;
-};
-
-struct _RygelPreferencesDialogPrivate {
-	RygelUserConfig* config;
-	GtkBuilder* builder;
-	GtkDialog* dialog;
-	GeeArrayList* sections;
-};
-
-
-static gpointer rygel_preferences_dialog_parent_class = NULL;
-
-GType rygel_preferences_dialog_get_type (void);
-GType rygel_preferences_section_get_type (void);
-#define RYGEL_PREFERENCES_DIALOG_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), RYGEL_TYPE_PREFERENCES_DIALOG, RygelPreferencesDialogPrivate))
-enum  {
-	RYGEL_PREFERENCES_DIALOG_DUMMY_PROPERTY
-};
-#define RYGEL_PREFERENCES_DIALOG_UI_FILE DATA_DIR "/rygel-preferences.ui"
-#define RYGEL_PREFERENCES_DIALOG_DIALOG "preferences-dialog"
-RygelGeneralPrefSection* rygel_general_pref_section_new (GtkBuilder* builder, RygelUserConfig* config, GError** error);
-RygelGeneralPrefSection* rygel_general_pref_section_construct (GType object_type, GtkBuilder* builder, RygelUserConfig* config, GError** error);
-GType rygel_general_pref_section_get_type (void);
-RygelTrackerPrefSection* rygel_tracker_pref_section_new (GtkBuilder* builder, RygelUserConfig* config);
-RygelTrackerPrefSection* rygel_tracker_pref_section_construct (GType object_type, GtkBuilder* builder, RygelUserConfig* config);
-GType rygel_plugin_pref_section_get_type (void);
-GType rygel_tracker_pref_section_get_type (void);
-RygelMediaExportPrefSection* rygel_media_export_pref_section_new (GtkBuilder* builder, RygelUserConfig* config);
-RygelMediaExportPrefSection* rygel_media_export_pref_section_construct (GType object_type, GtkBuilder* builder, RygelUserConfig* config);
-GType rygel_media_export_pref_section_get_type (void);
-RygelPreferencesDialog* rygel_preferences_dialog_new (GError** error);
-RygelPreferencesDialog* rygel_preferences_dialog_construct (GType object_type, GError** error);
-void rygel_preferences_section_save (RygelPreferencesSection* self);
-void rygel_preferences_dialog_run (RygelPreferencesDialog* self);
-gint rygel_preferences_dialog_main (char** args, int args_length1);
-static void rygel_preferences_dialog_finalize (GObject* obj);
-
-
-
-static gpointer _g_object_ref0 (gpointer self) {
-	return self ? g_object_ref (self) : NULL;
-}
-
-
-RygelPreferencesDialog* rygel_preferences_dialog_construct (GType object_type, GError** error) {
-	GError * _inner_error_;
-	RygelPreferencesDialog * self;
-	RygelUserConfig* _tmp0_;
-	RygelUserConfig* _tmp1_;
-	GtkBuilder* _tmp2_;
-	GtkDialog* _tmp3_;
-	GeeArrayList* _tmp4_;
-	RygelGeneralPrefSection* _tmp5_;
-	RygelGeneralPrefSection* _tmp6_;
-	RygelTrackerPrefSection* _tmp7_;
-	RygelMediaExportPrefSection* _tmp8_;
-	_inner_error_ = NULL;
-	self = (RygelPreferencesDialog*) g_object_new (object_type, NULL);
-	_tmp0_ = rygel_user_config_new (FALSE, &_inner_error_);
-	if (_inner_error_ != NULL) {
-		g_propagate_error (error, _inner_error_);
-		return;
-	}
-	self->priv->config = (_tmp1_ = _tmp0_, _g_object_unref0 (self->priv->config), _tmp1_);
-	self->priv->builder = (_tmp2_ = gtk_builder_new (), _g_object_unref0 (self->priv->builder), _tmp2_);
-	gtk_builder_add_from_file (self->priv->builder, RYGEL_PREFERENCES_DIALOG_UI_FILE, &_inner_error_);
-	if (_inner_error_ != NULL) {
-		g_propagate_error (error, _inner_error_);
-		return;
-	}
-	self->priv->dialog = (_tmp3_ = _g_object_ref0 (GTK_DIALOG (gtk_builder_get_object (self->priv->builder, RYGEL_PREFERENCES_DIALOG_DIALOG))), _g_object_unref0 (self->priv->dialog), _tmp3_);
-	g_assert (self->priv->dialog != NULL);
-	self->priv->sections = (_tmp4_ = gee_array_list_new (RYGEL_TYPE_PREFERENCES_SECTION, (GBoxedCopyFunc) g_object_ref, g_object_unref, g_direct_equal), _g_object_unref0 (self->priv->sections), _tmp4_);
-	_tmp5_ = rygel_general_pref_section_new (self->priv->builder, self->priv->config, &_inner_error_);
-	if (_inner_error_ != NULL) {
-		g_propagate_error (error, _inner_error_);
-		return;
-	}
-	gee_abstract_collection_add ((GeeAbstractCollection*) self->priv->sections, (RygelPreferencesSection*) (_tmp6_ = _tmp5_));
-	_g_object_unref0 (_tmp6_);
-	gee_abstract_collection_add ((GeeAbstractCollection*) self->priv->sections, (RygelPreferencesSection*) (_tmp7_ = rygel_tracker_pref_section_new (self->priv->builder, self->priv->config)));
-	_g_object_unref0 (_tmp7_);
-	gee_abstract_collection_add ((GeeAbstractCollection*) self->priv->sections, (RygelPreferencesSection*) (_tmp8_ = rygel_media_export_pref_section_new (self->priv->builder, self->priv->config)));
-	_g_object_unref0 (_tmp8_);
-	return self;
-}
-
-
-RygelPreferencesDialog* rygel_preferences_dialog_new (GError** error) {
-	return rygel_preferences_dialog_construct (RYGEL_TYPE_PREFERENCES_DIALOG, error);
-}
-
-
-void rygel_preferences_dialog_run (RygelPreferencesDialog* self) {
-	g_return_if_fail (self != NULL);
-	gtk_dialog_run (self->priv->dialog);
-	{
-		GeeIterator* _section_it;
-		_section_it = gee_abstract_collection_iterator ((GeeAbstractCollection*) self->priv->sections);
-		while (TRUE) {
-			RygelPreferencesSection* section;
-			if (!gee_iterator_next (_section_it)) {
-				break;
-			}
-			section = (RygelPreferencesSection*) gee_iterator_get (_section_it);
-			rygel_preferences_section_save (section);
-			_g_object_unref0 (section);
-		}
-		_g_object_unref0 (_section_it);
-	}
-	rygel_user_config_save (self->priv->config);
-}
-
-
-gint rygel_preferences_dialog_main (char** args, int args_length1) {
-	gint result;
-	GError * _inner_error_;
-	_inner_error_ = NULL;
-	gtk_init (&args_length1, &args);
-	{
-		RygelPreferencesDialog* dialog;
-		dialog = rygel_preferences_dialog_new (&_inner_error_);
-		if (_inner_error_ != NULL) {
-			goto __catch0_g_error;
-			goto __finally0;
-		}
-		rygel_preferences_dialog_run (dialog);
-		_g_object_unref0 (dialog);
-	}
-	goto __finally0;
-	__catch0_g_error:
-	{
-		GError * err;
-		err = _inner_error_;
-		_inner_error_ = NULL;
-		{
-			g_error ("rygel-preferences-dialog.vala:70: Failed to create preferences dialog: %s\n", err->message);
-			_g_error_free0 (err);
-		}
-	}
-	__finally0:
-	if (_inner_error_ != NULL) {
-		g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
-		g_clear_error (&_inner_error_);
-		return 0;
-	}
-	result = 0;
-	return result;
-}
-
-
-int main (int argc, char ** argv) {
-	g_thread_init (NULL);
-	g_type_init ();
-	return rygel_preferences_dialog_main (argv, argc);
-}
-
-
-static void rygel_preferences_dialog_class_init (RygelPreferencesDialogClass * klass) {
-	rygel_preferences_dialog_parent_class = g_type_class_peek_parent (klass);
-	g_type_class_add_private (klass, sizeof (RygelPreferencesDialogPrivate));
-	G_OBJECT_CLASS (klass)->finalize = rygel_preferences_dialog_finalize;
-}
-
-
-static void rygel_preferences_dialog_instance_init (RygelPreferencesDialog * self) {
-	self->priv = RYGEL_PREFERENCES_DIALOG_GET_PRIVATE (self);
-}
-
-
-static void rygel_preferences_dialog_finalize (GObject* obj) {
-	RygelPreferencesDialog * self;
-	self = RYGEL_PREFERENCES_DIALOG (obj);
-	_g_object_unref0 (self->priv->config);
-	_g_object_unref0 (self->priv->builder);
-	_g_object_unref0 (self->priv->dialog);
-	_g_object_unref0 (self->priv->sections);
-	G_OBJECT_CLASS (rygel_preferences_dialog_parent_class)->finalize (obj);
-}
-
-
-GType rygel_preferences_dialog_get_type (void) {
-	static GType rygel_preferences_dialog_type_id = 0;
-	if (rygel_preferences_dialog_type_id == 0) {
-		static const GTypeInfo g_define_type_info = { sizeof (RygelPreferencesDialogClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) rygel_preferences_dialog_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (RygelPreferencesDialog), 0, (GInstanceInitFunc) rygel_preferences_dialog_instance_init, NULL };
-		rygel_preferences_dialog_type_id = g_type_register_static (G_TYPE_OBJECT, "RygelPreferencesDialog", &g_define_type_info, 0);
-	}
-	return rygel_preferences_dialog_type_id;
-}
-
-
-
-
--- a/src/ui/rygel-preferences-section.c
+++ /dev/null
@@ -1,134 +0,0 @@
-/* rygel-preferences-section.c generated by valac, the Vala compiler
- * generated from rygel-preferences-section.vala, do not modify */
-
-/*
- * Copyright (C) 2009 Nokia Corporation.
- *
- * Author: Zeeshan Ali (Khattak) <zeeshanak@gnome.org>
- *                               <zeeshan.ali@nokia.com>
- *
- * This file is part of Rygel.
- *
- * Rygel is free software; you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * Rygel is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this program; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
- */
-
-#include <glib.h>
-#include <glib-object.h>
-#include <rygel.h>
-#include <stdlib.h>
-#include <string.h>
-
-
-#define RYGEL_TYPE_PREFERENCES_SECTION (rygel_preferences_section_get_type ())
-#define RYGEL_PREFERENCES_SECTION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_PREFERENCES_SECTION, RygelPreferencesSection))
-#define RYGEL_PREFERENCES_SECTION_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_PREFERENCES_SECTION, RygelPreferencesSectionClass))
-#define RYGEL_IS_PREFERENCES_SECTION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_PREFERENCES_SECTION))
-#define RYGEL_IS_PREFERENCES_SECTION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_PREFERENCES_SECTION))
-#define RYGEL_PREFERENCES_SECTION_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_PREFERENCES_SECTION, RygelPreferencesSectionClass))
-
-typedef struct _RygelPreferencesSection RygelPreferencesSection;
-typedef struct _RygelPreferencesSectionClass RygelPreferencesSectionClass;
-typedef struct _RygelPreferencesSectionPrivate RygelPreferencesSectionPrivate;
-#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
-#define _g_free0(var) (var = (g_free (var), NULL))
-
-struct _RygelPreferencesSection {
-	GObject parent_instance;
-	RygelPreferencesSectionPrivate * priv;
-	RygelUserConfig* config;
-	char* name;
-};
-
-struct _RygelPreferencesSectionClass {
-	GObjectClass parent_class;
-	void (*save) (RygelPreferencesSection* self);
-};
-
-
-static gpointer rygel_preferences_section_parent_class = NULL;
-
-GType rygel_preferences_section_get_type (void);
-enum  {
-	RYGEL_PREFERENCES_SECTION_DUMMY_PROPERTY
-};
-RygelPreferencesSection* rygel_preferences_section_construct (GType object_type, RygelUserConfig* config, const char* name);
-void rygel_preferences_section_save (RygelPreferencesSection* self);
-static void rygel_preferences_section_real_save (RygelPreferencesSection* self);
-static void rygel_preferences_section_finalize (GObject* obj);
-
-
-
-static gpointer _g_object_ref0 (gpointer self) {
-	return self ? g_object_ref (self) : NULL;
-}
-
-
-RygelPreferencesSection* rygel_preferences_section_construct (GType object_type, RygelUserConfig* config, const char* name) {
-	RygelPreferencesSection * self;
-	char* _tmp0_;
-	RygelUserConfig* _tmp1_;
-	g_return_val_if_fail (config != NULL, NULL);
-	g_return_val_if_fail (name != NULL, NULL);
-	self = (RygelPreferencesSection*) g_object_new (object_type, NULL);
-	self->name = (_tmp0_ = g_strdup (name), _g_free0 (self->name), _tmp0_);
-	self->config = (_tmp1_ = _g_object_ref0 (config), _g_object_unref0 (self->config), _tmp1_);
-	return self;
-}
-
-
-static void rygel_preferences_section_real_save (RygelPreferencesSection* self) {
-	g_return_if_fail (self != NULL);
-	g_critical ("Type `%s' does not implement abstract method `rygel_preferences_section_save'", g_type_name (G_TYPE_FROM_INSTANCE (self)));
-	return;
-}
-
-
-void rygel_preferences_section_save (RygelPreferencesSection* self) {
-	RYGEL_PREFERENCES_SECTION_GET_CLASS (self)->save (self);
-}
-
-
-static void rygel_preferences_section_class_init (RygelPreferencesSectionClass * klass) {
-	rygel_preferences_section_parent_class = g_type_class_peek_parent (klass);
-	RYGEL_PREFERENCES_SECTION_CLASS (klass)->save = rygel_preferences_section_real_save;
-	G_OBJECT_CLASS (klass)->finalize = rygel_preferences_section_finalize;
-}
-
-
-static void rygel_preferences_section_instance_init (RygelPreferencesSection * self) {
-}
-
-
-static void rygel_preferences_section_finalize (GObject* obj) {
-	RygelPreferencesSection * self;
-	self = RYGEL_PREFERENCES_SECTION (obj);
-	_g_object_unref0 (self->config);
-	_g_free0 (self->name);
-	G_OBJECT_CLASS (rygel_preferences_section_parent_class)->finalize (obj);
-}
-
-
-GType rygel_preferences_section_get_type (void) {
-	static GType rygel_preferences_section_type_id = 0;
-	if (rygel_preferences_section_type_id == 0) {
-		static const GTypeInfo g_define_type_info = { sizeof (RygelPreferencesSectionClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) rygel_preferences_section_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (RygelPreferencesSection), 0, (GInstanceInitFunc) rygel_preferences_section_instance_init, NULL };
-		rygel_preferences_section_type_id = g_type_register_static (G_TYPE_OBJECT, "RygelPreferencesSection", &g_define_type_info, G_TYPE_FLAG_ABSTRACT);
-	}
-	return rygel_preferences_section_type_id;
-}
-
-
-
-
--- a/src/ui/rygel-tracker-pref-section.c
+++ /dev/null
@@ -1,257 +0,0 @@
-/* rygel-tracker-pref-section.c generated by valac, the Vala compiler
- * generated from rygel-tracker-pref-section.vala, do not modify */
-
-/*
- * Copyright (C) 2009 Nokia Corporation.
- *
- * Author: Zeeshan Ali (Khattak) <zeeshanak@gnome.org>
- *                               <zeeshan.ali@nokia.com>
- *
- * This file is part of Rygel.
- *
- * Rygel is free software; you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * Rygel is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this program; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
- */
-
-#include <glib.h>
-#include <glib-object.h>
-#include <rygel.h>
-#include <stdlib.h>
-#include <string.h>
-#include <gee.h>
-#include <gtk/gtk.h>
-
-
-#define RYGEL_TYPE_PREFERENCES_SECTION (rygel_preferences_section_get_type ())
-#define RYGEL_PREFERENCES_SECTION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_PREFERENCES_SECTION, RygelPreferencesSection))
-#define RYGEL_PREFERENCES_SECTION_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_PREFERENCES_SECTION, RygelPreferencesSectionClass))
-#define RYGEL_IS_PREFERENCES_SECTION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_PREFERENCES_SECTION))
-#define RYGEL_IS_PREFERENCES_SECTION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_PREFERENCES_SECTION))
-#define RYGEL_PREFERENCES_SECTION_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_PREFERENCES_SECTION, RygelPreferencesSectionClass))
-
-typedef struct _RygelPreferencesSection RygelPreferencesSection;
-typedef struct _RygelPreferencesSectionClass RygelPreferencesSectionClass;
-typedef struct _RygelPreferencesSectionPrivate RygelPreferencesSectionPrivate;
-
-#define RYGEL_TYPE_PLUGIN_PREF_SECTION (rygel_plugin_pref_section_get_type ())
-#define RYGEL_PLUGIN_PREF_SECTION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_PLUGIN_PREF_SECTION, RygelPluginPrefSection))
-#define RYGEL_PLUGIN_PREF_SECTION_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_PLUGIN_PREF_SECTION, RygelPluginPrefSectionClass))
-#define RYGEL_IS_PLUGIN_PREF_SECTION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_PLUGIN_PREF_SECTION))
-#define RYGEL_IS_PLUGIN_PREF_SECTION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_PLUGIN_PREF_SECTION))
-#define RYGEL_PLUGIN_PREF_SECTION_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_PLUGIN_PREF_SECTION, RygelPluginPrefSectionClass))
-
-typedef struct _RygelPluginPrefSection RygelPluginPrefSection;
-typedef struct _RygelPluginPrefSectionClass RygelPluginPrefSectionClass;
-typedef struct _RygelPluginPrefSectionPrivate RygelPluginPrefSectionPrivate;
-
-#define RYGEL_TYPE_TRACKER_PREF_SECTION (rygel_tracker_pref_section_get_type ())
-#define RYGEL_TRACKER_PREF_SECTION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_TRACKER_PREF_SECTION, RygelTrackerPrefSection))
-#define RYGEL_TRACKER_PREF_SECTION_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_TRACKER_PREF_SECTION, RygelTrackerPrefSectionClass))
-#define RYGEL_IS_TRACKER_PREF_SECTION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_TRACKER_PREF_SECTION))
-#define RYGEL_IS_TRACKER_PREF_SECTION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_TRACKER_PREF_SECTION))
-#define RYGEL_TRACKER_PREF_SECTION_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_TRACKER_PREF_SECTION, RygelTrackerPrefSectionClass))
-
-typedef struct _RygelTrackerPrefSection RygelTrackerPrefSection;
-typedef struct _RygelTrackerPrefSectionClass RygelTrackerPrefSectionClass;
-typedef struct _RygelTrackerPrefSectionPrivate RygelTrackerPrefSectionPrivate;
-#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
-#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
-
-struct _RygelPreferencesSection {
-	GObject parent_instance;
-	RygelPreferencesSectionPrivate * priv;
-	RygelUserConfig* config;
-	char* name;
-};
-
-struct _RygelPreferencesSectionClass {
-	GObjectClass parent_class;
-	void (*save) (RygelPreferencesSection* self);
-};
-
-struct _RygelPluginPrefSection {
-	RygelPreferencesSection parent_instance;
-	RygelPluginPrefSectionPrivate * priv;
-	GeeArrayList* widgets;
-};
-
-struct _RygelPluginPrefSectionClass {
-	RygelPreferencesSectionClass parent_class;
-};
-
-struct _RygelTrackerPrefSection {
-	RygelPluginPrefSection parent_instance;
-	RygelTrackerPrefSectionPrivate * priv;
-};
-
-struct _RygelTrackerPrefSectionClass {
-	RygelPluginPrefSectionClass parent_class;
-};
-
-struct _RygelTrackerPrefSectionPrivate {
-	GtkCheckButton* videos_check;
-	GtkCheckButton* music_check;
-	GtkCheckButton* pictures_check;
-};
-
-
-static gpointer rygel_tracker_pref_section_parent_class = NULL;
-
-GType rygel_preferences_section_get_type (void);
-GType rygel_plugin_pref_section_get_type (void);
-GType rygel_tracker_pref_section_get_type (void);
-#define RYGEL_TRACKER_PREF_SECTION_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), RYGEL_TYPE_TRACKER_PREF_SECTION, RygelTrackerPrefSectionPrivate))
-enum  {
-	RYGEL_TRACKER_PREF_SECTION_DUMMY_PROPERTY
-};
-#define RYGEL_TRACKER_PREF_SECTION_NAME "Tracker"
-#define RYGEL_TRACKER_PREF_SECTION_VIDEOS_KEY "share-videos"
-#define RYGEL_TRACKER_PREF_SECTION_MUSIC_KEY "share-music"
-#define RYGEL_TRACKER_PREF_SECTION_PICTURES_KEY "share-pictures"
-#define RYGEL_TRACKER_PREF_SECTION_TAG_KEY "share-tagged"
-#define RYGEL_TRACKER_PREF_SECTION_VIDEOS_CHECK RYGEL_TRACKER_PREF_SECTION_VIDEOS_KEY "-checkbutton"
-#define RYGEL_TRACKER_PREF_SECTION_MUSIC_CHECK RYGEL_TRACKER_PREF_SECTION_MUSIC_KEY "-checkbutton"
-#define RYGEL_TRACKER_PREF_SECTION_PICTURES_CHECK RYGEL_TRACKER_PREF_SECTION_PICTURES_KEY "-checkbutton"
-RygelPluginPrefSection* rygel_plugin_pref_section_new (GtkBuilder* builder, RygelUserConfig* config, const char* name);
-RygelPluginPrefSection* rygel_plugin_pref_section_construct (GType object_type, GtkBuilder* builder, RygelUserConfig* config, const char* name);
-void rygel_plugin_pref_section_reset_widgets_sensitivity (RygelPluginPrefSection* self);
-RygelTrackerPrefSection* rygel_tracker_pref_section_new (GtkBuilder* builder, RygelUserConfig* config);
-RygelTrackerPrefSection* rygel_tracker_pref_section_construct (GType object_type, GtkBuilder* builder, RygelUserConfig* config);
-void rygel_preferences_section_save (RygelPreferencesSection* self);
-static void rygel_tracker_pref_section_real_save (RygelPreferencesSection* base);
-static void rygel_tracker_pref_section_finalize (GObject* obj);
-
-
-
-static gpointer _g_object_ref0 (gpointer self) {
-	return self ? g_object_ref (self) : NULL;
-}
-
-
-RygelTrackerPrefSection* rygel_tracker_pref_section_construct (GType object_type, GtkBuilder* builder, RygelUserConfig* config) {
-	GError * _inner_error_;
-	RygelTrackerPrefSection * self;
-	GtkCheckButton* _tmp0_;
-	GtkCheckButton* _tmp1_;
-	GtkCheckButton* _tmp2_;
-	g_return_val_if_fail (builder != NULL, NULL);
-	g_return_val_if_fail (config != NULL, NULL);
-	_inner_error_ = NULL;
-	self = (RygelTrackerPrefSection*) rygel_plugin_pref_section_construct (object_type, builder, config, RYGEL_TRACKER_PREF_SECTION_NAME);
-	self->priv->videos_check = (_tmp0_ = _g_object_ref0 (GTK_CHECK_BUTTON (gtk_builder_get_object (builder, RYGEL_TRACKER_PREF_SECTION_VIDEOS_CHECK))), _g_object_unref0 (self->priv->videos_check), _tmp0_);
-	g_assert (self->priv->videos_check != NULL);
-	self->priv->music_check = (_tmp1_ = _g_object_ref0 (GTK_CHECK_BUTTON (gtk_builder_get_object (builder, RYGEL_TRACKER_PREF_SECTION_MUSIC_CHECK))), _g_object_unref0 (self->priv->music_check), _tmp1_);
-	g_assert (self->priv->music_check != NULL);
-	self->priv->pictures_check = (_tmp2_ = _g_object_ref0 (GTK_CHECK_BUTTON (gtk_builder_get_object (builder, RYGEL_TRACKER_PREF_SECTION_PICTURES_CHECK))), _g_object_unref0 (self->priv->pictures_check), _tmp2_);
-	g_assert (self->priv->pictures_check != NULL);
-	gee_abstract_collection_add ((GeeAbstractCollection*) ((RygelPluginPrefSection*) self)->widgets, (GtkWidget*) self->priv->videos_check);
-	gee_abstract_collection_add ((GeeAbstractCollection*) ((RygelPluginPrefSection*) self)->widgets, (GtkWidget*) self->priv->music_check);
-	gee_abstract_collection_add ((GeeAbstractCollection*) ((RygelPluginPrefSection*) self)->widgets, (GtkWidget*) self->priv->pictures_check);
-	gtk_toggle_button_set_active ((GtkToggleButton*) self->priv->videos_check, TRUE);
-	gtk_toggle_button_set_active ((GtkToggleButton*) self->priv->music_check, TRUE);
-	gtk_toggle_button_set_active ((GtkToggleButton*) self->priv->pictures_check, TRUE);
-	{
-		gboolean _tmp3_;
-		gboolean _tmp4_;
-		gboolean _tmp5_;
-		_tmp3_ = rygel_configuration_get_bool ((RygelConfiguration*) config, ((RygelPreferencesSection*) self)->name, RYGEL_TRACKER_PREF_SECTION_VIDEOS_KEY, &_inner_error_);
-		if (_inner_error_ != NULL) {
-			goto __catch11_g_error;
-			goto __finally11;
-		}
-		gtk_toggle_button_set_active ((GtkToggleButton*) self->priv->videos_check, _tmp3_);
-		_tmp4_ = rygel_configuration_get_bool ((RygelConfiguration*) config, ((RygelPreferencesSection*) self)->name, RYGEL_TRACKER_PREF_SECTION_MUSIC_KEY, &_inner_error_);
-		if (_inner_error_ != NULL) {
-			goto __catch11_g_error;
-			goto __finally11;
-		}
-		gtk_toggle_button_set_active ((GtkToggleButton*) self->priv->music_check, _tmp4_);
-		_tmp5_ = rygel_configuration_get_bool ((RygelConfiguration*) config, ((RygelPreferencesSection*) self)->name, RYGEL_TRACKER_PREF_SECTION_PICTURES_KEY, &_inner_error_);
-		if (_inner_error_ != NULL) {
-			goto __catch11_g_error;
-			goto __finally11;
-		}
-		gtk_toggle_button_set_active ((GtkToggleButton*) self->priv->pictures_check, _tmp5_);
-	}
-	goto __finally11;
-	__catch11_g_error:
-	{
-		GError * err;
-		err = _inner_error_;
-		_inner_error_ = NULL;
-		{
-			_g_error_free0 (err);
-		}
-	}
-	__finally11:
-	if (_inner_error_ != NULL) {
-		g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
-		g_clear_error (&_inner_error_);
-		return NULL;
-	}
-	rygel_plugin_pref_section_reset_widgets_sensitivity ((RygelPluginPrefSection*) self);
-	return self;
-}
-
-
-RygelTrackerPrefSection* rygel_tracker_pref_section_new (GtkBuilder* builder, RygelUserConfig* config) {
-	return rygel_tracker_pref_section_construct (RYGEL_TYPE_TRACKER_PREF_SECTION, builder, config);
-}
-
-
-static void rygel_tracker_pref_section_real_save (RygelPreferencesSection* base) {
-	RygelTrackerPrefSection * self;
-	self = (RygelTrackerPrefSection*) base;
-	RYGEL_PREFERENCES_SECTION_CLASS (rygel_tracker_pref_section_parent_class)->save ((RygelPreferencesSection*) RYGEL_PLUGIN_PREF_SECTION (self));
-	rygel_user_config_set_bool (((RygelPreferencesSection*) self)->config, ((RygelPreferencesSection*) self)->name, RYGEL_TRACKER_PREF_SECTION_VIDEOS_KEY, gtk_toggle_button_get_active ((GtkToggleButton*) self->priv->videos_check));
-	rygel_user_config_set_bool (((RygelPreferencesSection*) self)->config, ((RygelPreferencesSection*) self)->name, RYGEL_TRACKER_PREF_SECTION_MUSIC_KEY, gtk_toggle_button_get_active ((GtkToggleButton*) self->priv->music_check));
-	rygel_user_config_set_bool (((RygelPreferencesSection*) self)->config, ((RygelPreferencesSection*) self)->name, RYGEL_TRACKER_PREF_SECTION_PICTURES_KEY, gtk_toggle_button_get_active ((GtkToggleButton*) self->priv->pictures_check));
-}
-
-
-static void rygel_tracker_pref_section_class_init (RygelTrackerPrefSectionClass * klass) {
-	rygel_tracker_pref_section_parent_class = g_type_class_peek_parent (klass);
-	g_type_class_add_private (klass, sizeof (RygelTrackerPrefSectionPrivate));
-	RYGEL_PREFERENCES_SECTION_CLASS (klass)->save = rygel_tracker_pref_section_real_save;
-	G_OBJECT_CLASS (klass)->finalize = rygel_tracker_pref_section_finalize;
-}
-
-
-static void rygel_tracker_pref_section_instance_init (RygelTrackerPrefSection * self) {
-	self->priv = RYGEL_TRACKER_PREF_SECTION_GET_PRIVATE (self);
-}
-
-
-static void rygel_tracker_pref_section_finalize (GObject* obj) {
-	RygelTrackerPrefSection * self;
-	self = RYGEL_TRACKER_PREF_SECTION (obj);
-	_g_object_unref0 (self->priv->videos_check);
-	_g_object_unref0 (self->priv->music_check);
-	_g_object_unref0 (self->priv->pictures_check);
-	G_OBJECT_CLASS (rygel_tracker_pref_section_parent_class)->finalize (obj);
-}
-
-
-GType rygel_tracker_pref_section_get_type (void) {
-	static GType rygel_tracker_pref_section_type_id = 0;
-	if (rygel_tracker_pref_section_type_id == 0) {
-		static const GTypeInfo g_define_type_info = { sizeof (RygelTrackerPrefSectionClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) rygel_tracker_pref_section_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (RygelTrackerPrefSection), 0, (GInstanceInitFunc) rygel_tracker_pref_section_instance_init, NULL };
-		rygel_tracker_pref_section_type_id = g_type_register_static (RYGEL_TYPE_PLUGIN_PREF_SECTION, "RygelTrackerPrefSection", &g_define_type_info, 0);
-	}
-	return rygel_tracker_pref_section_type_id;
-}
-
-
-
-
--- /dev/null
+++ b/vapi/dbus-glib-1.vapi
@@ -0,0 +1,165 @@
+/* dbus-glib-1.vala
+ *
+ * Copyright (C) 2007-2009  Jürg Billeter
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA
+ *
+ * Author:
+ * 	Jürg Billeter <j@bitron.ch>
+ */
+
+[CCode (cheader_filename = "dbus/dbus-glib-lowlevel.h,dbus/dbus-glib.h")]
+namespace DBus {
+	[CCode (cprefix = "DBUS_BUS_")]
+	public enum BusType {
+		SESSION,
+		SYSTEM,
+		STARTER
+	}
+
+	namespace RawBus {
+		[CCode (cname = "dbus_bus_get")]
+		public static RawConnection get (BusType type, ref RawError error);
+	}
+
+	[CCode (ref_function = "dbus_connection_ref", unref_function = "dbus_connection_unref", cname = "DBusConnection")]
+	public class RawConnection {
+		[CCode (cname = "dbus_connection_setup_with_g_main")]
+		public void setup_with_main (GLib.MainContext? context = null);
+		[CCode (cname = "dbus_connection_get_g_connection")]
+		public Connection get_g_connection ();
+		[CCode (cname = "dbus_connection_register_g_object")]
+		public void register_object (string at_path, GLib.Object object);
+	}
+
+	[CCode (cname = "DBusError", cprefix = "dbus_error_", destroy_function = "dbus_error_free")]
+	public struct RawError {
+		public string name;
+		public string message;
+
+		public RawError ();
+		public bool has_name (string name);
+		public bool is_set ();
+	}
+
+	[DBus (name = "org.freedesktop.DBus.Error")]
+	[CCode (cname = "DBusGError", lower_case_csuffix = "gerror", cprefix = "DBUS_GERROR_")]
+	public errordomain Error {
+		FAILED,
+		NO_MEMORY,
+		SERVICE_UNKNOWN,
+		NAME_HAS_NO_OWNER,
+		NO_REPLY,
+		[DBus (name = "IOError")]
+		IO_ERROR,
+		BAD_ADDRESS,
+		NOT_SUPPORTED,
+		LIMITS_EXCEEDED,
+		ACCESS_DENIED,
+		AUTH_FAILED,
+		NO_SERVER,
+		TIMEOUT,
+		NO_NETWORK,
+		ADDRESS_IN_USE,
+		DISCONNECTED,
+		INVALID_ARGS,
+		FILE_NOT_FOUND,
+		FILE_EXISTS,
+		UNKNOWN_METHOD,
+		TIMED_OUT,
+		MATCH_RULE_NOT_FOUND,
+		MATCH_RULE_INVALID,
+		[DBus (name = "Spawn.ExecFailed")]
+		SPAWN_EXEC_FAILED,
+		[DBus (name = "Spawn.ForkFailed")]
+		SPAWN_FORK_FAILED,
+		[DBus (name = "Spawn.ChildExited")]
+		SPAWN_CHILD_EXITED,
+		[DBus (name = "Spawn.ChildSignaled")]
+		SPAWN_CHILD_SIGNALED,
+		[DBus (name = "Spawn.Failed")]
+		SPAWN_FAILED,
+		UNIX_PROCESS_ID_UNKNOWN,
+		INVALID_SIGNATURE,
+		INVALID_FILE_CONTENT,
+		[DBus (name = "SELinuxSecurityContextUnknown")]
+		SELINUX_SECURITY_CONTEXT_UNKNOWN,
+		REMOTE_EXCEPTION
+	}
+
+	public struct Bus {
+		[CCode (cname = "dbus_g_bus_get")]
+		public static Connection get (BusType type) throws Error;
+	}
+
+	[Compact]
+	[CCode (ref_function = "dbus_g_connection_ref", unref_function = "dbus_g_connection_unref", cname = "DBusGConnection")]
+	public class Connection {
+		[CCode (cname = "dbus_g_proxy_new_for_name")]
+		public Object get_object (string name, string path, string? interface_ = null);
+		[CCode (cname = "dbus_g_proxy_new_from_type")]
+		public GLib.Object get_object_from_type (string name, string path, string interface_, GLib.Type type);
+		[CCode (cname = "dbus_g_connection_register_g_object")]
+		public void register_object (string at_path, GLib.Object object);
+		[CCode (cname = "dbus_g_connection_lookup_g_object")]
+		public weak GLib.Object lookup_object (string at_path);
+		[CCode (cname = "dbus_g_connection_get_connection")]
+		public RawConnection get_connection ();
+	}
+
+	[CCode (cname = "DBusGProxy", lower_case_csuffix = "g_proxy")]
+	public class Object : GLib.Object {
+		public bool call (string method, out GLib.Error error, GLib.Type first_arg_type, ...);
+		public weak ProxyCall begin_call (string method, ProxyCallNotify notify, GLib.DestroyNotify destroy, GLib.Type first_arg_type, ...);
+		public bool end_call (ProxyCall call, out GLib.Error error, GLib.Type first_arg_type, ...);
+		public void cancel_call (ProxyCall call);
+		public weak string get_path ();
+		public weak string get_bus_name ();
+		public weak string get_interface ();
+	}
+
+	[CCode (cname = "char", const_cname = "const char", copy_function = "g_strdup", free_function = "g_free", cheader_filename = "stdlib.h,string.h,glib.h", type_id = "DBUS_TYPE_G_OBJECT_PATH", marshaller_type_name = "STRING", get_value_function = "g_value_get_string", set_value_function = "g_value_set_string", type_signature = "o")]
+	public class ObjectPath : string {
+		[CCode (cname = "g_strdup")]
+		public ObjectPath (string path);
+	}
+
+	[CCode (cname = "char", const_cname = "const char", copy_function = "g_strdup", free_function = "g_free", cheader_filename = "stdlib.h,string.h,glib.h", type_id = "DBUS_TYPE_G_OBJECT_PATH", marshaller_type_name = "STRING", get_value_function = "g_value_get_string", set_value_function = "g_value_set_string")]
+	public class BusName : string {
+		[CCode (cname = "g_strdup")]
+		public BusName (string bus_name);
+	}
+
+	[CCode (cname = "DBusGProxyCallNotify")]
+	public delegate void ProxyCallNotify (Object obj, ProxyCall call_id);
+
+	[CCode (cname = "DBusGProxyCall")]
+	public class ProxyCall {
+	}
+
+	[Flags]
+	public enum NameFlag {
+		ALLOW_REPLACEMENT,
+		REPLACE_EXISTING,
+		DO_NOT_QUEUE
+	}
+
+	public enum RequestNameReply {
+		PRIMARY_OWNER,
+		IN_QUEUE,
+		EXISTS,
+		ALREADY_OWNER
+	}
+}
--- /dev/null
+++ b/vapi/gee-1.0.vapi
@@ -0,0 +1,411 @@
+/* gee-1.0.vapi generated by valac, do not modify. */
+
+[CCode (cprefix = "Gee", lower_case_cprefix = "gee_")]
+namespace Gee {
+	[CCode (cprefix = "GeeFunctions", lower_case_cprefix = "gee_functions_")]
+	namespace Functions {
+		[CCode (cheader_filename = "gee.h")]
+		public static GLib.CompareFunc get_compare_func_for (GLib.Type t);
+		[CCode (cheader_filename = "gee.h")]
+		public static GLib.EqualFunc get_equal_func_for (GLib.Type t);
+		[CCode (cheader_filename = "gee.h")]
+		public static GLib.HashFunc get_hash_func_for (GLib.Type t);
+	}
+	[CCode (cheader_filename = "gee.h")]
+	public abstract class AbstractCollection<G> : GLib.Object, Gee.Iterable<G>, Gee.Collection<G> {
+		public AbstractCollection ();
+		public abstract bool add (G item);
+		public virtual bool add_all (Gee.Collection<G> collection);
+		public abstract void clear ();
+		public abstract bool contains (G item);
+		public virtual bool contains_all (Gee.Collection<G> collection);
+		public abstract Gee.Iterator<G> iterator ();
+		public abstract bool remove (G item);
+		public virtual bool remove_all (Gee.Collection<G> collection);
+		public virtual bool retain_all (Gee.Collection<G> collection);
+		public virtual G[] to_array ();
+		public virtual bool is_empty { get; }
+		public virtual Gee.Collection<G> read_only_view { owned get; }
+		public abstract int size { get; }
+	}
+	[CCode (cheader_filename = "gee.h")]
+	public abstract class AbstractList<G> : Gee.AbstractCollection<G>, Gee.List<G> {
+		public AbstractList ();
+		public virtual G first ();
+		public abstract G @get (int index);
+		public abstract int index_of (G item);
+		public abstract void insert (int index, G item);
+		public virtual void insert_all (int index, Gee.Collection<G> collection);
+		public virtual G last ();
+		public abstract Gee.ListIterator<G> list_iterator ();
+		public abstract G remove_at (int index);
+		public abstract void @set (int index, G item);
+		public abstract Gee.List<G>? slice (int start, int stop);
+		public virtual Gee.List<G> read_only_view { owned get; }
+	}
+	[CCode (cheader_filename = "gee.h")]
+	public abstract class AbstractMap<K,V> : GLib.Object, Gee.Iterable<Gee.Map.Entry<K,V>>, Gee.Map<K,V> {
+		public AbstractMap ();
+		public abstract void clear ();
+		public abstract V @get (K key);
+		public abstract bool has (K key, V value);
+		public virtual bool has_all (Gee.Map<K,V> map);
+		public abstract bool has_key (K key);
+		public abstract Gee.MapIterator<K,V> map_iterator ();
+		public abstract void @set (K key, V value);
+		public virtual void set_all (Gee.Map<K,V> map);
+		public abstract bool unset (K key, out V value = null);
+		public virtual bool unset_all (Gee.Map<K,V> map);
+		public abstract Gee.Set<Gee.Map.Entry<K,V>> entries { owned get; }
+		public virtual bool is_empty { get; }
+		public abstract Gee.Set<K> keys { owned get; }
+		public virtual Gee.Map<K,V> read_only_view { owned get; }
+		public abstract int size { get; }
+		public abstract Gee.Collection<V> values { owned get; }
+	}
+	[CCode (cheader_filename = "gee.h")]
+	public abstract class AbstractMultiMap<K,V> : GLib.Object, Gee.MultiMap<K,V> {
+		protected Gee.Map<K,Gee.Collection<V>> _storage_map;
+		public AbstractMultiMap (Gee.Map<K,Gee.Collection<V>> storage_map);
+		protected abstract Gee.MultiSet<K> create_multi_key_set ();
+		protected abstract Gee.Collection<V> create_value_storage ();
+		protected abstract GLib.EqualFunc get_value_equal_func ();
+	}
+	[CCode (cheader_filename = "gee.h")]
+	public abstract class AbstractMultiSet<G> : Gee.AbstractCollection<G>, Gee.MultiSet<G> {
+		protected Gee.Map<G,int> _storage_map;
+		public AbstractMultiSet (Gee.Map<G,int> storage_map);
+		public override bool add (G item);
+		public override void clear ();
+		public override bool contains (G item);
+		public override Gee.Iterator<G> iterator ();
+		public override bool remove (G item);
+		public override int size { get; }
+	}
+	[CCode (cheader_filename = "gee.h")]
+	public abstract class AbstractQueue<G> : Gee.AbstractCollection<G>, Gee.Queue<G> {
+		public AbstractQueue ();
+		public abstract int drain (Gee.Collection<G> recipient, int amount = -1);
+		public abstract bool offer (G element);
+		public abstract G peek ();
+		public abstract G poll ();
+		public abstract int capacity { get; }
+		public abstract bool is_full { get; }
+		public abstract int remaining_capacity { get; }
+	}
+	[CCode (cheader_filename = "gee.h")]
+	public abstract class AbstractSet<G> : Gee.AbstractCollection<G>, Gee.Set<G> {
+		public AbstractSet ();
+		public virtual Gee.Set<G> read_only_view { owned get; }
+	}
+	[CCode (cheader_filename = "gee.h")]
+	public class ArrayList<G> : Gee.AbstractList<G> {
+		public ArrayList (GLib.EqualFunc? equal_func = null);
+		public override bool add (G item);
+		public override bool add_all (Gee.Collection<G> collection);
+		public override void clear ();
+		public override bool contains (G item);
+		public override G @get (int index);
+		public override int index_of (G item);
+		public override void insert (int index, G item);
+		public override Gee.Iterator<G> iterator ();
+		public override Gee.ListIterator<G> list_iterator ();
+		public override bool remove (G item);
+		public override G remove_at (int index);
+		public override void @set (int index, G item);
+		public override Gee.List<G>? slice (int start, int stop);
+		public GLib.EqualFunc equal_func { get; set; }
+		public override int size { get; }
+	}
+	[CCode (cheader_filename = "gee.h")]
+	public class HashMap<K,V> : Gee.AbstractMap<K,V> {
+		public HashMap (GLib.HashFunc? key_hash_func = null, GLib.EqualFunc? key_equal_func = null, GLib.EqualFunc? value_equal_func = null);
+		public override void clear ();
+		public override V @get (K key);
+		public override bool has (K key, V value);
+		public override bool has_key (K key);
+		public override Gee.MapIterator<K,V> map_iterator ();
+		public override void @set (K key, V value);
+		public override bool unset (K key, out V value = null);
+		public override Gee.Set<Gee.Map.Entry<K,V>> entries { owned get; }
+		public GLib.EqualFunc key_equal_func { get; set; }
+		public GLib.HashFunc key_hash_func { get; set; }
+		public override Gee.Set<K> keys { owned get; }
+		public override int size { get; }
+		public GLib.EqualFunc value_equal_func { get; set; }
+		public override Gee.Collection<V> values { owned get; }
+	}
+	[CCode (cheader_filename = "gee.h")]
+	public class HashMultiMap<K,V> : Gee.AbstractMultiMap<K,V> {
+		public HashMultiMap (GLib.HashFunc? key_hash_func = null, GLib.EqualFunc? key_equal_func = null, GLib.HashFunc? value_hash_func = null, GLib.EqualFunc? value_equal_func = null);
+		protected override Gee.MultiSet<K> create_multi_key_set ();
+		protected override Gee.Collection<V> create_value_storage ();
+		protected override GLib.EqualFunc get_value_equal_func ();
+		public GLib.EqualFunc key_equal_func { get; }
+		public GLib.HashFunc key_hash_func { get; }
+		public GLib.EqualFunc value_equal_func { get; set; }
+		public GLib.HashFunc value_hash_func { get; set; }
+	}
+	[CCode (cheader_filename = "gee.h")]
+	public class HashMultiSet<G> : Gee.AbstractMultiSet<G> {
+		public HashMultiSet (GLib.HashFunc? hash_func = null, GLib.EqualFunc? equal_func = null);
+		public GLib.EqualFunc equal_func { get; }
+		public GLib.HashFunc hash_func { get; }
+	}
+	[CCode (cheader_filename = "gee.h")]
+	public class HashSet<G> : Gee.AbstractSet<G> {
+		public HashSet (GLib.HashFunc? hash_func = null, GLib.EqualFunc? equal_func = null);
+		public override bool add (G key);
+		public override void clear ();
+		public override bool contains (G key);
+		public override Gee.Iterator<G> iterator ();
+		public override bool remove (G key);
+		public GLib.EqualFunc equal_func { get; set; }
+		public GLib.HashFunc hash_func { get; set; }
+		public override int size { get; }
+	}
+	[CCode (cheader_filename = "gee.h")]
+	public class LinkedList<G> : Gee.AbstractList<G>, Gee.Queue<G>, Gee.Deque<G> {
+		public LinkedList (GLib.EqualFunc? equal_func = null);
+		public override bool add (G item);
+		public override void clear ();
+		public override bool contains (G item);
+		public override G first ();
+		public override G @get (int index);
+		public override int index_of (G item);
+		public override void insert (int index, G item);
+		public override Gee.Iterator<G> iterator ();
+		public override G last ();
+		public override Gee.ListIterator<G> list_iterator ();
+		public override bool remove (G item);
+		public override G remove_at (int index);
+		public override void @set (int index, G item);
+		public override Gee.List<G>? slice (int start, int stop);
+		public GLib.EqualFunc equal_func { get; set; }
+		public override int size { get; }
+	}
+	[CCode (cheader_filename = "gee.h")]
+	public class PriorityQueue<G> : Gee.AbstractQueue<G> {
+		public PriorityQueue (GLib.CompareFunc? compare_func = null);
+		public override bool add (G item);
+		public override void clear ();
+		public override bool contains (G item);
+		public override int drain (Gee.Collection<G> recipient, int amount = -1);
+		public override Gee.Iterator<G> iterator ();
+		public override bool offer (G element);
+		public override G peek ();
+		public override G poll ();
+		public override bool remove (G item);
+		public override int capacity { get; }
+		public GLib.CompareFunc compare_func { get; set; }
+		public override bool is_full { get; }
+		public override int remaining_capacity { get; }
+		public override int size { get; }
+	}
+	[CCode (cheader_filename = "gee.h")]
+	public class TreeMap<K,V> : Gee.AbstractMap<K,V> {
+		public TreeMap (GLib.CompareFunc? key_compare_func = null, GLib.EqualFunc? value_equal_func = null);
+		public override void clear ();
+		public override V @get (K key);
+		public override bool has (K key, V value);
+		public override bool has_key (K key);
+		public override Gee.MapIterator<K,V> map_iterator ();
+		public override void @set (K key, V value);
+		public override bool unset (K key, out V value = null);
+		public override Gee.Set<Gee.Map.Entry<K,V>> entries { owned get; }
+		public GLib.CompareFunc key_compare_func { get; set; }
+		public override Gee.Set<K> keys { owned get; }
+		public override int size { get; }
+		public GLib.EqualFunc value_equal_func { get; set; }
+		public override Gee.Collection<V> values { owned get; }
+	}
+	[CCode (cheader_filename = "gee.h")]
+	public class TreeMultiMap<K,V> : Gee.AbstractMultiMap<K,V> {
+		public TreeMultiMap (GLib.CompareFunc? key_compare_func = null, GLib.CompareFunc? value_compare_func = null);
+		protected override Gee.MultiSet<K> create_multi_key_set ();
+		protected override Gee.Collection<V> create_value_storage ();
+		protected override GLib.EqualFunc get_value_equal_func ();
+		public GLib.CompareFunc key_compare_func { get; }
+		public GLib.CompareFunc value_compare_func { get; set; }
+	}
+	[CCode (cheader_filename = "gee.h")]
+	public class TreeMultiSet<G> : Gee.AbstractMultiSet<G> {
+		public TreeMultiSet (GLib.CompareFunc? compare_func = null);
+		public GLib.CompareFunc compare_func { get; }
+	}
+	[CCode (cheader_filename = "gee.h")]
+	public class TreeSet<G> : Gee.AbstractSet<G>, Gee.SortedSet<G> {
+		public TreeSet (GLib.CompareFunc? compare_func = null);
+		public override bool add (G item);
+		public override void clear ();
+		public override bool contains (G item);
+		public override Gee.Iterator<G> iterator ();
+		public override bool remove (G item);
+		public GLib.CompareFunc compare_func { get; set; }
+		public override int size { get; }
+	}
+	[CCode (cheader_filename = "gee.h")]
+	public interface BidirIterator<G> : Gee.Iterator<G> {
+		public abstract bool has_previous ();
+		public abstract bool last ();
+		public abstract bool previous ();
+	}
+	[CCode (cheader_filename = "gee.h")]
+	public interface Collection<G> : Gee.Iterable<G> {
+		public abstract bool add (G item);
+		public abstract bool add_all (Gee.Collection<G> collection);
+		public abstract void clear ();
+		public abstract bool contains (G item);
+		public abstract bool contains_all (Gee.Collection<G> collection);
+		public static Gee.Collection<G> empty<G> ();
+		public abstract bool remove (G item);
+		public abstract bool remove_all (Gee.Collection<G> collection);
+		public abstract bool retain_all (Gee.Collection<G> collection);
+		public abstract G[] to_array ();
+		public abstract bool is_empty { get; }
+		public abstract Gee.Collection<G> read_only_view { owned get; }
+		public abstract int size { get; }
+	}
+	[CCode (cheader_filename = "gee.h")]
+	public interface Comparable<G> : GLib.Object {
+		public abstract int compare_to (G object);
+	}
+	[CCode (cheader_filename = "gee.h")]
+	public interface Deque<G> : Gee.Queue<G> {
+		public abstract int drain_head (Gee.Collection<G> recipient, int amount = -1);
+		public abstract int drain_tail (Gee.Collection<G> recipient, int amount = -1);
+		public abstract bool offer_head (G element);
+		public abstract bool offer_tail (G element);
+		public abstract G peek_head ();
+		public abstract G peek_tail ();
+		public abstract G poll_head ();
+		public abstract G poll_tail ();
+	}
+	[CCode (cheader_filename = "gee.h")]
+	public interface Iterable<G> : GLib.Object {
+		public abstract Gee.Iterator<G> iterator ();
+		public abstract GLib.Type element_type { get; }
+	}
+	[CCode (cheader_filename = "gee.h")]
+	public interface Iterator<G> : GLib.Object {
+		public abstract bool first ();
+		public abstract G @get ();
+		public abstract bool has_next ();
+		public abstract bool next ();
+		public abstract void remove ();
+	}
+	[CCode (cheader_filename = "gee.h")]
+	public interface List<G> : Gee.Collection<G> {
+		public static Gee.List<G> empty<G> ();
+		public abstract G first ();
+		public abstract G @get (int index);
+		public abstract int index_of (G item);
+		public abstract void insert (int index, G item);
+		public abstract void insert_all (int index, Gee.Collection<G> collection);
+		public abstract G last ();
+		public abstract Gee.ListIterator<G> list_iterator ();
+		public abstract G remove_at (int index);
+		public abstract void @set (int index, G item);
+		public abstract Gee.List<G>? slice (int start, int stop);
+		public abstract void sort (GLib.CompareFunc? compare_func = null);
+		public abstract Gee.List<G> read_only_view { owned get; }
+	}
+	[CCode (cheader_filename = "gee.h")]
+	public interface ListIterator<G> : Gee.BidirIterator<G> {
+		public abstract void add (G item);
+		public abstract int index ();
+		public abstract void insert (G item);
+		public abstract void @set (G item);
+	}
+	[CCode (cheader_filename = "gee.h")]
+	public interface Map<K,V> : GLib.Object, Gee.Iterable<Gee.Map.Entry<K,V>> {
+		[CCode (cheader_filename = "gee.h")]
+		public abstract class Entry<K,V> : GLib.Object {
+			public Entry ();
+			public abstract K key { get; }
+			public abstract V value { get; set; }
+		}
+		public abstract void clear ();
+		public abstract bool contains (K key);
+		public abstract bool contains_all (Gee.Map<K,V> map);
+		public static Gee.Map<K,V> empty<K,V> ();
+		public abstract V @get (K key);
+		public abstract bool has (K key, V value);
+		public abstract bool has_all (Gee.Map<K,V> map);
+		public abstract bool has_key (K key);
+		public abstract Gee.MapIterator<K,V> map_iterator ();
+		public abstract bool remove (K key, out V value = null);
+		public abstract bool remove_all (Gee.Map<K,V> map);
+		public abstract void @set (K key, V value);
+		public abstract void set_all (Gee.Map<K,V> map);
+		public abstract bool unset (K key, out V value = null);
+		public abstract bool unset_all (Gee.Map<K,V> map);
+		public abstract Gee.Set<Gee.Map.Entry<K,V>> entries { owned get; }
+		public abstract bool is_empty { get; }
+		public abstract GLib.Type key_type { get; }
+		public abstract Gee.Set<K> keys { owned get; }
+		public abstract Gee.Map<K,V> read_only_view { owned get; }
+		public abstract int size { get; }
+		public abstract GLib.Type value_type { get; }
+		public abstract Gee.Collection<V> values { owned get; }
+	}
+	[CCode (cheader_filename = "gee.h")]
+	public interface MapIterator<K,V> : GLib.Object {
+		public abstract bool first ();
+		public abstract K get_key ();
+		public abstract V get_value ();
+		public abstract bool has_next ();
+		public abstract bool next ();
+		public abstract void set_value (V value);
+		public abstract void unset ();
+	}
+	[CCode (cheader_filename = "gee.h")]
+	public interface MultiMap<K,V> : GLib.Object {
+		public abstract void clear ();
+		public abstract bool contains (K key);
+		public abstract Gee.Collection<V> @get (K key);
+		public abstract Gee.MultiSet<K> get_all_keys ();
+		public abstract Gee.Set<K> get_keys ();
+		public abstract Gee.Collection<V> get_values ();
+		public abstract bool remove (K key, V value);
+		public abstract bool remove_all (K key);
+		public abstract void @set (K key, V value);
+		public abstract int size { get; }
+	}
+	[CCode (cheader_filename = "gee.h")]
+	public interface MultiSet<G> : Gee.Collection<G> {
+		public abstract int count (G item);
+	}
+	[CCode (cheader_filename = "gee.h")]
+	public interface Queue<G> : Gee.Collection<G> {
+		public const int UNBOUNDED_CAPACITY;
+		public abstract int drain (Gee.Collection<G> recipient, int amount = -1);
+		public abstract bool offer (G element);
+		public abstract G peek ();
+		public abstract G poll ();
+		public abstract int capacity { get; }
+		public abstract bool is_full { get; }
+		public abstract int remaining_capacity { get; }
+	}
+	[CCode (cheader_filename = "gee.h")]
+	public interface Set<G> : Gee.Collection<G> {
+		public static Gee.Set<G> empty<G> ();
+		public abstract Gee.Set<G> read_only_view { owned get; }
+	}
+	[CCode (cheader_filename = "gee.h")]
+	public interface SortedSet<G> : Gee.Set<G> {
+		public abstract Gee.BidirIterator<G> bidir_iterator ();
+		public abstract G ceil (G element);
+		public abstract G first ();
+		public abstract G floor (G element);
+		public abstract Gee.SortedSet<G> head_set (G before);
+		public abstract G higher (G element);
+		public abstract Gee.BidirIterator<G>? iterator_at (G element);
+		public abstract G last ();
+		public abstract G lower (G element);
+		public abstract Gee.SortedSet<G> sub_set (G from, G to);
+		public abstract Gee.SortedSet<G> tail_set (G after);
+	}
+	[CCode (cheader_filename = "gee.h")]
+	public static int direct_compare (void* _val1, void* _val2);
+}
--- /dev/null
+++ b/vapi/gssdp-1.0.vapi
@@ -0,0 +1,50 @@
+/* gssdp-1.0.vapi generated by vapigen, do not modify. */
+
+[CCode (cprefix = "GSSDP", lower_case_cprefix = "gssdp_")]
+namespace GSSDP {
+	[CCode (cheader_filename = "libgssdp/gssdp.h")]
+	public class Client : GLib.Object {
+		[CCode (has_construct_function = false)]
+		public Client.full (GLib.MainContext main_context, string host_ip) throws GLib.Error;
+		public unowned string get_host_ip ();
+		[CCode (has_construct_function = false)]
+		public Client (GLib.MainContext? main_context, string? @interface) throws GLib.Error;
+		[NoAccessorMethod]
+		public bool active { get; set; }
+		public string host_ip { get; }
+		public string @interface { get; construct; }
+		public void* main_context { get; construct; }
+		public string server_id { get; set; }
+	}
+	[CCode (cheader_filename = "libgssdp/gssdp.h")]
+	public class ResourceBrowser : GLib.Object {
+		[CCode (has_construct_function = false)]
+		public ResourceBrowser (GSSDP.Client client, string target);
+		public bool active { get; set; }
+		public GSSDP.Client client { get; construct; }
+		public uint mx { get; set; }
+		public string target { get; set; }
+		public signal void resource_available (string usn, GLib.List<string> locations);
+		public virtual signal void resource_unavailable (string usn);
+	}
+	[CCode (cheader_filename = "libgssdp/gssdp.h")]
+	public class ResourceGroup : GLib.Object {
+		public uint add_resource (string target, string usn, GLib.List locations);
+		public uint add_resource_simple (string target, string usn, string location);
+		[CCode (has_construct_function = false)]
+		public ResourceGroup (GSSDP.Client client);
+		public void remove_resource (uint resource_id);
+		public bool available { get; set; }
+		public GSSDP.Client client { get; construct; }
+		public uint max_age { get; set; }
+		public uint message_delay { get; set; }
+	}
+	[CCode (cprefix = "GSSDP_ERROR_", cheader_filename = "libgssdp/gssdp.h")]
+	public errordomain Error {
+		FAILED,
+	}
+	[CCode (cheader_filename = "libgssdp/gssdp.h")]
+	public const string ALL_RESOURCES;
+	[CCode (cheader_filename = "libgssdp/gssdp.h")]
+	public static GLib.Quark error_quark ();
+}
--- /dev/null
+++ b/vapi/gupnp-1.0.deps
@@ -0,0 +1,4 @@
+gssdp-1.0
+libsoup-2.4
+gio-2.0
+libxml-2.0
--- /dev/null
+++ b/vapi/gupnp-1.0.vapi
@@ -0,0 +1,284 @@
+/* gupnp-1.0.vapi generated by vapigen, do not modify. */
+
+[CCode (cprefix = "GUPnP", lower_case_cprefix = "gupnp_")]
+namespace GUPnP {
+	[CCode (cheader_filename = "libgupnp/gupnp.h")]
+	public class Context : GSSDP.Client {
+		public void host_path (string local_path, string server_path);
+		[CCode (has_construct_function = false)]
+		public Context (GLib.MainContext? main_context, string? @interface, uint port) throws GLib.Error;
+		public void unhost_path (string server_path);
+		public uint port { get; construct; }
+		public Soup.Server server { get; }
+		public Soup.Session session { get; }
+		public uint subscription_timeout { get; construct; }
+	}
+	[CCode (cheader_filename = "libgupnp/gupnp.h")]
+	public class ContextManager : GLib.Object {
+		public void manage_control_point (GUPnP.ControlPoint control_point);
+		public void manage_root_device (GUPnP.RootDevice root_device);
+		[CCode (has_construct_function = false)]
+		public ContextManager (GLib.MainContext? main_context, uint port);
+		public GUPnP.ContextManager context_manager { construct; }
+		[NoAccessorMethod]
+		public void* main_context { get; construct; }
+		[NoAccessorMethod]
+		public uint port { get; construct; }
+		public virtual signal void context_available (GUPnP.Context p0);
+		public virtual signal void context_unavailable (GUPnP.Context p0);
+	}
+	[CCode (cheader_filename = "libgupnp/gupnp.h")]
+	public class ControlPoint : GSSDP.ResourceBrowser {
+		[CCode (has_construct_function = false)]
+		public ControlPoint.full (GUPnP.Context context, GUPnP.ResourceFactory factory, string target);
+		public unowned GUPnP.Context get_context ();
+		public unowned GLib.List<GUPnP.DeviceProxy> list_device_proxies ();
+		public unowned GLib.List<GUPnP.ServiceProxy> list_service_proxies ();
+		[CCode (has_construct_function = false)]
+		public ControlPoint (GUPnP.Context context, string target);
+		public GUPnP.ResourceFactory resource_factory { get; construct; }
+		public virtual signal void device_proxy_available (GUPnP.DeviceProxy proxy);
+		public virtual signal void device_proxy_unavailable (GUPnP.DeviceProxy proxy);
+		public virtual signal void service_proxy_available (GUPnP.ServiceProxy proxy);
+		public virtual signal void service_proxy_unavailable (GUPnP.ServiceProxy proxy);
+	}
+	[CCode (cheader_filename = "libgupnp/gupnp.h")]
+	public class Device : GUPnP.DeviceInfo {
+		[NoAccessorMethod]
+		public GUPnP.RootDevice root_device { owned get; construct; }
+	}
+	[CCode (cheader_filename = "libgupnp/gupnp.h")]
+	public class DeviceInfo : GLib.Object {
+		public string get_description_value (string element);
+		public virtual GUPnP.DeviceInfo? get_device (string type);
+		public unowned string get_device_type ();
+		public string get_friendly_name ();
+		public string get_icon_url (string requested_mime_type, int requested_depth, int requested_width, int requested_height, bool prefer_bigger, out unowned string mime_type, out int depth, out int width, out int height);
+		public string get_manufacturer ();
+		public string get_manufacturer_url ();
+		public string get_model_description ();
+		public string get_model_name ();
+		public string get_model_number ();
+		public string get_model_url ();
+		public string get_presentation_url ();
+		public string get_serial_number ();
+		public virtual GUPnP.ServiceInfo? get_service (string type);
+		public string get_upc ();
+		public GLib.List<string> list_device_types ();
+		public GLib.List<GUPnP.DeviceInfo> list_devices ();
+		public GLib.List<string> list_dlna_capabilities ();
+		public GLib.List<string> list_service_types ();
+		public GLib.List<GUPnP.ServiceInfo> list_services ();
+		[CCode (has_construct_function = false)]
+		public DeviceInfo ();
+		public GUPnP.Context context { get; construct; }
+		public string device_type { get; construct; }
+		public string location { get; construct; }
+		public GUPnP.ResourceFactory resource_factory { get; construct; }
+		public string udn { get; construct; }
+		public Soup.URI url_base { get; construct; }
+	}
+	[CCode (cheader_filename = "libgupnp/gupnp.h")]
+	public class DeviceProxy : GUPnP.DeviceInfo {
+	}
+	[CCode (cheader_filename = "libgupnp/gupnp.h")]
+	public class ResourceFactory : GLib.Object {
+		public static unowned GUPnP.ResourceFactory get_default ();
+		[CCode (has_construct_function = false)]
+		public ResourceFactory ();
+		public void register_resource_proxy_type (string upnp_type, GLib.Type type);
+		public void register_resource_type (string upnp_type, GLib.Type type);
+		public bool unregister_resource_proxy_type (string upnp_type);
+		public bool unregister_resource_type (string upnp_type);
+	}
+	[CCode (cheader_filename = "libgupnp/gupnp.h")]
+	public class RootDevice : GUPnP.Device {
+		[CCode (has_construct_function = false)]
+		public RootDevice.full (GUPnP.Context context, GUPnP.ResourceFactory factory, GUPnP.XMLDoc description_doc, string description_path, string description_dir);
+		public unowned string get_description_dir ();
+		public unowned string get_description_path ();
+		[CCode (has_construct_function = false)]
+		public RootDevice (GUPnP.Context context, string description_path, string description_dir);
+		public bool available { get; set; }
+		public string description_dir { get; construct; }
+		public GUPnP.XMLDoc description_doc { construct; }
+		public string description_path { get; construct; }
+	}
+	[CCode (cheader_filename = "libgupnp/gupnp.h")]
+	public class Service : GUPnP.ServiceInfo {
+		public void freeze_notify ();
+		[CCode (has_construct_function = false)]
+		public Service ();
+		public void notify (...);
+		public void notify_value (string variable, GLib.Value value);
+		public void thaw_notify ();
+		[NoAccessorMethod]
+		public GUPnP.RootDevice root_device { owned get; construct; }
+		public virtual signal void action_invoked (owned GUPnP.ServiceAction action);
+		public virtual signal void notify_failed (GLib.List<Soup.URI> callback_urls, GLib.Error reason);
+		public virtual signal void query_variable (string variable, ref GLib.Value value);
+	}
+	[CCode (ref_function = "", unref_function = "", cheader_filename = "libgupnp/gupnp.h")]
+	public class ServiceAction {
+		public void @get (...);
+		public GLib.List<string> get_locales ();
+		public Soup.Message<string> get_message ();
+		public unowned string get_name ();
+		public void get_value (string argument, ref GLib.Value value);
+		public void @return ();
+		public void return_error (uint error_code, string? error_description);
+		public void @set (...);
+		public void set_value (string argument, ref GLib.Value value);
+	}
+	[Compact]
+	[CCode (cheader_filename = "libgupnp/gupnp.h")]
+	public class ServiceActionArgInfo {
+		public GUPnP.ServiceActionArgDirection direction;
+		public weak string name;
+		public weak string related_state_variable;
+		public bool retval;
+	}
+	[CCode (ref_function = "gupnp_service_action_info_ref", unref_function = "gupnp_service_action_info_unref", cheader_filename = "libgupnp/gupnp.h")]
+	public class ServiceActionInfo {
+		public weak GLib.List<GUPnP.ServiceActionArgInfo> arguments;
+		public weak string name;
+		[CCode (has_construct_function = false)]
+		public ServiceActionInfo ();
+	}
+	[CCode (cheader_filename = "libgupnp/gupnp.h")]
+	public class ServiceInfo : GLib.Object {
+		public string get_control_url ();
+		public string get_event_subscription_url ();
+		public string get_id ();
+		public GUPnP.ServiceIntrospection? get_introspection () throws GLib.Error;
+		public void get_introspection_async (GUPnP.ServiceIntrospectionCallback callback);
+		public string get_scpd_url ();
+		[CCode (has_construct_function = false)]
+		public ServiceInfo ();
+		public GUPnP.Context context { get; construct; }
+		public string location { get; construct; }
+		public string service_type { get; construct; }
+		public string udn { get; construct; }
+		public Soup.URI url_base { get; construct; }
+	}
+	[CCode (cheader_filename = "libgupnp/gupnp.h")]
+	public class ServiceIntrospection : GLib.Object {
+		public unowned GUPnP.ServiceActionInfo get_action (string action_name);
+		public unowned GUPnP.ServiceStateVariableInfo get_state_variable (string variable_name);
+		public unowned GLib.List<string> list_action_names ();
+		public unowned GLib.List<GUPnP.ServiceActionInfo> list_actions ();
+		public unowned GLib.List<string> list_state_variable_names ();
+		public unowned GLib.List<GUPnP.ServiceStateVariableInfo> list_state_variables ();
+	}
+	[CCode (cheader_filename = "libgupnp/gupnp.h")]
+	public class ServiceProxy : GUPnP.ServiceInfo {
+		public bool add_notify (string variable, GLib.Type type, GUPnP.ServiceProxyNotifyCallback callback);
+		public unowned GUPnP.ServiceProxyAction begin_action (string action, GUPnP.ServiceProxyActionCallback callback, ...);
+		public unowned GUPnP.ServiceProxyAction begin_action_hash (string action, GUPnP.ServiceProxyActionCallback callback, GLib.HashTable hash);
+		public void cancel_action (GUPnP.ServiceProxyAction action);
+		public bool end_action (GUPnP.ServiceProxyAction action, ...) throws GLib.Error;
+		public bool end_action_hash (GUPnP.ServiceProxyAction action, GLib.HashTable hash) throws GLib.Error;
+		[CCode (has_construct_function = false)]
+		public ServiceProxy ();
+		public bool remove_notify (string variable, GUPnP.ServiceProxyNotifyCallback callback);
+		public bool send_action (string action, ...) throws GLib.Error;
+		public bool send_action_hash (string action, GLib.HashTable in_hash, ref unowned GLib.HashTable out_hash) throws GLib.Error;
+		public bool subscribed { get; set; }
+		public virtual signal void subscription_lost (GLib.Error reason);
+	}
+	[Compact]
+	[CCode (cheader_filename = "libgupnp/gupnp.h")]
+	public class ServiceProxyAction {
+	}
+	[CCode (ref_function = "gupnp_service_state_variable_info_ref", unref_function = "gupnp_service_state_variable_info_unref", cheader_filename = "libgupnp/gupnp.h")]
+	public class ServiceStateVariableInfo {
+		public weak GLib.List<string> allowed_values;
+		public GLib.Value default_value;
+		public bool is_numeric;
+		public GLib.Value maximum;
+		public GLib.Value minimum;
+		public weak string name;
+		public bool send_events;
+		public GLib.Value step;
+		public GLib.Type type;
+		[CCode (has_construct_function = false)]
+		public ServiceStateVariableInfo ();
+	}
+	[CCode (cheader_filename = "libgupnp/gupnp.h")]
+	public class XMLDoc : GLib.Object {
+		public weak Xml.Doc doc;
+		[CCode (has_construct_function = false)]
+		public XMLDoc.from_path (string path) throws GLib.Error;
+		[CCode (has_construct_function = false)]
+		public XMLDoc (Xml.Doc xml_doc);
+	}
+	[CCode (type_id = "GUPNP_TYPE_BIN_BASE64", cheader_filename = "libgupnp/gupnp.h")]
+	public struct BinBase64 {
+	}
+	[CCode (type_id = "GUPNP_TYPE_BIN_HEX", cheader_filename = "libgupnp/gupnp.h")]
+	public struct BinHex {
+	}
+	[CCode (type_id = "GUPNP_TYPE_DATE", cheader_filename = "libgupnp/gupnp.h")]
+	public struct Date {
+	}
+	[CCode (type_id = "GUPNP_TYPE_DATE_TIME", cheader_filename = "libgupnp/gupnp.h")]
+	public struct DateTime {
+	}
+	[CCode (type_id = "GUPNP_TYPE_DATE_TIME_TZ", cheader_filename = "libgupnp/gupnp.h")]
+	public struct DateTimeTZ {
+	}
+	[CCode (type_id = "GUPNP_TYPE_TIME", cheader_filename = "libgupnp/gupnp.h")]
+	public struct Time {
+	}
+	[CCode (type_id = "GUPNP_TYPE_TIME_TZ", cheader_filename = "libgupnp/gupnp.h")]
+	public struct TimeTZ {
+	}
+	[CCode (type_id = "GUPNP_TYPE_URI", cheader_filename = "libgupnp/gupnp.h")]
+	public struct URI {
+	}
+	[CCode (type_id = "GUPNP_TYPE_UUID", cheader_filename = "libgupnp/gupnp.h")]
+	public struct UUID {
+	}
+	[CCode (cprefix = "GUPNP_SERVICE_ACTION_ARG_DIRECTION_", has_type_id = "0", cheader_filename = "libgupnp/gupnp.h")]
+	public enum ServiceActionArgDirection {
+		IN,
+		OUT
+	}
+	[CCode (cprefix = "GUPNP_XML_ERROR_", has_type_id = "0", cheader_filename = "libgupnp/gupnp.h")]
+	public enum XMLError {
+		PARSE,
+		NO_NODE,
+		EMPTY_NODE,
+		OTHER
+	}
+	[CCode (cprefix = "GUPNP_CONTROL_ERROR_", cheader_filename = "libgupnp/gupnp.h")]
+	public errordomain ControlError {
+		INVALID_ACTION,
+		INVALID_ARGS,
+		OUT_OF_SYNC,
+		ACTION_FAILED,
+	}
+	[CCode (cprefix = "GUPNP_EVENTING_ERROR_", cheader_filename = "libgupnp/gupnp.h")]
+	public errordomain EventingError {
+		SUBSCRIPTION_FAILED,
+		SUBSCRIPTION_LOST,
+		NOTIFY_FAILED,
+	}
+	[CCode (cprefix = "GUPNP_SERVER_ERROR_", cheader_filename = "libgupnp/gupnp.h")]
+	public errordomain ServerError {
+		INTERNAL_SERVER_ERROR,
+		NOT_FOUND,
+		NOT_IMPLEMENTED,
+		INVALID_RESPONSE,
+		INVALID_URL,
+		OTHER,
+	}
+	[CCode (cheader_filename = "libgupnp/gupnp.h")]
+	public delegate void ServiceIntrospectionCallback (GUPnP.ServiceInfo info, GUPnP.ServiceIntrospection introspection, GLib.Error error);
+	[CCode (cheader_filename = "libgupnp/gupnp.h")]
+	public delegate void ServiceProxyActionCallback (GUPnP.ServiceProxy proxy, GUPnP.ServiceProxyAction action);
+	[CCode (cheader_filename = "libgupnp/gupnp.h")]
+	public delegate void ServiceProxyNotifyCallback (GUPnP.ServiceProxy proxy, string variable, GLib.Value value);
+	[CCode (cheader_filename = "libgupnp/gupnp.h")]
+	public static GLib.Quark xml_error_quark ();
+}
--- /dev/null
+++ b/vapi/gupnp-av-1.0.deps
@@ -0,0 +1,6 @@
+gupnp-1.0
+gssdp-1.0
+libxml-2.0
+libsoup-2.4
+glib-2.0
+gio-2.0
--- /dev/null
+++ b/vapi/gupnp-av-1.0.vapi
@@ -0,0 +1,181 @@
+/* gupnp-av-1.0.vapi generated by vapigen, do not modify. */
+
+[CCode (cprefix = "GUPnP", lower_case_cprefix = "gupnp_")]
+namespace GUPnP {
+	[CCode (cheader_filename = "libgupnp-av/gupnp-av.h")]
+	public class DIDLLiteContainer : GUPnP.DIDLLiteObject {
+		public uint child_count { get; set; }
+		public bool searchable { get; set; }
+	}
+	[CCode (cheader_filename = "libgupnp-av/gupnp-av.h")]
+	public class DIDLLiteDescriptor : GLib.Object {
+		public string content { get; set; }
+		public string id { get; set; }
+		public string metadata_type { get; set; }
+		public string name_space { get; set; }
+		public GUPnP.XMLDoc xml_doc { construct; }
+		public void* xml_node { get; construct; }
+	}
+	[CCode (cheader_filename = "libgupnp-av/gupnp-av.h")]
+	public class DIDLLiteItem : GUPnP.DIDLLiteObject {
+		public string ref_id { get; set; }
+	}
+	[CCode (cheader_filename = "libgupnp-av/gupnp-av.h")]
+	public class DIDLLiteObject : GLib.Object {
+		public GUPnP.DIDLLiteDescriptor add_descriptor ();
+		public GUPnP.DIDLLiteResource add_resource ();
+		public GUPnP.DIDLLiteResource get_compat_resource (string sink_protocol_info, bool lenient);
+		public unowned GLib.List get_properties (string name);
+		public GLib.List<GUPnP.DIDLLiteResource> get_resources ();
+		public string album { get; set; }
+		public string album_art { get; set; }
+		public string artist { get; set; }
+		public string author { get; set; }
+		public string creator { get; set; }
+		public string date { get; set; }
+		public string description { get; set; }
+		public string genre { get; set; }
+		public string id { get; set; }
+		public string parent_id { get; set; }
+		public bool restricted { get; set; }
+		public string title { get; set; }
+		public int track_number { get; set; }
+		public string upnp_class { get; set; }
+		public string write_status { get; set; }
+		public GUPnP.XMLDoc xml_doc { construct; }
+		public void* xml_node { get; construct; }
+	}
+	[CCode (cheader_filename = "libgupnp-av/gupnp-av.h")]
+	public class DIDLLiteParser : GLib.Object {
+		public void* gupnp_reserved;
+		[CCode (has_construct_function = false)]
+		public DIDLLiteParser ();
+		public bool parse_didl (string didl) throws GLib.Error;
+		public virtual signal void container_available (GUPnP.DIDLLiteContainer container);
+		public virtual signal void item_available (GUPnP.DIDLLiteItem item);
+		public virtual signal void object_available (GUPnP.DIDLLiteObject object);
+	}
+	[CCode (cheader_filename = "libgupnp-av/gupnp-av.h")]
+	public class DIDLLiteResource : GLib.Object {
+		public int audio_channels { get; set; }
+		public int bitrate { get; set; }
+		public int bits_per_sample { get; set; }
+		public int color_depth { get; set; }
+		public long duration { get; set; }
+		public int height { get; set; }
+		public string import_uri { get; set; }
+		public string protection { get; set; }
+		public GUPnP.ProtocolInfo protocol_info { get; set; }
+		public int sample_freq { get; set; }
+		public long size { get; set; }
+		public string uri { get; set; }
+		public int width { get; set; }
+		public GUPnP.XMLDoc xml_doc { construct; }
+		public void* xml_node { get; construct; }
+	}
+	[CCode (cheader_filename = "libgupnp-av/gupnp-av.h")]
+	public class DIDLLiteWriter : GLib.Object {
+		public const string NAMESPACE_DC;
+		public const string NAMESPACE_UPNP;
+		public GUPnP.DIDLLiteContainer add_container ();
+		public GUPnP.DIDLLiteDescriptor add_descriptor ();
+		public GUPnP.DIDLLiteItem add_item ();
+		public void filter (string filter);
+		public string get_string ();
+		public unowned Xml.Node get_xml_node ();
+		[CCode (has_construct_function = false)]
+		public DIDLLiteWriter (string? language);
+		public string language { get; construct; }
+		public void* xml_node { get; }
+	}
+	[CCode (cheader_filename = "libgupnp-av/gupnp-av.h")]
+	public class LastChangeParser : GLib.Object {
+		[CCode (has_construct_function = false)]
+		public LastChangeParser ();
+		public bool parse_last_change (uint instance_id, string last_change_xml, ...) throws GLib.Error;
+	}
+	[CCode (cheader_filename = "libgupnp-av/gupnp-av.h")]
+	public class ProtocolInfo : GLib.Object {
+		[CCode (has_construct_function = false)]
+		public ProtocolInfo.from_string (string protocol_info) throws GLib.Error;
+		public bool is_compatible (GUPnP.ProtocolInfo info2);
+		[CCode (has_construct_function = false)]
+		public ProtocolInfo ();
+		public string to_string ();
+		public GUPnP.DLNAConversion dlna_conversion { get; set; }
+		public GUPnP.DLNAFlags dlna_flags { get; set; }
+		public GUPnP.DLNAOperation dlna_operation { get; set; }
+		public string dlna_profile { get; set; }
+		public string mime_type { get; set; }
+		public string network { get; set; }
+		[CCode (array_length = false, array_null_terminated = true)]
+		public string[] play_speeds { get; set; }
+		public string protocol { get; set; }
+	}
+	[CCode (cheader_filename = "libgupnp-av/gupnp-av.h")]
+	public class SearchCriteriaParser : GLib.Object {
+		public static GLib.Quark error_quark ();
+		[CCode (has_construct_function = false)]
+		public SearchCriteriaParser ();
+		public bool parse_text (string text) throws GLib.Error;
+		public virtual signal void begin_parens ();
+		public virtual signal void conjunction ();
+		public virtual signal void disjunction ();
+		public virtual signal void end_parens ();
+		public signal bool expression (string property, uint op, string value, GLib.Error error);
+	}
+	[CCode (cprefix = "GUPNP_DLNA_CONVERSION_", cheader_filename = "libgupnp-av/gupnp-av.h")]
+	[Flags]
+	public enum DLNAConversion {
+		NONE,
+		TRANSCODED
+	}
+	[CCode (cprefix = "GUPNP_DLNA_FLAGS_", cheader_filename = "libgupnp-av/gupnp-av.h")]
+	[Flags]
+	public enum DLNAFlags {
+		NONE,
+		SENDER_PACED,
+		TIME_BASED_SEEK,
+		BYTE_BASED_SEEK,
+		PLAY_CONTAINER,
+		S0_INCREASE,
+		SN_INCREASE,
+		RTSP_PAUSE,
+		STREAMING_TRANSFER_MODE,
+		INTERACTIVE_TRANSFER_MODE,
+		BACKGROUND_TRANSFER_MODE,
+		CONNECTION_STALL,
+		DLNA_V15
+	}
+	[CCode (cprefix = "GUPNP_DLNA_OPERATION_", cheader_filename = "libgupnp-av/gupnp-av.h")]
+	[Flags]
+	public enum DLNAOperation {
+		NONE,
+		RANGE,
+		TIMESEEK
+	}
+	[CCode (cprefix = "GUPNP_PROTOCOL_ERROR_", has_type_id = "0", cheader_filename = "libgupnp-av/gupnp-av.h")]
+	public enum ProtocolError {
+		INVALID_SYNTAX,
+		OTHER
+	}
+	[CCode (cprefix = "GUPNP_SEARCH_CRITERIA_OP_", has_type_id = "0", cheader_filename = "libgupnp-av/gupnp-av.h")]
+	public enum SearchCriteriaOp {
+		EQ,
+		NEQ,
+		LESS,
+		LEQ,
+		GREATER,
+		GEQ,
+		CONTAINS,
+		DOES_NOT_CONTAIN,
+		DERIVED_FROM,
+		EXISTS
+	}
+	[CCode (cprefix = "GUPNP_SEARCH_CRITERIA_PARSER_ERROR_", cheader_filename = "libgupnp-av/gupnp-av.h")]
+	public errordomain SearchCriteriaParserError {
+		FAILED,
+	}
+	[CCode (cheader_filename = "libgupnp-av/gupnp-av.h")]
+	public static GLib.Quark protocol_error_quark ();
+}
--- /dev/null
+++ b/vapi/sqlite3.vapi
@@ -0,0 +1,207 @@
+/* sqlite3.vala
+ *
+ * Copyright (C) 2007 Jürg Billeter
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA
+ *
+ * Author:
+ * 	Jürg Billeter <j@bitron.ch>
+ */
+
+[CCode (lower_case_cprefix = "sqlite3_", cheader_filename = "sqlite3.h")]
+namespace Sqlite {
+	/* Database Connection Handle */
+	[Compact]
+	[CCode (free_function = "sqlite3_close", cname = "sqlite3", cprefix = "sqlite3_")]
+	public class Database {
+		public int busy_timeout (int ms);
+		public int changes ();
+		public int exec (string sql, Callback? sqlite3_callback = null, out string errmsg = null);
+		public int extended_result_codes (int onoff);
+		public int get_autocommit ();
+		public void interrupt ();
+		public int64 last_insert_rowid ();
+		public int total_changes ();
+
+		public int complete (string sql);
+		public int get_table (string sql, [CCode (array_length = false)] out weak string[] resultp, out int nrow, out int ncolumn, out string errmsg);
+		public static void free_table ([CCode (array_length = false)] string[] result);
+		public static int open (string filename, out Database db);
+		public static int open_v2 (string filename, out Database db, int flags = OPEN_READWRITE | OPEN_CREATE, string? zVfs = null);
+		public int errcode ();
+		public weak string errmsg ();
+		public int prepare (string sql, int n_bytes, out Statement stmt, out string tail = null);
+		public int prepare_v2 (string sql, int n_bytes, out Statement stmt, out string tail = null);
+		public void trace (TraceCallback? xtrace);
+		public void profile (ProfileCallback? xprofile);
+		public void commit_hook (CommitCallback? commit_hook);
+		public void rollback_hook (RollbackCallback? rollback_hook);
+	}
+
+	[CCode (instance_pos = 0)]
+	public delegate void TraceCallback (string message);
+	[CCode (instance_pos = 0)]
+	public delegate void ProfileCallback (string sql, uint64 time);
+	public delegate int CommitCallback ();
+	public delegate void RollbackCallback ();
+
+	/* Dynamically Typed Value Object */
+	[Compact]
+	[CCode (cname = "sqlite3_value")]
+	public class Value {
+		[CCode (cname = "sqlite3_value_blob")]
+		public void* to_blob ();
+		[CCode (cname = "sqlite3_value_bytes")]
+		public int to_bytes ();
+		[CCode (cname = "sqlite3_value_double")]
+		public double to_double ();
+		[CCode (cname = "sqlite3_value_int")]
+		public int to_int ();
+		[CCode (cname = "sqlite3_value_int64")]
+		public int64 to_int64 ();
+		[CCode (cname = "sqlite3_value_text")]
+		public weak string to_text ();
+		[CCode (cname = "sqlite3_value_type")]
+		public int to_type ();
+		[CCode (cname = "sqlite3_value_numeric_type")]
+		public int to_numeric_type ();
+	}
+
+	[CCode (cname = "sqlite3_callback", instance_pos = 0)]
+	public delegate int Callback (int n_columns, [CCode (array_length = false)] string[] values, [CCode (array_length = false)] string[] column_names);
+
+	[CCode (cname = "SQLITE_OK")]
+	public const int OK;
+	[CCode (cname = "SQLITE_ERROR")]
+	public const int ERROR;
+	[CCode (cname = "SQLITE_INTERNAL")]
+	public const int INTERNAL;
+	[CCode (cname = "SQLITE_PERM")]
+	public const int PERM;
+	[CCode (cname = "SQLITE_ABORT")]
+	public const int ABORT;
+	[CCode (cname = "SQLITE_BUSY")]
+	public const int BUSY;
+	[CCode (cname = "SQLITE_LOCKED")]
+	public const int LOCKED;
+	[CCode (cname = "SQLITE_NOMEM")]
+	public const int NOMEM;
+	[CCode (cname = "SQLITE_READONLY")]
+	public const int READONLY;
+	[CCode (cname = "SQLITE_INTERRUPT")]
+	public const int INTERRUPT;
+	[CCode (cname = "SQLITE_IOERR")]
+	public const int IOERR;
+	[CCode (cname = "SQLITE_CORRUPT")]
+	public const int CORRUPT;
+	[CCode (cname = "SQLITE_NOTFOUND")]
+	public const int NOTFOUND;
+	[CCode (cname = "SQLITE_FULL")]
+	public const int FULL;
+	[CCode (cname = "SQLITE_CANTOPEN")]
+	public const int CANTOPEN;
+	[CCode (cname = "SQLITE_PROTOCOL")]
+	public const int PROTOCOL;
+	[CCode (cname = "SQLITE_EMPTY")]
+	public const int EMPTY;
+	[CCode (cname = "SQLITE_SCHEMA")]
+	public const int SCHEMA;
+	[CCode (cname = "SQLITE_TOOBIG")]
+	public const int TOOBIG;
+	[CCode (cname = "SQLITE_CONSTRAINT")]
+	public const int CONSTRAINT;
+	[CCode (cname = "SQLITE_MISMATCH")]
+	public const int MISMATCH;
+	[CCode (cname = "SQLITE_MISUSE")]
+	public const int MISUSE;
+	[CCode (cname = "SQLITE_NOLFS")]
+	public const int NOLFS;
+	[CCode (cname = "SQLITE_AUTH")]
+	public const int AUTH;
+	[CCode (cname = "SQLITE_FORMAT")]
+	public const int FORMAT;
+	[CCode (cname = "SQLITE_RANGE")]
+	public const int RANGE;
+	[CCode (cname = "SQLITE_NOTADB")]
+	public const int NOTADB;
+	[CCode (cname = "SQLITE_ROW")]
+	public const int ROW;
+	[CCode (cname = "SQLITE_DONE")]
+	public const int DONE;
+	[CCode (cname = "SQLITE_OPEN_READONLY")]
+	public const int OPEN_READONLY;
+	[CCode (cname = "SQLITE_OPEN_READWRITE")]
+	public const int OPEN_READWRITE;
+	[CCode (cname = "SQLITE_OPEN_CREATE")]
+	public const int OPEN_CREATE;
+	[CCode (cname = "SQLITE_INTEGER")]
+	public const int INTEGER;
+	[CCode (cname = "SQLITE_FLOAT")]
+	public const int FLOAT;
+	[CCode (cname = "SQLITE_BLOB")]
+	public const int BLOB;
+	[CCode (cname = "SQLITE_NULL")]
+	public const int NULL;
+	[CCode (cname = "SQLITE3_TEXT")]
+	public const int TEXT;
+	[CCode (cname = "SQLITE_MUTEX_FAST")]
+	public const int MUTEX_FAST;
+	[CCode (cname = "SQLITE_MUTEX_RECURSIVE")]
+	public const int MUTEX_RECURSIVE;
+
+	/* SQL Statement Object */
+	[Compact]
+	[CCode (free_function = "sqlite3_finalize", cname = "sqlite3_stmt", cprefix = "sqlite3_")]
+	public class Statement {
+		public int bind_parameter_count ();
+		public int bind_parameter_index (string name);
+		public weak string bind_parameter_name (int index);
+		public int clear_bindings ();
+		public int column_count ();
+		public int data_count ();
+		public weak Database db_handle ();
+		public int reset ();
+		public int step ();
+		public int bind_blob (int index, void* value, int n, GLib.DestroyNotify destroy_notify);
+		public int bind_double (int index, double value);
+		public int bind_int (int index, int value);
+		public int bind_int64 (int index, int64 value);
+		public int bind_null (int index);
+		public int bind_text (int index, owned string value, int n = -1, GLib.DestroyNotify destroy_notify = GLib.g_free);
+		public int bind_value (int index, Value value);
+		public int bind_zeroblob (int index, int n);
+		public void* column_blob (int col);
+		public int column_bytes (int col);
+		public double column_double (int col);
+		public int column_int (int col);
+		public int64 column_int64 (int col);
+		public weak string column_text (int col);
+		public int column_type (int col);
+		public weak Value column_value (int col);
+		public weak string column_name (int index);
+		public weak string sql ();
+	}
+
+	[Compact]
+	[CCode (cname = "sqlite3_mutex")]
+	public class Mutex {
+		[CCode (cname = "sqlite3_mutex_alloc")]
+		public Mutex (int mutex_type = MUTEX_RECURSIVE);
+		public void enter ();
+		public int @try ();
+		public void leave ();
+	}
+}
+
