--- a/configure.ac
+++ b/configure.ac
@@ -21,11 +21,12 @@ AC_PROG_LIBTOOL
 AC_FUNC_MMAP
 
 VALA_REQUIRED=0.7.7
+GLIB_REQUIRED=2.21.3
 GUPNP_REQUIRED=0.13
 GUPNP_AV_REQUIRED=0.5
 GUPNP_VALA_REQUIRED=0.6
 DBUS_GLIB_REQUIRED=0.74
-GSTREAMER_REQUIRED=0.10.23
+VLC_REQUIRED=2.0.5
 GIO_REQUIRED=2.16
 GEE_REQUIRED=0.3.0
 UUID_REQUIRED=1.41.3
@@ -36,10 +37,10 @@ LIBSQLITE3_REQUIRED=3.5
 PKG_CHECK_MODULES(LIBGUPNP, gupnp-1.0 >= $GUPNP_REQUIRED)
 PKG_CHECK_MODULES(LIBGUPNP_AV, gupnp-av-1.0 >= $GUPNP_AV_REQUIRED)
 PKG_CHECK_MODULES(LIBDBUS_GLIB, dbus-glib-1 >= $DBUS_GLIB_REQUIRED)
-PKG_CHECK_MODULES(LIBGSTREAMER, gstreamer-0.10 >= $GSTREAMER_REQUIRED)
+PKG_CHECK_MODULES(LIBVLC, libvlc >= $VLC_REQUIRED)
+PKG_CHECK_MODULES(LIBGLIB, glib-2.0 >= $GLIB_REQUIRED)
 PKG_CHECK_MODULES(LIBGIO, gio-2.0 >= $GIO_REQUIRED)
 PKG_CHECK_MODULES(GEE, gee-1.0 >= $GEE_REQUIRED)
-PKG_CHECK_MODULES(UUID, uuid >= $UUID_REQUIRED)
 PKG_CHECK_MODULES(LIBSOUP, libsoup-2.4 >= $LIBSOUP_REQUIRED)
 PKG_CHECK_MODULES(LIBSQLITE3, sqlite3 >= $LIBSQLITE3_REQUIRED)
 
@@ -60,37 +61,8 @@ if test x$enable_vala = xyes ; then
         AC_MSG_ERROR([Cannot find the "valac" compiler in your PATH])
     fi
 
-    PKG_CHECK_MODULES(GUPNP_VALA, gupnp-vala-1.0 >= $GUPNP_VALA_REQUIRED)
     VAPIDIR=`pkg-config --variable=vapidir vala-1.0`
 
-    # FIXME: Whats the proper way for checking for particular Vala bindings
-    AC_CHECK_FILE("${VAPIDIR}/gupnp-1.0.vapi",
-                  true,
-                  [AC_MSG_ERROR("Unable to find Vala bindings for gupnp-1.0")])
-
-    AC_CHECK_FILE("${VAPIDIR}/gupnp-av-1.0.vapi",
-                  true,
-                  [AC_MSG_ERROR("Unable to find Vala bindings for gupnp-av-1.0")])
-
-    AC_CHECK_FILE("${VAPIDIR}/dbus-glib-1.vapi",
-                  true,
-                  [AC_MSG_ERROR("Unable to find Vala bindings for dbus-glib-1")])
-
-    AC_CHECK_FILE("${VAPIDIR}/gstreamer-0.10.vapi",
-                  true,
-                  [AC_MSG_ERROR("Unable to find Vala bindings for gstreamer-0.10")])
-
-    AC_CHECK_FILE("${VAPIDIR}/gio-2.0.vapi",
-                  true,
-                  [AC_MSG_ERROR("Unable to find Vala bindings for gio-2.0")])
-
-    AC_CHECK_FILE("${VAPIDIR}/gee-1.0.vapi",
-                  true,
-                  [AC_MSG_ERROR("Unable to find Vala bindings for gee-1.0")])
-
-    AC_CHECK_FILE("${VAPIDIR}/sqlite3.vapi",
-                  true,
-                  [AC_MSG_ERROR("Unable to find Vala bindings for sqlite3")])
 else
     VAPIDIR=`echo ${datadir}/vala/vapi`
 fi
@@ -202,6 +174,11 @@ AC_ARG_ENABLE(gstlaunch-plugin,
 	[  --enable-gstlaunch-plugin          build Gstreamer launchline plugin],,
         enable_gstlaunch_plugin=no)
 
+# Build GstRenderer plugin
+AC_ARG_ENABLE(gst-renderer-plugin,
+	[  --enable-gst-renderer-plugin       build renderer plugin],,
+        enable_gst_renderer_plugin=no)
+
 
 AC_SUBST(abs_top_builddir)
 
@@ -214,6 +191,7 @@ AM_CONDITIONAL([BUILD_MEDIATHEK_PLUGIN],
 AM_CONDITIONAL([BUILD_MEDIA_EXPORT_PLUGIN], [test "x$enable_media_export_plugin" = "xyes"])
 AM_CONDITIONAL([BUILD_EXTERNAL_PLUGIN], [test "x$enable_external_plugin" = "xyes"])
 AM_CONDITIONAL([BUILD_GSTLAUNCH_PLUGIN], [test "x$enable_gstlaunch_plugin" = "xyes"])
+AM_CONDITIONAL([BUILD_GST_RENDERER_PLUGIN], [test "x$enable_gst_renderer_plugin" = "xyes"])
 
 # Gettext
 GETTEXT_PACKAGE=rygel
@@ -239,6 +217,7 @@ src/plugins/external/Makefile
 src/plugins/gstlaunch/Makefile
 src/plugins/mediathek/Makefile
 src/plugins/tracker/Makefile
+src/plugins/gst-renderer/Makefile
 src/plugins/test/Makefile
 data/Makefile
 data/xml/Makefile
@@ -265,4 +244,5 @@ echo "
         media-export            ${enable_media_export_plugin}
         external:               ${enable_external_plugin}
         gstlaunch:              ${enable_gstlaunch_plugin}
+        gst-renderer:           ${enable_gst_renderer_plugin}
 "
--- /dev/null
+++ b/data/xml/AVTransport.xml
@@ -0,0 +1,483 @@
+<?xml version="1.0" encoding="utf-8"?>
+<scpd xmlns="urn:schemas-upnp-org:service-1-0">
+<specVersion>
+<major>1</major>
+<minor>0</minor>
+</specVersion>
+	<serviceStateTable>
+		<stateVariable sendEvents="no">
+			<name>TransportState</name>
+			<dataType>string</dataType>
+			<defaultValue>NO_MEDIA_PRESENT</defaultValue>
+			<allowedValueList>
+				<allowedValue>STOPPED</allowedValue>
+				<allowedValue>PLAYING</allowedValue>
+				<allowedValue>PAUSED_PLAYBACK</allowedValue>
+				<allowedValue>TRANSITIONING</allowedValue>
+				<allowedValue>NO_MEDIA_PRESENT</allowedValue>
+			</allowedValueList>
+		</stateVariable>
+		<stateVariable sendEvents="no">
+			<name>TransportStatus</name>
+			<dataType>string</dataType>
+			<defaultValue>OK</defaultValue>
+			<allowedValueList>
+				<allowedValue>OK</allowedValue>
+				<allowedValue>ERROR_OCCURRED</allowedValue>
+			</allowedValueList>
+		</stateVariable>
+		<stateVariable sendEvents="no">
+			<name>CurrentTransportActions</name>
+			<dataType>string</dataType>
+			<defaultValue></defaultValue>
+		</stateVariable>
+		<stateVariable sendEvents="no">
+			<name>PlaybackStorageMedium</name>
+			<dataType>string</dataType>
+			<defaultValue></defaultValue>
+		</stateVariable>
+		<stateVariable sendEvents="no">
+			<name>RecordStorageMedium</name>
+			<dataType>string</dataType>
+			<defaultValue></defaultValue>
+		</stateVariable>
+		<stateVariable sendEvents="no">
+			<name>PossiblePlaybackStorageMedia</name>
+			<dataType>string</dataType>
+			<defaultValue></defaultValue>
+		</stateVariable>
+		<stateVariable sendEvents="no">
+			<name>PossibleRecordStorageMedia</name>
+			<dataType>string</dataType>
+			<defaultValue></defaultValue>
+		</stateVariable>
+		<stateVariable sendEvents="no">
+			<name>CurrentPlayMode</name>
+			<dataType>string</dataType>
+			<defaultValue>NORMAL</defaultValue>
+			<allowedValueList>
+				<allowedValue>NORMAL</allowedValue>
+			</allowedValueList>
+			<defaultValue>NORMAL</defaultValue>
+		</stateVariable>
+		<stateVariable sendEvents="no">
+			<name>TransportPlaySpeed</name>
+			<dataType>string</dataType>
+			<defaultValue>1</defaultValue>
+			<allowedValueList>
+				<allowedValue>1</allowedValue>
+			</allowedValueList>
+			<defaultValue>1</defaultValue>
+		</stateVariable>
+		<stateVariable sendEvents="no">
+			<name>RecordMediumWriteStatus</name>
+			<dataType>string</dataType>
+			<defaultValue>NOT_IMPLEMENTED</defaultValue>
+			<allowedValueList>
+				<allowedValue>NOT_IMPLEMENTED</allowedValue>
+			</allowedValueList>
+		</stateVariable>
+		<stateVariable sendEvents="no">
+			<name>CurrentRecordQualityMode</name>
+			<dataType>string</dataType>
+			<defaultValue></defaultValue>
+		</stateVariable>
+		<stateVariable sendEvents="no">
+			<name>PossibleRecordQualityModes</name>
+			<dataType>string</dataType>
+			<defaultValue></defaultValue>
+		</stateVariable>
+		<stateVariable sendEvents="no">
+			<name>NumberOfTracks</name>
+			<dataType>ui4</dataType>
+			<defaultValue>0</defaultValue>
+			<allowedValueRange>
+				<minimum>0</minimum>
+				<maximum>1</maximum>
+			</allowedValueRange>
+		</stateVariable>
+		<stateVariable sendEvents="no">
+			<name>CurrentTrack</name>
+			<dataType>ui4</dataType>
+			<defaultValue>0</defaultValue>
+			<allowedValueRange>
+				<minimum>0</minimum>
+				<maximum>1</maximum>
+				<step>1</step>
+			</allowedValueRange>
+		</stateVariable>
+		<stateVariable sendEvents="no">
+			<name>CurrentTrackDuration</name>
+			<dataType>string</dataType>
+			<defaultValue>00:00:00</defaultValue>
+		</stateVariable>
+		<stateVariable sendEvents="no">
+			<name>CurrentMediaDuration</name>
+			<dataType>string</dataType>
+			<defaultValue>00:00:00</defaultValue>
+		</stateVariable>
+		<stateVariable sendEvents="no">
+			<name>CurrentTrackMetaData</name>
+			<dataType>string</dataType>
+			<defaultValue></defaultValue>
+		</stateVariable>
+		<stateVariable sendEvents="no">
+			<name>AVTransportURIMetaData</name>
+			<dataType>string</dataType>
+			<defaultValue></defaultValue>
+		</stateVariable>
+		<stateVariable sendEvents="no">
+			<name>CurrentTrackURI</name>
+			<dataType>string</dataType>
+			<defaultValue></defaultValue>
+		</stateVariable>
+		<stateVariable sendEvents="no">
+			<name>AVTransportURI</name>
+			<dataType>string</dataType>
+			<defaultValue></defaultValue>
+		</stateVariable>
+		<stateVariable sendEvents="no">
+			<name>NextAVTransportURI</name>
+			<dataType>string</dataType>
+			<defaultValue></defaultValue>
+		</stateVariable>
+		<stateVariable sendEvents="no">
+			<name>NextAVTransportURIMetaData</name>
+			<dataType>string</dataType>
+			<defaultValue></defaultValue>
+		</stateVariable>
+		<stateVariable sendEvents="no">
+			<name>RelativeTimePosition</name>
+			<dataType>string</dataType>
+			<defaultValue>00:00:00</defaultValue>
+		</stateVariable>
+		<stateVariable sendEvents="no">
+			<name>AbsoluteTimePosition</name>
+			<dataType>string</dataType>
+			<defaultValue>00:00:00</defaultValue>
+		</stateVariable>
+		<stateVariable sendEvents="no">
+			<name>RelativeCounterPosition</name>
+			<dataType>i4</dataType>
+			<defaultValue>0</defaultValue>
+		</stateVariable>
+		<stateVariable sendEvents="no">
+			<name>AbsoluteCounterPosition</name>
+			<dataType>i4</dataType>
+			<defaultValue>0</defaultValue>
+		</stateVariable>
+		<stateVariable sendEvents="yes">
+			<name>LastChange</name>
+			<dataType>string</dataType>
+			<defaultValue></defaultValue>
+		</stateVariable>
+		<stateVariable sendEvents="no">
+			<name>A_ARG_TYPE_SeekMode</name>
+			<dataType>string</dataType>
+			<defaultValue>ABS_TIME</defaultValue>
+			<allowedValueList>
+				<allowedValue>ABS_TIME</allowedValue>
+				<allowedValue>REL_TIME</allowedValue>
+				<allowedValue>TRACK_NR</allowedValue>
+			</allowedValueList>
+		</stateVariable>
+		<stateVariable sendEvents="no">
+			<name>A_ARG_TYPE_SeekTarget</name>
+			<dataType>string</dataType>
+			<defaultValue></defaultValue>
+		</stateVariable>
+		<stateVariable sendEvents="no">
+			<name>A_ARG_TYPE_InstanceID</name>
+			<dataType>ui4</dataType>
+			<defaultValue>0</defaultValue>
+		</stateVariable>
+	</serviceStateTable>
+	<actionList>
+		<action>
+			<name>SetAVTransportURI</name>
+			<argumentList>
+				<argument>
+					<name>InstanceID</name>
+					<direction>in</direction>
+					<relatedStateVariable>A_ARG_TYPE_InstanceID</relatedStateVariable>
+				</argument>
+				<argument>
+					<name>CurrentURI</name>
+					<direction>in</direction>
+					<relatedStateVariable>AVTransportURI</relatedStateVariable>
+				</argument>
+				<argument>
+					<name>CurrentURIMetaData</name>
+					<direction>in</direction>
+					<relatedStateVariable>AVTransportURIMetaData</relatedStateVariable>
+				</argument>
+			</argumentList>
+		</action>
+		<action>
+			<name>GetCurrentTransportActions</name>
+			<argumentList>
+				<argument>
+					<name>InstanceID</name>
+					<direction>in</direction>
+					<relatedStateVariable>A_ARG_TYPE_InstanceID</relatedStateVariable>
+				</argument>
+				<argument>
+					<name>Actions</name>
+					<direction>out</direction>
+					<relatedStateVariable>CurrentTransportActions</relatedStateVariable>
+				</argument>
+			</argumentList>
+		</action>
+		<action>
+			<name>GetMediaInfo</name>
+			<argumentList>
+				<argument>
+					<name>InstanceID</name>
+					<direction>in</direction>
+					<relatedStateVariable>A_ARG_TYPE_InstanceID</relatedStateVariable>
+				</argument>
+				<argument>
+					<name>NrTracks</name>
+					<direction>out</direction>
+					<relatedStateVariable>NumberOfTracks</relatedStateVariable>
+				</argument>
+				<argument>
+					<name>MediaDuration</name>
+					<direction>out</direction>
+					<relatedStateVariable>CurrentMediaDuration</relatedStateVariable>
+				</argument>
+				<argument>
+					<name>CurrentURI</name>
+					<direction>out</direction>
+					<relatedStateVariable>AVTransportURI</relatedStateVariable>
+				</argument>
+				<argument>
+					<name>CurrentURIMetaData</name>
+					<direction>out</direction>
+					<relatedStateVariable>AVTransportURIMetaData</relatedStateVariable>
+				</argument>
+				<argument>
+					<name>NextURI</name>
+					<direction>out</direction>
+					<relatedStateVariable>NextAVTransportURI</relatedStateVariable>
+				</argument>
+				<argument>
+					<name>NextURIMetaData</name>
+					<direction>out</direction>
+					<relatedStateVariable>NextAVTransportURIMetaData</relatedStateVariable>
+				</argument>
+				<argument>
+					<name>PlayMedium</name>
+					<direction>out</direction>
+					<relatedStateVariable>PlaybackStorageMedium</relatedStateVariable>
+				</argument>
+				<argument>
+					<name>RecordMedium</name>
+					<direction>out</direction>
+					<relatedStateVariable>RecordStorageMedium</relatedStateVariable>
+				</argument>
+				<argument>
+					<name>WriteStatus</name>
+					<direction>out</direction>
+					<relatedStateVariable>RecordMediumWriteStatus</relatedStateVariable>
+				</argument>
+			</argumentList>
+		</action>
+		<action>
+			<name>GetTransportInfo</name>
+			<argumentList>
+				<argument>
+					<name>InstanceID</name>
+					<direction>in</direction>
+					<relatedStateVariable>A_ARG_TYPE_InstanceID</relatedStateVariable>
+				</argument>
+				<argument>
+					<name>CurrentTransportState</name>
+					<direction>out</direction>
+					<relatedStateVariable>TransportState</relatedStateVariable>
+				</argument>
+				<argument>
+					<name>CurrentTransportStatus</name>
+					<direction>out</direction>
+					<relatedStateVariable>TransportStatus</relatedStateVariable>
+				</argument>
+				<argument>
+					<name>CurrentSpeed</name>
+					<direction>out</direction>
+					<relatedStateVariable>TransportPlaySpeed</relatedStateVariable>
+				</argument>
+			</argumentList>
+		</action>
+		<action>
+			<name>GetPositionInfo</name>
+			<argumentList>
+				<argument>
+					<name>InstanceID</name>
+					<direction>in</direction>
+					<relatedStateVariable>A_ARG_TYPE_InstanceID</relatedStateVariable>
+				</argument>
+				<argument>
+					<name>Track</name>
+					<direction>out</direction>
+					<relatedStateVariable>CurrentTrack</relatedStateVariable>
+				</argument>
+				<argument>
+					<name>TrackDuration</name>
+					<direction>out</direction>
+					<relatedStateVariable>CurrentTrackDuration</relatedStateVariable>
+				</argument>
+				<argument>
+					<name>TrackMetaData</name>
+					<direction>out</direction>
+					<relatedStateVariable>CurrentTrackMetaData</relatedStateVariable>
+				</argument>
+				<argument>
+					<name>TrackURI</name>
+					<direction>out</direction>
+					<relatedStateVariable>CurrentTrackURI</relatedStateVariable>
+				</argument>
+				<argument>
+					<name>RelTime</name>
+					<direction>out</direction>
+					<relatedStateVariable>RelativeTimePosition</relatedStateVariable>
+				</argument>
+				<argument>
+					<name>AbsTime</name>
+					<direction>out</direction>
+					<relatedStateVariable>AbsoluteTimePosition</relatedStateVariable>
+				</argument>
+				<argument>
+					<name>RelCount</name>
+					<direction>out</direction>
+					<relatedStateVariable>RelativeCounterPosition</relatedStateVariable>
+				</argument>
+				<argument>
+					<name>AbsCount</name>
+					<direction>out</direction>
+					<relatedStateVariable>AbsoluteCounterPosition</relatedStateVariable>
+				</argument>
+			</argumentList>
+		</action>
+		<action>
+			<name>GetDeviceCapabilities</name>
+			<argumentList>
+				<argument>
+					<name>InstanceID</name>
+					<direction>in</direction>
+					<relatedStateVariable>A_ARG_TYPE_InstanceID</relatedStateVariable>
+				</argument>
+				<argument>
+					<name>PlayMedia</name>
+					<direction>out</direction>
+					<relatedStateVariable>PossiblePlaybackStorageMedia</relatedStateVariable>
+				</argument>
+				<argument>
+					<name>RecMedia</name>
+					<direction>out</direction>
+					<relatedStateVariable>PossibleRecordStorageMedia</relatedStateVariable>
+				</argument>
+				<argument>
+					<name>RecQualityModes</name>
+					<direction>out</direction>
+					<relatedStateVariable>PossibleRecordQualityModes</relatedStateVariable>
+				</argument>
+			</argumentList>
+		</action>
+		<action>
+			<name>GetTransportSettings</name>
+			<argumentList>
+				<argument>
+					<name>InstanceID</name>
+					<direction>in</direction>
+					<relatedStateVariable>A_ARG_TYPE_InstanceID</relatedStateVariable>
+				</argument>
+				<argument>
+					<name>PlayMode</name>
+					<direction>out</direction>
+					<relatedStateVariable>CurrentPlayMode</relatedStateVariable>
+				</argument>
+				<argument>
+					<name>RecQualityMode</name>
+					<direction>out</direction>
+					<relatedStateVariable>CurrentRecordQualityMode</relatedStateVariable>
+				</argument>
+			</argumentList>
+		</action>
+		<action>
+			<name>Stop</name>
+			<argumentList>
+				<argument>
+					<name>InstanceID</name>
+					<direction>in</direction>
+					<relatedStateVariable>A_ARG_TYPE_InstanceID</relatedStateVariable>
+				</argument>
+			</argumentList>
+		</action>
+		<action>
+			<name>Play</name>
+			<argumentList>
+				<argument>
+					<name>InstanceID</name>
+					<direction>in</direction>
+					<relatedStateVariable>A_ARG_TYPE_InstanceID</relatedStateVariable>
+				</argument>
+				<argument>
+					<name>Speed</name>
+					<direction>in</direction>
+					<relatedStateVariable>TransportPlaySpeed</relatedStateVariable>
+				</argument>
+			</argumentList>
+		</action>
+		<action>
+			<name>Pause</name>
+			<argumentList>
+				<argument>
+					<name>InstanceID</name>
+					<direction>in</direction>
+					<relatedStateVariable>A_ARG_TYPE_InstanceID</relatedStateVariable>
+				</argument>
+			</argumentList>
+		</action>
+		<action>
+			<name>Seek</name>
+			<argumentList>
+				<argument>
+					<name>InstanceID</name>
+					<direction>in</direction>
+					<relatedStateVariable>A_ARG_TYPE_InstanceID</relatedStateVariable>
+				</argument>
+				<argument>
+					<name>Unit</name>
+					<direction>in</direction>
+					<relatedStateVariable>A_ARG_TYPE_SeekMode</relatedStateVariable>
+				</argument>
+				<argument>
+					<name>Target</name>
+					<direction>in</direction>
+					<relatedStateVariable>A_ARG_TYPE_SeekTarget</relatedStateVariable>
+				</argument>
+			</argumentList>
+		</action>
+		<action>
+			<name>Next</name>
+			<argumentList>
+				<argument>
+					<name>InstanceID</name>
+					<direction>in</direction>
+					<relatedStateVariable>A_ARG_TYPE_InstanceID</relatedStateVariable>
+				</argument>
+			</argumentList>
+		</action>
+		<action>
+			<name>Previous</name>
+			<argumentList>
+				<argument>
+					<name>InstanceID</name>
+					<direction>in</direction>
+					<relatedStateVariable>A_ARG_TYPE_InstanceID</relatedStateVariable>
+				</argument>
+			</argumentList>
+		</action>
+	</actionList>
+</scpd>
+
--- a/data/xml/ConnectionManager.xml
+++ b/data/xml/ConnectionManager.xml
@@ -1,4 +1,4 @@
-<?xml version="1.0"?>
+<?xml version="1.0" encoding="utf-8"?>
 <!--============================================================
 Title: UPnP AV Connection Manager Service (CM) Template
 
@@ -13,29 +13,30 @@ This includes disabling any automatic ta
 feature provided by your editor.
 ================================================================-->
 <scpd xmlns="urn:schemas-upnp-org:service-1-0">
+<specVersion>
+<major>1</major>
+<minor>0</minor>
+</specVersion>
 	<serviceStateTable>
-		<stateVariable>
+		<stateVariable sendEvents="yes">
 			<name>SourceProtocolInfo</name>
-			<sendEventsAttribute>yes</sendEventsAttribute>
 			<dataType>string</dataType>
+			<defaultValue></defaultValue>
 		</stateVariable>
-
-		<stateVariable>
+		<stateVariable sendEvents="yes">
 			<name>SinkProtocolInfo</name>
-			<sendEventsAttribute>yes</sendEventsAttribute>
 			<dataType>string</dataType>
+			<defaultValue></defaultValue>
 		</stateVariable>
-
-		<stateVariable>
+		<stateVariable sendEvents="yes">
 			<name>CurrentConnectionIDs</name>
-			<sendEventsAttribute>yes</sendEventsAttribute>
 			<dataType>string</dataType>
+			<defaultValue></defaultValue>
 		</stateVariable>
-
-		<stateVariable>
+		<stateVariable sendEvents="no">
 			<name>A_ARG_TYPE_ConnectionStatus</name>
-			<sendEventsAttribute>no</sendEventsAttribute>
 			<dataType>string</dataType>
+			<defaultValue>Unknown</defaultValue>
 			<allowedValueList>
 				<allowedValue>OK</allowedValue>
 				<allowedValue>ContentFormatMismatch</allowedValue>
@@ -44,48 +45,41 @@ feature provided by your editor.
 				<allowedValue>Unknown</allowedValue>
 			</allowedValueList>
 		</stateVariable>
-
-		<stateVariable>
+		<stateVariable sendEvents="no">
 			<name>A_ARG_TYPE_ConnectionManager</name>
-			<sendEventsAttribute>no</sendEventsAttribute>
 			<dataType>string</dataType>
+			<defaultValue></defaultValue>
 		</stateVariable>
-
-		<stateVariable>
+		<stateVariable sendEvents="no">
 			<name>A_ARG_TYPE_Direction</name>
-			<sendEventsAttribute>no</sendEventsAttribute>
 			<dataType>string</dataType>
+			<defaultValue></defaultValue>
 			<allowedValueList>
 				<allowedValue>Input</allowedValue>
 				<allowedValue>Output</allowedValue>
 			</allowedValueList>
 		</stateVariable>
-
-		<stateVariable>
+		<stateVariable sendEvents="no">
 			<name>A_ARG_TYPE_ProtocolInfo</name>
-			<sendEventsAttribute>no</sendEventsAttribute>
 			<dataType>string</dataType>
+			<defaultValue></defaultValue>
 		</stateVariable>
-
-		<stateVariable>
+		<stateVariable sendEvents="no">
 			<name>A_ARG_TYPE_ConnectionID</name>
-			<sendEventsAttribute>no</sendEventsAttribute>
 			<dataType>i4</dataType>
+			<defaultValue>0</defaultValue>
 		</stateVariable>
-
-		<stateVariable>
+		<stateVariable sendEvents="no">
 			<name>A_ARG_TYPE_AVTransportID</name>
-			<sendEventsAttribute>no</sendEventsAttribute>
 			<dataType>i4</dataType>
+			<defaultValue>0</defaultValue>
 		</stateVariable>
-
-		<stateVariable>
+		<stateVariable sendEvents="no">
 			<name>A_ARG_TYPE_RcsID</name>
-			<sendEventsAttribute>no</sendEventsAttribute>
 			<dataType>i4</dataType>
+			<defaultValue>0</defaultValue>
 		</stateVariable>
 	</serviceStateTable>
-
 	<actionList>
 		<action>
 			<name>GetProtocolInfo</name>
@@ -102,61 +96,6 @@ feature provided by your editor.
 				</argument>
 			</argumentList>
 		</action>
-
-		<action>
-			<Optional/>
-			<name>PrepareForConnection</name>
-			<argumentList>
-				<argument>
-					<name>RemoteProtocolInfo</name>
-					<direction>in</direction>
-					<relatedStateVariable>A_ARG_TYPE_ProtocolInfo</relatedStateVariable>
-				</argument>
-				<argument>
-					<name>PeerConnectionManager</name>
-					<direction>in</direction>
-					<relatedStateVariable>A_ARG_TYPE_ConnectionManager</relatedStateVariable>
-				</argument>
-				<argument>
-					<name>PeerConnectionID</name>
-					<direction>in</direction>
-					<relatedStateVariable>A_ARG_TYPE_ConnectionID</relatedStateVariable>
-				</argument>
-				<argument>
-					<name>Direction</name>
-					<direction>in</direction>
-					<relatedStateVariable>A_ARG_TYPE_Direction</relatedStateVariable>
-				</argument>
-				<argument>
-					<name>ConnectionID</name>
-					<direction>out</direction>
-					<relatedStateVariable>A_ARG_TYPE_ConnectionID</relatedStateVariable>
-				</argument>
-				<argument>
-					<name>AVTransportID</name>
-					<direction>out</direction>
-					<relatedStateVariable>A_ARG_TYPE_AVTransportID</relatedStateVariable>
-				</argument>
-				<argument>
-					<name>RcsID</name>
-					<direction>out</direction>
-					<relatedStateVariable>A_ARG_TYPE_RcsID</relatedStateVariable>
-				</argument>
-			</argumentList>
-		</action>
-
-		<action>
-			<Optional/>
-			<name>ConnectionComplete</name>
-			<argumentList>
-				<argument>
-					<name>ConnectionID</name>
-					<direction>in</direction>
-					<relatedStateVariable>A_ARG_TYPE_ConnectionID</relatedStateVariable>
-				</argument>
-			</argumentList>
-		</action>
-
 		<action>
 			<name>GetCurrentConnectionIDs</name>
 			<argumentList>
@@ -167,7 +106,6 @@ feature provided by your editor.
 				</argument>
 			</argumentList>
 		</action>
-
 		<action>
 			<name>GetCurrentConnectionInfo</name>
 			<argumentList>
--- a/data/xml/Makefile.am
+++ b/data/xml/Makefile.am
@@ -1,6 +1,9 @@
 xml_DATA = MediaServer2.xml \
+	   MediaRenderer.xml \
 	   ContentDirectory.xml \
-	   ConnectionManager.xml
+	   ConnectionManager.xml \
+	   AVTransport.xml \
+	   RenderingControl.xml
 
 xmldir = $(datadir)/rygel/xml
 
--- /dev/null
+++ b/data/xml/MediaRenderer.xml
@@ -0,0 +1,59 @@
+<?xml version="1.0" encoding="utf-8"?>
+<root xmlns="urn:schemas-upnp-org:device-1-0" xmlns:dlna="urn:schemas-dlna-org:device-1-0"
+      xmlns:pnpx="http://schemas.microsoft.com/windows/pnpx/2005/11"
+      xmlns:df="http://schemas.microsoft.com/windows/2008/09/devicefoundation">
+	<specVersion>
+		<major>1</major>
+		<minor>0</minor>
+	</specVersion>
+	<device>
+		<presentationURL></presentationURL>
+		<deviceType>urn:schemas-upnp-org:device:MediaRenderer:1</deviceType>
+		<friendlyName>Skifta Audio Module</friendlyName>
+		<manufacturer>Qualcomm Atheros</manufacturer>
+		<manufacturerURL>http://www.atheros.com</manufacturerURL>
+		<modelName>Skifta Audio Module</modelName>
+		<modelNumber>1.0</modelNumber>
+		<modelDescription>Skifta Audio Module</modelDescription>
+		<modelURL>http://www.atheros.com</modelURL>
+		<UDN></UDN>
+		<serviceList>
+		</serviceList>
+		<dlna:X_DLNADOC>DMR-1.50</dlna:X_DLNADOC>
+		<dlna:X_DLNACAP></dlna:X_DLNACAP>
+		<pnpx:X_compatibleId>MS_DigitalMediaDeviceClass_DMR_V001</pnpx:X_compatibleId>
+		<pnpx:X_deviceCategory>MediaDevices MediaDevices.Speakers</pnpx:X_deviceCategory>
+		<pnpx:X_hardwareId>VEN_0033&amp;DEV_0003&amp;REV_10</pnpx:X_hardwareId>
+		<df:X_deviceCategory>Multimedia.DMR Audio.Speakers.Wireless</df:X_deviceCategory>
+		<iconList>
+			<icon>
+				<mimetype>image/jpeg</mimetype>
+				<width>48</width>
+				<height>48</height>
+				<depth>24</depth>
+				<url>xml/Skifta_icon_SM.jpg</url>
+			</icon>
+			<icon>
+				<mimetype>image/jpeg</mimetype>
+				<width>120</width>
+				<height>120</height>
+				<depth>24</depth>
+				<url>xml/Skifta_icon_LRG.jpg</url>
+			</icon>
+			<icon>
+				<mimetype>image/png</mimetype>
+				<width>48</width>
+				<height>48</height>
+				<depth>24</depth>
+				<url>xml/Skifta_icon_SM.png</url>
+			</icon>
+			<icon>
+				<mimetype>image/png</mimetype>
+				<width>120</width>
+				<height>120</height>
+				<depth>24</depth>
+				<url>xml/Skifta_icon_LRG.png</url>
+			</icon>
+		</iconList>
+	</device>
+</root>
--- /dev/null
+++ b/data/xml/RenderingControl.xml
@@ -0,0 +1,167 @@
+<?xml version="1.0" encoding="utf-8"?>
+<scpd xmlns="urn:schemas-upnp-org:service-1-0">
+<specVersion>
+<major>1</major>
+<minor>0</minor>
+</specVersion>
+	<serviceStateTable>
+		<stateVariable sendEvents="yes">
+			<name>LastChange</name>
+			<dataType>string</dataType>
+			<defaultValue></defaultValue>
+		</stateVariable>
+		<stateVariable sendEvents="no">
+			<name>PresetNameList</name>
+			<dataType>string</dataType>
+			<defaultValue></defaultValue>
+		</stateVariable>
+		<stateVariable sendEvents="no">
+			<name>Mute</name>
+			<dataType>boolean</dataType>
+			<defaultValue>0</defaultValue>
+		</stateVariable>
+		<stateVariable sendEvents="no">
+			<name>Volume</name>
+			<dataType>ui2</dataType>
+			<defaultValue>50</defaultValue>
+			<allowedValueRange>
+				<minimum>0</minimum>
+				<maximum>100</maximum>
+				<step>1</step>
+			</allowedValueRange>
+		</stateVariable>
+		<stateVariable sendEvents="no">
+			<name>A_ARG_TYPE_Channel</name>
+			<dataType>string</dataType>
+			<defaultValue>Master</defaultValue>
+			<allowedValueList>
+				<allowedValue>Master</allowedValue>
+			</allowedValueList>
+		</stateVariable>
+		<stateVariable sendEvents="no">
+			<name>A_ARG_TYPE_InstanceID</name>
+			<dataType>ui4</dataType>
+			<defaultValue>0</defaultValue>
+		</stateVariable>
+		<stateVariable sendEvents="no">
+			<name>A_ARG_TYPE_PresetName</name>
+			<dataType>string</dataType>
+			<defaultValue>FactoryDefaults</defaultValue>
+			<allowedValueList>
+				<allowedValue>FactoryDefaults</allowedValue>
+			</allowedValueList>
+		</stateVariable>
+	</serviceStateTable>
+	<actionList>
+		<action>
+			<name>ListPresets</name>
+			<argumentList>
+				<argument>
+					<name>InstanceID</name>
+					<direction>in</direction>
+					<relatedStateVariable>A_ARG_TYPE_InstanceID</relatedStateVariable>
+				</argument>
+				<argument>
+					<name>CurrentPresetNameList</name>
+					<direction>out</direction>
+					<relatedStateVariable>PresetNameList</relatedStateVariable>
+				</argument>
+			</argumentList>
+		</action>
+		<action>
+			<name>SelectPreset</name>
+			<argumentList>
+				<argument>
+					<name>InstanceID</name>
+					<direction>in</direction>
+					<relatedStateVariable>A_ARG_TYPE_InstanceID</relatedStateVariable>
+				</argument>
+				<argument>
+					<name>PresetName</name>
+					<direction>in</direction>
+					<relatedStateVariable>A_ARG_TYPE_PresetName</relatedStateVariable>
+				</argument>
+			</argumentList>
+		</action>
+		<action>
+			<name>GetMute</name>
+			<argumentList>
+				<argument>
+					<name>InstanceID</name>
+					<direction>in</direction>
+					<relatedStateVariable>A_ARG_TYPE_InstanceID</relatedStateVariable>
+				</argument>
+				<argument>
+					<name>Channel</name>
+					<direction>in</direction>
+					<relatedStateVariable>A_ARG_TYPE_Channel</relatedStateVariable>
+				</argument>
+				<argument>
+					<name>CurrentMute</name>
+					<direction>out</direction>
+					<relatedStateVariable>Mute</relatedStateVariable>
+				</argument>
+			</argumentList>
+		</action>
+		<action>
+			<name>SetMute</name>
+			<argumentList>
+				<argument>
+					<name>InstanceID</name>
+					<direction>in</direction>
+					<relatedStateVariable>A_ARG_TYPE_InstanceID</relatedStateVariable>
+				</argument>
+				<argument>
+					<name>Channel</name>
+					<direction>in</direction>
+					<relatedStateVariable>A_ARG_TYPE_Channel</relatedStateVariable>
+				</argument>
+				<argument>
+					<name>DesiredMute</name>
+					<direction>in</direction>
+					<relatedStateVariable>Mute</relatedStateVariable>
+				</argument>
+			</argumentList>
+		</action>
+		<action>
+			<name>GetVolume</name>
+			<argumentList>
+				<argument>
+					<name>InstanceID</name>
+					<direction>in</direction>
+					<relatedStateVariable>A_ARG_TYPE_InstanceID</relatedStateVariable>
+				</argument>
+				<argument>
+					<name>Channel</name>
+					<direction>in</direction>
+					<relatedStateVariable>A_ARG_TYPE_Channel</relatedStateVariable>
+				</argument>
+				<argument>
+					<name>CurrentVolume</name>
+					<direction>out</direction>
+					<relatedStateVariable>Volume</relatedStateVariable>
+				</argument>
+			</argumentList>
+		</action>
+		<action>
+			<name>SetVolume</name>
+			<argumentList>
+				<argument>
+					<name>InstanceID</name>
+					<direction>in</direction>
+					<relatedStateVariable>A_ARG_TYPE_InstanceID</relatedStateVariable>
+				</argument>
+				<argument>
+					<name>Channel</name>
+					<direction>in</direction>
+					<relatedStateVariable>A_ARG_TYPE_Channel</relatedStateVariable>
+				</argument>
+				<argument>
+					<name>DesiredVolume</name>
+					<direction>in</direction>
+					<relatedStateVariable>Volume</relatedStateVariable>
+				</argument>
+			</argumentList>
+		</action>
+	</actionList>
+</scpd>
--- a/src/plugins/Makefile.am
+++ b/src/plugins/Makefile.am
@@ -22,11 +22,16 @@ if BUILD_GSTLAUNCH_PLUGIN
 GSTLAUNCH_PLUGIN = gstlaunch
 endif
 
+if BUILD_GST_RENDERER_PLUGIN
+GST_RENDERER = gst-renderer
+endif
+
 SUBDIRS = $(TEST_PLUGIN) \
 	  $(TRACKER_PLUGIN) \
 	  $(MEDIATHEK_PLUGIN) \
 	  $(MEDIA_EXPORT_PLUGIN) \
 	  $(EXTERNAL_PLUGIN) \
-	  $(GSTLAUNCH_PLUGIN)
+	  $(GSTLAUNCH_PLUGIN) \
+	  $(GST_RENDERER)
 
 MAINTAINERCLEANFILES = Makefile.in
--- /dev/null
+++ b/src/plugins/gst-renderer/Makefile.am
@@ -0,0 +1,56 @@
+if UNINSTALLED
+shareddir = $(abs_top_builddir)/data
+else
+shareddir = $(datadir)/rygel
+endif
+
+plugindir = $(libdir)/rygel-1.0
+
+plugin_LTLIBRARIES = librygel-gst.la
+
+DATA_DIR=$(shareddir:$(prefix)%=%)
+
+AM_CFLAGS = $(LIBGUPNP_CFLAGS) \
+	    $(LIBGUPNP_AV_CFLAGS) \
+	    $(GEE_CFLAGS) \
+	    $(GTK_CFLAGS) \
+	    $(LIBVLC_CFLAGS) \
+	    $(LIBDBUS_GLIB_CFLAGS) \
+	    -I$(top_srcdir)/src/rygel -DDATA_DIR='"$(DATA_DIR)"'
+
+librygel_gst_la_SOURCES = rygel-gst-connection-manager.vala \
+			  rygel-gst-rendering-control.vala \
+			  rygel-gst-av-transport.vala \
+			  rygel-gst-changelog.vala \
+			  rygel-gst-plugin.vala \
+			  rygel-gst-audio-player-instance.vala \
+			  rygel-helper-gst-time.vala \
+			  rygel-gst-metadata-parser.vala \
+			  rygel-gst-player-states.vala \
+			  owl-audio-player.c
+
+librygel_gst_la_VALAFLAGS = 	--vapidir=$(srcdir) \
+				--vapidir=$(top_srcdir)/src/rygel \
+				--vapidir=$(top_srcdir)/vapi \
+				--pkg rygel-1.0 \
+				--pkg cstuff \
+				--pkg gupnp-1.0 \
+				--pkg gupnp-av-1.0 \
+				--pkg owl-audio-player \
+				--pkg gee-1.0 \
+				--pkg gconf-2.0 \
+				--pkg gtk+-2.0
+
+librygel_gst_la_LIBADD = $(LIBGUPNP_LIBS) \
+			 $(LIBGUPNP_AV_LIBS) \
+			 $(LIBVLC_LIBS) \
+			 $(GEE_LIBS) \
+			 $(GTK_LIBS) \
+			 $(LIBDBUS_GLIB_LIBS) \
+			 $(LIBGCONF_LIBS)
+
+librygel_gst_la_LDFLAGS = -shared -fPIC -module -avoid-version
+
+CLEANFILES = $(BUILT_SOURCES)
+MAINTAINERCLEANFILES = Makefile.in
+EXTRA_DIST = $(BUILT_SOURCES) owl-audio-player.vapi
--- /dev/null
+++ b/src/plugins/gst-renderer/owl-audio-player.c
@@ -0,0 +1,858 @@
+/*
+ * owl-audio-player.c
+ *   A GObject based wrapper for vlc media player
+ *
+ * (C) Copyright 2010, Ubicom, Inc.
+ * (C) Copyright 2012, Qualcomm Atheros, Inc.
+ *
+ * This file is part of the Ubicom32 Rygel.
+ *
+ * This program is free software: you can redistribute
+ * it and/or modify it under the terms of the GNU Lesser General Public
+ * License (LGPL) as published by the Free Software Foundation, either version 2.1
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it
+ * will be useful, but WITHOUT ANY WARRANTY; without even the implied
+ * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+ * the GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program.  If not,
+ * see <http://www.gnu.org/licenses/>.
+ *
+ * Ubicom32 implementation derived from (with many thanks):
+ *   OpenedHand's owl-audio-player.c file by Jorn Baayen <jorn@openedhand.com>
+ */
+
+#include <vlc/vlc.h>
+
+#include "owl-audio-player.h"
+
+G_DEFINE_TYPE (OwlAudioPlayer,
+               owl_audio_player,
+               G_TYPE_OBJECT);
+
+struct _OwlAudioPlayerPrivate {
+	libvlc_instance_t * pVLCInstance;
+	libvlc_media_player_t * pMediaPlayer;
+	libvlc_event_manager_t * pEvtManager;
+
+	char *uri;
+	char *protocol_info;
+
+	int duration;
+	gboolean can_seek;
+};
+
+enum {
+        PROP_0,
+        PROP_URI,
+        PROP_PROTOCOL_INFO,
+        PROP_STATE,
+        PROP_POSITION,
+        PROP_VOLUME,
+        PROP_MUTE,
+        PROP_CAN_SEEK,
+        PROP_DURATION
+};
+
+enum {
+        PLAYING,
+        PAUSED,
+        EOS,
+        ERROR,
+        LAST_SIGNAL
+};
+
+static guint signals[LAST_SIGNAL];
+
+#define TICK_TIMEOUT 0.5
+
+/* TODO: Possibly retrieve these through introspection. The problem is that we
+ * need them in class_init already. */
+#define VLC_VOL_DEFAULT 50.0
+#define VLC_VOL_MAX     200.0
+#define VLC_VOL_MUTE_DEFAULT FALSE
+
+/**
+ * Player playing media.
+ **/
+static void
+vlc_media_player_playing_cb( const libvlc_event_t *event, void *app_data )
+{
+	OwlAudioPlayer *audio_player = app_data;
+	g_return_if_fail (OWL_IS_AUDIO_PLAYER (audio_player));
+        /**
+         * Emit PLAYING signal.
+         **/
+        g_signal_emit (audio_player,
+                       signals[PLAYING],
+                       0);
+}
+
+/**
+ * Player paused playing media.
+ **/
+static void
+vlc_media_player_paused_cb( const libvlc_event_t *event, void *app_data )
+{
+	OwlAudioPlayer *audio_player = app_data;
+	g_return_if_fail (OWL_IS_AUDIO_PLAYER (audio_player));
+        /**
+         * Emit PAUSED signal.
+         **/
+        g_signal_emit (audio_player,
+                       signals[PAUSED],
+                       0);
+}
+
+/**
+ * End of stream reached.
+ **/
+static void
+vlc_eos_cb( const libvlc_event_t *event, void *app_data )
+{
+	OwlAudioPlayer *audio_player = app_data;
+	g_return_if_fail (OWL_IS_AUDIO_PLAYER (audio_player));
+        /**
+         * Emit EOS signal.
+         **/
+        g_signal_emit (audio_player,
+                       signals[EOS],
+                       0);
+}
+
+/**
+ * Error occured.
+ **/
+static void
+vlc_error_cb( const libvlc_event_t *event, void *app_data )
+{
+	OwlAudioPlayer *audio_player = app_data;
+	g_return_if_fail (OWL_IS_AUDIO_PLAYER (audio_player));
+
+        /**
+         * Emit ERROR signal.
+         **/
+        g_signal_emit (audio_player,
+                       signals[ERROR],
+                       0);
+}
+
+/**
+ * Duration/length changed.
+ **/
+static void
+vlc_media_player_duration_changed_cb( const libvlc_event_t *event, void *app_data )
+{
+	OwlAudioPlayer *audio_player = app_data;
+	g_return_if_fail (OWL_IS_AUDIO_PLAYER (audio_player));
+
+	if (audio_player->priv->duration == -1) {
+		audio_player->priv->duration = (event->u.media_duration_changed.new_duration + 500LL) / 1000000LL;
+		g_object_notify(audio_player, "duration");
+	}
+}
+
+static void
+owl_audio_player_init (OwlAudioPlayer *audio_player)
+{
+        /**
+         * Create pointer to private data.
+         **/
+        audio_player->priv =
+                G_TYPE_INSTANCE_GET_PRIVATE (audio_player,
+                                             OWL_TYPE_AUDIO_PLAYER,
+                                             OwlAudioPlayerPrivate);
+
+	const char * const vlc_args[] = {
+		"-I", "dummy",
+		"--ipv4-timeout=60000",     // No special interface
+		"--http-reconnect",// Try to reconnect when connection is lost
+		"--ignore-config" // Don't use VLC's config
+		};
+
+	libvlc_instance_t * pVLCInstance = NULL;
+	libvlc_media_player_t * pMediaPlayer = NULL;
+	libvlc_event_manager_t * pEvtManager = NULL;
+
+	// init vlc modules, should be done only once
+	pVLCInstance = libvlc_new (sizeof(vlc_args) / sizeof(vlc_args[0]), vlc_args);
+	g_assert(pVLCInstance);
+
+	// Create a media player playing environement
+	pMediaPlayer = libvlc_media_player_new(pVLCInstance);
+	g_assert(pMediaPlayer);
+
+	// Create an event manager for the player for handling e.g. time change events
+	pEvtManager = libvlc_media_player_event_manager(pMediaPlayer);
+
+	libvlc_event_attach(pEvtManager,
+	                    libvlc_MediaPlayerEndReached,
+	                    vlc_eos_cb,
+	                    audio_player);
+	libvlc_event_attach(pEvtManager,
+	                    libvlc_MediaPlayerEncounteredError,
+	                    vlc_error_cb,
+	                    audio_player);
+	libvlc_event_attach(pEvtManager,
+	                    libvlc_MediaPlayerPaused,
+	                    vlc_media_player_paused_cb,
+	                    audio_player);
+	libvlc_event_attach(pEvtManager,
+	                    libvlc_MediaPlayerPlaying,
+	                    vlc_media_player_playing_cb,
+	                    audio_player);
+
+	audio_player->priv->pVLCInstance = pVLCInstance;
+	audio_player->priv->pMediaPlayer = pMediaPlayer;
+	audio_player->priv->pEvtManager = pEvtManager;
+}
+
+static void
+owl_audio_player_set_property (GObject      *object,
+                               guint         property_id,
+                               const GValue *value,
+                               GParamSpec   *pspec)
+{
+        OwlAudioPlayer *audio_player;
+
+        audio_player = OWL_AUDIO_PLAYER (object);
+
+        switch (property_id) {
+        case PROP_PROTOCOL_INFO:
+                owl_audio_player_set_protocol_info (audio_player,
+                                                    g_value_get_string (value));
+                break;
+        case PROP_POSITION:
+                owl_audio_player_set_position (audio_player,
+                                               g_value_get_int (value));
+                break;
+        case PROP_VOLUME:
+                owl_audio_player_set_volume (audio_player,
+                                             g_value_get_uint (value));
+                break;
+        case PROP_MUTE:
+                owl_audio_player_set_mute (audio_player,
+                                           g_value_get_uint (value));
+                break;
+        default:
+                G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
+                break;
+        }
+}
+
+static void
+owl_audio_player_get_property (GObject    *object,
+                               guint       property_id,
+                               GValue     *value,
+                               GParamSpec *pspec)
+{
+	OwlAudioPlayer *audio_player;
+
+	audio_player = OWL_AUDIO_PLAYER (object);
+
+	switch (property_id) {
+	case PROP_URI:
+	        g_value_set_string
+	                (value,
+	                 owl_audio_player_get_uri (audio_player));
+	        break;
+	case PROP_PROTOCOL_INFO:
+	        g_value_set_string
+	                (value,
+	                 owl_audio_player_get_protocol_info (audio_player));
+	        break;
+	case PROP_STATE:
+	        g_value_set_enum
+	                (value,
+	                 owl_audio_player_get_state (audio_player));
+	        break;
+	case PROP_POSITION:
+	        g_value_set_int
+	                (value,
+	                 owl_audio_player_get_position (audio_player));
+	        break;
+	case PROP_VOLUME:
+	        g_value_set_double
+	                (value,
+	                 owl_audio_player_get_volume (audio_player));
+	        break;
+	case PROP_MUTE:
+	        g_value_set_double
+	                (value,
+	                 owl_audio_player_get_mute (audio_player));
+	        break;
+	case PROP_CAN_SEEK:
+	        g_value_set_boolean
+	                (value,
+	                 owl_audio_player_get_can_seek (audio_player));
+	        break;
+	case PROP_DURATION:
+	        g_value_set_int
+	                (value,
+	                 owl_audio_player_get_duration (audio_player));
+	        break;
+	default:
+	        G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
+	        break;
+	}
+}
+
+static void
+owl_audio_player_dispose (GObject *object)
+{
+	OwlAudioPlayer *audio_player;
+	GObjectClass *object_class;
+
+	audio_player = OWL_AUDIO_PLAYER (object);
+
+	if (audio_player->priv->pMediaPlayer) {
+		libvlc_media_player_release (audio_player->priv->pMediaPlayer);
+	        audio_player->priv->pMediaPlayer = NULL;
+	}
+
+	if (audio_player->priv->pVLCInstance) {
+		libvlc_release (audio_player->priv->pVLCInstance);
+	        audio_player->priv->pVLCInstance = NULL;
+	}
+
+	object_class = G_OBJECT_CLASS (owl_audio_player_parent_class);
+	object_class->dispose (object);
+}
+
+static void
+owl_audio_player_finalize (GObject *object)
+{
+	OwlAudioPlayer *audio_player;
+	GObjectClass *object_class;
+
+	audio_player = OWL_AUDIO_PLAYER (object);
+
+	g_free (audio_player->priv->uri);
+	g_free (audio_player->priv->protocol_info);
+
+	object_class = G_OBJECT_CLASS (owl_audio_player_parent_class);
+	object_class->finalize (object);
+}
+
+static void
+owl_audio_player_class_init (OwlAudioPlayerClass *klass)
+{
+	GObjectClass *object_class;
+
+	object_class = G_OBJECT_CLASS (klass);
+
+	object_class->set_property = owl_audio_player_set_property;
+	object_class->get_property = owl_audio_player_get_property;
+	object_class->dispose      = owl_audio_player_dispose;
+	object_class->finalize     = owl_audio_player_finalize;
+
+	g_type_class_add_private (klass, sizeof (OwlAudioPlayerPrivate));
+
+	g_object_class_install_property
+	        (object_class,
+	         PROP_URI,
+	         g_param_spec_string
+	                 ("uri",
+	                  "URI",
+	                  "The loaded URI.",
+	                  NULL,
+	                  G_PARAM_READWRITE |
+	                  G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK |
+	                  G_PARAM_STATIC_BLURB));
+
+	g_object_class_install_property
+	        (object_class,
+	         PROP_PROTOCOL_INFO,
+	         g_param_spec_string
+	                 ("protocol-info",
+	                  "PROTOCOL_INFO",
+	                  "The DLNA protocolInfo.",
+	                  NULL,
+	                  G_PARAM_READWRITE |
+	                  G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK |
+	                  G_PARAM_STATIC_BLURB));
+
+	g_object_class_install_property
+	        (object_class,
+	         PROP_STATE,
+	         g_param_spec_boolean
+	                 ("state",
+	                  "Playing State",
+	                  "Returns playing state.",
+	                  FALSE,
+	                  G_PARAM_READWRITE |
+	                  G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK |
+	                  G_PARAM_STATIC_BLURB));
+
+	g_object_class_install_property
+	        (object_class,
+	         PROP_POSITION,
+	         g_param_spec_int
+	                 ("position",
+	                  "Position",
+	                  "The position in the current stream in seconds.",
+	                  0, G_MAXINT, 0,
+	                  G_PARAM_READWRITE |
+	                  G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK |
+	                  G_PARAM_STATIC_BLURB));
+
+	g_object_class_install_property
+	        (object_class,
+	         PROP_VOLUME,
+	         g_param_spec_uint
+	                 ("volume",
+	                  "Volume",
+	                  "The audio volume.",
+	                  0, VLC_VOL_MAX, VLC_VOL_DEFAULT,
+	                  G_PARAM_READWRITE |
+	                  G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK |
+	                  G_PARAM_STATIC_BLURB));
+
+	g_object_class_install_property
+	        (object_class,
+	         PROP_MUTE,
+	         g_param_spec_uint
+	                 ("mute",
+	                  "Mute",
+	                  "The audio mute.",
+	                  0, 1, VLC_VOL_MUTE_DEFAULT,
+	                  G_PARAM_READWRITE |
+	                  G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK |
+	                  G_PARAM_STATIC_BLURB));
+
+	g_object_class_install_property
+	        (object_class,
+	         PROP_CAN_SEEK,
+	         g_param_spec_boolean
+	                 ("can-seek",
+	                  "Can seek",
+	                  "TRUE if the current stream is seekable.",
+	                  FALSE,
+	                  G_PARAM_READABLE |
+	                  G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK |
+	                  G_PARAM_STATIC_BLURB));
+
+	g_object_class_install_property
+	        (object_class,
+	         PROP_DURATION,
+	         g_param_spec_int
+	                 ("duration",
+	                  "Duration",
+	                  "The duration of the current stream in seconds.",
+	                  0, G_MAXINT, 0,
+	                  G_PARAM_READABLE |
+	                  G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK |
+	                  G_PARAM_STATIC_BLURB));
+
+	signals[PLAYING] =
+	        g_signal_new ("playing",
+	                      OWL_TYPE_AUDIO_PLAYER,
+	                      G_SIGNAL_RUN_LAST,
+	                      G_STRUCT_OFFSET (OwlAudioPlayerClass,
+	                                       playing),
+	                      NULL, NULL,
+	                      g_cclosure_marshal_VOID__VOID,
+	                      G_TYPE_NONE, 0);
+
+	signals[PAUSED] =
+	        g_signal_new ("paused",
+	                      OWL_TYPE_AUDIO_PLAYER,
+	                      G_SIGNAL_RUN_LAST,
+	                      G_STRUCT_OFFSET (OwlAudioPlayerClass,
+	                                       paused),
+	                      NULL, NULL,
+	                      g_cclosure_marshal_VOID__VOID,
+	                      G_TYPE_NONE, 0);
+
+	signals[EOS] =
+	        g_signal_new ("eos",
+	                      OWL_TYPE_AUDIO_PLAYER,
+	                      G_SIGNAL_RUN_LAST,
+	                      G_STRUCT_OFFSET (OwlAudioPlayerClass,
+	                                       eos),
+	                      NULL, NULL,
+	                      g_cclosure_marshal_VOID__VOID,
+	                      G_TYPE_NONE, 0);
+
+	signals[ERROR] =
+	        g_signal_new ("error",
+	                      OWL_TYPE_AUDIO_PLAYER,
+	                      G_SIGNAL_RUN_LAST,
+	                      G_STRUCT_OFFSET (OwlAudioPlayerClass,
+	                                       error),
+	                      NULL, NULL,
+	                      g_cclosure_marshal_VOID__POINTER,
+	                      G_TYPE_NONE, 1, G_TYPE_POINTER);
+}
+
+/**
+ * owl_audio_player_construct
+ *
+ * Return value: A new #OwlAudioPlayer.
+ **/
+OwlAudioPlayer *
+owl_audio_player_construct (GType object_type)
+{
+	return g_object_new (OWL_TYPE_AUDIO_PLAYER, NULL);
+}
+
+/**
+ * owl_audio_player_new
+ *
+ * Return value: A new #OwlAudioPlayer.
+ **/
+OwlAudioPlayer *
+owl_audio_player_new (void)
+{
+	return owl_audio_player_construct (OWL_TYPE_AUDIO_PLAYER);
+}
+
+/**
+ * owl_audio_player_set_protocol_info
+ * @audio_player: A #OwlAudioPlayer
+ * @protocol_info: A PROTOCOL_INFO
+ *
+ * Loads @protocol_info.
+ **/
+void
+owl_audio_player_set_protocol_info (OwlAudioPlayer *audio_player,
+                                    const char     *protocol_info)
+{
+	g_return_if_fail (OWL_IS_AUDIO_PLAYER (audio_player));
+
+	if (!audio_player->priv->pMediaPlayer)
+	        return;
+
+	if (protocol_info && audio_player->priv->protocol_info && !strcmp(protocol_info, audio_player->priv->protocol_info)) {
+		return;
+	}
+
+	g_free (audio_player->priv->protocol_info);
+
+	if (protocol_info) {
+	        audio_player->priv->protocol_info = g_strdup (protocol_info);
+	} else {
+	        audio_player->priv->protocol_info = NULL;
+	}
+}
+
+/**
+ * owl_audio_player_get_protocol_info
+ * @audio_player: A #OwlAudioPlayer
+ *
+ * Return value: The DLNA protocolInfo, or NULL if none set.
+ **/
+const char *
+owl_audio_player_get_protocol_info (OwlAudioPlayer *audio_player)
+{
+	g_return_val_if_fail (OWL_IS_AUDIO_PLAYER (audio_player), NULL);
+
+	return audio_player->priv->protocol_info;
+}
+
+/**
+ * owl_audio_player_get_uri
+ * @audio_player: A #OwlAudioPlayer
+ *
+ * Return value: The loaded URI, or NULL if none set.
+ **/
+const char *
+owl_audio_player_get_uri (OwlAudioPlayer *audio_player)
+{
+	g_return_val_if_fail (OWL_IS_AUDIO_PLAYER (audio_player), NULL);
+
+	return audio_player->priv->uri;
+}
+
+/**
+ * owl_audio_player_pause
+ * @audio_player: A #OwlAudioPlayer
+ *
+ * Pauses playing media.
+ **/
+void
+owl_audio_player_pause (OwlAudioPlayer *audio_player)
+{
+	g_return_if_fail (OWL_IS_AUDIO_PLAYER (audio_player));
+
+	if (!audio_player->priv->pMediaPlayer)
+	        return;
+
+	if (owl_audio_player_get_state(audio_player) != OWL_PLAYING_STATE_PLAYING) {
+		return;
+	}
+
+	libvlc_media_player_pause(audio_player->priv->pMediaPlayer);
+}
+
+/**
+ * owl_audio_player_resume
+ * @audio_player: A #OwlAudioPlayer
+ *
+ * Resumes paused media.
+ **/
+void
+owl_audio_player_resume (OwlAudioPlayer *audio_player)
+{
+	g_return_if_fail (OWL_IS_AUDIO_PLAYER (audio_player));
+
+	if (!audio_player->priv->pMediaPlayer)
+	        return;
+
+	if (owl_audio_player_get_state(audio_player) != OWL_PLAYING_STATE_PAUSED_PLAYBACK) {
+		return;
+	}
+
+	libvlc_media_player_pause(audio_player->priv->pMediaPlayer);
+}
+
+/**
+ * owl_audio_player_stop
+ * @audio_player: A #OwlAudioPlayer
+ *
+ * Stops playing media.
+ **/
+void
+owl_audio_player_stop (OwlAudioPlayer *audio_player)
+{
+	g_return_if_fail (OWL_IS_AUDIO_PLAYER (audio_player));
+
+	if (!audio_player->priv->pMediaPlayer)
+	        return;
+
+	libvlc_media_player_stop(audio_player->priv->pMediaPlayer);
+}
+
+/**
+ * owl_audio_player_play
+ * @audio_player: A #OwlAudioPlayer
+ * @uri: A URI
+ *
+ * Plays the media at @uri.
+ **/
+void
+owl_audio_player_play (OwlAudioPlayer *audio_player,
+                       const char *uri)
+{
+	g_return_if_fail (OWL_IS_AUDIO_PLAYER (audio_player));
+
+	if (!audio_player->priv->pMediaPlayer)
+	        return;
+
+	if (!uri) {
+		return;
+	}
+
+	g_free (audio_player->priv->uri);
+	audio_player->priv->uri = g_strdup (uri);
+
+	/**
+	 * Set new media.
+	 **/
+	libvlc_media_t * pMedia = libvlc_media_new_location (audio_player->priv->pVLCInstance, uri);
+	libvlc_event_attach(libvlc_media_event_manager(pMedia),
+	                    libvlc_MediaDurationChanged,
+	                    vlc_media_player_duration_changed_cb,
+	                    audio_player);
+	libvlc_media_player_set_media (audio_player->priv->pMediaPlayer, pMedia);
+
+	/**
+	 * Play media
+	 **/
+	libvlc_media_player_play(audio_player->priv->pMediaPlayer);
+
+	/**
+	 * Reset properties.
+	 **/
+	audio_player->priv->can_seek = 0;
+	audio_player->priv->duration = -1;
+}
+
+/**
+ * owl_audio_player_get_state
+ * @audio_player: A #OwlAudioPlayer
+ *
+ * Return value: Playing state of @audio_player.
+ **/
+owl_playing_state
+owl_audio_player_get_state (OwlAudioPlayer *audio_player)
+{
+	g_return_val_if_fail (OWL_IS_AUDIO_PLAYER (audio_player), FALSE);
+
+	if (!audio_player->priv->pMediaPlayer)
+	        return FALSE;
+
+	libvlc_state_t state = libvlc_media_player_get_state(audio_player->priv->pMediaPlayer);
+
+	switch (state) {
+	case libvlc_Opening:
+	case libvlc_Buffering:
+		return OWL_PLAYING_STATE_TRANSITIONING;
+	case libvlc_Playing:
+		return OWL_PLAYING_STATE_PLAYING;
+	case libvlc_Stopped:
+	case libvlc_Ended:
+	case libvlc_Error:
+	case libvlc_NothingSpecial:
+		return OWL_PLAYING_STATE_STOPPED;
+	case libvlc_Paused:
+		return OWL_PLAYING_STATE_PAUSED_PLAYBACK;
+	}
+}
+
+/**
+ * owl_audio_player_set_position
+ * @audio_player: A #OwlAudioPlayer
+ * @time_in_seconds: The position in the current stream in seconds.
+ *
+ * Sets the position in the current stream to @time_in_seconds.
+ **/
+void
+owl_audio_player_set_position (OwlAudioPlayer *audio_player,
+                               int time_in_seconds)
+{
+	g_return_if_fail (OWL_IS_AUDIO_PLAYER (audio_player));
+
+	if (!audio_player->priv->pVLCInstance)
+		return;
+
+	if (time_in_seconds < 0) {
+		return;
+	}
+
+	libvlc_time_t time_in_mseconds = time_in_seconds * 1000;
+	libvlc_media_player_set_time(audio_player->priv->pMediaPlayer, time_in_mseconds);
+	g_debug("%p: New time is %lld", audio_player, time_in_mseconds);
+}
+
+/**
+ * owl_audio_player_get_position
+ * @audio_player: A #OwlAudioPlayer
+ *
+ * Return value: The position in the current file in seconds.
+ **/
+int
+owl_audio_player_get_position (OwlAudioPlayer *audio_player)
+{
+	g_return_val_if_fail (OWL_IS_AUDIO_PLAYER (audio_player), -1);
+
+	if (!audio_player->priv->pMediaPlayer)
+	        return -1;
+
+	libvlc_time_t time_in_mseconds = libvlc_media_player_get_time(audio_player->priv->pMediaPlayer);
+
+	return time_in_mseconds / 1000;
+}
+
+/**
+ * owl_audio_player_set_volume
+ * @audio_player: A #OwlAudioPlayer
+ * @volume: The audio volume to set, in the range 0.0 - 4.0.
+ *
+ * Sets the current audio volume to @volume.
+ **/
+void
+owl_audio_player_set_volume (OwlAudioPlayer *audio_player,
+                             unsigned int          volume)
+{
+	g_return_if_fail (OWL_IS_AUDIO_PLAYER (audio_player));
+	g_return_if_fail (volume >= 0.0 && volume <= VLC_VOL_MAX);
+
+	if (!audio_player->priv->pVLCInstance)
+	        return;
+
+	libvlc_audio_set_volume(audio_player->priv->pMediaPlayer, volume);
+}
+
+/**
+ * owl_audio_player_get_volume
+ * @audio_player: A #OwlAudioPlayer
+ *
+ * Return value: The current audio volume, in the range 0.0 - 4.0.
+ **/
+unsigned int
+owl_audio_player_get_volume (OwlAudioPlayer *audio_player)
+{
+	unsigned int volume;
+
+	g_return_val_if_fail (OWL_IS_AUDIO_PLAYER (audio_player), 0);
+
+	if (!audio_player->priv->pVLCInstance)
+	        return 0.0;
+
+	volume = libvlc_audio_get_volume(audio_player->priv->pMediaPlayer);
+
+	return volume;
+}
+
+/**
+ * owl_audio_player_set_mute
+ * @audio_player: A #OwlAudioPlayer
+ * @mute: TRUE if volume should be muted, FALSE otherwise
+ *
+ * Sets the current audio mute to @mute.
+ **/
+void
+owl_audio_player_set_mute (OwlAudioPlayer *audio_player,
+                           gboolean                mute)
+{
+	g_return_if_fail (OWL_IS_AUDIO_PLAYER (audio_player));
+
+	if (!audio_player->priv->pVLCInstance)
+	        return;
+
+	libvlc_audio_set_mute(audio_player->priv->pMediaPlayer, mute);
+}
+
+/**
+ * owl_audio_player_get_mute
+ * @audio_player: A #OwlAudioPlayer
+ *
+ * Return value: TRUE if the current volume is muted.
+ **/
+gboolean
+owl_audio_player_get_mute (OwlAudioPlayer *audio_player)
+{
+	gboolean mute;
+
+	g_return_val_if_fail (OWL_IS_AUDIO_PLAYER (audio_player), 0);
+
+	if (!audio_player->priv->pVLCInstance)
+	        return FALSE;
+
+	mute = libvlc_audio_get_mute(audio_player->priv->pMediaPlayer);
+
+	return mute;
+}
+
+/**
+ * owl_audio_player_get_can_seek
+ * @audio_player: A #OwlAudioPlayer
+ *
+ * Return value: TRUE if the current stream is seekable.
+ **/
+gboolean
+owl_audio_player_get_can_seek (OwlAudioPlayer *audio_player)
+{
+	g_return_val_if_fail (OWL_IS_AUDIO_PLAYER (audio_player), FALSE);
+
+	int is_seekable = libvlc_media_player_is_seekable(audio_player->priv->pMediaPlayer);
+	return is_seekable;
+}
+
+/**
+ * owl_audio_player_get_duration
+ * @audio_player: A #OwlAudioPlayer
+ *
+ * Return value: The duration of the current stream in seconds.
+ **/
+int
+owl_audio_player_get_duration (OwlAudioPlayer *audio_player)
+{
+	g_return_val_if_fail (OWL_IS_AUDIO_PLAYER (audio_player), -1);
+
+	return audio_player->priv->duration;
+}
--- /dev/null
+++ b/src/plugins/gst-renderer/owl-audio-player.h
@@ -0,0 +1,147 @@
+/*
+ * owl-audio-player.h
+ *   A GObject based wrapper for vlc media player
+ *
+ * (C) Copyright 2010, Ubicom, Inc.
+ *
+ * This file is part of the Ubicom32 Rygel.
+ *
+ * This program is free software: you can redistribute
+ * it and/or modify it under the terms of the GNU Lesser General Public
+ * License (LGPL) as published by the Free Software Foundation, either version 2.1
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it
+ * will be useful, but WITHOUT ANY WARRANTY; without even the implied
+ * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+ * the GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program.  If not,
+ * see <http://www.gnu.org/licenses/>.
+ *
+ * Ubicom32 implementation derived from (with many thanks):
+ *   OpenedHand's owl-audio-player.h file by Jorn Baayen <jorn@openedhand.com>
+ */
+
+#ifndef __OWL_AUDIO_PLAYER_H__
+#define __OWL_AUDIO_PLAYER_H__
+
+#include <glib-object.h>
+
+G_BEGIN_DECLS
+
+#define OWL_TYPE_AUDIO_PLAYER \
+                (owl_audio_player_get_type ())
+#define OWL_AUDIO_PLAYER(obj) \
+                (G_TYPE_CHECK_INSTANCE_CAST ((obj), \
+                 OWL_TYPE_AUDIO_PLAYER, \
+                 OwlAudioPlayer))
+#define OWL_AUDIO_PLAYER_CLASS(klass) \
+                (G_TYPE_CHECK_CLASS_CAST ((klass), \
+                 OWL_TYPE_AUDIO_PLAYER, \
+                 OwlAudioPlayerClass))
+#define OWL_IS_AUDIO_PLAYER(obj) \
+                (G_TYPE_CHECK_INSTANCE_TYPE ((obj), \
+                 OWL_TYPE_AUDIO_PLAYER))
+#define OWL_IS_AUDIO_PLAYER_CLASS(klass) \
+                (G_TYPE_CHECK_CLASS_TYPE ((klass), \
+                 OWL_TYPE_AUDIO_PLAYER))
+#define OWL_AUDIO_PLAYER_GET_CLASS(obj) \
+                (G_TYPE_INSTANCE_GET_CLASS ((obj), \
+                 OWL_TYPE_AUDIO_PLAYER, \
+                 OwlAudioPlayerClass))
+
+typedef enum _owl_playing_state{
+        OWL_PLAYING_STATE_PLAYING,
+        OWL_PLAYING_STATE_PAUSED_PLAYBACK,
+        OWL_PLAYING_STATE_STOPPED,
+	 OWL_PLAYING_STATE_TRANSITIONING
+} owl_playing_state;
+
+typedef struct _OwlAudioPlayerPrivate OwlAudioPlayerPrivate;
+
+typedef struct {
+        GObject parent;
+
+        OwlAudioPlayerPrivate *priv;
+} OwlAudioPlayer;
+
+typedef struct {
+        GObjectClass parent_class;
+
+        /* Signals */
+        void (* playing)            (OwlAudioPlayer *audio_player);
+        void (* paused)             (OwlAudioPlayer *audio_player);
+        void (* eos)                (OwlAudioPlayer *audio_player);
+        void (* error)              (OwlAudioPlayer *audio_player,
+                                     GError         *error);
+
+        /* Future padding */
+        void (* _reserved1) (void);
+        void (* _reserved2) (void);
+        void (* _reserved3) (void);
+        void (* _reserved4) (void);
+} OwlAudioPlayerClass;
+
+GType
+owl_audio_player_get_type           (void) G_GNUC_CONST;
+
+OwlAudioPlayer *
+owl_audio_player_new                (void);
+
+const char *
+owl_audio_player_get_uri            (OwlAudioPlayer *audio_player);
+
+void
+owl_audio_player_set_protocol_info  (OwlAudioPlayer *audio_player,
+                                     const char     *protocol_info);
+
+const char *
+owl_audio_player_get_protocol_info  (OwlAudioPlayer *audio_player);
+
+void
+owl_audio_player_play               (OwlAudioPlayer *audio_player,
+                                     const char     *uri);
+
+void
+owl_audio_player_pause              (OwlAudioPlayer *audio_player);
+
+void
+owl_audio_player_resume             (OwlAudioPlayer *audio_player);
+
+void
+owl_audio_player_stop               (OwlAudioPlayer *audio_player);
+
+owl_playing_state
+owl_audio_player_get_state        (OwlAudioPlayer *audio_player);
+
+void
+owl_audio_player_set_position       (OwlAudioPlayer *audio_player,
+                                     int             time_in_seconds);
+
+int
+owl_audio_player_get_position       (OwlAudioPlayer *audio_player);
+
+void
+owl_audio_player_set_volume         (OwlAudioPlayer *audio_player,
+                                     unsigned int          volume);
+
+unsigned int
+owl_audio_player_get_volume         (OwlAudioPlayer *audio_player);
+
+void
+owl_audio_player_set_mute           (OwlAudioPlayer *audio_player,
+                                     gboolean                mute);
+gboolean
+owl_audio_player_get_mute           (OwlAudioPlayer *audio_player);
+
+gboolean
+owl_audio_player_get_can_seek       (OwlAudioPlayer *audio_player);
+
+int
+owl_audio_player_get_duration       (OwlAudioPlayer *audio_player);
+
+G_END_DECLS
+
+#endif /* __OWL_AUDIO_PLAYER_H__ */
--- /dev/null
+++ b/src/plugins/gst-renderer/owl-audio-player.vapi
@@ -0,0 +1,69 @@
+/*
+ * owl-audio-player.vapi
+ *   A GObject based wrapper for vlc media player
+ *
+ * (C) Copyright 2010, Ubicom, Inc.
+ *
+ * This file is part of the Ubicom32 Rygel.
+ *
+ * This program is free software: you can redistribute
+ * it and/or modify it under the terms of the GNU Lesser General Public
+ * License (LGPL) as published by the Free Software Foundation, either version 2.1
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it
+ * will be useful, but WITHOUT ANY WARRANTY; without even the implied
+ * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+ * the GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program.  If not,
+ * see <http://www.gnu.org/licenses/>.
+ *
+ * Ubicom32 implementation derived from (with many thanks):
+ *   OpenedHand's owl-audio-player.vapi file by Jorn Baayen <jorn@openedhand.com>
+ */
+
+[CCode (cprefix = "Owl", lower_case_cprefix = "owl_")]
+namespace Owl {
+	[CCode (cname = "owl_playing_state", has_type_id = false)]
+	public enum PlayingState {
+		PLAYING,
+		PAUSED_PLAYBACK,
+		STOPPED,
+		TRANSITIONING
+	}
+
+	[CCode (cheader_filename = "owl-audio-player.h")]
+	public class AudioPlayer : GLib.Object {
+		public bool get_can_seek ();
+		public int get_duration ();
+		public bool get_mute ();
+		public PlayingState get_state ();
+		public int get_position ();
+		public weak string get_uri ();
+		public weak string get_protocol_info ();
+		public uint get_volume ();
+		public AudioPlayer ();
+		public void set_mute (bool mute);
+		public void play (string uri);
+		public void pause ();
+		public void resume ();
+		public void stop ();
+		public void set_position (int time_in_seconds);
+		public void set_protocol_info (string protocol_info);
+		public void set_volume (uint volume);
+		public bool can_seek { get; }
+		public int duration { get; }
+		public bool mute { get; set; }
+		public PlayingState state { get; }
+		public int position { get; set; }
+		public string uri { get; }
+		public string protocol_info { get; set; }
+		public uint volume { get; set; }
+		public virtual signal void playing ();
+		public virtual signal void paused ();
+		public virtual signal void eos ();
+		public virtual signal void error (GLib.Error error);
+	}
+}
--- /dev/null
+++ b/src/plugins/gst-renderer/owl-video-widget.h
@@ -0,0 +1,128 @@
+/*
+ * Copyright (C) 2006 OpenedHand Ltd.
+ *
+ * OpenedHand Widget Library Video Widget - A GStreamer video GTK+ widget
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ * Author: Jorn Baayen <jorn@openedhand.com>
+ */
+
+#ifndef __OWL_VIDEO_WIDGET_H__
+#define __OWL_VIDEO_WIDGET_H__
+
+#include <gtk/gtkbin.h>
+#include <gst/gsttaglist.h>
+
+G_BEGIN_DECLS
+
+#define OWL_TYPE_VIDEO_WIDGET \
+                (owl_video_widget_get_type ())
+#define OWL_VIDEO_WIDGET(obj) \
+                (G_TYPE_CHECK_INSTANCE_CAST ((obj), \
+                 OWL_TYPE_VIDEO_WIDGET, \
+                 OwlVideoWidget))
+#define OWL_VIDEO_WIDGET_CLASS(klass) \
+                (G_TYPE_CHECK_CLASS_CAST ((klass), \
+                 OWL_TYPE_VIDEO_WIDGET, \
+                 OwlVideoWidgetClass))
+#define OWL_IS_VIDEO_WIDGET(obj) \
+                (G_TYPE_CHECK_INSTANCE_TYPE ((obj), \
+                 OWL_TYPE_VIDEO_WIDGET))
+#define OWL_IS_VIDEO_WIDGET_CLASS(klass) \
+                (G_TYPE_CHECK_CLASS_TYPE ((klass), \
+                 OWL_TYPE_VIDEO_WIDGET))
+#define OWL_VIDEO_WIDGET_GET_CLASS(obj) \
+                (G_TYPE_INSTANCE_GET_CLASS ((obj), \
+                 OWL_TYPE_VIDEO_WIDGET, \
+                 OwlVideoWidgetClass))
+
+typedef struct _OwlVideoWidgetPrivate OwlVideoWidgetPrivate;
+
+typedef struct {
+        GtkBin parent;
+
+        OwlVideoWidgetPrivate *priv;
+} OwlVideoWidget;
+
+typedef struct {
+        GtkBinClass parent_class;
+
+        /* Signals */
+        void (* tag_list_available) (OwlVideoWidget *video_widget,
+                                     GstTagList     *tag_list);
+        void (* eos)                (OwlVideoWidget *video_widget);
+        void (* error)              (OwlVideoWidget *video_widget,
+                                     GError         *error);
+
+        /* Future padding */
+        void (* _owl_reserved1) (void);
+        void (* _owl_reserved2) (void);
+        void (* _owl_reserved3) (void);
+        void (* _owl_reserved4) (void);
+} OwlVideoWidgetClass;
+
+GType
+owl_video_widget_get_type               (void) G_GNUC_CONST;
+
+GtkWidget *
+owl_video_widget_new                    (void);
+
+void
+owl_video_widget_set_uri                (OwlVideoWidget *video_widget,
+                                         const char     *uri);
+
+const char *
+owl_video_widget_get_uri                (OwlVideoWidget *video_widget);
+
+void
+owl_video_widget_set_playing            (OwlVideoWidget *video_widget,
+                                         gboolean        playing);
+
+gboolean
+owl_video_widget_get_playing            (OwlVideoWidget *video_widget);
+
+void
+owl_video_widget_set_position           (OwlVideoWidget *video_widget,
+                                         int             position);
+
+int
+owl_video_widget_get_position           (OwlVideoWidget *video_widget);
+
+void
+owl_video_widget_set_volume             (OwlVideoWidget *video_widget,
+                                         double          volume);
+
+double
+owl_video_widget_get_volume             (OwlVideoWidget *video_widget);
+
+gboolean
+owl_video_widget_get_can_seek           (OwlVideoWidget *video_widget);
+
+int
+owl_video_widget_get_buffer_percent     (OwlVideoWidget *video_widget);
+
+int
+owl_video_widget_get_duration           (OwlVideoWidget *video_widget);
+
+void
+owl_video_widget_set_force_aspect_ratio (OwlVideoWidget *video_widget,
+                                         gboolean        force_aspect_ratio);
+
+gboolean
+owl_video_widget_get_force_aspect_ratio (OwlVideoWidget *video_widget);
+
+G_END_DECLS
+
+#endif /* __OWL_VIDEO_WIDGET_H__ */
--- /dev/null
+++ b/src/plugins/gst-renderer/owl-video-widget.vapi
@@ -0,0 +1,31 @@
+[CCode (cprefix = "Owl", lower_case_cprefix = "owl_")]
+namespace Owl {
+	[CCode (cheader_filename = "owl-video-widget.h")]
+	public class VideoWidget : Gtk.Bin, Atk.Implementor, Gtk.Buildable {
+		public int get_buffer_percent ();
+		public bool get_can_seek ();
+		public int get_duration ();
+		public bool get_force_aspect_ratio ();
+		public bool get_playing ();
+		public int get_position ();
+		public weak string get_uri ();
+		public double get_volume ();
+		public VideoWidget ();
+		public void set_force_aspect_ratio (bool force_aspect_ratio);
+		public void set_playing (bool playing);
+		public void set_position (int position);
+		public void set_uri (string uri);
+		public void set_volume (double volume);
+		public int buffer_percent { get; }
+		public bool can_seek { get; }
+		public int duration { get; }
+		public bool force_aspect_ratio { get; set; }
+		public bool playing { get; set; }
+		public int position { get; set; }
+		public string uri { get; set; }
+		public double volume { get; set; }
+		public virtual signal void eos ();
+		public virtual signal void error (GLib.Error error);
+		public virtual signal void tag_list_available (Gst.TagList tag_list);
+	}
+}
--- /dev/null
+++ b/src/plugins/gst-renderer/rygel-gst-audio-player-instance.vala
@@ -0,0 +1,37 @@
+/*
+ * rygel-gst-audio-player-instance.vala
+ *   Singleton implementation for audio player
+ *
+ * (C) Copyright 2010, Ubicom, Inc.
+ *
+ * This file is part of the Ubicom32 Rygel.
+ *
+ * This program is free software: you can redistribute
+ * it and/or modify it under the terms of the GNU Lesser General Public
+ * License (LGPL) as published by the Free Software Foundation, either version 2.1
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it
+ * will be useful, but WITHOUT ANY WARRANTY; without even the implied
+ * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+ * the GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program.  If not,
+ * see <http://www.gnu.org/licenses/>.
+ */
+
+using Owl;
+
+public class Rygel.GstAudioPlayerInstance : AudioPlayer {
+
+  	private static GstAudioPlayerInstance audio_player = null;
+
+  	public static GstAudioPlayerInstance instance() {
+		if (audio_player == null) {
+			audio_player = new GstAudioPlayerInstance();
+		}
+
+		return audio_player;
+	}
+}
--- /dev/null
+++ b/src/plugins/gst-renderer/rygel-gst-av-transport.vala
@@ -0,0 +1,592 @@
+/*
+ * Copyright (C) 2008 OpenedHand Ltd.
+ * Copyright (C) 2009 Nokia Corporation.
+ *
+ * Author: Jorn Baayen <jorn@openedhand.com>
+ *         Zeeshan Ali (Khattak) <zeeshanak@gnome.org>
+ *                               <zeeshan.ali@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ */
+
+using GUPnP;
+using Rygel.Helper;
+using CStuff;
+using Owl;
+
+public class Rygel.GstAVTransport : Service {
+    public const string UPNP_ID = "urn:upnp-org:serviceId:AVTransport";
+    public const string UPNP_TYPE =
+                    "urn:schemas-upnp-org:service:AVTransport:1";
+    public const string DESCRIPTION_PATH = "xml/AVTransport.xml";
+    public const string LAST_CHANGE_NS =
+                    "urn:schemas-upnp-org:metadata-1-0/AVT/";
+
+    public  static string PLAY_SPEED = "1";
+    private static string PLAY_MODE = "NORMAL";
+    private static string PLAYBACK_MEDIA = "NONE,NETWORK";
+    private static string TRANSPORT_STATUS = "OK";
+
+    public MetadataParser metadataParser;
+    private DBusService dbus_service;
+
+    private PlayerPlaying           state_playing           = new PlayerPlaying();
+    private PlayerNoMediaPresent    state_no_media_present  = new PlayerNoMediaPresent();
+    private PlayerStopped           state_stopped           = new PlayerStopped();
+    private PlayerTransitioning     state_transitioning     = new PlayerTransitioning();
+    private PlayerPausedPlayback    state_paused_playback   = new PlayerPausedPlayback();
+    private PlayerState             cur_state;
+
+    // The setters below update the LastChange message
+    private uint _n_tracks = 0;
+    public uint n_tracks {
+        get {
+            return this._n_tracks;
+        }
+
+        set {
+            this._n_tracks = value;
+
+            this.changelog.log ("NumberOfTracks", this._n_tracks.to_string ());
+        }
+    }
+
+    private uint _track = 0;
+    public uint track {
+        get {
+            return this._track;
+        }
+
+        set {
+            this._track = value;
+
+            this.changelog.log ("CurrentTrack", this._track.to_string ());
+        }
+    }
+
+    private string _metadata = "";
+    public string metadata {
+        get {
+            return this._metadata;
+        }
+
+        set {
+            this._metadata = value;
+
+            string escaped = Markup.escape_text (this._metadata, -1);
+
+            this.changelog.log ("CurrentTrackMetaData", escaped);
+            this.changelog.log ("AVTransportURIMetaData", escaped);
+        }
+    }
+
+    public string playback_state {
+        owned get {
+            return this.cur_state.get_name ();
+        }
+
+        set {
+            if (value == this.playback_state) {
+                /*Ignore the state change request*/
+                debug("Already in " + value + ". Ignoring state change request.");
+                return;
+            }
+
+            switch (value) {
+                case "STOPPED":
+                    if (dbus_service != null) {
+                        dbus_service.PlayerStopped();
+                    }
+                    this.cur_state = this.state_stopped;
+                    break;
+                case "PAUSED_PLAYBACK":
+                    this.cur_state = this.state_paused_playback;
+                    break;
+                case "PLAYING":
+                    if (dbus_service != null) {
+                        string artist = (this.metadataParser == null || this.metadataParser.artist == null) ? "" : this.metadataParser.artist;
+                        string title = (this.metadataParser == null || this.metadataParser.title == null) ? "" : this.metadataParser.title;
+                        dbus_service.PlayerPlaying(artist, title);
+                    }
+                    this.cur_state = this.state_playing;
+                    break;
+                case "NO_MEDIA_PRESENT":
+                    this.cur_state = this.state_no_media_present;
+                    break;
+                case "TRANSITIONING":
+                    this.cur_state = this.state_transitioning;
+                    break;
+                default:
+                    break;
+            }
+            this.cur_state.enter (this);
+        }
+    }
+
+    private string _uri = "";
+    public string uri {
+        //transfer ownership by owned
+        owned get {
+                return _uri;
+        }
+
+        set {
+            this._uri = Markup.escape_text (value);
+
+            this.n_tracks = 1;
+            this.track = 1;
+            this.position = "00:00:00";
+            if (this._uri == "") {
+                this.playback_state = "NO_MEDIA_PRESENT";
+                this.n_tracks = 0;
+                this.track = 0;
+                this.metadataParser = null;
+            } else {
+                if (this.playback_state == "NO_MEDIA_PRESENT") {
+                    this.playback_state = "STOPPED";
+                }
+            }
+
+            this.changelog.log ("CurrentTrackURI", this._uri);
+            this.changelog.log ("AVTransportURI", this._uri);
+        }
+    }
+
+    public string duration {
+        //transfer ownership by owned
+        owned get {
+            if (this.metadataParser != null && this.metadataParser.duration != -1) {
+                return GstTime.to_string((int)this.metadataParser.duration);
+            }
+            if (this.uri != "") {
+                debug("%p: duration get %s", this, GstTime.to_string(this.audio_player.duration));
+                return GstTime.to_string(this.audio_player.duration);
+            } else {
+                return "00:00:00";
+            }
+        }
+    }
+
+    private void notify_duration_cb (Object audio_player, ParamSpec p) {
+        this.changelog.log ("CurrentTrackDuration", this.duration);
+        this.changelog.log ("CurrentMediaDuration", this.duration);
+        Timeout.add (1, this.change_state);
+    }
+
+    public string position {
+        //transfer ownership by owned
+        owned get {
+            if (this.uri == "") {
+                return "00:00:00";
+            }
+            return GstTime.to_string(this.audio_player.position);
+        }
+
+        set {
+            this.audio_player.position = GstTime.from_string (value);
+            debug("%p: position set %s", this, value);
+        }
+    }
+
+    public string protocol_info {
+        //transfer ownership by owned
+        owned get {
+                if (this.metadataParser != null && this.metadataParser.protocol_info != null) {
+                    return this.metadataParser.protocol_info.to_string();
+                }
+                return "";
+        }
+    }
+
+    private bool change_state () {
+        PlayingState new_state = audio_player.state;
+        if (this.playback_state == "STOPPED" && new_state != PlayingState.TRANSITIONING) {
+            debug("Possibly invalid transition callback from player");
+            return false;
+        }
+
+        switch(new_state) {
+        case PlayingState.PLAYING:
+            this.playback_state = "PLAYING";
+            break;
+        case PlayingState.PAUSED_PLAYBACK:
+            this.playback_state = "PAUSED_PLAYBACK";
+            break;
+        case PlayingState.STOPPED:
+            this.playback_state = "STOPPED";
+            break;
+        case PlayingState.TRANSITIONING:
+            this.playback_state = "TRANSITIONING";
+            break;
+        }
+
+        return false;
+    }
+
+    private void playing_cb () {
+        debug("%p: playing callback from player", this);
+        if (this.audio_player.duration == -1) {
+            debug("Duration is not computed yet");
+            Timeout.add_seconds (3, this.change_state);
+            return;
+        }
+        Timeout.add (1, this.change_state);
+    }
+
+    private void paused_cb () {
+        debug("%p: paused callback from player", this);
+        Timeout.add (1, this.change_state);
+    }
+
+    private bool eos_cb_timeout () {
+        this.playback_state = "STOPPED";
+        return false;
+    }
+
+    private void eos_cb () {
+        debug("%p: eos callback from player", this);
+        Timeout.add (1, this.eos_cb_timeout);
+    }
+
+    private void player_error_cb () {
+        /*
+         * An error might occur at the player side for several reasons.
+         * One common reason is the player might not be supporting the
+         * requested media format. In such a case we stop the player.
+         */
+        debug("%p: Error received from media player", this);
+        Timeout.add (1, this.change_state);
+    }
+
+    public GstChangeLog changelog;
+    private GstAudioPlayerInstance audio_player;
+
+    public override void constructed () {
+
+        this.changelog = new GstChangeLog (this, LAST_CHANGE_NS);
+        this.audio_player = GstAudioPlayerInstance.instance();
+        this.cur_state = this.state_no_media_present;
+
+        query_variable["LastChange"]            += this.query_last_change_cb;
+
+        action_invoked["SetAVTransportURI"]     += this.set_av_transport_uri_cb;
+        action_invoked["GetMediaInfo"]          += this.get_media_info_cb;
+        action_invoked["GetTransportInfo"]      += this.get_transport_info_cb;
+        action_invoked["GetCurrentTransportActions"]
+                                                += this.get_current_current_transport_actions_cb;
+        action_invoked["GetPositionInfo"]       += this.get_position_info_cb;
+        action_invoked["GetDeviceCapabilities"] += this.get_device_capabilities_cb;
+        action_invoked["GetTransportSettings"]  += this.get_transport_settings_cb;
+        action_invoked["Stop"]                  += this.stop_cb;
+        action_invoked["Play"]                  += this.play_cb;
+        action_invoked["Pause"]                 += this.pause_cb;
+        action_invoked["Seek"]                  += this.seek_cb;
+        action_invoked["Next"]                  += this.next_cb;
+        action_invoked["Previous"]              += this.previous_cb;
+
+        this.audio_player.notify["duration"]    += notify_duration_cb;
+        this.audio_player.playing               += this.playing_cb;
+        this.audio_player.paused                += this.paused_cb;
+        this.audio_player.eos                   += this.eos_cb;
+        this.audio_player.error                 += this.player_error_cb;
+
+        dbus_service = DBusService.get_default();
+        if (dbus_service == null) {
+            warning("%p: DBus service instance not created.", this);
+            return;
+        }
+    }
+
+    private void query_last_change_cb (GstAVTransport s,
+                                       string         variable,
+                                       ref Value      val) {
+
+        debug("%p: Initial Event Notification was sent for AVTransport", this);
+
+        // Send current state
+        GstChangeLog log = new GstChangeLog (null, LAST_CHANGE_NS);
+
+        string escaped;
+
+        /*
+            AVTransport.xml <serviceStateTable>
+            <stateVariable>
+        */
+
+        log.log ("TransportState",               this.playback_state);
+        log.log ("TransportStatus",              this.TRANSPORT_STATUS);
+        log.log ("CurrentTransportActions",      this.cur_state.get_current_transport_actions ());
+        log.log ("PlaybackStorageMedium",        "NOT_IMPLEMENTED");
+        log.log ("RecordStorageMedium",          "NOT_IMPLEMENTED");
+        log.log ("PossiblePlaybackStorageMedia", this.PLAYBACK_MEDIA);
+        log.log ("PossibleRecordStorageMedia",   "NOT_IMPLEMENTED");
+        log.log ("CurrentPlayMode",              this.PLAY_MODE);
+        log.log ("TransportPlaySpeed",           this.PLAY_SPEED);
+        log.log ("RecordMediumWriteStatus",      "NOT_IMPLEMENTED");
+        log.log ("CurrentRecordQualityMode",     "NOT_IMPLEMENTED");
+        log.log ("PossibleRecordQualityModes",   "NOT_IMPLEMENTED");
+        log.log ("NumberOfTracks",               this.n_tracks.to_string ());
+        log.log ("CurrentTrack",                 this.track.to_string ());
+        log.log ("CurrentTrackDuration",         this.duration);
+        log.log ("CurrentMediaDuration",         this.duration);
+        escaped = Markup.escape_text (this.metadata, -1);
+        log.log ("CurrentTrackMetaData",         escaped);
+        log.log ("AVTransportURIMetaData",       escaped);
+        log.log ("CurrentTrackURI",              this.uri);
+        log.log ("AVTransportURI",               this.uri);
+        log.log ("NextAVTransportURI",           "NOT_IMPLEMENTED");
+        log.log ("NextAVTransportURIMetaData",   "NOT_IMPLEMENTED");
+
+        val.init (typeof (string));
+        val.set_string (log.finish ());
+    }
+
+    // Error out if InstanceID is not 0
+    private bool check_instance_id (ServiceAction action) {
+        uint instance_id;
+
+        action.get ("InstanceID", typeof (uint), out instance_id);
+        if (instance_id != 0) {
+            action.return_error (718, "Invalid InstanceID");
+
+            return false;
+        }
+
+        return true;
+    }
+
+    private void set_av_transport_uri_cb (GstAVTransport      s,
+                                          owned ServiceAction action) {
+        if (!this.check_instance_id (action)) {
+            return;
+        }
+
+        string _uri, _metadata;
+
+        action.get ("CurrentURI",         typeof (string), out _uri,
+                    "CurrentURIMetaData", typeof (string), out _metadata);
+
+        this.uri = _uri;
+
+        this.metadataParser = new MetadataParser(_uri);
+        try {
+                this.metadataParser.parse_didl(_metadata);
+
+                debug("%p: Artist        : %s",  this, this.metadataParser.artist);
+                debug("%p: Song          : %s",  this, this.metadataParser.title);
+                debug("%p: Bitrate       : %d",  this, this.metadataParser.bitrate);
+                debug("%p: # Audio chans : %d",  this, this.metadataParser.audio_channels);
+                debug("%p: Sampling rate : %d",  this, this.metadataParser.sample_freq);
+                debug("%p: Duration      : %ld", this, this.metadataParser.duration);
+                debug("%p: Size          : %ld", this, this.metadataParser.size);
+        } catch (GLib.Error e) {
+                warning("%p: Couldn't parse metadata!", this);
+        }
+
+        this.metadata = _metadata;
+        if (this.metadataParser != null && this.metadataParser.protocol_info != null) {
+            this.audio_player.protocol_info = this.metadataParser.protocol_info.to_string ();
+        } else {
+            this.audio_player.protocol_info = null;
+        }
+
+        debug("%p: Set AVTransport URI: %s", this, this.uri);
+
+        action.return ();
+    }
+
+    private void get_media_info_cb (GstAVTransport      s,
+                                    owned ServiceAction action) {
+        if (!this.check_instance_id (action)) {
+            return;
+        }
+
+        action.set ("NrTracks",
+                        typeof (uint),
+                        this.n_tracks,
+                    "MediaDuration",
+                        typeof (string),
+                        this.duration,
+                    "CurrentURI",
+                        typeof (string),
+                        this.uri,
+                    "CurrentURIMetaData",
+                        typeof (string),
+                        this.metadata,
+                    "NextURI",
+                        typeof (string),
+                        "NOT_IMPLEMENTED",
+                    "NextURIMetaData",
+                        typeof (string),
+                        "NOT_IMPLEMENTED",
+                    "PlayMedium",
+                        typeof (string),
+                        "NOT_IMPLEMENTED",
+                    "RecordMedium",
+                        typeof (string),
+                        "NOT_IMPLEMENTED",
+                    "WriteStatus",
+                        typeof (string),
+                        "NOT_IMPLEMENTED");
+
+        action.return ();
+    }
+
+    private void get_transport_info_cb (GstAVTransport      s,
+                                        owned ServiceAction action) {
+        if (!this.check_instance_id (action)) {
+            return;
+        }
+
+        action.set ("CurrentTransportState",
+                        typeof (string),
+                        this.playback_state,
+                    "CurrentTransportStatus",
+                        typeof (string),
+                        this.TRANSPORT_STATUS,
+                    "CurrentSpeed",
+                        typeof (string),
+                        this.PLAY_SPEED);
+
+        action.return ();
+    }
+
+    private void get_current_current_transport_actions_cb (GstAVTransport      s,
+                                                           owned ServiceAction action) {
+        if (!this.check_instance_id (action)) {
+            return;
+        }
+
+        action.set ("Actions",
+                        typeof (string),
+                        this.cur_state.get_current_transport_actions ());
+
+        debug("%p: Get Current Transport Actions: %s", this, this.cur_state.get_current_transport_actions ());
+
+        action.return ();
+
+    }
+
+    private void get_position_info_cb (GstAVTransport      s,
+                                       owned ServiceAction action) {
+        if (!this.check_instance_id (action)) {
+            return;
+        }
+
+        action.set ("Track",
+                        typeof (uint),
+                        this.track,
+                    "TrackDuration",
+                        typeof (string),
+                        this.duration,
+                    "TrackMetaData",
+                        typeof (string),
+                        this.metadata,
+                    "TrackURI",
+                        typeof (string),
+                        this.uri,
+                    "RelTime",
+                        typeof (string),
+                        this.position,
+                    "AbsTime",
+                        typeof (string),
+                        this.position,
+                    "RelCount",
+                        typeof (int),
+                        int.MAX,
+                    "AbsCount",
+                        typeof (int),
+                        int.MAX);
+
+        action.return ();
+    }
+
+    private void get_device_capabilities_cb (GstAVTransport      s,
+                                             owned ServiceAction action) {
+        if (!this.check_instance_id (action)) {
+            return;
+        }
+
+        action.set ("PlayMedia",       typeof (string), this.PLAYBACK_MEDIA,
+                    "RecMedia",        typeof (string), "NOT_IMPLEMENTED",
+                    "RecQualityModes", typeof (string), "NOT_IMPLEMENTED");
+
+        action.return ();
+    }
+
+    private void get_transport_settings_cb (GstAVTransport      s,
+                                            owned ServiceAction action) {
+        if (!this.check_instance_id (action)) {
+            return;
+        }
+
+        action.set ("PlayMode",       typeof (string), this.PLAY_MODE,
+                    "RecQualityMode", typeof (string), "NOT_IMPLEMENTED");
+
+        action.return ();
+    }
+
+    private void stop_cb (GstAVTransport s, owned ServiceAction action) {
+        if (!this.check_instance_id (action)) {
+            return;
+        }
+
+        this.cur_state.stop (s, action);
+    }
+
+    private void play_cb (GstAVTransport s, owned ServiceAction action) {
+        if (!this.check_instance_id (action)) {
+            return;
+        }
+
+        this.cur_state.play (s, action, this.uri);
+    }
+
+    private void pause_cb (GstAVTransport s, owned ServiceAction action) {
+        if (!this.check_instance_id (action)) {
+            return;
+        }
+
+        this.cur_state.pause (s, action);
+    }
+
+    private void seek_cb (GstAVTransport s, owned ServiceAction action) {
+        if (!check_instance_id (action)) {
+            return;
+        }
+
+        this.cur_state.seek (s, action);
+    }
+
+    public virtual void next_cb (GstAVTransport s, owned ServiceAction action) {
+        if (!check_instance_id (action)) {
+            return;
+        }
+
+        this.cur_state.next (s, action);
+    }
+
+    public virtual void previous_cb (GstAVTransport s, owned ServiceAction action) {
+        if (!check_instance_id (action)) {
+            return;
+        }
+
+        this.cur_state.previous (s, action);
+    }
+}
--- /dev/null
+++ b/src/plugins/gst-renderer/rygel-gst-changelog.vala
@@ -0,0 +1,144 @@
+/*
+ * Copyright (C) 2008 OpenedHand Ltd.
+ * Copyright (C) 2009 Nokia Corporation.
+ *
+ * Author: Jorn Baayen <jorn@openedhand.com>
+ *         Zeeshan Ali (Khattak) <zeeshanak@gnome.org>
+ *                               <zeeshan.ali@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ */
+
+using GUPnP;
+using Gee;
+
+// Helper class for building LastChange messages
+public class Rygel.GstChangeLog : Object {
+    public unowned Service service { get; set; }
+
+    private string service_ns;
+
+    private StringBuilder str;
+
+    private HashMap<string, string> hash;
+    private Mutex hash_mutex;
+
+    private uint timeout_id = 0;
+
+    public GstChangeLog (Service? service, string service_ns) {
+        this.service = service;
+        this.service_ns = service_ns;
+        this.str = new StringBuilder ();
+        this.hash = new HashMap<string, string> ();
+        this.hash_mutex = new Mutex();
+    }
+
+    ~GstChangeLog () {
+        if (this.timeout_id != 0) {
+            Source.remove (this.timeout_id);
+        }
+    }
+
+    private bool timeout () {
+        if(this.hash.size != 0) {
+            // Emit notification
+            this.notify_change ();
+
+            return true;
+        }
+
+        this.timeout_id = 0;
+
+        return false;
+    }
+
+    private void ensure_timeout () {
+        /*
+         * Get into the moderation period,
+         * accumulate updates of any state variables and sent out them when period expires.
+         */
+        this.timeout_id = Timeout.add (400, this.timeout);
+    }
+
+    private void notify_change () {
+        string notify_message;
+        notify_message = this.finish ();
+        this.service.notify ("LastChange",
+                             typeof (string),
+                             notify_message);
+        //debug("%p: LastChange Event Notification Message was Sent: %s\n", this, notify_message);
+
+        // Reset
+        hash_mutex.lock();
+        this.hash.clear ();
+        hash_mutex.unlock();
+        this.str.erase (0, -1);
+    }
+
+    public void log (string variable,
+                     string value) {
+        hash_mutex.lock();
+        this.hash.set (variable,
+                       "<%s val=\"%s\"/>".printf (variable,value));
+        hash_mutex.unlock();
+
+        if (this.service != null && this.timeout_id == 0) {
+            /*
+             * It's an itinial LastChange event and should be sent out immediately,
+             * for followings events get into moderation period
+             */
+            this.notify_change ();
+            this.ensure_timeout ();
+        }
+    }
+
+    public void log_with_channel (string variable,
+                                  string value,
+                                  string channel) {
+        hash_mutex.lock();
+        this.hash.set (variable,
+                       "<%s val=\"%s\" channel=\"%s\"/>".printf (variable,
+                       value,
+                       channel));
+        hash_mutex.unlock();
+
+        if (this.service != null && this.timeout_id == 0) {
+            /*
+             * It's an itinial LastChange event and should be sent out immediately,
+             * for followings events get into moderation period
+             */
+            this.notify_change ();
+            this.ensure_timeout ();
+        }
+    }
+
+    public string finish () {
+        this.str.append ("<Event xmlns=\"" +
+                         this.service_ns +
+                         "\"><InstanceID val=\"0\">");
+        hash_mutex.lock();
+        foreach (string line in this.hash.values) {
+            this.str.append (line);
+        }
+        hash_mutex.unlock();
+        this.str.append ("</InstanceID></Event>");
+
+        return this.str.str;
+    }
+}
--- /dev/null
+++ b/src/plugins/gst-renderer/rygel-gst-connection-manager.vala
@@ -0,0 +1,97 @@
+/*
+ * Copyright (C) 2008 OpenedHand Ltd.
+ *
+ * Author: Jorn Baayen <jorn@openedhand.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ */
+
+using GUPnP;
+
+public class Rygel.GstConnectionManager : Rygel.ConnectionManager {
+    public override void constructed () {
+        base.constructed ();
+
+        this.connection_ids       = "0";
+        this.sink_protocol_info   = "http-get:*:audio/L16:DLNA.ORG_PN=LPCM;DLNA.ORG_FLAGS=AD300000000000000000000000000000," +
+                                    "http-get:*:audio/mpeg:DLNA.ORG_PN=MP3;DLNA.ORG_FLAGS=AD300000000000000000000000000000," +
+                                    "http-get:*:audio/vnd.dlna.adts:DLNA.ORG_PN=AAC_ADTS;DLNA.ORG_FLAGS=AD300000000000000000000000000000," +
+                                    "http-get:*:audio/mp4:DLNA.ORG_PN=AAC_ISO;DLNA.ORG_FLAGS=AD300000000000000000000000000000," +
+                                    "http-get:*:audio/3gpp:DLNA.ORG_PN=AAC_ISO;DLNA.ORG_FLAGS=AD300000000000000000000000000000," +
+                                    "http-get:*:audio/mp4:DLNA.ORG_PN=AAC_ISO_320;DLNA.ORG_FLAGS=AD300000000000000000000000000000," +
+                                    "http-get:*:audio/3gpp:DLNA.ORG_PN=AAC_ISO_320;DLNA.ORG_FLAGS=AD300000000000000000000000000000," +
+                                    "http-get:*:audio/vnd.dlna.adts:DLNA.ORG_PN=AAC_ADTS_320;DLNA.ORG_FLAGS=AD300000000000000000000000000000," +
+                                    "http-get:*:audio/mp4:DLNA.ORG_PN=AAC_LTP_ISO;DLNA.ORG_FLAGS=AD300000000000000000000000000000," +
+                                    "http-get:*:audio/L16:*," +
+                                    "http-get:*:audio/mpeg:*," +
+                                    "http-get:*:audio/mp4:*," +
+                                    "http-get:*:audio/3gpp:*," +
+                                    "http-get:*:audio/x-m4a:*," +
+                                    "http-get:*:audio/x-wav:*," +
+									"http-get:*:audio/x-vorbis:*," +
+                                    "http-get:*:audio/x-vorbis+ogg:*," +
+									"http-get:*:audio/x-ms-wma:*," +
+                                    "http-get:*:audio/x-ms-asf:*," +
+                                    "http-get:*:audio/x-flac:*," +
+                                    "http-get:*:audio/x-mod:*," +
+									"http-get:*:audio/x-ac3:*," +
+                                    "http-get:*:audio/x-m4a:*";
+    }
+
+    private override void get_current_connection_info_cb (ConnectionManager   cm,
+                                                 owned ServiceAction action) {
+
+        int connection_id;
+
+        /* We support single connection at a time, which must have ConnectionID=0 */
+        action.get ("ConnectionID", typeof (int), out connection_id);
+        if (connection_id != 0) {
+            action.return_error (706, "Invalid connection reference");
+
+            return;
+        }
+
+        RootDevice root_device = (Rygel.RootDevice) this.root_device;
+        GstAVTransport avt = null;
+
+        /* Find the AVTransport service attached to this root device. */
+        foreach (var service in root_device.services) {
+            if (service.get_type().is_a (typeof (Rygel.GstAVTransport))) {
+                avt = (Rygel.GstAVTransport) service;
+                break;
+            }
+        }
+
+        if (avt == null) {
+            /* This should never happen in fact! */
+            action.return_error (501, "Action Failed");
+            return;
+        }
+
+        action.set ("RcsID",                 typeof (int),    0,
+                    "AVTransportID",         typeof (int),    0,
+                    "ProtocolInfo",          typeof (string), avt.protocol_info,
+                    "PeerConnectionManager", typeof (string), "",
+                    "PeerConnectionID",      typeof (int),    -1,
+                    "Direction",             typeof (string), "Input",
+                    "Status",                typeof (string), "Unknown");
+
+        action.return ();
+    }
+}
--- /dev/null
+++ b/src/plugins/gst-renderer/rygel-gst-metadata-parser.vala
@@ -0,0 +1,131 @@
+/*
+ * rygel-gst-metadata-parser.vala
+ *   Metadata parser implementation
+ *
+ * (C) Copyright 2010, Ubicom, Inc.
+ *
+ * This file is part of the Ubicom32 Rygel.
+ *
+ * This program is free software: you can redistribute
+ * it and/or modify it under the terms of the GNU Lesser General Public
+ * License (LGPL) as published by the Free Software Foundation, either version 2.1
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it
+ * will be useful, but WITHOUT ANY WARRANTY; without even the implied
+ * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+ * the GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program.  If not,
+ * see <http://www.gnu.org/licenses/>.
+ */
+
+using GUPnP;
+using CStuff;
+
+public class Rygel.MetadataParser : GUPnP.DIDLLiteParser {
+
+       private DIDLLiteObject object;
+       private DIDLLiteResource resource;
+       private string resourceURI;
+
+       public MetadataParser (string resourceURI) {
+               this.resourceURI        = resourceURI;
+               this.object_available   += this.object_available_cb;
+       }
+
+       private void object_available_cb(DIDLLiteObject object)
+       {
+               debug("object_available_cb");
+               this.object = object;
+
+               foreach(var resource in object.get_resources()){
+                       if (this.resourceURI == resource.uri) {
+                               this.resource = resource;
+                               break;
+                       }
+               }
+       }
+
+       public string title {
+               get {
+                       if (object != null) {
+                               return object.title;
+                       }
+                       return "";
+               }
+       }
+
+       public string artist {
+               get {
+                       if (object != null) {
+                               return object.artist;
+                       }
+                       return "";
+               }
+       }
+
+       public int bitrate {
+               get {
+                       if (resource != null) {
+                               return resource.bitrate;
+                       }
+                       return -1;
+               }
+       }
+
+       public int sample_freq {
+               get {
+                       if (resource != null) {
+                               return resource.sample_freq;
+                       }
+                       return -1;
+               }
+       }
+
+       public int audio_channels {
+               get {
+                       if (resource != null) {
+                               return resource.audio_channels;
+                       }
+                       return -1;
+               }
+       }
+
+       public long duration {
+               get {
+                       if (resource != null) {
+                               return resource.duration;
+                       }
+                       return -1;
+               }
+       }
+
+       public long size {
+               get {
+                       if (resource != null) {
+                               return resource.size;
+                       }
+                       return -1;
+               }
+       }
+
+       public string uri {
+               get {
+                       if (resource != null) {
+                               return resource.uri;
+                       }
+                       return "";
+               }
+       }
+
+       public ProtocolInfo? protocol_info {
+               get {
+                       if (resource != null) {
+                               return resource.protocol_info;
+                       }
+                       return null;
+               }
+       }
+}
--- /dev/null
+++ b/src/plugins/gst-renderer/rygel-gst-player-states.vala
@@ -0,0 +1,249 @@
+/*
+ * rygel-gst-audio-player-instance.vala
+ *   Singleton implementation for audio player
+ *
+ * (C) Copyright 2010, Ubicom, Inc.
+ *
+ * This file is part of the Ubicom32 Rygel.
+ *
+ * This program is free software: you can redistribute
+ * it and/or modify it under the terms of the GNU Lesser General Public
+ * License (LGPL) as published by the Free Software Foundation, either version 2.1
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it
+ * will be useful, but WITHOUT ANY WARRANTY; without even the implied
+ * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+ * the GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program.  If not,
+ * see <http://www.gnu.org/licenses/>.
+ */
+
+using Owl;
+using GUPnP;
+using Rygel.Helper;
+
+public class Rygel.PlayerState {
+    private string state_name;
+    private string current_transport_actions;
+
+    public PlayerState(string state_name, string current_transport_actions) {
+        this.state_name = state_name;
+        this.current_transport_actions = current_transport_actions;
+    }
+
+    public virtual void enter (GstAVTransport s) {
+        debug("%p: Changing playback state to %s", this, this.state_name);
+        s.changelog.log ("TransportState", this.state_name);
+        s.changelog.log ("CurrentTransportActions", this.current_transport_actions);
+    }
+
+    public virtual string get_name () {
+        return this.state_name;
+    }
+
+    public virtual string get_current_transport_actions () {
+        return this.current_transport_actions;
+    }
+
+    public virtual void play (GstAVTransport s, owned ServiceAction action, string uri) {
+        debug("%p: %s: Play Action Requested, Transition not available", this, this.get_name());
+        action.return_error (701, "Transition not available");
+    }
+
+    public virtual void pause (GstAVTransport s, owned ServiceAction action) {
+        debug("%p: %s: Pause Action Requested, Transition not available", this, this.get_name());
+        action.return_error (701, "Transition not available");
+    }
+
+    public virtual void stop (GstAVTransport s, owned ServiceAction action) {
+        debug("%p: %s: Stop Action Requested, Transition not available", this, this.get_name());
+        action.return_error (701, "Transition not available");
+    }
+
+    public virtual void seek (GstAVTransport s, owned ServiceAction action) {
+        debug("%p: Seek Action Requested, Transition not available", this);
+        action.return_error (701, "Transition not available");
+    }
+
+    protected virtual void default_seek (GstAVTransport s, owned ServiceAction action) {
+        string unit, target;
+        action.get ("Unit",   typeof (string), out unit,
+                    "Target", typeof (string), out target);
+
+        switch (unit) {
+        case "ABS_TIME":
+        case "REL_TIME":
+                ProtocolInfo pinfo = s.metadataParser.protocol_info;
+                if (pinfo != null) {
+                    if ((pinfo.dlna_flags & DLNAFlags.BYTE_BASED_SEEK) != 0) {
+                        debug("%p: Server supports byte-based seek under LRADA mode", this);
+                    } else if ((pinfo.dlna_operation & DLNAOperation.RANGE) != 0) {
+                        debug("%p: Server supports byte-based seek under FRADA mode", this);
+                    } else {
+                        /* Currently, we only support byte-based seek in transport. */
+                        debug("%p: Time-based seek not supported!", this);
+                        action.return_error (710, "Seek mode not supported");
+                        return;
+                    }
+                } else {
+                        /*
+                         * Looks like we received a non-dlna content. However,
+                         * the Control Point might be non-dlna, hence does not provide
+                         * any DLNA info even if the server provides it. In such a case,
+                         * the transport layer is responsible to check that information.
+                         */
+                        debug("%p: No DLNA info found for the resource.", this);
+                }
+
+                if(GstTime.from_string (target) >= GstTime.from_string (s.duration)) {
+                        debug("%p:Seek Target value greater than or equal to TrackDuration !", this);
+                        action.return_error (711, "Illegal Seek Target");
+                        return;
+                }
+
+                s.position = target;
+                debug("%p: Seek Action Requested with Position: %s", this, s.position);
+                action.return ();
+
+                return;
+        default:
+            action.return_error (710, "Seek mode not supported");
+
+            return;
+        }
+    }
+
+    public virtual void next (GstAVTransport s, owned ServiceAction action) {
+        debug("%p: Next Action Requested, Illegal Seek Target", this);
+        action.return_error (711, "Illegal Seek Target");
+    }
+
+    public virtual void previous (GstAVTransport s, owned ServiceAction action) {
+        debug("%p: Previous Action Requested, Illegal Seek Target", this);
+        action.return_error (711, "Illegal Seek Target");
+    }
+}
+
+public class Rygel.PlayerNoMediaPresent : PlayerState {
+
+    public PlayerNoMediaPresent() {
+        base("NO_MEDIA_PRESENT", "");
+    }
+}
+
+public class Rygel.PlayerTransitioning : PlayerState {
+
+    public PlayerTransitioning() {
+        base("TRANSITIONING", "");
+    }
+}
+
+public class Rygel.PlayerStopped : PlayerState {
+
+    public PlayerStopped() {
+        base("STOPPED", "Play,Seek,X_DLNA_SeekTime");
+    }
+
+    public override void play (GstAVTransport s, owned ServiceAction action, string uri) {
+        string speed;
+        action.get ("Speed", typeof (string), out speed);
+        if (speed != s.PLAY_SPEED) {
+            action.return_error (717, "Play speed not supported");
+
+            return;
+        }
+
+        GstAudioPlayerInstance.instance().play (uri);
+        s.playback_state = "TRANSITIONING";
+
+        action.return ();
+    }
+
+    public override void seek (GstAVTransport s, owned ServiceAction action) {
+        default_seek(s, action);
+    }
+
+    public override void stop (GstAVTransport s, owned ServiceAction action) {
+        GstAudioPlayerInstance.instance().stop ();
+
+        action.return ();
+    }
+}
+
+public class Rygel.PlayerPlaying : PlayerState {
+
+    public PlayerPlaying() {
+        base("PLAYING", "Stop,Pause,Seek,X_DLNA_SeekTime");
+    }
+
+    public override void play (GstAVTransport s, owned ServiceAction action, string uri) {
+        string speed;
+        action.get ("Speed", typeof (string), out speed);
+        if (speed != s.PLAY_SPEED) {
+            action.return_error (717, "Play speed not supported");
+
+            return;
+        }
+
+        if (uri != GstAudioPlayerInstance.instance().uri) {
+            GstAudioPlayerInstance.instance().play (uri);
+            s.playback_state = "TRANSITIONING";
+        }
+
+        action.return ();
+    }
+
+    public override void pause (GstAVTransport s, owned ServiceAction action) {
+        s.playback_state = "TRANSITIONING";
+        GstAudioPlayerInstance.instance().pause ();
+
+        action.return ();
+    }
+
+    public override void stop (GstAVTransport s, owned ServiceAction action) {
+        GstAudioPlayerInstance.instance().stop ();
+
+        action.return ();
+    }
+
+    public override void seek (GstAVTransport s, owned ServiceAction action) {
+        default_seek(s, action);
+    }
+}
+
+public class Rygel.PlayerPausedPlayback : PlayerState {
+
+    public PlayerPausedPlayback() {
+        base("PAUSED_PLAYBACK", "Stop,Play");
+    }
+
+    public override void play (GstAVTransport s, owned ServiceAction action, string uri) {
+        string speed;
+        action.get ("Speed", typeof (string), out speed);
+        if (speed != s.PLAY_SPEED) {
+            action.return_error (717, "Play speed not supported");
+
+            return;
+        }
+
+        if (uri != GstAudioPlayerInstance.instance().uri) {
+            GstAudioPlayerInstance.instance().play (uri);
+            s.playback_state = "TRANSITIONING";
+        } else {
+            GstAudioPlayerInstance.instance().resume ();
+            s.playback_state = "PLAYING";
+        }
+
+        action.return ();
+    }
+
+    public override void stop (GstAVTransport s, owned ServiceAction action) {
+        GstAudioPlayerInstance.instance().stop ();
+
+        action.return ();
+    }
+}
+
--- /dev/null
+++ b/src/plugins/gst-renderer/rygel-gst-plugin.vala
@@ -0,0 +1,53 @@
+/*
+ * Copyright (C) 2008 Zeeshan Ali (Khattak) <zeeshanak@gnome.org>.
+ * Copyright (C) 2008 Nokia Corporation, all rights reserved.
+ *
+ * Author: Zeeshan Ali (Khattak) <zeeshanak@gnome.org>
+ *                               <zeeshan.ali@nokia.com>
+ *
+ * This file is part of Rygel.
+ *
+ * Rygel is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * Rygel is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ */
+
+using Rygel;
+using Gee;
+using CStuff;
+
+[ModuleInit]
+public void module_init (PluginLoader loader) {
+    string MEDIA_RENDERER_DESC_PATH = BuildConfig.DATA_DIR +
+                                      "/xml/MediaRenderer.xml";
+
+    var plugin = new Plugin (MEDIA_RENDERER_DESC_PATH,
+                             "GstRenderer",
+                             "Ubicom Renderer");
+
+    plugin.add_resource (new ResourceInfo (ConnectionManager.UPNP_ID,
+                                           ConnectionManager.UPNP_TYPE,
+                                           ConnectionManager.DESCRIPTION_PATH,
+                                           typeof (GstConnectionManager)));
+    plugin.add_resource (new ResourceInfo (GstAVTransport.UPNP_ID,
+                                           GstAVTransport.UPNP_TYPE,
+                                           GstAVTransport.DESCRIPTION_PATH,
+                                           typeof (GstAVTransport)));
+    plugin.add_resource (new ResourceInfo (GstRenderingControl.UPNP_ID,
+                                           GstRenderingControl.UPNP_TYPE,
+                                           GstRenderingControl.DESCRIPTION_PATH,
+                                           typeof (GstRenderingControl)));
+
+    loader.add_plugin (plugin);
+}
+
--- /dev/null
+++ b/src/plugins/gst-renderer/rygel-gst-rendering-control.vala
@@ -0,0 +1,273 @@
+/*
+ * Copyright (C) 2008 OpenedHand Ltd.
+ * Copyright (C) 2009 Nokia Corporation.
+ *
+ * Author: Jorn Baayen <jorn@openedhand.com>
+ *         Zeeshan Ali (Khattak) <zeeshanak@gnome.org>
+ *                               <zeeshan.ali@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ */
+
+using GUPnP;
+using Rygel;
+
+public class Rygel.GstRenderingControl : Service {
+    public const string UPNP_ID = "urn:upnp-org:serviceId:RenderingControl";
+    public const string UPNP_TYPE =
+                    "urn:schemas-upnp-org:service:RenderingControl:1";
+    public const string DESCRIPTION_PATH = "xml/RenderingControl.xml";
+    public const string LAST_CHANGE_NS =
+                    "urn:schemas-upnp-org:metadata-1-0/RCS/";
+
+    private DBusService dbus_service;
+
+    public bool mute {
+        get {
+            return this.audio_player.mute;
+        }
+
+        set {
+            this.audio_player.mute = value;
+            this.changelog.log_with_channel ("Mute",
+                                             value ? "1" : "0",
+                                             "Master");
+            if (dbus_service != null) {
+                dbus_service.Volume (this.volume, value);
+            }
+        }
+    }
+
+    public uint volume {
+        get {
+            return this.audio_player.volume;
+        }
+
+        set {
+            this.audio_player.volume = value;
+            this.changelog.log_with_channel ("Volume",
+                                             value.to_string (),
+                                             "Master");
+            if (dbus_service != null) {
+                dbus_service.Volume (value, this.mute);
+            }
+        }
+    }
+
+    private string _preset_name_list = "FactoryDefaults, InstallationDefaults";
+    public string preset_name_list {
+        get {
+            return this._preset_name_list;
+        }
+
+        set {
+            this._preset_name_list = value;
+
+            if (_preset_name_list  == "FactoryDefaults") {
+                this.mute = false;
+                this.volume = 50;
+            }
+            else if (_preset_name_list == "InstallationDefaults") {
+                //a new preset configuration may be tuned later on for InstallationDefaults
+                this.mute = false;
+                this.volume = 50;
+            }
+
+            this.changelog.log("PresetNameList", this.preset_name_list);
+        }
+    }
+
+    private GstChangeLog changelog;
+    private GstAudioPlayerInstance audio_player;
+
+    public override void constructed () {
+        this.changelog = new GstChangeLog (this, LAST_CHANGE_NS);
+        this.audio_player = GstAudioPlayerInstance.instance ();
+
+        query_variable["LastChange"] += this.query_last_change_cb;
+
+        action_invoked["ListPresets"]  += this.list_presets_cb;
+        action_invoked["SelectPreset"] += this.select_preset_cb;
+        action_invoked["GetMute"]      += this.get_mute_cb;
+        action_invoked["SetMute"]      += this.set_mute_cb;
+        action_invoked["GetVolume"]    += this.get_volume_cb;
+        action_invoked["SetVolume"]    += this.set_volume_cb;
+
+        dbus_service = DBusService.get_default();
+        if (dbus_service == null) {
+            warning("%p: DBus service instance not created.", this);
+            return;
+        }
+    }
+
+    private void query_last_change_cb (GstRenderingControl s,
+                                       string              var,
+                                       ref GLib.Value      val) {
+        debug("%p: Initial Event Notification was sent for RenderingControl", this);
+        // Send current state
+        var log = new GstChangeLog (null, LAST_CHANGE_NS);
+
+        log.log_with_channel ("Mute", this.mute ? "1" : "0", "Master");
+        log.log_with_channel ("Volume", this.volume.to_string (), "Master");
+        log.log("PresetNameList", this.preset_name_list);
+
+        val.init (typeof (string));
+        val.set_string (log.finish ());
+    }
+
+    // Error out if InstanceID is not 0
+    private bool check_instance_id (ServiceAction action) {
+        uint instance_id;
+
+        action.get ("InstanceID", typeof (uint), out instance_id);
+        if (instance_id != 0) {
+            action.return_error (702, "Invalid InstanceID");
+
+            return false;
+        }
+
+        return true;
+    }
+
+    private void list_presets_cb (GstRenderingControl s,
+                                  owned ServiceAction action) {
+        if (!this.check_instance_id (action)) {
+            return;
+        }
+
+        action.set ("CurrentPresetNameList",
+                        typeof (string),
+                        this.preset_name_list);
+
+        action.return ();
+    }
+
+    private void select_preset_cb (GstRenderingControl s,
+                                   owned ServiceAction action) {
+        if (!check_instance_id (action)) {
+            return;
+        }
+
+        string preset_name;
+
+        action.get ("PresetName", typeof (string), out preset_name);
+
+        if (preset_name == "FactoryDefaults") {
+            this.preset_name_list = "FactoryDefaults";
+        }
+        else if (preset_name == "InstallationDefaults") {
+            this.preset_name_list = "InstallationDefaults";
+        }
+        else {
+            action.return_error (701, "Invalid Name");
+
+            return;
+        }
+
+        action.return ();
+    }
+
+    // Error out if 'Channel' is not 'Master'
+    private bool check_channel (ServiceAction action) {
+        string channel;
+
+        action.get ("Channel", typeof (string), out channel);
+        if (channel != "Master") {
+            action.return_error (501, "Action Failed");
+
+            return false;
+        }
+
+        return true;
+    }
+
+    private void get_mute_cb (GstRenderingControl s,
+                              owned ServiceAction action) {
+        if (!this.check_instance_id (action)) {
+            return;
+        }
+
+        if (!check_channel (action)) {
+            return;
+        }
+
+        action.set ("CurrentMute", typeof (bool), this.mute);
+
+        action.return ();
+    }
+
+    private void set_mute_cb (GstRenderingControl s,
+                              owned ServiceAction action) {
+        if (!check_instance_id (action)) {
+            return;
+        }
+
+        if (!check_channel (action)) {
+            return;
+        }
+
+        bool mute;
+
+        action.get ("DesiredMute", typeof (bool), out mute);
+
+        this.mute = mute;
+
+        action.return ();
+    }
+
+    private void get_volume_cb (GstRenderingControl s,
+                                owned ServiceAction action) {
+        if (!this.check_instance_id (action)) {
+            return;
+        }
+
+        if (!check_channel (action)) {
+            return;
+        }
+
+        action.set ("CurrentVolume", typeof (uint), this.volume);
+
+        action.return ();
+    }
+
+    private void set_volume_cb (GstRenderingControl s,
+                                owned ServiceAction action) {
+        if (!this.check_instance_id (action)) {
+            return;
+        }
+
+        if (!check_channel (action)) {
+            return;
+        }
+
+        uint volume;
+
+        action.get ("DesiredVolume", typeof (uint), out volume);
+        if (volume > 100) {
+            action.return_error (501, "Action Failed");
+
+            return;
+        }
+
+        this.volume = volume;
+
+        action.return ();
+    }
+}
+
--- /dev/null
+++ b/src/plugins/gst-renderer/rygel-gst-video-window.vala
@@ -0,0 +1,197 @@
+/*
+ * Copyright (C) 2008 OpenedHand Ltd.
+ *
+ * Author: Jorn Baayen <jorn@openedhand.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ */
+
+using Gtk;
+using Gst;
+using Owl;
+
+public class Rygel.GstVideoWindow : Window {
+    private static GstVideoWindow video_window;
+
+    private VideoWidget video_widget;
+
+    private string _playback_state = "STOPPED";
+    public string playback_state {
+        get {
+            return this._playback_state;
+        }
+
+        set {
+            this._playback_state = value;
+
+            switch (_playback_state) {
+                case "STOPPED":
+                    this.video_widget.playing = false;
+
+                if (this.video_widget.can_seek) {
+                    this.video_widget.position = 0;
+                }
+
+                break;
+                case "PAUSED_PLAYBACK":
+                    this.video_widget.playing = false;
+                break;
+                case "PLAYING":
+                    this.video_widget.playing = true;
+                break;
+                default:
+                break;
+            }
+        }
+    }
+
+    public string uri {
+        get {
+            return this.video_widget.uri;
+        }
+
+        set {
+            this.video_widget.uri = value;
+        }
+    }
+
+    public double volume {
+        get {
+            return this.video_widget.volume;
+        }
+
+        set {
+            this.video_widget.volume = value;
+        }
+    }
+
+    public string duration { get; private set; }
+    public string playback_position { get; private set; }
+
+    construct {
+        this.type = WindowType.TOPLEVEL;
+    }
+
+    private GstVideoWindow () {
+        this.fullscreen_state = true;
+
+        this.video_widget.eos += this.eos_cb;
+        this.video_widget.notify["duration"] += this.notify_duration_cb;
+        this.video_widget.notify["position"] += this.notify_position_cb;
+
+        // Show a video widget
+        this.video_widget = new VideoWidget ();
+        this.video_widget.show ();
+
+        this.add (video_widget);
+        this.show_all ();
+
+        this.key_press_event += this.key_press_callback;
+    }
+
+    public static GstVideoWindow get_default () {
+        if (video_window == null) {
+            video_window = new GstVideoWindow ();
+        }
+
+        return video_window;
+    }
+
+    public bool fullscreen_state {
+        get {
+            if (this.window != null) {
+                return (this.window.get_state () &
+                        Gdk.WindowState.FULLSCREEN) != 0;
+            }
+
+            return false;
+        }
+
+        set {
+            if (value)
+                this.fullscreen ();
+            else {
+                this.unfullscreen ();
+            }
+        }
+    }
+
+    private bool key_press_callback (GstVideoWindow window,
+                                     Gdk.EventKey   event) {
+        switch (event.keyval) {
+            case 0xffc8: /* Gdk.KeySyms.F11 */
+                this.fullscreen_state = ! fullscreen_state;
+                break;
+            case 0xff1b: /* Gdk.KeySyms.Escape */
+                this.fullscreen_state = false;
+                break;
+            default:
+                break;
+        }
+        return false;
+    }
+
+    private void eos_cb (VideoWidget video_widget) {
+        this.playback_state = "STOPPED";
+    }
+
+    private void notify_duration_cb (VideoWidget video_widget,
+                                     ParamSpec   p) {
+        this.duration = Time.to_string (video_widget.duration);
+    }
+
+    private void notify_position_cb (VideoWidget video_widget,
+                                     ParamSpec   p) {
+        this.playback_position = Time.to_string (video_widget.position);
+    }
+
+    public bool seek (string time) {
+        if (this.video_widget.can_seek) {
+            this.video_widget.position = Time.from_string (time);
+
+            return true;
+        } else {
+            return false;
+        }
+    }
+}
+
+// Helper class for converting between second and string representations
+// of time.
+private class Time {
+    public static int from_string (string str) {
+        int hours, minutes, seconds;
+
+        str.scanf ("%d:%2d:%2d%*s", out hours, out minutes, out seconds);
+
+        return hours * 3600 + minutes * 60 + seconds;
+    }
+
+    public static string to_string (int time) {
+        int hours, minutes, seconds;
+
+        hours   = time / 3600;
+        seconds = time % 3600;
+        minutes = seconds / 60;
+        seconds = seconds % 60;
+
+        return "%d:%.2d:%.2d".printf (hours, minutes, seconds);
+    }
+}
+
--- /dev/null
+++ b/src/plugins/gst-renderer/rygel-helper-gst-time.vala
@@ -0,0 +1,46 @@
+/*
+ * Copyright (C) 2008 OpenedHand Ltd.
+ *
+ * Author: Jorn Baayen <jorn@openedhand.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ */
+using CStuff;
+
+// Helper class for converting between second and string representations
+// of time.
+private class Rygel.Helper.GstTime {
+    public static int from_string (string str) {
+        int hours, minutes, seconds;
+
+        str.scanf ("%2d:%2d:%2d%*s", out hours, out minutes, out seconds);
+
+        return hours * 3600 + minutes * 60 + seconds;
+    }
+
+    public static string to_string (int time) {
+        int hours, minutes, seconds;
+
+        hours   = time / 3600;
+        seconds = time % 60;
+        minutes = (time / 60) % 60;
+
+        return "%.2d:%.2d:%.2d".printf (hours, minutes, seconds);
+    }
+}
--- a/src/rygel/Makefile.am
+++ b/src/rygel/Makefile.am
@@ -12,9 +12,14 @@ else
 plugindir = $(libdir)/rygel-1.0
 endif
 
+DATA_DIR=$(shareddir:$(prefix)%=%)
+SYS_CONFIG_DIR=$(sysconfdir:$(prefix)%=%)
+PLUGIN_DIR=$(plugindir:$(prefix)%=%)
+DESKTOP_DIR=$(desktopdir:$(prefix)%=%)
+
 AM_CFLAGS = $(LIBGUPNP_CFLAGS) \
 	    $(LIBGUPNP_AV_CFLAGS) \
-	    $(LIBGSTREAMER_CFLAGS) \
+	    $(LIBGLIB_CFLAGS) \
 	    $(GIO_CFLAGS) \
 	    $(GEE_CFLAGS) \
 	    $(UUID_CFLAGS) \
@@ -22,8 +27,8 @@ AM_CFLAGS = $(LIBGUPNP_CFLAGS) \
 	    $(LIBDBUS_GLIB_CFLAGS) \
 	    $(LIBSQLITE3_CFLAGS) \
 	    -I$(top_srcdir) \
-	    -DDATA_DIR='"$(shareddir)"' -DSYS_CONFIG_DIR='"$(sysconfdir)"'\
-	    -DPLUGIN_DIR='"$(plugindir)"' -DDESKTOP_DIR='"$(desktopdir)"'\
+	    -DDATA_DIR='"$(DATA_DIR)"' -DSYS_CONFIG_DIR='"$(SYS_CONFIG_DIR)"'\
+	    -DPLUGIN_DIR='"$(PLUGIN_DIR)"' -DDESKTOP_DIR='"$(DESKTOP_DIR)"'\
 	    -include config.h
 
 librygelincdir = $(includedir)/rygel-1.0
@@ -47,17 +52,12 @@ VAPI_SOURCE_FILES = rygel-configuration.
 		    rygel-cmdline-config.vala \
 		    rygel-content-directory.vala \
 		    rygel-connection-manager.vala \
-		    rygel-transcode-manager.vala \
 		    rygel-http-server.vala \
 		    rygel-state-machine.vala \
 		    rygel-http-request.vala \
 		    rygel-http-request-handler.vala \
 		    rygel-http-identity-handler.vala \
-		    rygel-http-transcode-handler.vala \
-		    rygel-http-seek.vala \
 		    rygel-http-response.vala \
-		    rygel-live-response.vala \
-		    rygel-seekable-response.vala \
 		    rygel-resource-info.vala \
 		    rygel-icon-info.vala \
 		    rygel-plugin.vala \
@@ -72,28 +72,20 @@ VAPI_SOURCE_FILES = rygel-configuration.
 		    rygel-thumbnailer.vala \
 		    rygel-browse.vala \
 		    rygel-didl-lite-writer.vala \
-		    rygel-transcoder.vala \
-		    rygel-mp2ts-transcoder.vala \
-		    rygel-mp3-transcoder.vala \
-		    rygel-l16-transcoder.vala \
-		    rygel-mp2ts-transcoder-bin.vala \
-		    rygel-mp3-transcoder-bin.vala \
-		    rygel-l16-transcoder-bin.vala \
-		    rygel-gst-utils.vala \
 		    rygel-media-db.vala \
-		    rygel-metadata-extractor.vala \
 		    rygel-media-db-container.vala \
 		    rygel-media-db-object-factory.vala \
-		    rygel-log-handler.vala
+		    rygel-log-handler.vala \
+		    rygel-network-manager.vala \
+		    rygel-network-device.c
 
 rygel_VALAFLAGS = \
-	-H rygel.h -C --library=rygel-1.0 --vapidir=$(srcdir) --thread \
+	-H rygel.h -C --library=rygel-1.0 --vapidir=$(srcdir) --vapidir=$(top_srcdir)/vapi --thread \
 	--pkg cstuff --pkg gupnp-1.0 --pkg gupnp-av-1.0 --pkg dbus-glib-1 \
-	--pkg gstreamer-0.10 --pkg gio-2.0 --pkg gee-1.0 --pkg sqlite3
+	--pkg gmodule-2.0 --pkg gio-2.0 --pkg gee-1.0 --pkg sqlite3 --pkg rygel-network-device
 
 rygel_LDADD = $(LIBGUPNP_LIBS) \
 	      $(LIBGUPNP_AV_LIBS) \
-	      $(LIBGSTREAMER_LIBS) \
 	      $(GIO_LIBS) \
 	      $(GEE_LIBS) \
 	      $(UUID_LIBS) \
@@ -107,7 +99,6 @@ VAPI_FILES = rygel-1.0.vapi
 DEPS_FILES = rygel-1.0.deps
 
 vapidir = $(VAPIDIR)
-vapi_DATA = $(VAPI_FILES) $(DEPS_FILES)
 rygel-1.0.vapi rygel.h: $(VAPI_SOURCE_FILES)
 
 noinst_LIBRARIES = librygel-configuration.a
--- a/src/rygel/rygel-cmdline-config.vala
+++ b/src/rygel/rygel-cmdline-config.vala
@@ -103,7 +103,6 @@ public class Rygel.CmdlineConfig : GLib.
         var opt_context = new OptionContext (parameter_string);
         opt_context.set_help_enabled (true);
         opt_context.add_main_entries (options, null);
-        opt_context.add_group (Gst.init_get_option_group ());
         opt_context.parse (ref args);
 
 		if (version) {
--- a/src/rygel/rygel-connection-manager.vala
+++ b/src/rygel/rygel-connection-manager.vala
@@ -31,7 +31,7 @@ using GUPnP;
 public class Rygel.ConnectionManager : Service {
     public const string UPNP_ID = "urn:upnp-org:serviceId:ConnectionManager";
     public const string UPNP_TYPE =
-                    "urn:schemas-upnp-org:service:ConnectionManager:2";
+                    "urn:schemas-upnp-org:service:ConnectionManager:1";
     public const string DESCRIPTION_PATH = "xml/ConnectionManager.xml";
 
     protected string sink_protocol_info;
@@ -39,7 +39,11 @@ public class Rygel.ConnectionManager : S
 
     protected string source_protocol_info {
         owned get {
-            return this.get_http_server ().get_protocol_info ();
+            HTTPServer server = this.get_http_server ();
+            if (server != null) {
+                return server.get_protocol_info ();
+            }
+            return "";
         }
     }
 
@@ -97,7 +101,7 @@ public class Rygel.ConnectionManager : S
         action.return ();
     }
 
-    private void get_current_connection_info_cb (ConnectionManager   cm,
+    protected virtual void get_current_connection_info_cb (ConnectionManager   cm,
                                                  owned ServiceAction action) {
         int connection_id;
 
@@ -108,8 +112,8 @@ public class Rygel.ConnectionManager : S
             return;
         }
 
-        action.set ("ResID",                 typeof (int),    -1,
-                    "AVTransportID",         typeof (int),    -1,
+        action.set ("RcsID",                 typeof (int),    0,
+                    "AVTransportID",         typeof (int),    0,
                     "ProtocolInfo",          typeof (string), "",
                     "PeerConnectionManager", typeof (string), "",
                     "PeerConnectionID",      typeof (int),    -1,
--- a/src/rygel/rygel-dbus-service.vala
+++ b/src/rygel/rygel-dbus-service.vala
@@ -20,6 +20,8 @@
  * along with this program; if not, write to the Free Software Foundation,
  * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
  */
+using GUPnP;
+using CStuff;
 
 [DBus (name = "org.gnome.Rygel1")]
 public class Rygel.DBusService : Object {
@@ -28,8 +30,35 @@ public class Rygel.DBusService : Object
 
     private Main main;
 
-    public DBusService (Main main) throws DBus.Error {
-        this.main = main;
+    /* Signal emmitted to the bus in case of udn generated */
+    public signal void UdnChanged (string new_udn);
+
+    /* Signal emmitted to the bus in case of player stopped */
+    public signal void PlayerStopped ();
+
+    /* Signal emitted to the bus in case of player is in playing state */
+    public signal void PlayerPlaying (string artist, string title);
+
+    /* Signal emmitted to the bus in case of volume/mute changed */
+    public signal void Volume (uint volume, bool mute);
+
+    private static DBusService instance;
+
+    public static DBusService get_default() {
+        if (instance != null) {
+            return instance;
+        }
+        try {
+            instance = new DBusService();
+        } catch (DBus.Error err) {
+             warning ("Failed to create D-Bus service: %s", err.message);
+             return null;
+        }
+        return instance;
+    }
+
+    private DBusService () throws DBus.Error {
+        this.main = Main.get_default ();
 
         var conn = DBus.Bus.get (DBus.BusType. SESSION);
 
@@ -52,5 +81,61 @@ public class Rygel.DBusService : Object
     public void Shutdown () {
         this.main.exit (0);
     }
+
+    public int ChangeFriendlyName (string friendlyname) {
+	if (friendlyname == "") {
+            warning("%p: Received empty friendly name!", this);
+            return -1;
+	}
+
+        string device_desc_path = "/root/.config/Rygel/GstRenderer.xml";
+        RootDevice root_device = this.main.get_root_device_by_desc_path(device_desc_path);
+        if (root_device == null) {
+            warning("%p: No root device with description path %s", this, device_desc_path);
+            return -1;
+        }
+
+        /*
+         * Read device description XML file and update the friendly name.
+         */
+        var doc = new XMLDoc.from_path (device_desc_path);
+	Xml.Node *device_element;
+        device_element = Utils.get_xml_element ((Xml.Node *) doc.doc, "root", "device", null);
+        if (device_element == null) {
+            warning ("%p: Element /root/device not found.", this);
+            return -1;
+        }
+
+        Xml.Node *element = Utils.get_xml_element (device_element, "friendlyName", null);
+        if (element == null) {
+            warning ("%p: Element /root/device/friendlyName not found.", this);
+            return -1;
+        }
+
+        string cur_name = element->get_content ();
+        debug("%p: current friendly name : %s New: %s", this, cur_name, friendlyname);
+        element->set_content (friendlyname);
+
+	/*
+	 * Save modified description file
+	 */
+        FileStream fs = FileStream.open (device_desc_path, "w+");
+        if (fs == null) {
+            warning("%p: Could not open file: %s.\n", this, device_desc_path);
+            return -1;
+        }
+
+        int res = Xml.Doc.dump (fs, doc.doc);
+        if (res == -1) {
+            warning("%p: Failed to write modified description to %s.\n", this, device_desc_path);
+            return -1;
+        }
+
+        debug("%p: Sending byebye messages", this);
+        root_device.available = false;
+        debug("%p: Sending alive messages", this);
+        root_device.available = true;
+        return 1;
+    }
 }
 
--- a/src/rygel/rygel-http-identity-handler.vala
+++ b/src/rygel/rygel-http-identity-handler.vala
@@ -49,15 +49,7 @@ internal class Rygel.HTTPIdentityHandler
         }
 
         if (request.thumbnail == null && request.item.should_stream ()) {
-            if (request.time_range != null) {
-                request.time_range.add_response_header (request.msg,
-                                                        request.item.duration);
-            }
         } else {
-            request.msg.response_headers.append ("Accept-Ranges", "bytes");
-            if (request.byte_range != null) {
-                request.byte_range.add_response_header (request.msg, size);
-            }
         }
 
         // Chain-up
@@ -67,28 +59,13 @@ internal class Rygel.HTTPIdentityHandler
     public override HTTPResponse render_body (HTTPRequest request)
                                               throws HTTPRequestError {
         if (request.thumbnail != null) {
-            return new SeekableResponse (request.server,
-                                         request.msg,
-                                         request.thumbnail.uri,
-                                         request.byte_range,
-                                         request.thumbnail.size,
-                                         this.cancellable);
+		throw new HTTPRequestError.NOT_FOUND ("Not found");
         }
 
         var item = request.item;
 
         if (item.should_stream ()) {
-            Gst.Element src = item.create_stream_source ();
-            if (src == null) {
-                throw new HTTPRequestError.NOT_FOUND ("Not found");
-            }
-
-            return new LiveResponse (request.server,
-                                     request.msg,
-                                     "RygelLiveResponse",
-                                     src,
-                                     request.time_range,
-                                     this.cancellable);
+		throw new HTTPRequestError.NOT_FOUND ("Not found");
         } else {
             if (item.uris.size == 0) {
                 throw new HTTPRequestError.NOT_FOUND (
@@ -96,12 +73,7 @@ internal class Rygel.HTTPIdentityHandler
                         item.id);
             }
 
-            return new SeekableResponse (request.server,
-                                         request.msg,
-                                         item.uris.get (0),
-                                         request.byte_range,
-                                         item.size,
-                                         this.cancellable);
+		throw new HTTPRequestError.NOT_FOUND ("Not found");
         }
     }
 
--- a/src/rygel/rygel-http-request.vala
+++ b/src/rygel/rygel-http-request.vala
@@ -23,7 +23,6 @@
  * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
  */
 
-using Gst;
 
 internal errordomain Rygel.HTTPRequestError {
     UNACCEPTABLE = Soup.KnownStatusCode.NOT_ACCEPTABLE,
@@ -49,8 +48,6 @@ internal class Rygel.HTTPRequest : GLib.
     private int thumbnail_index;
     public MediaItem item;
     public Thumbnail thumbnail;
-    public HTTPSeek byte_range;
-    public HTTPSeek time_range;
 
     private HTTPRequestHandler request_handler;
 
@@ -108,15 +105,8 @@ internal class Rygel.HTTPRequest : GLib.
 
     private void handle_item_request () {
         try {
-            this.byte_range = HTTPSeek.from_byte_range(this.msg);
-            this.time_range = HTTPSeek.from_time_range(this.msg);
-
             // Add headers
             this.request_handler.add_response_headers (this);
-            debug ("Following HTTP headers appended to response:");
-            this.msg.response_headers.foreach ((name, value) => {
-                    debug ("%s : %s", name, value);
-            });
 
             if (this.msg.method == "HEAD") {
                 // Only headers requested, no need to send contents
@@ -134,7 +124,7 @@ internal class Rygel.HTTPRequest : GLib.
     }
 
     private void on_item_found (GLib.Object? source_object,
-                                AsyncResult  res) {
+                                AsyncResult res) {
         var container = (MediaContainer) source_object;
 
         MediaObject media_object;
@@ -167,14 +157,6 @@ internal class Rygel.HTTPRequest : GLib.
         }
 
         this.item_id = this.query.lookup ("itemid");
-        var target = this.query.lookup ("transcode");
-        if (target != null) {
-            debug ("Transcoding target: %s", target);
-
-            var transcoder = this.http_server.get_transcoder (target);
-            this.request_handler = new HTTPTranscodeHandler (transcoder,
-                                                             this.cancellable);
-        }
 
         var index = this.query.lookup ("thumbnail");
         if (index != null) {
--- a/src/rygel/rygel-http-response.vala
+++ b/src/rygel/rygel-http-response.vala
@@ -21,7 +21,6 @@
  * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
  */
 
-using Gst;
 
 internal abstract class Rygel.HTTPResponse : GLib.Object, Rygel.StateMachine {
     public Soup.Server server { get; private set; }
--- a/src/rygel/rygel-http-server.vala
+++ b/src/rygel/rygel-http-server.vala
@@ -21,11 +21,10 @@
  * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
  */
 
-using Gst;
 using GUPnP;
 using Gee;
 
-internal class Rygel.HTTPServer : Rygel.TranscodeManager, Rygel.StateMachine {
+internal class Rygel.HTTPServer : GLib.Object, Rygel.StateMachine {
     private const string SERVER_PATH_PREFIX = "/RygelHTTPServer";
     private string path_root;
 
@@ -38,8 +37,6 @@ internal class Rygel.HTTPServer : Rygel.
 
     public HTTPServer (ContentDirectory content_dir,
                        string           name) throws GLib.Error {
-        base ();
-
         this.root_container = content_dir.root_container;
         this.context = content_dir.context;
         this.cancellable = content_dir.cancellable;
@@ -61,7 +58,7 @@ internal class Rygel.HTTPServer : Rygel.
      * implemenation out there just choose the first one in the list instead of
      * the one they can handle.
      */
-    internal override void add_resources (DIDLLiteItem didl_item,
+    internal void add_resources (DIDLLiteItem didl_item,
                                           MediaItem    item)
                                 throws Error {
         if (!this.http_uri_present (item)) {
@@ -71,8 +68,6 @@ internal class Rygel.HTTPServer : Rygel.
             item.add_resource (didl_item, uri, protocol);
         }
 
-        base.add_resources (didl_item, item);
-
         // Thumbnails comes in the end
         foreach (var thumbnail in item.thumbnails) {
             if (!is_http_uri (thumbnail.uri)) {
@@ -126,7 +121,7 @@ internal class Rygel.HTTPServer : Rygel.
                                           path);
     }
 
-    internal override string create_uri_for_item (MediaItem item,
+    internal string create_uri_for_item (MediaItem item,
                                                   int       thumbnail_index,
                                                   string?   transcode_target,
                                                   out string protocol) {
@@ -146,16 +141,12 @@ internal class Rygel.HTTPServer : Rygel.
         return create_uri_for_path (query);
     }
 
-    internal override string get_protocol () {
+    internal string get_protocol () {
         return "http-get";
     }
 
-    internal override string get_protocol_info () {
+    internal string get_protocol_info () {
         var protocol_info = this.get_protocol () + ":*:*:*";
-        var base_info = base.get_protocol_info ();
-
-        if (base_info != "")
-            protocol_info += "," + base_info;
 
         return protocol_info;
     }
--- a/src/rygel/rygel-main.vala
+++ b/src/rygel/rygel-main.vala
@@ -38,6 +38,16 @@ public class Rygel.Main : Object {
 
     private int exit_code;
 
+    private static Main instance;
+    public static Main get_default() {
+        if (instance == null) {
+            instance = new Main();
+        }
+
+        return instance;
+    }
+
+
     private Main () throws GLib.Error {
         Environment.set_application_name (_(BuildConfig.PACKAGE_NAME));
 
@@ -61,6 +71,21 @@ public class Rygel.Main : Object {
         this.main_loop.quit ();
     }
 
+    public RootDevice get_root_device_by_desc_path(string device_desc_path) {
+
+	debug("%p: requested device description path is %s", this, device_desc_path);
+	RootDevice root_device = null;
+	foreach(var _root_device in this.root_devices) {
+		debug("%p: device description path is %s", this, _root_device.description_path);
+		if (_root_device.description_path == device_desc_path) {
+			root_device = _root_device;
+			break;
+		}
+	}
+
+	return root_device;
+    }
+
     private int run () {
         this.plugin_loader.load_plugins ();
 
@@ -193,17 +218,20 @@ public class Rygel.Main : Object {
     private static int main (string[] args) {
         Main main;
         DBusService service;
+        NetworkManagerService nm_service;
+
+        try {
+            nm_service = new NetworkManagerService ();
+        } catch (DBus.Error err) {
+            warning ("Failed to start D-Bus service: %s", err.message);
+        }
 
         try {
             // Parse commandline options
             CmdlineConfig.parse_args (ref args);
 
-            // initialize gstreamer
-            var dummy_args = new string[0];
-            Gst.init (ref dummy_args);
-
-            main = new Main ();
-            service = new DBusService (main);
+            main = Main.get_default ();
+            service = DBusService.get_default ();
         } catch (DBus.Error err) {
             warning ("Failed to start D-Bus service: %s", err.message);
         } catch (CmdlineConfigError.VERSION_ONLY err) {
--- a/src/rygel/rygel-media-item.vala
+++ b/src/rygel/rygel-media-item.vala
@@ -22,7 +22,6 @@
 
 using GUPnP;
 using Gee;
-using Gst;
 
 private errordomain Rygel.MediaItemError {
     BAD_URI
@@ -77,24 +76,6 @@ public class Rygel.MediaItem : MediaObje
         this.thumbnails = new ArrayList<Thumbnail> ();
     }
 
-    // Live media items need to provide a nice working implementation of this
-    // method if they can/do not provide a valid URI
-    public virtual Element? create_stream_source () {
-        dynamic Element src = null;
-
-        if (this.uris.size != 0) {
-            src = Element.make_from_uri (URIType.SRC, this.uris.get (0), null);
-        }
-
-        if (src != null && src.get_type ().name () == "GstRTSPSrc") {
-            // For rtspsrc since some RTSP sources takes a while to start
-            // transmitting
-            src.tcp_timeout = (int64) 60000000;
-        }
-
-        return src;
-    }
-
     // Return true if item should be streamed as a live response with
     // time based seeking, or false to serve directly with byte range
     // seeking.
@@ -127,14 +108,6 @@ public class Rygel.MediaItem : MediaObje
         }
     }
 
-    internal int compare_transcoders (void *a, void *b) {
-        var transcoder1 = (Transcoder) a;
-        var transcoder2 = (Transcoder) b;
-
-        return (int) transcoder1.get_distance (this) -
-               (int) transcoder2.get_distance (this);
-    }
-
     internal void add_resources (DIDLLiteItem didl_item,
                                  bool         allow_internal)
                                  throws Error {
--- /dev/null
+++ b/src/rygel/rygel-network-manager.vala
@@ -0,0 +1,186 @@
+/*
+ * rygel-network-manager.vala
+ *   A simple NetworkManager implementation for Rygel
+ *
+ * (C) Copyright 2010, Ubicom, Inc.
+ *
+ * This file is part of the Ubicom32 Rygel.
+ *
+ * This program is free software: you can redistribute
+ * it and/or modify it under the terms of the GNU Lesser General Public
+ * License (LGPL) as published by the Free Software Foundation, either version 2.1
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it
+ * will be useful, but WITHOUT ANY WARRANTY; without even the implied
+ * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+ * the GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program.  If not,
+ * see <http://www.gnu.org/licenses/>.
+ */
+
+using Rygel.NetworkDevice;
+
+ /*
+  * A very limited NetworkManager implementation designed to satisfy
+  * the requirements of GUPnP and Rygel
+  */
+[DBus (name = "org.freedesktop.NetworkManager")]
+public class Rygel.NetworkManagerService : Object {
+    private static string NM_SERVICE = "org.freedesktop.NetworkManager";
+    private static string NM_PATH = "/org/freedesktop/NetworkManager";
+    private static string DEVICE_PATH = "/a/b/";
+
+    private DBus.ObjectPath []device_paths;         /* Array of associated network device paths */
+
+    public NetworkManagerService () throws DBus.Error {
+
+        var conn = DBus.Bus.get (DBus.BusType.SYSTEM);
+
+        dynamic DBus.Object bus = conn.get_object ("org.freedesktop.DBus",
+                                                   "/org/freedesktop/DBus",
+                                                   "org.freedesktop.DBus");
+
+        /* try to register service in system bus */
+        uint request_name_result  = bus.request_name (NM_SERVICE, (uint) 0);
+
+        if (request_name_result != DBus.RequestNameReply.PRIMARY_OWNER) {
+            warning ("Failed to start D-Bus service, name '%s' already taken",
+                     NM_SERVICE);
+        }
+        conn.register_object (NM_PATH, this);
+
+        GLib.List<string> interface_list = NetworkDevice.get_interface_list ();
+        uint n_devices = interface_list.length ();
+        DBus.ObjectPath []device_paths = new DBus.ObjectPath[n_devices];
+        for (uint i = 0; i < n_devices; i++) {
+            string interface_name = interface_list.nth_data (i);
+            device_paths[i] = new DBus.ObjectPath (DEVICE_PATH + interface_name);
+            conn.register_object (device_paths[i], new NetworkManagerDevice (interface_name));
+        }
+        this.device_paths = device_paths;
+    }
+
+    /*
+     * Returns the paths of associated network devices to the bus
+     */
+    public DBus.ObjectPath []GetDevices () {
+        return this.device_paths;
+    }
+}
+
+/*
+ * Represents a network device
+ */
+[DBus (name = "org.freedesktop.NetworkManager.Device")]
+public class Rygel.NetworkManagerDevice : Object {
+
+    private static int NETWORK_STATUS_CHECK_INTERVAL = 4;
+    private string ip;              /* ip address of the device */
+    private string netmask;         /* netmask of the device */
+    private bool connection_is_up;  /* connection status of the device */
+
+    public NetworkManagerDevice (string interface_name) {
+        this.Interface = interface_name;
+        NetworkDevice.get_state (this.Interface, &this.State);
+        NetworkDevice.get_ip (interface_name, &this.ip);
+        NetworkDevice.get_netmask (interface_name, &this.netmask);
+        NetworkDevice.get_status(interface_name, &this.connection_is_up);
+
+        Timeout.add_seconds (NETWORK_STATUS_CHECK_INTERVAL, this.check_state);
+    }
+
+    public uint State { get; set; }
+
+    /* Name of the device */
+    public string Interface { get; set; }
+
+    /* Signal emmitted to the bus in case of state change */
+    public signal void StateChanged (uint new_state, uint old_state, uint reason);
+
+    /* Signal emitted to the bus in case of connection status changed */
+    public signal void ConnectionStatus (bool connection);
+
+    /*
+     * Checks the state of the device and emits the relevant signals to the bus
+     * Returns true most of the cases, if it returns false, it is removed from timeout queue
+     */
+    private bool check_state () {
+
+        /*
+         * This connection status of relevant interface (this.Interface)
+         * The function used below works for ralink only
+         * false stands for, connection is not available
+         * true stands for, conecction is available
+         */
+        bool connection_is_up = false;
+        int ret = NetworkDevice.get_status(this.Interface, &connection_is_up);
+        if (ret == -1) {
+            return true;
+        }
+
+        if (connection_is_up != this.connection_is_up) {
+            message(this.Interface + "connection status : " + (connection_is_up ? "Connected" : "Disconnected"));
+            ConnectionStatus (connection_is_up);
+            this.connection_is_up = connection_is_up;
+        }
+
+        if (!connection_is_up) {
+            if (this.State == NMDeviceState.NM_DEVICE_STATE_ACTIVATED) {
+                StateChanged (NMDeviceState.NM_DEVICE_STATE_DISCONNECTED, this.State, 0);
+                this.State = NMDeviceState.NM_DEVICE_STATE_DISCONNECTED;
+            }
+            return true;
+        }
+
+        var new_state = NMDeviceState.NM_DEVICE_STATE_UNKNOWN;
+        NetworkDevice.get_state (this.Interface, &new_state);
+        bool interface_is_up = (new_state == NMDeviceState.NM_DEVICE_STATE_ACTIVATED);
+
+        if (!interface_is_up) {
+            if (this.State == NMDeviceState.NM_DEVICE_STATE_ACTIVATED) {
+                StateChanged (NMDeviceState.NM_DEVICE_STATE_DISCONNECTED, this.State, 0);
+                this.State = NMDeviceState.NM_DEVICE_STATE_DISCONNECTED;
+            }
+            return true;
+        }
+
+        string ip = "";
+        ret = NetworkDevice.get_ip (this.Interface, &ip);
+        if (ret == -1) {
+            if (this.State == NMDeviceState.NM_DEVICE_STATE_ACTIVATED) {
+                StateChanged (NMDeviceState.NM_DEVICE_STATE_DISCONNECTED, this.State, 0);
+                this.State = NMDeviceState.NM_DEVICE_STATE_DISCONNECTED;
+            }
+            return true;
+        }
+
+        string netmask = "";
+        ret = NetworkDevice.get_netmask (this.Interface, &netmask);
+        if (ret == -1) {
+            if (this.State == NMDeviceState.NM_DEVICE_STATE_ACTIVATED) {
+                StateChanged (NMDeviceState.NM_DEVICE_STATE_DISCONNECTED, this.State, 0);
+                this.State = NMDeviceState.NM_DEVICE_STATE_DISCONNECTED;
+            }
+            return true;
+        }
+
+        if (this.State != NMDeviceState.NM_DEVICE_STATE_ACTIVATED) {
+            StateChanged (NMDeviceState.NM_DEVICE_STATE_ACTIVATED, this.State, 0);
+            this.State = NMDeviceState.NM_DEVICE_STATE_ACTIVATED;
+            return true;
+        }
+
+        if (ip != this.ip || netmask != this.netmask) {
+             StateChanged (NMDeviceState.NM_DEVICE_STATE_IP_CONFIG, this.State, 0);
+             StateChanged (NMDeviceState.NM_DEVICE_STATE_ACTIVATED, this.State, 0);
+             this.ip = ip;
+             this.netmask = netmask;
+         }
+
+         return true;
+    }
+}
+
--- a/src/rygel/rygel-plugin-loader.vala
+++ b/src/rygel/rygel-plugin-loader.vala
@@ -65,7 +65,7 @@ public class Rygel.PluginLoader : Object
     }
 
     public Collection<Plugin> list_plugins () {
-        return this.plugin_hash.get_values ();
+        return this.plugin_hash.values;
     }
 
     private void load_modules_from_dir (File dir) {
--- a/src/rygel/rygel-root-device-factory.vala
+++ b/src/rygel/rygel-root-device-factory.vala
@@ -24,6 +24,7 @@
 
 using GUPnP;
 using CStuff;
+using Rygel.NetworkDevice;
 
 public errordomain RootDeviceFactoryError {
     XML_PARSE,
@@ -115,6 +116,9 @@ public class Rygel.RootDeviceFactory {
                                         plugin.name,
                                         plugin.title);
 
+        /* Then set the presentation URL */
+        this.set_presentation_url (device_element);
+
         /* Then list each icon */
         this.add_icons_to_desc (device_element, plugin);
 
@@ -139,18 +143,21 @@ public class Rygel.RootDeviceFactory {
             return;
         }
 
-        string title;
-        try {
-            title = this.config.get_title (plugin_name);
-        } catch (GLib.Error err) {
-            title = plugin_title;
-        }
-
-        title = title.replace ("@REALNAME@", Environment.get_real_name ());
-        title = title.replace ("@USERNAME@", Environment.get_user_name ());
-        title = title.replace ("@HOSTNAME@", Environment.get_host_name ());
+        string friendlyname = element->get_content ();
+        if (friendlyname == null || friendlyname == "") {
+            string title;
+            try {
+                title = this.config.get_title (plugin_name);
+            } catch (GLib.Error err) {
+                title = plugin_title;
+            }
+
+            title = title.replace ("@REALNAME@", Environment.get_real_name ());
+            title = title.replace ("@USERNAME@", Environment.get_user_name ());
+            title = title.replace ("@HOSTNAME@", Environment.get_host_name ());
 
-        element->set_content (title);
+            element->set_content (title);
+	}
 
         /* UDN */
         element = Utils.get_xml_element (device_element, "UDN");
@@ -165,6 +172,44 @@ public class Rygel.RootDeviceFactory {
             udn = Utils.generate_random_udn ();
 
             element->set_content (udn);
+
+            DBusService dbus_service = DBusService.get_default();
+            if (dbus_service == null) {
+                warning("%p: DBus service instance not created.", this);
+                return;
+            }
+            dbus_service.UdnChanged(udn);
+        }
+    }
+
+    private void set_presentation_url (Xml.Node *device_element) {
+        Xml.Node *element = Utils.get_xml_element (device_element,
+                                                   "presentationURL",
+                                                   null);
+        if (element == null) {
+            warning ("Element /root/device/presentationURL not found.");
+
+            return;
+        }
+
+        string presentation_url = element->get_content ();
+        GLib.List<string> interface_list = NetworkDevice.get_interface_list ();
+        if (interface_list == null) {
+            warning ("%p: Interface list is NULL.", this);
+            return;
+        }
+        string interface_name = interface_list.nth_data (0);
+
+        string ip = "";
+        int ret = NetworkDevice.get_ip (interface_name, &ip);
+        if (ret == -1) {
+            warning ("%p: Could not get IP address.", this);
+            return;
+        }
+
+        string new_presentation_url = "http://" + ip + "/";
+        if (presentation_url != new_presentation_url) {
+            element->set_content (new_presentation_url);
         }
     }
 
--- a/src/rygel/rygel-root-device.vala
+++ b/src/rygel/rygel-root-device.vala
@@ -29,7 +29,7 @@ using Gee;
  * Represents a Root device.
  */
 public class Rygel.RootDevice: GUPnP.RootDevice {
-    internal ArrayList<ServiceInfo> services;   /* Services we implement */
+    protected ArrayList<ServiceInfo> services;   /* Services we implement */
 
     public RootDevice (GUPnP.Context context,
                        Plugin        plugin,
--- a/src/rygel/rygel-thumbnailer.vala
+++ b/src/rygel/rygel-thumbnailer.vala
@@ -20,7 +20,6 @@
  * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
  */
 
-using Gst;
 
 internal errordomain ThumbnailerError {
     NO_DIR,
--- /dev/null
+++ b/m4/codeset.m4
@@ -0,0 +1,21 @@
+# codeset.m4 serial 2 (gettext-0.16)
+dnl Copyright (C) 2000-2002, 2006 Free Software Foundation, Inc.
+dnl This file is free software; the Free Software Foundation
+dnl gives unlimited permission to copy and/or distribute it,
+dnl with or without modifications, as long as this notice is preserved.
+
+dnl From Bruno Haible.
+
+AC_DEFUN([AM_LANGINFO_CODESET],
+[
+  AC_CACHE_CHECK([for nl_langinfo and CODESET], am_cv_langinfo_codeset,
+    [AC_TRY_LINK([#include <langinfo.h>],
+      [char* cs = nl_langinfo(CODESET); return !cs;],
+      am_cv_langinfo_codeset=yes,
+      am_cv_langinfo_codeset=no)
+    ])
+  if test $am_cv_langinfo_codeset = yes; then
+    AC_DEFINE(HAVE_LANGINFO_CODESET, 1,
+      [Define if you have <langinfo.h> and nl_langinfo(CODESET).])
+  fi
+])
--- /dev/null
+++ b/m4/gettext.m4
@@ -0,0 +1,381 @@
+# gettext.m4 serial 60 (gettext-0.17)
+dnl Copyright (C) 1995-2007 Free Software Foundation, Inc.
+dnl This file is free software; the Free Software Foundation
+dnl gives unlimited permission to copy and/or distribute it,
+dnl with or without modifications, as long as this notice is preserved.
+dnl
+dnl This file can can be used in projects which are not available under
+dnl the GNU General Public License or the GNU Library General Public
+dnl License but which still want to provide support for the GNU gettext
+dnl functionality.
+dnl Please note that the actual code of the GNU gettext library is covered
+dnl by the GNU Library General Public License, and the rest of the GNU
+dnl gettext package package is covered by the GNU General Public License.
+dnl They are *not* in the public domain.
+
+dnl Authors:
+dnl   Ulrich Drepper <drepper@cygnus.com>, 1995-2000.
+dnl   Bruno Haible <haible@clisp.cons.org>, 2000-2006.
+
+dnl Macro to add for using GNU gettext.
+
+dnl Usage: AM_GNU_GETTEXT([INTLSYMBOL], [NEEDSYMBOL], [INTLDIR]).
+dnl INTLSYMBOL can be one of 'external', 'no-libtool', 'use-libtool'. The
+dnl    default (if it is not specified or empty) is 'no-libtool'.
+dnl    INTLSYMBOL should be 'external' for packages with no intl directory,
+dnl    and 'no-libtool' or 'use-libtool' for packages with an intl directory.
+dnl    If INTLSYMBOL is 'use-libtool', then a libtool library
+dnl    $(top_builddir)/intl/libintl.la will be created (shared and/or static,
+dnl    depending on --{enable,disable}-{shared,static} and on the presence of
+dnl    AM-DISABLE-SHARED). If INTLSYMBOL is 'no-libtool', a static library
+dnl    $(top_builddir)/intl/libintl.a will be created.
+dnl If NEEDSYMBOL is specified and is 'need-ngettext', then GNU gettext
+dnl    implementations (in libc or libintl) without the ngettext() function
+dnl    will be ignored.  If NEEDSYMBOL is specified and is
+dnl    'need-formatstring-macros', then GNU gettext implementations that don't
+dnl    support the ISO C 99 <inttypes.h> formatstring macros will be ignored.
+dnl INTLDIR is used to find the intl libraries.  If empty,
+dnl    the value `$(top_builddir)/intl/' is used.
+dnl
+dnl The result of the configuration is one of three cases:
+dnl 1) GNU gettext, as included in the intl subdirectory, will be compiled
+dnl    and used.
+dnl    Catalog format: GNU --> install in $(datadir)
+dnl    Catalog extension: .mo after installation, .gmo in source tree
+dnl 2) GNU gettext has been found in the system's C library.
+dnl    Catalog format: GNU --> install in $(datadir)
+dnl    Catalog extension: .mo after installation, .gmo in source tree
+dnl 3) No internationalization, always use English msgid.
+dnl    Catalog format: none
+dnl    Catalog extension: none
+dnl If INTLSYMBOL is 'external', only cases 2 and 3 can occur.
+dnl The use of .gmo is historical (it was needed to avoid overwriting the
+dnl GNU format catalogs when building on a platform with an X/Open gettext),
+dnl but we keep it in order not to force irrelevant filename changes on the
+dnl maintainers.
+dnl
+AC_DEFUN([AM_GNU_GETTEXT],
+[
+  dnl Argument checking.
+  ifelse([$1], [], , [ifelse([$1], [external], , [ifelse([$1], [no-libtool], , [ifelse([$1], [use-libtool], ,
+    [errprint([ERROR: invalid first argument to AM_GNU_GETTEXT
+])])])])])
+  ifelse([$2], [], , [ifelse([$2], [need-ngettext], , [ifelse([$2], [need-formatstring-macros], ,
+    [errprint([ERROR: invalid second argument to AM_GNU_GETTEXT
+])])])])
+  define([gt_included_intl],
+    ifelse([$1], [external],
+      ifdef([AM_GNU_GETTEXT_][INTL_SUBDIR], [yes], [no]),
+      [yes]))
+  define([gt_libtool_suffix_prefix], ifelse([$1], [use-libtool], [l], []))
+  gt_NEEDS_INIT
+  AM_GNU_GETTEXT_NEED([$2])
+
+  AC_REQUIRE([AM_PO_SUBDIRS])dnl
+  ifelse(gt_included_intl, yes, [
+    AC_REQUIRE([AM_INTL_SUBDIR])dnl
+  ])
+
+  dnl Prerequisites of AC_LIB_LINKFLAGS_BODY.
+  AC_REQUIRE([AC_LIB_PREPARE_PREFIX])
+  AC_REQUIRE([AC_LIB_RPATH])
+
+  dnl Sometimes libintl requires libiconv, so first search for libiconv.
+  dnl Ideally we would do this search only after the
+  dnl      if test "$USE_NLS" = "yes"; then
+  dnl        if { eval "gt_val=\$$gt_func_gnugettext_libc"; test "$gt_val" != "yes"; }; then
+  dnl tests. But if configure.in invokes AM_ICONV after AM_GNU_GETTEXT
+  dnl the configure script would need to contain the same shell code
+  dnl again, outside any 'if'. There are two solutions:
+  dnl - Invoke AM_ICONV_LINKFLAGS_BODY here, outside any 'if'.
+  dnl - Control the expansions in more detail using AC_PROVIDE_IFELSE.
+  dnl Since AC_PROVIDE_IFELSE is only in autoconf >= 2.52 and not
+  dnl documented, we avoid it.
+  ifelse(gt_included_intl, yes, , [
+    AC_REQUIRE([AM_ICONV_LINKFLAGS_BODY])
+  ])
+
+  dnl Sometimes, on MacOS X, libintl requires linking with CoreFoundation.
+  gt_INTL_MACOSX
+
+  dnl Set USE_NLS.
+  AC_REQUIRE([AM_NLS])
+
+  ifelse(gt_included_intl, yes, [
+    BUILD_INCLUDED_LIBINTL=no
+    USE_INCLUDED_LIBINTL=no
+  ])
+  LIBINTL=
+  LTLIBINTL=
+  POSUB=
+
+  dnl Add a version number to the cache macros.
+  case " $gt_needs " in
+    *" need-formatstring-macros "*) gt_api_version=3 ;;
+    *" need-ngettext "*) gt_api_version=2 ;;
+    *) gt_api_version=1 ;;
+  esac
+  gt_func_gnugettext_libc="gt_cv_func_gnugettext${gt_api_version}_libc"
+  gt_func_gnugettext_libintl="gt_cv_func_gnugettext${gt_api_version}_libintl"
+
+  dnl If we use NLS figure out what method
+  if test "$USE_NLS" = "yes"; then
+    gt_use_preinstalled_gnugettext=no
+    ifelse(gt_included_intl, yes, [
+      AC_MSG_CHECKING([whether included gettext is requested])
+      AC_ARG_WITH(included-gettext,
+        [  --with-included-gettext use the GNU gettext library included here],
+        nls_cv_force_use_gnu_gettext=$withval,
+        nls_cv_force_use_gnu_gettext=no)
+      AC_MSG_RESULT($nls_cv_force_use_gnu_gettext)
+
+      nls_cv_use_gnu_gettext="$nls_cv_force_use_gnu_gettext"
+      if test "$nls_cv_force_use_gnu_gettext" != "yes"; then
+    ])
+        dnl User does not insist on using GNU NLS library.  Figure out what
+        dnl to use.  If GNU gettext is available we use this.  Else we have
+        dnl to fall back to GNU NLS library.
+
+        if test $gt_api_version -ge 3; then
+          gt_revision_test_code='
+#ifndef __GNU_GETTEXT_SUPPORTED_REVISION
+#define __GNU_GETTEXT_SUPPORTED_REVISION(major) ((major) == 0 ? 0 : -1)
+#endif
+changequote(,)dnl
+typedef int array [2 * (__GNU_GETTEXT_SUPPORTED_REVISION(0) >= 1) - 1];
+changequote([,])dnl
+'
+        else
+          gt_revision_test_code=
+        fi
+        if test $gt_api_version -ge 2; then
+          gt_expression_test_code=' + * ngettext ("", "", 0)'
+        else
+          gt_expression_test_code=
+        fi
+
+        AC_CACHE_CHECK([for GNU gettext in libc], [$gt_func_gnugettext_libc],
+         [AC_TRY_LINK([#include <libintl.h>
+$gt_revision_test_code
+extern int _nl_msg_cat_cntr;
+extern int *_nl_domain_bindings;],
+            [bindtextdomain ("", "");
+return * gettext ("")$gt_expression_test_code + _nl_msg_cat_cntr + *_nl_domain_bindings],
+            [eval "$gt_func_gnugettext_libc=yes"],
+            [eval "$gt_func_gnugettext_libc=no"])])
+
+        if { eval "gt_val=\$$gt_func_gnugettext_libc"; test "$gt_val" != "yes"; }; then
+          dnl Sometimes libintl requires libiconv, so first search for libiconv.
+          ifelse(gt_included_intl, yes, , [
+            AM_ICONV_LINK
+          ])
+          dnl Search for libintl and define LIBINTL, LTLIBINTL and INCINTL
+          dnl accordingly. Don't use AC_LIB_LINKFLAGS_BODY([intl],[iconv])
+          dnl because that would add "-liconv" to LIBINTL and LTLIBINTL
+          dnl even if libiconv doesn't exist.
+          AC_LIB_LINKFLAGS_BODY([intl])
+          AC_CACHE_CHECK([for GNU gettext in libintl],
+            [$gt_func_gnugettext_libintl],
+           [gt_save_CPPFLAGS="$CPPFLAGS"
+            CPPFLAGS="$CPPFLAGS $INCINTL"
+            gt_save_LIBS="$LIBS"
+            LIBS="$LIBS $LIBINTL"
+            dnl Now see whether libintl exists and does not depend on libiconv.
+            AC_TRY_LINK([#include <libintl.h>
+$gt_revision_test_code
+extern int _nl_msg_cat_cntr;
+extern
+#ifdef __cplusplus
+"C"
+#endif
+const char *_nl_expand_alias (const char *);],
+              [bindtextdomain ("", "");
+return * gettext ("")$gt_expression_test_code + _nl_msg_cat_cntr + *_nl_expand_alias ("")],
+              [eval "$gt_func_gnugettext_libintl=yes"],
+              [eval "$gt_func_gnugettext_libintl=no"])
+            dnl Now see whether libintl exists and depends on libiconv.
+            if { eval "gt_val=\$$gt_func_gnugettext_libintl"; test "$gt_val" != yes; } && test -n "$LIBICONV"; then
+              LIBS="$LIBS $LIBICONV"
+              AC_TRY_LINK([#include <libintl.h>
+$gt_revision_test_code
+extern int _nl_msg_cat_cntr;
+extern
+#ifdef __cplusplus
+"C"
+#endif
+const char *_nl_expand_alias (const char *);],
+                [bindtextdomain ("", "");
+return * gettext ("")$gt_expression_test_code + _nl_msg_cat_cntr + *_nl_expand_alias ("")],
+               [LIBINTL="$LIBINTL $LIBICONV"
+                LTLIBINTL="$LTLIBINTL $LTLIBICONV"
+                eval "$gt_func_gnugettext_libintl=yes"
+               ])
+            fi
+            CPPFLAGS="$gt_save_CPPFLAGS"
+            LIBS="$gt_save_LIBS"])
+        fi
+
+        dnl If an already present or preinstalled GNU gettext() is found,
+        dnl use it.  But if this macro is used in GNU gettext, and GNU
+        dnl gettext is already preinstalled in libintl, we update this
+        dnl libintl.  (Cf. the install rule in intl/Makefile.in.)
+        if { eval "gt_val=\$$gt_func_gnugettext_libc"; test "$gt_val" = "yes"; } \
+           || { { eval "gt_val=\$$gt_func_gnugettext_libintl"; test "$gt_val" = "yes"; } \
+                && test "$PACKAGE" != gettext-runtime \
+                && test "$PACKAGE" != gettext-tools; }; then
+          gt_use_preinstalled_gnugettext=yes
+        else
+          dnl Reset the values set by searching for libintl.
+          LIBINTL=
+          LTLIBINTL=
+          INCINTL=
+        fi
+
+    ifelse(gt_included_intl, yes, [
+        if test "$gt_use_preinstalled_gnugettext" != "yes"; then
+          dnl GNU gettext is not found in the C library.
+          dnl Fall back on included GNU gettext library.
+          nls_cv_use_gnu_gettext=yes
+        fi
+      fi
+
+      if test "$nls_cv_use_gnu_gettext" = "yes"; then
+        dnl Mark actions used to generate GNU NLS library.
+        BUILD_INCLUDED_LIBINTL=yes
+        USE_INCLUDED_LIBINTL=yes
+        LIBINTL="ifelse([$3],[],\${top_builddir}/intl,[$3])/libintl.[]gt_libtool_suffix_prefix[]a $LIBICONV $LIBTHREAD"
+        LTLIBINTL="ifelse([$3],[],\${top_builddir}/intl,[$3])/libintl.[]gt_libtool_suffix_prefix[]a $LTLIBICONV $LTLIBTHREAD"
+        LIBS=`echo " $LIBS " | sed -e 's/ -lintl / /' -e 's/^ //' -e 's/ $//'`
+      fi
+
+      CATOBJEXT=
+      if test "$gt_use_preinstalled_gnugettext" = "yes" \
+         || test "$nls_cv_use_gnu_gettext" = "yes"; then
+        dnl Mark actions to use GNU gettext tools.
+        CATOBJEXT=.gmo
+      fi
+    ])
+
+    if test -n "$INTL_MACOSX_LIBS"; then
+      if test "$gt_use_preinstalled_gnugettext" = "yes" \
+         || test "$nls_cv_use_gnu_gettext" = "yes"; then
+        dnl Some extra flags are needed during linking.
+        LIBINTL="$LIBINTL $INTL_MACOSX_LIBS"
+        LTLIBINTL="$LTLIBINTL $INTL_MACOSX_LIBS"
+      fi
+    fi
+
+    if test "$gt_use_preinstalled_gnugettext" = "yes" \
+       || test "$nls_cv_use_gnu_gettext" = "yes"; then
+      AC_DEFINE(ENABLE_NLS, 1,
+        [Define to 1 if translation of program messages to the user's native language
+   is requested.])
+    else
+      USE_NLS=no
+    fi
+  fi
+
+  AC_MSG_CHECKING([whether to use NLS])
+  AC_MSG_RESULT([$USE_NLS])
+  if test "$USE_NLS" = "yes"; then
+    AC_MSG_CHECKING([where the gettext function comes from])
+    if test "$gt_use_preinstalled_gnugettext" = "yes"; then
+      if { eval "gt_val=\$$gt_func_gnugettext_libintl"; test "$gt_val" = "yes"; }; then
+        gt_source="external libintl"
+      else
+        gt_source="libc"
+      fi
+    else
+      gt_source="included intl directory"
+    fi
+    AC_MSG_RESULT([$gt_source])
+  fi
+
+  if test "$USE_NLS" = "yes"; then
+
+    if test "$gt_use_preinstalled_gnugettext" = "yes"; then
+      if { eval "gt_val=\$$gt_func_gnugettext_libintl"; test "$gt_val" = "yes"; }; then
+        AC_MSG_CHECKING([how to link with libintl])
+        AC_MSG_RESULT([$LIBINTL])
+        AC_LIB_APPENDTOVAR([CPPFLAGS], [$INCINTL])
+      fi
+
+      dnl For backward compatibility. Some packages may be using this.
+      AC_DEFINE(HAVE_GETTEXT, 1,
+       [Define if the GNU gettext() function is already present or preinstalled.])
+      AC_DEFINE(HAVE_DCGETTEXT, 1,
+       [Define if the GNU dcgettext() function is already present or preinstalled.])
+    fi
+
+    dnl We need to process the po/ directory.
+    POSUB=po
+  fi
+
+  ifelse(gt_included_intl, yes, [
+    dnl If this is used in GNU gettext we have to set BUILD_INCLUDED_LIBINTL
+    dnl to 'yes' because some of the testsuite requires it.
+    if test "$PACKAGE" = gettext-runtime || test "$PACKAGE" = gettext-tools; then
+      BUILD_INCLUDED_LIBINTL=yes
+    fi
+
+    dnl Make all variables we use known to autoconf.
+    AC_SUBST(BUILD_INCLUDED_LIBINTL)
+    AC_SUBST(USE_INCLUDED_LIBINTL)
+    AC_SUBST(CATOBJEXT)
+
+    dnl For backward compatibility. Some configure.ins may be using this.
+    nls_cv_header_intl=
+    nls_cv_header_libgt=
+
+    dnl For backward compatibility. Some Makefiles may be using this.
+    DATADIRNAME=share
+    AC_SUBST(DATADIRNAME)
+
+    dnl For backward compatibility. Some Makefiles may be using this.
+    INSTOBJEXT=.mo
+    AC_SUBST(INSTOBJEXT)
+
+    dnl For backward compatibility. Some Makefiles may be using this.
+    GENCAT=gencat
+    AC_SUBST(GENCAT)
+
+    dnl For backward compatibility. Some Makefiles may be using this.
+    INTLOBJS=
+    if test "$USE_INCLUDED_LIBINTL" = yes; then
+      INTLOBJS="\$(GETTOBJS)"
+    fi
+    AC_SUBST(INTLOBJS)
+
+    dnl Enable libtool support if the surrounding package wishes it.
+    INTL_LIBTOOL_SUFFIX_PREFIX=gt_libtool_suffix_prefix
+    AC_SUBST(INTL_LIBTOOL_SUFFIX_PREFIX)
+  ])
+
+  dnl For backward compatibility. Some Makefiles may be using this.
+  INTLLIBS="$LIBINTL"
+  AC_SUBST(INTLLIBS)
+
+  dnl Make all documented variables known to autoconf.
+  AC_SUBST(LIBINTL)
+  AC_SUBST(LTLIBINTL)
+  AC_SUBST(POSUB)
+])
+
+
+dnl gt_NEEDS_INIT ensures that the gt_needs variable is initialized.
+m4_define([gt_NEEDS_INIT],
+[
+  m4_divert_text([DEFAULTS], [gt_needs=])
+  m4_define([gt_NEEDS_INIT], [])
+])
+
+
+dnl Usage: AM_GNU_GETTEXT_NEED([NEEDSYMBOL])
+AC_DEFUN([AM_GNU_GETTEXT_NEED],
+[
+  m4_divert_text([INIT_PREPARE], [gt_needs="$gt_needs $1"])
+])
+
+
+dnl Usage: AM_GNU_GETTEXT_VERSION([gettext-version])
+AC_DEFUN([AM_GNU_GETTEXT_VERSION], [])
--- /dev/null
+++ b/m4/glib-gettext.m4
@@ -0,0 +1,432 @@
+# Copyright (C) 1995-2002 Free Software Foundation, Inc.
+# Copyright (C) 2001-2003,2004 Red Hat, Inc.
+#
+# This file is free software, distributed under the terms of the GNU
+# General Public License.  As a special exception to the GNU General
+# Public License, this file may be distributed as part of a program
+# that contains a configuration script generated by Autoconf, under
+# the same distribution terms as the rest of that program.
+#
+# This file can be copied and used freely without restrictions.  It can
+# be used in projects which are not available under the GNU Public License
+# but which still want to provide support for the GNU gettext functionality.
+#
+# Macro to add for using GNU gettext.
+# Ulrich Drepper <drepper@cygnus.com>, 1995, 1996
+#
+# Modified to never use included libintl.
+# Owen Taylor <otaylor@redhat.com>, 12/15/1998
+#
+# Major rework to remove unused code
+# Owen Taylor <otaylor@redhat.com>, 12/11/2002
+#
+# Added better handling of ALL_LINGUAS from GNU gettext version
+# written by Bruno Haible, Owen Taylor <otaylor.redhat.com> 5/30/3002
+#
+# Modified to require ngettext
+# Matthias Clasen <mclasen@redhat.com> 08/06/2004
+#
+# We need this here as well, since someone might use autoconf-2.5x
+# to configure GLib then an older version to configure a package
+# using AM_GLIB_GNU_GETTEXT
+AC_PREREQ(2.53)
+
+dnl
+dnl We go to great lengths to make sure that aclocal won't
+dnl try to pull in the installed version of these macros
+dnl when running aclocal in the glib directory.
+dnl
+m4_copy([AC_DEFUN],[glib_DEFUN])
+m4_copy([AC_REQUIRE],[glib_REQUIRE])
+dnl
+dnl At the end, if we're not within glib, we'll define the public
+dnl definitions in terms of our private definitions.
+dnl
+
+# GLIB_LC_MESSAGES
+#--------------------
+glib_DEFUN([GLIB_LC_MESSAGES],
+  [AC_CHECK_HEADERS([locale.h])
+    if test $ac_cv_header_locale_h = yes; then
+    AC_CACHE_CHECK([for LC_MESSAGES], am_cv_val_LC_MESSAGES,
+      [AC_TRY_LINK([#include <locale.h>], [return LC_MESSAGES],
+       am_cv_val_LC_MESSAGES=yes, am_cv_val_LC_MESSAGES=no)])
+    if test $am_cv_val_LC_MESSAGES = yes; then
+      AC_DEFINE(HAVE_LC_MESSAGES, 1,
+        [Define if your <locale.h> file defines LC_MESSAGES.])
+    fi
+  fi])
+
+# GLIB_PATH_PROG_WITH_TEST
+#----------------------------
+dnl GLIB_PATH_PROG_WITH_TEST(VARIABLE, PROG-TO-CHECK-FOR,
+dnl   TEST-PERFORMED-ON-FOUND_PROGRAM [, VALUE-IF-NOT-FOUND [, PATH]])
+glib_DEFUN([GLIB_PATH_PROG_WITH_TEST],
+[# Extract the first word of "$2", so it can be a program name with args.
+set dummy $2; ac_word=[$]2
+AC_MSG_CHECKING([for $ac_word])
+AC_CACHE_VAL(ac_cv_path_$1,
+[case "[$]$1" in
+  /*)
+  ac_cv_path_$1="[$]$1" # Let the user override the test with a path.
+  ;;
+  *)
+  IFS="${IFS= 	}"; ac_save_ifs="$IFS"; IFS="${IFS}:"
+  for ac_dir in ifelse([$5], , $PATH, [$5]); do
+    test -z "$ac_dir" && ac_dir=.
+    if test -f $ac_dir/$ac_word; then
+      if [$3]; then
+	ac_cv_path_$1="$ac_dir/$ac_word"
+	break
+      fi
+    fi
+  done
+  IFS="$ac_save_ifs"
+dnl If no 4th arg is given, leave the cache variable unset,
+dnl so AC_PATH_PROGS will keep looking.
+ifelse([$4], , , [  test -z "[$]ac_cv_path_$1" && ac_cv_path_$1="$4"
+])dnl
+  ;;
+esac])dnl
+$1="$ac_cv_path_$1"
+if test ifelse([$4], , [-n "[$]$1"], ["[$]$1" != "$4"]); then
+  AC_MSG_RESULT([$]$1)
+else
+  AC_MSG_RESULT(no)
+fi
+AC_SUBST($1)dnl
+])
+
+# GLIB_WITH_NLS
+#-----------------
+glib_DEFUN([GLIB_WITH_NLS],
+  dnl NLS is obligatory
+  [USE_NLS=yes
+    AC_SUBST(USE_NLS)
+
+    gt_cv_have_gettext=no
+
+    CATOBJEXT=NONE
+    XGETTEXT=:
+    INTLLIBS=
+
+    AC_CHECK_HEADER(libintl.h,
+     [gt_cv_func_dgettext_libintl="no"
+      libintl_extra_libs=""
+
+      #
+      # First check in libc
+      #
+      AC_CACHE_CHECK([for ngettext in libc], gt_cv_func_ngettext_libc,
+        [AC_TRY_LINK([
+#include <libintl.h>
+],
+         [return !ngettext ("","", 1)],
+	  gt_cv_func_ngettext_libc=yes,
+          gt_cv_func_ngettext_libc=no)
+        ])
+
+      if test "$gt_cv_func_ngettext_libc" = "yes" ; then
+	      AC_CACHE_CHECK([for dgettext in libc], gt_cv_func_dgettext_libc,
+        	[AC_TRY_LINK([
+#include <libintl.h>
+],
+	          [return !dgettext ("","")],
+		  gt_cv_func_dgettext_libc=yes,
+	          gt_cv_func_dgettext_libc=no)
+        	])
+      fi
+
+      if test "$gt_cv_func_ngettext_libc" = "yes" ; then
+        AC_CHECK_FUNCS(bind_textdomain_codeset)
+      fi
+
+      #
+      # If we don't have everything we want, check in libintl
+      #
+      if test "$gt_cv_func_dgettext_libc" != "yes" \
+	 || test "$gt_cv_func_ngettext_libc" != "yes" \
+         || test "$ac_cv_func_bind_textdomain_codeset" != "yes" ; then
+
+        AC_CHECK_LIB(intl, bindtextdomain,
+	    [AC_CHECK_LIB(intl, ngettext,
+		    [AC_CHECK_LIB(intl, dgettext,
+			          gt_cv_func_dgettext_libintl=yes)])])
+
+	if test "$gt_cv_func_dgettext_libintl" != "yes" ; then
+	  AC_MSG_CHECKING([if -liconv is needed to use gettext])
+	  AC_MSG_RESULT([])
+  	  AC_CHECK_LIB(intl, ngettext,
+          	[AC_CHECK_LIB(intl, dcgettext,
+		       [gt_cv_func_dgettext_libintl=yes
+			libintl_extra_libs=-liconv],
+			:,-liconv)],
+		:,-liconv)
+        fi
+
+        #
+        # If we found libintl, then check in it for bind_textdomain_codeset();
+        # we'll prefer libc if neither have bind_textdomain_codeset(),
+        # and both have dgettext and ngettext
+        #
+        if test "$gt_cv_func_dgettext_libintl" = "yes" ; then
+          glib_save_LIBS="$LIBS"
+          LIBS="$LIBS -lintl $libintl_extra_libs"
+          unset ac_cv_func_bind_textdomain_codeset
+          AC_CHECK_FUNCS(bind_textdomain_codeset)
+          LIBS="$glib_save_LIBS"
+
+          if test "$ac_cv_func_bind_textdomain_codeset" = "yes" ; then
+            gt_cv_func_dgettext_libc=no
+          else
+            if test "$gt_cv_func_dgettext_libc" = "yes" \
+		&& test "$gt_cv_func_ngettext_libc" = "yes"; then
+              gt_cv_func_dgettext_libintl=no
+            fi
+          fi
+        fi
+      fi
+
+      if test "$gt_cv_func_dgettext_libc" = "yes" \
+	|| test "$gt_cv_func_dgettext_libintl" = "yes"; then
+        gt_cv_have_gettext=yes
+      fi
+
+      if test "$gt_cv_func_dgettext_libintl" = "yes"; then
+        INTLLIBS="-lintl $libintl_extra_libs"
+      fi
+
+      if test "$gt_cv_have_gettext" = "yes"; then
+	AC_DEFINE(HAVE_GETTEXT,1,
+	  [Define if the GNU gettext() function is already present or preinstalled.])
+	GLIB_PATH_PROG_WITH_TEST(MSGFMT, msgfmt,
+	  [test -z "`$ac_dir/$ac_word -h 2>&1 | grep 'dv '`"], no)dnl
+	if test "$MSGFMT" != "no"; then
+          glib_save_LIBS="$LIBS"
+          LIBS="$LIBS $INTLLIBS"
+	  AC_CHECK_FUNCS(dcgettext)
+	  MSGFMT_OPTS=
+	  AC_MSG_CHECKING([if msgfmt accepts -c])
+	  GLIB_RUN_PROG([$MSGFMT -c -o /dev/null],[
+msgid ""
+msgstr ""
+"Content-Type: text/plain; charset=UTF-8\n"
+"Project-Id-Version: test 1.0\n"
+"PO-Revision-Date: 2007-02-15 12:01+0100\n"
+"Last-Translator: test <foo@bar.xx>\n"
+"Language-Team: C <LL@li.org>\n"
+"MIME-Version: 1.0\n"
+"Content-Transfer-Encoding: 8bit\n"
+], [MSGFMT_OPTS=-c; AC_MSG_RESULT([yes])], [AC_MSG_RESULT([no])])
+	  AC_SUBST(MSGFMT_OPTS)
+	  AC_PATH_PROG(GMSGFMT, gmsgfmt, $MSGFMT)
+	  GLIB_PATH_PROG_WITH_TEST(XGETTEXT, xgettext,
+	    [test -z "`$ac_dir/$ac_word -h 2>&1 | grep '(HELP)'`"], :)
+	  AC_TRY_LINK(, [extern int _nl_msg_cat_cntr;
+			 return _nl_msg_cat_cntr],
+	    [CATOBJEXT=.gmo
+             DATADIRNAME=share],
+	    [case $host in
+	    *-*-solaris*)
+	    dnl On Solaris, if bind_textdomain_codeset is in libc,
+	    dnl GNU format message catalog is always supported,
+            dnl since both are added to the libc all together.
+	    dnl Hence, we'd like to go with DATADIRNAME=share and
+	    dnl and CATOBJEXT=.gmo in this case.
+            AC_CHECK_FUNC(bind_textdomain_codeset,
+	      [CATOBJEXT=.gmo
+               DATADIRNAME=share],
+	      [CATOBJEXT=.mo
+               DATADIRNAME=lib])
+	    ;;
+	    *)
+	    CATOBJEXT=.mo
+            DATADIRNAME=lib
+	    ;;
+	    esac])
+          LIBS="$glib_save_LIBS"
+	  INSTOBJEXT=.mo
+	else
+	  gt_cv_have_gettext=no
+	fi
+      fi
+    ])
+
+    if test "$gt_cv_have_gettext" = "yes" ; then
+      AC_DEFINE(ENABLE_NLS, 1,
+        [always defined to indicate that i18n is enabled])
+    fi
+
+    dnl Test whether we really found GNU xgettext.
+    if test "$XGETTEXT" != ":"; then
+      dnl If it is not GNU xgettext we define it as : so that the
+      dnl Makefiles still can work.
+      if $XGETTEXT --omit-header /dev/null 2> /dev/null; then
+        : ;
+      else
+        AC_MSG_RESULT(
+	  [found xgettext program is not GNU xgettext; ignore it])
+        XGETTEXT=":"
+      fi
+    fi
+
+    # We need to process the po/ directory.
+    POSUB=po
+
+    AC_OUTPUT_COMMANDS(
+      [case "$CONFIG_FILES" in *po/Makefile.in*)
+        sed -e "/POTFILES =/r po/POTFILES" po/Makefile.in > po/Makefile
+      esac])
+
+    dnl These rules are solely for the distribution goal.  While doing this
+    dnl we only have to keep exactly one list of the available catalogs
+    dnl in configure.in.
+    for lang in $ALL_LINGUAS; do
+      GMOFILES="$GMOFILES $lang.gmo"
+      POFILES="$POFILES $lang.po"
+    done
+
+    dnl Make all variables we use known to autoconf.
+    AC_SUBST(CATALOGS)
+    AC_SUBST(CATOBJEXT)
+    AC_SUBST(DATADIRNAME)
+    AC_SUBST(GMOFILES)
+    AC_SUBST(INSTOBJEXT)
+    AC_SUBST(INTLLIBS)
+    AC_SUBST(PO_IN_DATADIR_TRUE)
+    AC_SUBST(PO_IN_DATADIR_FALSE)
+    AC_SUBST(POFILES)
+    AC_SUBST(POSUB)
+  ])
+
+# AM_GLIB_GNU_GETTEXT
+# -------------------
+# Do checks necessary for use of gettext. If a suitable implementation
+# of gettext is found in either in libintl or in the C library,
+# it will set INTLLIBS to the libraries needed for use of gettext
+# and AC_DEFINE() HAVE_GETTEXT and ENABLE_NLS. (The shell variable
+# gt_cv_have_gettext will be set to "yes".) It will also call AC_SUBST()
+# on various variables needed by the Makefile.in.in installed by
+# glib-gettextize.
+dnl
+glib_DEFUN([GLIB_GNU_GETTEXT],
+  [AC_REQUIRE([AC_PROG_CC])dnl
+   AC_REQUIRE([AC_HEADER_STDC])dnl
+
+   GLIB_LC_MESSAGES
+   GLIB_WITH_NLS
+
+   if test "$gt_cv_have_gettext" = "yes"; then
+     if test "x$ALL_LINGUAS" = "x"; then
+       LINGUAS=
+     else
+       AC_MSG_CHECKING(for catalogs to be installed)
+       NEW_LINGUAS=
+       for presentlang in $ALL_LINGUAS; do
+         useit=no
+         if test "%UNSET%" != "${LINGUAS-%UNSET%}"; then
+           desiredlanguages="$LINGUAS"
+         else
+           desiredlanguages="$ALL_LINGUAS"
+         fi
+         for desiredlang in $desiredlanguages; do
+ 	   # Use the presentlang catalog if desiredlang is
+           #   a. equal to presentlang, or
+           #   b. a variant of presentlang (because in this case,
+           #      presentlang can be used as a fallback for messages
+           #      which are not translated in the desiredlang catalog).
+           case "$desiredlang" in
+             "$presentlang"*) useit=yes;;
+           esac
+         done
+         if test $useit = yes; then
+           NEW_LINGUAS="$NEW_LINGUAS $presentlang"
+         fi
+       done
+       LINGUAS=$NEW_LINGUAS
+       AC_MSG_RESULT($LINGUAS)
+     fi
+
+     dnl Construct list of names of catalog files to be constructed.
+     if test -n "$LINGUAS"; then
+       for lang in $LINGUAS; do CATALOGS="$CATALOGS $lang$CATOBJEXT"; done
+     fi
+   fi
+
+   dnl If the AC_CONFIG_AUX_DIR macro for autoconf is used we possibly
+   dnl find the mkinstalldirs script in another subdir but ($top_srcdir).
+   dnl Try to locate is.
+   MKINSTALLDIRS=
+   if test -n "$ac_aux_dir"; then
+     MKINSTALLDIRS="$ac_aux_dir/mkinstalldirs"
+   fi
+   if test -z "$MKINSTALLDIRS"; then
+     MKINSTALLDIRS="\$(top_srcdir)/mkinstalldirs"
+   fi
+   AC_SUBST(MKINSTALLDIRS)
+
+   dnl Generate list of files to be processed by xgettext which will
+   dnl be included in po/Makefile.
+   test -d po || mkdir po
+   if test "x$srcdir" != "x."; then
+     if test "x`echo $srcdir | sed 's@/.*@@'`" = "x"; then
+       posrcprefix="$srcdir/"
+     else
+       posrcprefix="../$srcdir/"
+     fi
+   else
+     posrcprefix="../"
+   fi
+   rm -f po/POTFILES
+   sed -e "/^#/d" -e "/^\$/d" -e "s,.*,	$posrcprefix& \\\\," -e "\$s/\(.*\) \\\\/\1/" \
+	< $srcdir/po/POTFILES.in > po/POTFILES
+  ])
+
+# AM_GLIB_DEFINE_LOCALEDIR(VARIABLE)
+# -------------------------------
+# Define VARIABLE to the location where catalog files will
+# be installed by po/Makefile.
+glib_DEFUN([GLIB_DEFINE_LOCALEDIR],
+[glib_REQUIRE([GLIB_GNU_GETTEXT])dnl
+glib_save_prefix="$prefix"
+glib_save_exec_prefix="$exec_prefix"
+glib_save_datarootdir="$datarootdir"
+test "x$prefix" = xNONE && prefix=$ac_default_prefix
+test "x$exec_prefix" = xNONE && exec_prefix=$prefix
+datarootdir=`eval echo "${datarootdir}"`
+if test "x$CATOBJEXT" = "x.mo" ; then
+  localedir=`eval echo "${libdir}/locale"`
+else
+  localedir=`eval echo "${datadir}/locale"`
+fi
+prefix="$glib_save_prefix"
+exec_prefix="$glib_save_exec_prefix"
+datarootdir="$glib_save_datarootdir"
+AC_DEFINE_UNQUOTED($1, "$localedir",
+  [Define the location where the catalogs will be installed])
+])
+
+dnl
+dnl Now the definitions that aclocal will find
+dnl
+ifdef(glib_configure_in,[],[
+AC_DEFUN([AM_GLIB_GNU_GETTEXT],[GLIB_GNU_GETTEXT($@)])
+AC_DEFUN([AM_GLIB_DEFINE_LOCALEDIR],[GLIB_DEFINE_LOCALEDIR($@)])
+])dnl
+
+# GLIB_RUN_PROG(PROGRAM, TEST-FILE, [ACTION-IF-PASS], [ACTION-IF-FAIL])
+#
+# Create a temporary file with TEST-FILE as its contents and pass the
+# file name to PROGRAM.  Perform ACTION-IF-PASS if PROGRAM exits with
+# 0 and perform ACTION-IF-FAIL for any other exit status.
+AC_DEFUN([GLIB_RUN_PROG],
+[cat >conftest.foo <<_ACEOF
+$2
+_ACEOF
+if AC_RUN_LOG([$1 conftest.foo]); then
+  m4_ifval([$3], [$3], [:])
+m4_ifvaln([$4], [else $4])dnl
+echo "$as_me: failed input was:" >&AS_MESSAGE_LOG_FD
+sed 's/^/| /' conftest.foo >&AS_MESSAGE_LOG_FD
+fi])
+
--- /dev/null
+++ b/m4/glibc21.m4
@@ -0,0 +1,30 @@
+# glibc21.m4 serial 3
+dnl Copyright (C) 2000-2002, 2004 Free Software Foundation, Inc.
+dnl This file is free software; the Free Software Foundation
+dnl gives unlimited permission to copy and/or distribute it,
+dnl with or without modifications, as long as this notice is preserved.
+
+# Test for the GNU C Library, version 2.1 or newer.
+# From Bruno Haible.
+
+AC_DEFUN([gl_GLIBC21],
+  [
+    AC_CACHE_CHECK(whether we are using the GNU C Library 2.1 or newer,
+      ac_cv_gnu_library_2_1,
+      [AC_EGREP_CPP([Lucky GNU user],
+	[
+#include <features.h>
+#ifdef __GNU_LIBRARY__
+ #if (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 1) || (__GLIBC__ > 2)
+  Lucky GNU user
+ #endif
+#endif
+	],
+	ac_cv_gnu_library_2_1=yes,
+	ac_cv_gnu_library_2_1=no)
+      ]
+    )
+    AC_SUBST(GLIBC21)
+    GLIBC21="$ac_cv_gnu_library_2_1"
+  ]
+)
--- /dev/null
+++ b/m4/iconv.m4
@@ -0,0 +1,180 @@
+# iconv.m4 serial AM6 (gettext-0.17)
+dnl Copyright (C) 2000-2002, 2007 Free Software Foundation, Inc.
+dnl This file is free software; the Free Software Foundation
+dnl gives unlimited permission to copy and/or distribute it,
+dnl with or without modifications, as long as this notice is preserved.
+
+dnl From Bruno Haible.
+
+AC_DEFUN([AM_ICONV_LINKFLAGS_BODY],
+[
+  dnl Prerequisites of AC_LIB_LINKFLAGS_BODY.
+  AC_REQUIRE([AC_LIB_PREPARE_PREFIX])
+  AC_REQUIRE([AC_LIB_RPATH])
+
+  dnl Search for libiconv and define LIBICONV, LTLIBICONV and INCICONV
+  dnl accordingly.
+  AC_LIB_LINKFLAGS_BODY([iconv])
+])
+
+AC_DEFUN([AM_ICONV_LINK],
+[
+  dnl Some systems have iconv in libc, some have it in libiconv (OSF/1 and
+  dnl those with the standalone portable GNU libiconv installed).
+  AC_REQUIRE([AC_CANONICAL_HOST]) dnl for cross-compiles
+
+  dnl Search for libiconv and define LIBICONV, LTLIBICONV and INCICONV
+  dnl accordingly.
+  AC_REQUIRE([AM_ICONV_LINKFLAGS_BODY])
+
+  dnl Add $INCICONV to CPPFLAGS before performing the following checks,
+  dnl because if the user has installed libiconv and not disabled its use
+  dnl via --without-libiconv-prefix, he wants to use it. The first
+  dnl AC_TRY_LINK will then fail, the second AC_TRY_LINK will succeed.
+  am_save_CPPFLAGS="$CPPFLAGS"
+  AC_LIB_APPENDTOVAR([CPPFLAGS], [$INCICONV])
+
+  AC_CACHE_CHECK([for iconv], am_cv_func_iconv, [
+    am_cv_func_iconv="no, consider installing GNU libiconv"
+    am_cv_lib_iconv=no
+    AC_TRY_LINK([#include <stdlib.h>
+#include <iconv.h>],
+      [iconv_t cd = iconv_open("","");
+       iconv(cd,NULL,NULL,NULL,NULL);
+       iconv_close(cd);],
+      am_cv_func_iconv=yes)
+    if test "$am_cv_func_iconv" != yes; then
+      am_save_LIBS="$LIBS"
+      LIBS="$LIBS $LIBICONV"
+      AC_TRY_LINK([#include <stdlib.h>
+#include <iconv.h>],
+        [iconv_t cd = iconv_open("","");
+         iconv(cd,NULL,NULL,NULL,NULL);
+         iconv_close(cd);],
+        am_cv_lib_iconv=yes
+        am_cv_func_iconv=yes)
+      LIBS="$am_save_LIBS"
+    fi
+  ])
+  if test "$am_cv_func_iconv" = yes; then
+    AC_CACHE_CHECK([for working iconv], am_cv_func_iconv_works, [
+      dnl This tests against bugs in AIX 5.1 and HP-UX 11.11.
+      am_save_LIBS="$LIBS"
+      if test $am_cv_lib_iconv = yes; then
+        LIBS="$LIBS $LIBICONV"
+      fi
+      AC_TRY_RUN([
+#include <iconv.h>
+#include <string.h>
+int main ()
+{
+  /* Test against AIX 5.1 bug: Failures are not distinguishable from successful
+     returns.  */
+  {
+    iconv_t cd_utf8_to_88591 = iconv_open ("ISO8859-1", "UTF-8");
+    if (cd_utf8_to_88591 != (iconv_t)(-1))
+      {
+        static const char input[] = "\342\202\254"; /* EURO SIGN */
+        char buf[10];
+        const char *inptr = input;
+        size_t inbytesleft = strlen (input);
+        char *outptr = buf;
+        size_t outbytesleft = sizeof (buf);
+        size_t res = iconv (cd_utf8_to_88591,
+                            (char **) &inptr, &inbytesleft,
+                            &outptr, &outbytesleft);
+        if (res == 0)
+          return 1;
+      }
+  }
+#if 0 /* This bug could be worked around by the caller.  */
+  /* Test against HP-UX 11.11 bug: Positive return value instead of 0.  */
+  {
+    iconv_t cd_88591_to_utf8 = iconv_open ("utf8", "iso88591");
+    if (cd_88591_to_utf8 != (iconv_t)(-1))
+      {
+        static const char input[] = "\304rger mit b\366sen B\374bchen ohne Augenma\337";
+        char buf[50];
+        const char *inptr = input;
+        size_t inbytesleft = strlen (input);
+        char *outptr = buf;
+        size_t outbytesleft = sizeof (buf);
+        size_t res = iconv (cd_88591_to_utf8,
+                            (char **) &inptr, &inbytesleft,
+                            &outptr, &outbytesleft);
+        if ((int)res > 0)
+          return 1;
+      }
+  }
+#endif
+  /* Test against HP-UX 11.11 bug: No converter from EUC-JP to UTF-8 is
+     provided.  */
+  if (/* Try standardized names.  */
+      iconv_open ("UTF-8", "EUC-JP") == (iconv_t)(-1)
+      /* Try IRIX, OSF/1 names.  */
+      && iconv_open ("UTF-8", "eucJP") == (iconv_t)(-1)
+      /* Try AIX names.  */
+      && iconv_open ("UTF-8", "IBM-eucJP") == (iconv_t)(-1)
+      /* Try HP-UX names.  */
+      && iconv_open ("utf8", "eucJP") == (iconv_t)(-1))
+    return 1;
+  return 0;
+}], [am_cv_func_iconv_works=yes], [am_cv_func_iconv_works=no],
+        [case "$host_os" in
+           aix* | hpux*) am_cv_func_iconv_works="guessing no" ;;
+           *)            am_cv_func_iconv_works="guessing yes" ;;
+         esac])
+      LIBS="$am_save_LIBS"
+    ])
+    case "$am_cv_func_iconv_works" in
+      *no) am_func_iconv=no am_cv_lib_iconv=no ;;
+      *)   am_func_iconv=yes ;;
+    esac
+  else
+    am_func_iconv=no am_cv_lib_iconv=no
+  fi
+  if test "$am_func_iconv" = yes; then
+    AC_DEFINE(HAVE_ICONV, 1,
+      [Define if you have the iconv() function and it works.])
+  fi
+  if test "$am_cv_lib_iconv" = yes; then
+    AC_MSG_CHECKING([how to link with libiconv])
+    AC_MSG_RESULT([$LIBICONV])
+  else
+    dnl If $LIBICONV didn't lead to a usable library, we don't need $INCICONV
+    dnl either.
+    CPPFLAGS="$am_save_CPPFLAGS"
+    LIBICONV=
+    LTLIBICONV=
+  fi
+  AC_SUBST(LIBICONV)
+  AC_SUBST(LTLIBICONV)
+])
+
+AC_DEFUN([AM_ICONV],
+[
+  AM_ICONV_LINK
+  if test "$am_cv_func_iconv" = yes; then
+    AC_MSG_CHECKING([for iconv declaration])
+    AC_CACHE_VAL(am_cv_proto_iconv, [
+      AC_TRY_COMPILE([
+#include <stdlib.h>
+#include <iconv.h>
+extern
+#ifdef __cplusplus
+"C"
+#endif
+#if defined(__STDC__) || defined(__cplusplus)
+size_t iconv (iconv_t cd, char * *inbuf, size_t *inbytesleft, char * *outbuf, size_t *outbytesleft);
+#else
+size_t iconv();
+#endif
+], [], am_cv_proto_iconv_arg1="", am_cv_proto_iconv_arg1="const")
+      am_cv_proto_iconv="extern size_t iconv (iconv_t cd, $am_cv_proto_iconv_arg1 char * *inbuf, size_t *inbytesleft, char * *outbuf, size_t *outbytesleft);"])
+    am_cv_proto_iconv=`echo "[$]am_cv_proto_iconv" | tr -s ' ' | sed -e 's/( /(/'`
+    AC_MSG_RESULT([$]{ac_t:-
+         }[$]am_cv_proto_iconv)
+    AC_DEFINE_UNQUOTED(ICONV_CONST, $am_cv_proto_iconv_arg1,
+      [Define as const if the declaration of iconv() needs const.])
+  fi
+])
--- /dev/null
+++ b/m4/isc-posix.m4
@@ -0,0 +1,24 @@
+# isc-posix.m4 serial 2 (gettext-0.11.2)
+dnl Copyright (C) 1995-2002 Free Software Foundation, Inc.
+dnl This file is free software; the Free Software Foundation
+dnl gives unlimited permission to copy and/or distribute it,
+dnl with or without modifications, as long as this notice is preserved.
+
+# This file is not needed with autoconf-2.53 and newer.  Remove it in 2005.
+
+# This test replaces the one in autoconf.
+# Currently this macro should have the same name as the autoconf macro
+# because gettext's gettext.m4 (distributed in the automake package)
+# still uses it.  Otherwise, the use in gettext.m4 makes autoheader
+# give these diagnostics:
+#   configure.in:556: AC_TRY_COMPILE was called before AC_ISC_POSIX
+#   configure.in:556: AC_TRY_RUN was called before AC_ISC_POSIX
+
+undefine([AC_ISC_POSIX])
+
+AC_DEFUN([AC_ISC_POSIX],
+  [
+    dnl This test replaces the obsolescent AC_ISC_POSIX kludge.
+    AC_CHECK_LIB(cposix, strerror, [LIBS="$LIBS -lcposix"])
+  ]
+)
--- /dev/null
+++ b/m4/lcmessage.m4
@@ -0,0 +1,30 @@
+# lcmessage.m4 serial 4 (gettext-0.14.2)
+dnl Copyright (C) 1995-2002, 2004-2005 Free Software Foundation, Inc.
+dnl This file is free software; the Free Software Foundation
+dnl gives unlimited permission to copy and/or distribute it,
+dnl with or without modifications, as long as this notice is preserved.
+dnl
+dnl This file can can be used in projects which are not available under
+dnl the GNU General Public License or the GNU Library General Public
+dnl License but which still want to provide support for the GNU gettext
+dnl functionality.
+dnl Please note that the actual code of the GNU gettext library is covered
+dnl by the GNU Library General Public License, and the rest of the GNU
+dnl gettext package package is covered by the GNU General Public License.
+dnl They are *not* in the public domain.
+
+dnl Authors:
+dnl   Ulrich Drepper <drepper@cygnus.com>, 1995.
+
+# Check whether LC_MESSAGES is available in <locale.h>.
+
+AC_DEFUN([gt_LC_MESSAGES],
+[
+  AC_CACHE_CHECK([for LC_MESSAGES], gt_cv_val_LC_MESSAGES,
+    [AC_TRY_LINK([#include <locale.h>], [return LC_MESSAGES],
+       gt_cv_val_LC_MESSAGES=yes, gt_cv_val_LC_MESSAGES=no)])
+  if test $gt_cv_val_LC_MESSAGES = yes; then
+    AC_DEFINE(HAVE_LC_MESSAGES, 1,
+      [Define if your <locale.h> file defines LC_MESSAGES.])
+  fi
+])
--- /dev/null
+++ b/m4/lib-ld.m4
@@ -0,0 +1,110 @@
+# lib-ld.m4 serial 3 (gettext-0.13)
+dnl Copyright (C) 1996-2003 Free Software Foundation, Inc.
+dnl This file is free software; the Free Software Foundation
+dnl gives unlimited permission to copy and/or distribute it,
+dnl with or without modifications, as long as this notice is preserved.
+
+dnl Subroutines of libtool.m4,
+dnl with replacements s/AC_/AC_LIB/ and s/lt_cv/acl_cv/ to avoid collision
+dnl with libtool.m4.
+
+dnl From libtool-1.4. Sets the variable with_gnu_ld to yes or no.
+AC_DEFUN([AC_LIB_PROG_LD_GNU],
+[AC_CACHE_CHECK([if the linker ($LD) is GNU ld], acl_cv_prog_gnu_ld,
+[# I'd rather use --version here, but apparently some GNU ld's only accept -v.
+case `$LD -v 2>&1 </dev/null` in
+*GNU* | *'with BFD'*)
+  acl_cv_prog_gnu_ld=yes ;;
+*)
+  acl_cv_prog_gnu_ld=no ;;
+esac])
+with_gnu_ld=$acl_cv_prog_gnu_ld
+])
+
+dnl From libtool-1.4. Sets the variable LD.
+AC_DEFUN([AC_LIB_PROG_LD],
+[AC_ARG_WITH(gnu-ld,
+[  --with-gnu-ld           assume the C compiler uses GNU ld [default=no]],
+test "$withval" = no || with_gnu_ld=yes, with_gnu_ld=no)
+AC_REQUIRE([AC_PROG_CC])dnl
+AC_REQUIRE([AC_CANONICAL_HOST])dnl
+# Prepare PATH_SEPARATOR.
+# The user is always right.
+if test "${PATH_SEPARATOR+set}" != set; then
+  echo "#! /bin/sh" >conf$$.sh
+  echo  "exit 0"   >>conf$$.sh
+  chmod +x conf$$.sh
+  if (PATH="/nonexistent;."; conf$$.sh) >/dev/null 2>&1; then
+    PATH_SEPARATOR=';'
+  else
+    PATH_SEPARATOR=:
+  fi
+  rm -f conf$$.sh
+fi
+ac_prog=ld
+if test "$GCC" = yes; then
+  # Check if gcc -print-prog-name=ld gives a path.
+  AC_MSG_CHECKING([for ld used by GCC])
+  case $host in
+  *-*-mingw*)
+    # gcc leaves a trailing carriage return which upsets mingw
+    ac_prog=`($CC -print-prog-name=ld) 2>&5 | tr -d '\015'` ;;
+  *)
+    ac_prog=`($CC -print-prog-name=ld) 2>&5` ;;
+  esac
+  case $ac_prog in
+    # Accept absolute paths.
+    [[\\/]* | [A-Za-z]:[\\/]*)]
+      [re_direlt='/[^/][^/]*/\.\./']
+      # Canonicalize the path of ld
+      ac_prog=`echo $ac_prog| sed 's%\\\\%/%g'`
+      while echo $ac_prog | grep "$re_direlt" > /dev/null 2>&1; do
+	ac_prog=`echo $ac_prog| sed "s%$re_direlt%/%"`
+      done
+      test -z "$LD" && LD="$ac_prog"
+      ;;
+  "")
+    # If it fails, then pretend we aren't using GCC.
+    ac_prog=ld
+    ;;
+  *)
+    # If it is relative, then search for the first ld in PATH.
+    with_gnu_ld=unknown
+    ;;
+  esac
+elif test "$with_gnu_ld" = yes; then
+  AC_MSG_CHECKING([for GNU ld])
+else
+  AC_MSG_CHECKING([for non-GNU ld])
+fi
+AC_CACHE_VAL(acl_cv_path_LD,
+[if test -z "$LD"; then
+  IFS="${IFS= 	}"; ac_save_ifs="$IFS"; IFS="${IFS}${PATH_SEPARATOR-:}"
+  for ac_dir in $PATH; do
+    test -z "$ac_dir" && ac_dir=.
+    if test -f "$ac_dir/$ac_prog" || test -f "$ac_dir/$ac_prog$ac_exeext"; then
+      acl_cv_path_LD="$ac_dir/$ac_prog"
+      # Check to see if the program is GNU ld.  I'd rather use --version,
+      # but apparently some GNU ld's only accept -v.
+      # Break only if it was the GNU/non-GNU ld that we prefer.
+      case `"$acl_cv_path_LD" -v 2>&1 < /dev/null` in
+      *GNU* | *'with BFD'*)
+	test "$with_gnu_ld" != no && break ;;
+      *)
+	test "$with_gnu_ld" != yes && break ;;
+      esac
+    fi
+  done
+  IFS="$ac_save_ifs"
+else
+  acl_cv_path_LD="$LD" # Let the user override the test with a path.
+fi])
+LD="$acl_cv_path_LD"
+if test -n "$LD"; then
+  AC_MSG_RESULT($LD)
+else
+  AC_MSG_RESULT(no)
+fi
+test -z "$LD" && AC_MSG_ERROR([no acceptable ld found in \$PATH])
+AC_LIB_PROG_LD_GNU
+])
--- /dev/null
+++ b/m4/lib-link.m4
@@ -0,0 +1,709 @@
+# lib-link.m4 serial 13 (gettext-0.17)
+dnl Copyright (C) 2001-2007 Free Software Foundation, Inc.
+dnl This file is free software; the Free Software Foundation
+dnl gives unlimited permission to copy and/or distribute it,
+dnl with or without modifications, as long as this notice is preserved.
+
+dnl From Bruno Haible.
+
+AC_PREREQ(2.54)
+
+dnl AC_LIB_LINKFLAGS(name [, dependencies]) searches for libname and
+dnl the libraries corresponding to explicit and implicit dependencies.
+dnl Sets and AC_SUBSTs the LIB${NAME} and LTLIB${NAME} variables and
+dnl augments the CPPFLAGS variable.
+dnl Sets and AC_SUBSTs the LIB${NAME}_PREFIX variable to nonempty if libname
+dnl was found in ${LIB${NAME}_PREFIX}/$acl_libdirstem.
+AC_DEFUN([AC_LIB_LINKFLAGS],
+[
+  AC_REQUIRE([AC_LIB_PREPARE_PREFIX])
+  AC_REQUIRE([AC_LIB_RPATH])
+  define([Name],[translit([$1],[./-], [___])])
+  define([NAME],[translit([$1],[abcdefghijklmnopqrstuvwxyz./-],
+                               [ABCDEFGHIJKLMNOPQRSTUVWXYZ___])])
+  AC_CACHE_CHECK([how to link with lib[]$1], [ac_cv_lib[]Name[]_libs], [
+    AC_LIB_LINKFLAGS_BODY([$1], [$2])
+    ac_cv_lib[]Name[]_libs="$LIB[]NAME"
+    ac_cv_lib[]Name[]_ltlibs="$LTLIB[]NAME"
+    ac_cv_lib[]Name[]_cppflags="$INC[]NAME"
+    ac_cv_lib[]Name[]_prefix="$LIB[]NAME[]_PREFIX"
+  ])
+  LIB[]NAME="$ac_cv_lib[]Name[]_libs"
+  LTLIB[]NAME="$ac_cv_lib[]Name[]_ltlibs"
+  INC[]NAME="$ac_cv_lib[]Name[]_cppflags"
+  LIB[]NAME[]_PREFIX="$ac_cv_lib[]Name[]_prefix"
+  AC_LIB_APPENDTOVAR([CPPFLAGS], [$INC]NAME)
+  AC_SUBST([LIB]NAME)
+  AC_SUBST([LTLIB]NAME)
+  AC_SUBST([LIB]NAME[_PREFIX])
+  dnl Also set HAVE_LIB[]NAME so that AC_LIB_HAVE_LINKFLAGS can reuse the
+  dnl results of this search when this library appears as a dependency.
+  HAVE_LIB[]NAME=yes
+  undefine([Name])
+  undefine([NAME])
+])
+
+dnl AC_LIB_HAVE_LINKFLAGS(name, dependencies, includes, testcode)
+dnl searches for libname and the libraries corresponding to explicit and
+dnl implicit dependencies, together with the specified include files and
+dnl the ability to compile and link the specified testcode. If found, it
+dnl sets and AC_SUBSTs HAVE_LIB${NAME}=yes and the LIB${NAME} and
+dnl LTLIB${NAME} variables and augments the CPPFLAGS variable, and
+dnl #defines HAVE_LIB${NAME} to 1. Otherwise, it sets and AC_SUBSTs
+dnl HAVE_LIB${NAME}=no and LIB${NAME} and LTLIB${NAME} to empty.
+dnl Sets and AC_SUBSTs the LIB${NAME}_PREFIX variable to nonempty if libname
+dnl was found in ${LIB${NAME}_PREFIX}/$acl_libdirstem.
+AC_DEFUN([AC_LIB_HAVE_LINKFLAGS],
+[
+  AC_REQUIRE([AC_LIB_PREPARE_PREFIX])
+  AC_REQUIRE([AC_LIB_RPATH])
+  define([Name],[translit([$1],[./-], [___])])
+  define([NAME],[translit([$1],[abcdefghijklmnopqrstuvwxyz./-],
+                               [ABCDEFGHIJKLMNOPQRSTUVWXYZ___])])
+
+  dnl Search for lib[]Name and define LIB[]NAME, LTLIB[]NAME and INC[]NAME
+  dnl accordingly.
+  AC_LIB_LINKFLAGS_BODY([$1], [$2])
+
+  dnl Add $INC[]NAME to CPPFLAGS before performing the following checks,
+  dnl because if the user has installed lib[]Name and not disabled its use
+  dnl via --without-lib[]Name-prefix, he wants to use it.
+  ac_save_CPPFLAGS="$CPPFLAGS"
+  AC_LIB_APPENDTOVAR([CPPFLAGS], [$INC]NAME)
+
+  AC_CACHE_CHECK([for lib[]$1], [ac_cv_lib[]Name], [
+    ac_save_LIBS="$LIBS"
+    LIBS="$LIBS $LIB[]NAME"
+    AC_TRY_LINK([$3], [$4], [ac_cv_lib[]Name=yes], [ac_cv_lib[]Name=no])
+    LIBS="$ac_save_LIBS"
+  ])
+  if test "$ac_cv_lib[]Name" = yes; then
+    HAVE_LIB[]NAME=yes
+    AC_DEFINE([HAVE_LIB]NAME, 1, [Define if you have the $1 library.])
+    AC_MSG_CHECKING([how to link with lib[]$1])
+    AC_MSG_RESULT([$LIB[]NAME])
+  else
+    HAVE_LIB[]NAME=no
+    dnl If $LIB[]NAME didn't lead to a usable library, we don't need
+    dnl $INC[]NAME either.
+    CPPFLAGS="$ac_save_CPPFLAGS"
+    LIB[]NAME=
+    LTLIB[]NAME=
+    LIB[]NAME[]_PREFIX=
+  fi
+  AC_SUBST([HAVE_LIB]NAME)
+  AC_SUBST([LIB]NAME)
+  AC_SUBST([LTLIB]NAME)
+  AC_SUBST([LIB]NAME[_PREFIX])
+  undefine([Name])
+  undefine([NAME])
+])
+
+dnl Determine the platform dependent parameters needed to use rpath:
+dnl   acl_libext,
+dnl   acl_shlibext,
+dnl   acl_hardcode_libdir_flag_spec,
+dnl   acl_hardcode_libdir_separator,
+dnl   acl_hardcode_direct,
+dnl   acl_hardcode_minus_L.
+AC_DEFUN([AC_LIB_RPATH],
+[
+  dnl Tell automake >= 1.10 to complain if config.rpath is missing.
+  m4_ifdef([AC_REQUIRE_AUX_FILE], [AC_REQUIRE_AUX_FILE([config.rpath])])
+  AC_REQUIRE([AC_PROG_CC])                dnl we use $CC, $GCC, $LDFLAGS
+  AC_REQUIRE([AC_LIB_PROG_LD])            dnl we use $LD, $with_gnu_ld
+  AC_REQUIRE([AC_CANONICAL_HOST])         dnl we use $host
+  AC_REQUIRE([AC_CONFIG_AUX_DIR_DEFAULT]) dnl we use $ac_aux_dir
+  AC_CACHE_CHECK([for shared library run path origin], acl_cv_rpath, [
+    CC="$CC" GCC="$GCC" LDFLAGS="$LDFLAGS" LD="$LD" with_gnu_ld="$with_gnu_ld" \
+    ${CONFIG_SHELL-/bin/sh} "$ac_aux_dir/config.rpath" "$host" > conftest.sh
+    . ./conftest.sh
+    rm -f ./conftest.sh
+    acl_cv_rpath=done
+  ])
+  wl="$acl_cv_wl"
+  acl_libext="$acl_cv_libext"
+  acl_shlibext="$acl_cv_shlibext"
+  acl_libname_spec="$acl_cv_libname_spec"
+  acl_library_names_spec="$acl_cv_library_names_spec"
+  acl_hardcode_libdir_flag_spec="$acl_cv_hardcode_libdir_flag_spec"
+  acl_hardcode_libdir_separator="$acl_cv_hardcode_libdir_separator"
+  acl_hardcode_direct="$acl_cv_hardcode_direct"
+  acl_hardcode_minus_L="$acl_cv_hardcode_minus_L"
+  dnl Determine whether the user wants rpath handling at all.
+  AC_ARG_ENABLE(rpath,
+    [  --disable-rpath         do not hardcode runtime library paths],
+    :, enable_rpath=yes)
+])
+
+dnl AC_LIB_LINKFLAGS_BODY(name [, dependencies]) searches for libname and
+dnl the libraries corresponding to explicit and implicit dependencies.
+dnl Sets the LIB${NAME}, LTLIB${NAME} and INC${NAME} variables.
+dnl Also, sets the LIB${NAME}_PREFIX variable to nonempty if libname was found
+dnl in ${LIB${NAME}_PREFIX}/$acl_libdirstem.
+AC_DEFUN([AC_LIB_LINKFLAGS_BODY],
+[
+  AC_REQUIRE([AC_LIB_PREPARE_MULTILIB])
+  define([NAME],[translit([$1],[abcdefghijklmnopqrstuvwxyz./-],
+                               [ABCDEFGHIJKLMNOPQRSTUVWXYZ___])])
+  dnl Autoconf >= 2.61 supports dots in --with options.
+  define([N_A_M_E],[m4_if(m4_version_compare(m4_defn([m4_PACKAGE_VERSION]),[2.61]),[-1],[translit([$1],[.],[_])],[$1])])
+  dnl By default, look in $includedir and $libdir.
+  use_additional=yes
+  AC_LIB_WITH_FINAL_PREFIX([
+    eval additional_includedir=\"$includedir\"
+    eval additional_libdir=\"$libdir\"
+  ])
+  AC_LIB_ARG_WITH([lib]N_A_M_E[-prefix],
+[  --with-lib]N_A_M_E[-prefix[=DIR]  search for lib$1 in DIR/include and DIR/lib
+  --without-lib]N_A_M_E[-prefix     don't search for lib$1 in includedir and libdir],
+[
+    if test "X$withval" = "Xno"; then
+      use_additional=no
+    else
+      if test "X$withval" = "X"; then
+        AC_LIB_WITH_FINAL_PREFIX([
+          eval additional_includedir=\"$includedir\"
+          eval additional_libdir=\"$libdir\"
+        ])
+      else
+        additional_includedir="$withval/include"
+        additional_libdir="$withval/$acl_libdirstem"
+      fi
+    fi
+])
+  dnl Search the library and its dependencies in $additional_libdir and
+  dnl $LDFLAGS. Using breadth-first-seach.
+  LIB[]NAME=
+  LTLIB[]NAME=
+  INC[]NAME=
+  LIB[]NAME[]_PREFIX=
+  rpathdirs=
+  ltrpathdirs=
+  names_already_handled=
+  names_next_round='$1 $2'
+  while test -n "$names_next_round"; do
+    names_this_round="$names_next_round"
+    names_next_round=
+    for name in $names_this_round; do
+      already_handled=
+      for n in $names_already_handled; do
+        if test "$n" = "$name"; then
+          already_handled=yes
+          break
+        fi
+      done
+      if test -z "$already_handled"; then
+        names_already_handled="$names_already_handled $name"
+        dnl See if it was already located by an earlier AC_LIB_LINKFLAGS
+        dnl or AC_LIB_HAVE_LINKFLAGS call.
+        uppername=`echo "$name" | sed -e 'y|abcdefghijklmnopqrstuvwxyz./-|ABCDEFGHIJKLMNOPQRSTUVWXYZ___|'`
+        eval value=\"\$HAVE_LIB$uppername\"
+        if test -n "$value"; then
+          if test "$value" = yes; then
+            eval value=\"\$LIB$uppername\"
+            test -z "$value" || LIB[]NAME="${LIB[]NAME}${LIB[]NAME:+ }$value"
+            eval value=\"\$LTLIB$uppername\"
+            test -z "$value" || LTLIB[]NAME="${LTLIB[]NAME}${LTLIB[]NAME:+ }$value"
+          else
+            dnl An earlier call to AC_LIB_HAVE_LINKFLAGS has determined
+            dnl that this library doesn't exist. So just drop it.
+            :
+          fi
+        else
+          dnl Search the library lib$name in $additional_libdir and $LDFLAGS
+          dnl and the already constructed $LIBNAME/$LTLIBNAME.
+          found_dir=
+          found_la=
+          found_so=
+          found_a=
+          eval libname=\"$acl_libname_spec\"    # typically: libname=lib$name
+          if test -n "$acl_shlibext"; then
+            shrext=".$acl_shlibext"             # typically: shrext=.so
+          else
+            shrext=
+          fi
+          if test $use_additional = yes; then
+            dir="$additional_libdir"
+            dnl The same code as in the loop below:
+            dnl First look for a shared library.
+            if test -n "$acl_shlibext"; then
+              if test -f "$dir/$libname$shrext"; then
+                found_dir="$dir"
+                found_so="$dir/$libname$shrext"
+              else
+                if test "$acl_library_names_spec" = '$libname$shrext$versuffix'; then
+                  ver=`(cd "$dir" && \
+                        for f in "$libname$shrext".*; do echo "$f"; done \
+                        | sed -e "s,^$libname$shrext\\\\.,," \
+                        | sort -t '.' -n -r -k1,1 -k2,2 -k3,3 -k4,4 -k5,5 \
+                        | sed 1q ) 2>/dev/null`
+                  if test -n "$ver" && test -f "$dir/$libname$shrext.$ver"; then
+                    found_dir="$dir"
+                    found_so="$dir/$libname$shrext.$ver"
+                  fi
+                else
+                  eval library_names=\"$acl_library_names_spec\"
+                  for f in $library_names; do
+                    if test -f "$dir/$f"; then
+                      found_dir="$dir"
+                      found_so="$dir/$f"
+                      break
+                    fi
+                  done
+                fi
+              fi
+            fi
+            dnl Then look for a static library.
+            if test "X$found_dir" = "X"; then
+              if test -f "$dir/$libname.$acl_libext"; then
+                found_dir="$dir"
+                found_a="$dir/$libname.$acl_libext"
+              fi
+            fi
+            if test "X$found_dir" != "X"; then
+              if test -f "$dir/$libname.la"; then
+                found_la="$dir/$libname.la"
+              fi
+            fi
+          fi
+          if test "X$found_dir" = "X"; then
+            for x in $LDFLAGS $LTLIB[]NAME; do
+              AC_LIB_WITH_FINAL_PREFIX([eval x=\"$x\"])
+              case "$x" in
+                -L*)
+                  dir=`echo "X$x" | sed -e 's/^X-L//'`
+                  dnl First look for a shared library.
+                  if test -n "$acl_shlibext"; then
+                    if test -f "$dir/$libname$shrext"; then
+                      found_dir="$dir"
+                      found_so="$dir/$libname$shrext"
+                    else
+                      if test "$acl_library_names_spec" = '$libname$shrext$versuffix'; then
+                        ver=`(cd "$dir" && \
+                              for f in "$libname$shrext".*; do echo "$f"; done \
+                              | sed -e "s,^$libname$shrext\\\\.,," \
+                              | sort -t '.' -n -r -k1,1 -k2,2 -k3,3 -k4,4 -k5,5 \
+                              | sed 1q ) 2>/dev/null`
+                        if test -n "$ver" && test -f "$dir/$libname$shrext.$ver"; then
+                          found_dir="$dir"
+                          found_so="$dir/$libname$shrext.$ver"
+                        fi
+                      else
+                        eval library_names=\"$acl_library_names_spec\"
+                        for f in $library_names; do
+                          if test -f "$dir/$f"; then
+                            found_dir="$dir"
+                            found_so="$dir/$f"
+                            break
+                          fi
+                        done
+                      fi
+                    fi
+                  fi
+                  dnl Then look for a static library.
+                  if test "X$found_dir" = "X"; then
+                    if test -f "$dir/$libname.$acl_libext"; then
+                      found_dir="$dir"
+                      found_a="$dir/$libname.$acl_libext"
+                    fi
+                  fi
+                  if test "X$found_dir" != "X"; then
+                    if test -f "$dir/$libname.la"; then
+                      found_la="$dir/$libname.la"
+                    fi
+                  fi
+                  ;;
+              esac
+              if test "X$found_dir" != "X"; then
+                break
+              fi
+            done
+          fi
+          if test "X$found_dir" != "X"; then
+            dnl Found the library.
+            LTLIB[]NAME="${LTLIB[]NAME}${LTLIB[]NAME:+ }-L$found_dir -l$name"
+            if test "X$found_so" != "X"; then
+              dnl Linking with a shared library. We attempt to hardcode its
+              dnl directory into the executable's runpath, unless it's the
+              dnl standard /usr/lib.
+              if test "$enable_rpath" = no || test "X$found_dir" = "X/usr/$acl_libdirstem"; then
+                dnl No hardcoding is needed.
+                LIB[]NAME="${LIB[]NAME}${LIB[]NAME:+ }$found_so"
+              else
+                dnl Use an explicit option to hardcode DIR into the resulting
+                dnl binary.
+                dnl Potentially add DIR to ltrpathdirs.
+                dnl The ltrpathdirs will be appended to $LTLIBNAME at the end.
+                haveit=
+                for x in $ltrpathdirs; do
+                  if test "X$x" = "X$found_dir"; then
+                    haveit=yes
+                    break
+                  fi
+                done
+                if test -z "$haveit"; then
+                  ltrpathdirs="$ltrpathdirs $found_dir"
+                fi
+                dnl The hardcoding into $LIBNAME is system dependent.
+                if test "$acl_hardcode_direct" = yes; then
+                  dnl Using DIR/libNAME.so during linking hardcodes DIR into the
+                  dnl resulting binary.
+                  LIB[]NAME="${LIB[]NAME}${LIB[]NAME:+ }$found_so"
+                else
+                  if test -n "$acl_hardcode_libdir_flag_spec" && test "$acl_hardcode_minus_L" = no; then
+                    dnl Use an explicit option to hardcode DIR into the resulting
+                    dnl binary.
+                    LIB[]NAME="${LIB[]NAME}${LIB[]NAME:+ }$found_so"
+                    dnl Potentially add DIR to rpathdirs.
+                    dnl The rpathdirs will be appended to $LIBNAME at the end.
+                    haveit=
+                    for x in $rpathdirs; do
+                      if test "X$x" = "X$found_dir"; then
+                        haveit=yes
+                        break
+                      fi
+                    done
+                    if test -z "$haveit"; then
+                      rpathdirs="$rpathdirs $found_dir"
+                    fi
+                  else
+                    dnl Rely on "-L$found_dir".
+                    dnl But don't add it if it's already contained in the LDFLAGS
+                    dnl or the already constructed $LIBNAME
+                    haveit=
+                    for x in $LDFLAGS $LIB[]NAME; do
+                      AC_LIB_WITH_FINAL_PREFIX([eval x=\"$x\"])
+                      if test "X$x" = "X-L$found_dir"; then
+                        haveit=yes
+                        break
+                      fi
+                    done
+                    if test -z "$haveit"; then
+                      LIB[]NAME="${LIB[]NAME}${LIB[]NAME:+ }-L$found_dir"
+                    fi
+                    if test "$acl_hardcode_minus_L" != no; then
+                      dnl FIXME: Not sure whether we should use
+                      dnl "-L$found_dir -l$name" or "-L$found_dir $found_so"
+                      dnl here.
+                      LIB[]NAME="${LIB[]NAME}${LIB[]NAME:+ }$found_so"
+                    else
+                      dnl We cannot use $acl_hardcode_runpath_var and LD_RUN_PATH
+                      dnl here, because this doesn't fit in flags passed to the
+                      dnl compiler. So give up. No hardcoding. This affects only
+                      dnl very old systems.
+                      dnl FIXME: Not sure whether we should use
+                      dnl "-L$found_dir -l$name" or "-L$found_dir $found_so"
+                      dnl here.
+                      LIB[]NAME="${LIB[]NAME}${LIB[]NAME:+ }-l$name"
+                    fi
+                  fi
+                fi
+              fi
+            else
+              if test "X$found_a" != "X"; then
+                dnl Linking with a static library.
+                LIB[]NAME="${LIB[]NAME}${LIB[]NAME:+ }$found_a"
+              else
+                dnl We shouldn't come here, but anyway it's good to have a
+                dnl fallback.
+                LIB[]NAME="${LIB[]NAME}${LIB[]NAME:+ }-L$found_dir -l$name"
+              fi
+            fi
+            dnl Assume the include files are nearby.
+            additional_includedir=
+            case "$found_dir" in
+              */$acl_libdirstem | */$acl_libdirstem/)
+                basedir=`echo "X$found_dir" | sed -e 's,^X,,' -e "s,/$acl_libdirstem/"'*$,,'`
+                LIB[]NAME[]_PREFIX="$basedir"
+                additional_includedir="$basedir/include"
+                ;;
+            esac
+            if test "X$additional_includedir" != "X"; then
+              dnl Potentially add $additional_includedir to $INCNAME.
+              dnl But don't add it
+              dnl   1. if it's the standard /usr/include,
+              dnl   2. if it's /usr/local/include and we are using GCC on Linux,
+              dnl   3. if it's already present in $CPPFLAGS or the already
+              dnl      constructed $INCNAME,
+              dnl   4. if it doesn't exist as a directory.
+              if test "X$additional_includedir" != "X/usr/include"; then
+                haveit=
+                if test "X$additional_includedir" = "X/usr/local/include"; then
+                  if test -n "$GCC"; then
+                    case $host_os in
+                      linux* | gnu* | k*bsd*-gnu) haveit=yes;;
+                    esac
+                  fi
+                fi
+                if test -z "$haveit"; then
+                  for x in $CPPFLAGS $INC[]NAME; do
+                    AC_LIB_WITH_FINAL_PREFIX([eval x=\"$x\"])
+                    if test "X$x" = "X-I$additional_includedir"; then
+                      haveit=yes
+                      break
+                    fi
+                  done
+                  if test -z "$haveit"; then
+                    if test -d "$additional_includedir"; then
+                      dnl Really add $additional_includedir to $INCNAME.
+                      INC[]NAME="${INC[]NAME}${INC[]NAME:+ }-I$additional_includedir"
+                    fi
+                  fi
+                fi
+              fi
+            fi
+            dnl Look for dependencies.
+            if test -n "$found_la"; then
+              dnl Read the .la file. It defines the variables
+              dnl dlname, library_names, old_library, dependency_libs, current,
+              dnl age, revision, installed, dlopen, dlpreopen, libdir.
+              save_libdir="$libdir"
+              case "$found_la" in
+                */* | *\\*) . "$found_la" ;;
+                *) . "./$found_la" ;;
+              esac
+              libdir="$save_libdir"
+              dnl We use only dependency_libs.
+              for dep in $dependency_libs; do
+                case "$dep" in
+                  -L*)
+                    additional_libdir=`echo "X$dep" | sed -e 's/^X-L//'`
+                    dnl Potentially add $additional_libdir to $LIBNAME and $LTLIBNAME.
+                    dnl But don't add it
+                    dnl   1. if it's the standard /usr/lib,
+                    dnl   2. if it's /usr/local/lib and we are using GCC on Linux,
+                    dnl   3. if it's already present in $LDFLAGS or the already
+                    dnl      constructed $LIBNAME,
+                    dnl   4. if it doesn't exist as a directory.
+                    if test "X$additional_libdir" != "X/usr/$acl_libdirstem"; then
+                      haveit=
+                      if test "X$additional_libdir" = "X/usr/local/$acl_libdirstem"; then
+                        if test -n "$GCC"; then
+                          case $host_os in
+                            linux* | gnu* | k*bsd*-gnu) haveit=yes;;
+                          esac
+                        fi
+                      fi
+                      if test -z "$haveit"; then
+                        haveit=
+                        for x in $LDFLAGS $LIB[]NAME; do
+                          AC_LIB_WITH_FINAL_PREFIX([eval x=\"$x\"])
+                          if test "X$x" = "X-L$additional_libdir"; then
+                            haveit=yes
+                            break
+                          fi
+                        done
+                        if test -z "$haveit"; then
+                          if test -d "$additional_libdir"; then
+                            dnl Really add $additional_libdir to $LIBNAME.
+                            LIB[]NAME="${LIB[]NAME}${LIB[]NAME:+ }-L$additional_libdir"
+                          fi
+                        fi
+                        haveit=
+                        for x in $LDFLAGS $LTLIB[]NAME; do
+                          AC_LIB_WITH_FINAL_PREFIX([eval x=\"$x\"])
+                          if test "X$x" = "X-L$additional_libdir"; then
+                            haveit=yes
+                            break
+                          fi
+                        done
+                        if test -z "$haveit"; then
+                          if test -d "$additional_libdir"; then
+                            dnl Really add $additional_libdir to $LTLIBNAME.
+                            LTLIB[]NAME="${LTLIB[]NAME}${LTLIB[]NAME:+ }-L$additional_libdir"
+                          fi
+                        fi
+                      fi
+                    fi
+                    ;;
+                  -R*)
+                    dir=`echo "X$dep" | sed -e 's/^X-R//'`
+                    if test "$enable_rpath" != no; then
+                      dnl Potentially add DIR to rpathdirs.
+                      dnl The rpathdirs will be appended to $LIBNAME at the end.
+                      haveit=
+                      for x in $rpathdirs; do
+                        if test "X$x" = "X$dir"; then
+                          haveit=yes
+                          break
+                        fi
+                      done
+                      if test -z "$haveit"; then
+                        rpathdirs="$rpathdirs $dir"
+                      fi
+                      dnl Potentially add DIR to ltrpathdirs.
+                      dnl The ltrpathdirs will be appended to $LTLIBNAME at the end.
+                      haveit=
+                      for x in $ltrpathdirs; do
+                        if test "X$x" = "X$dir"; then
+                          haveit=yes
+                          break
+                        fi
+                      done
+                      if test -z "$haveit"; then
+                        ltrpathdirs="$ltrpathdirs $dir"
+                      fi
+                    fi
+                    ;;
+                  -l*)
+                    dnl Handle this in the next round.
+                    names_next_round="$names_next_round "`echo "X$dep" | sed -e 's/^X-l//'`
+                    ;;
+                  *.la)
+                    dnl Handle this in the next round. Throw away the .la's
+                    dnl directory; it is already contained in a preceding -L
+                    dnl option.
+                    names_next_round="$names_next_round "`echo "X$dep" | sed -e 's,^X.*/,,' -e 's,^lib,,' -e 's,\.la$,,'`
+                    ;;
+                  *)
+                    dnl Most likely an immediate library name.
+                    LIB[]NAME="${LIB[]NAME}${LIB[]NAME:+ }$dep"
+                    LTLIB[]NAME="${LTLIB[]NAME}${LTLIB[]NAME:+ }$dep"
+                    ;;
+                esac
+              done
+            fi
+          else
+            dnl Didn't find the library; assume it is in the system directories
+            dnl known to the linker and runtime loader. (All the system
+            dnl directories known to the linker should also be known to the
+            dnl runtime loader, otherwise the system is severely misconfigured.)
+            LIB[]NAME="${LIB[]NAME}${LIB[]NAME:+ }-l$name"
+            LTLIB[]NAME="${LTLIB[]NAME}${LTLIB[]NAME:+ }-l$name"
+          fi
+        fi
+      fi
+    done
+  done
+  if test "X$rpathdirs" != "X"; then
+    if test -n "$acl_hardcode_libdir_separator"; then
+      dnl Weird platform: only the last -rpath option counts, the user must
+      dnl pass all path elements in one option. We can arrange that for a
+      dnl single library, but not when more than one $LIBNAMEs are used.
+      alldirs=
+      for found_dir in $rpathdirs; do
+        alldirs="${alldirs}${alldirs:+$acl_hardcode_libdir_separator}$found_dir"
+      done
+      dnl Note: acl_hardcode_libdir_flag_spec uses $libdir and $wl.
+      acl_save_libdir="$libdir"
+      libdir="$alldirs"
+      eval flag=\"$acl_hardcode_libdir_flag_spec\"
+      libdir="$acl_save_libdir"
+      LIB[]NAME="${LIB[]NAME}${LIB[]NAME:+ }$flag"
+    else
+      dnl The -rpath options are cumulative.
+      for found_dir in $rpathdirs; do
+        acl_save_libdir="$libdir"
+        libdir="$found_dir"
+        eval flag=\"$acl_hardcode_libdir_flag_spec\"
+        libdir="$acl_save_libdir"
+        LIB[]NAME="${LIB[]NAME}${LIB[]NAME:+ }$flag"
+      done
+    fi
+  fi
+  if test "X$ltrpathdirs" != "X"; then
+    dnl When using libtool, the option that works for both libraries and
+    dnl executables is -R. The -R options are cumulative.
+    for found_dir in $ltrpathdirs; do
+      LTLIB[]NAME="${LTLIB[]NAME}${LTLIB[]NAME:+ }-R$found_dir"
+    done
+  fi
+])
+
+dnl AC_LIB_APPENDTOVAR(VAR, CONTENTS) appends the elements of CONTENTS to VAR,
+dnl unless already present in VAR.
+dnl Works only for CPPFLAGS, not for LIB* variables because that sometimes
+dnl contains two or three consecutive elements that belong together.
+AC_DEFUN([AC_LIB_APPENDTOVAR],
+[
+  for element in [$2]; do
+    haveit=
+    for x in $[$1]; do
+      AC_LIB_WITH_FINAL_PREFIX([eval x=\"$x\"])
+      if test "X$x" = "X$element"; then
+        haveit=yes
+        break
+      fi
+    done
+    if test -z "$haveit"; then
+      [$1]="${[$1]}${[$1]:+ }$element"
+    fi
+  done
+])
+
+dnl For those cases where a variable contains several -L and -l options
+dnl referring to unknown libraries and directories, this macro determines the
+dnl necessary additional linker options for the runtime path.
+dnl AC_LIB_LINKFLAGS_FROM_LIBS([LDADDVAR], [LIBSVALUE], [USE-LIBTOOL])
+dnl sets LDADDVAR to linker options needed together with LIBSVALUE.
+dnl If USE-LIBTOOL evaluates to non-empty, linking with libtool is assumed,
+dnl otherwise linking without libtool is assumed.
+AC_DEFUN([AC_LIB_LINKFLAGS_FROM_LIBS],
+[
+  AC_REQUIRE([AC_LIB_RPATH])
+  AC_REQUIRE([AC_LIB_PREPARE_MULTILIB])
+  $1=
+  if test "$enable_rpath" != no; then
+    if test -n "$acl_hardcode_libdir_flag_spec" && test "$acl_hardcode_minus_L" = no; then
+      dnl Use an explicit option to hardcode directories into the resulting
+      dnl binary.
+      rpathdirs=
+      next=
+      for opt in $2; do
+        if test -n "$next"; then
+          dir="$next"
+          dnl No need to hardcode the standard /usr/lib.
+          if test "X$dir" != "X/usr/$acl_libdirstem"; then
+            rpathdirs="$rpathdirs $dir"
+          fi
+          next=
+        else
+          case $opt in
+            -L) next=yes ;;
+            -L*) dir=`echo "X$opt" | sed -e 's,^X-L,,'`
+                 dnl No need to hardcode the standard /usr/lib.
+                 if test "X$dir" != "X/usr/$acl_libdirstem"; then
+                   rpathdirs="$rpathdirs $dir"
+                 fi
+                 next= ;;
+            *) next= ;;
+          esac
+        fi
+      done
+      if test "X$rpathdirs" != "X"; then
+        if test -n ""$3""; then
+          dnl libtool is used for linking. Use -R options.
+          for dir in $rpathdirs; do
+            $1="${$1}${$1:+ }-R$dir"
+          done
+        else
+          dnl The linker is used for linking directly.
+          if test -n "$acl_hardcode_libdir_separator"; then
+            dnl Weird platform: only the last -rpath option counts, the user
+            dnl must pass all path elements in one option.
+            alldirs=
+            for dir in $rpathdirs; do
+              alldirs="${alldirs}${alldirs:+$acl_hardcode_libdir_separator}$dir"
+            done
+            acl_save_libdir="$libdir"
+            libdir="$alldirs"
+            eval flag=\"$acl_hardcode_libdir_flag_spec\"
+            libdir="$acl_save_libdir"
+            $1="$flag"
+          else
+            dnl The -rpath options are cumulative.
+            for dir in $rpathdirs; do
+              acl_save_libdir="$libdir"
+              libdir="$dir"
+              eval flag=\"$acl_hardcode_libdir_flag_spec\"
+              libdir="$acl_save_libdir"
+              $1="${$1}${$1:+ }$flag"
+            done
+          fi
+        fi
+      fi
+    fi
+  fi
+  AC_SUBST([$1])
+])
--- /dev/null
+++ b/m4/lib-prefix.m4
@@ -0,0 +1,185 @@
+# lib-prefix.m4 serial 5 (gettext-0.15)
+dnl Copyright (C) 2001-2005 Free Software Foundation, Inc.
+dnl This file is free software; the Free Software Foundation
+dnl gives unlimited permission to copy and/or distribute it,
+dnl with or without modifications, as long as this notice is preserved.
+
+dnl From Bruno Haible.
+
+dnl AC_LIB_ARG_WITH is synonymous to AC_ARG_WITH in autoconf-2.13, and
+dnl similar to AC_ARG_WITH in autoconf 2.52...2.57 except that is doesn't
+dnl require excessive bracketing.
+ifdef([AC_HELP_STRING],
+[AC_DEFUN([AC_LIB_ARG_WITH], [AC_ARG_WITH([$1],[[$2]],[$3],[$4])])],
+[AC_DEFUN([AC_][LIB_ARG_WITH], [AC_ARG_WITH([$1],[$2],[$3],[$4])])])
+
+dnl AC_LIB_PREFIX adds to the CPPFLAGS and LDFLAGS the flags that are needed
+dnl to access previously installed libraries. The basic assumption is that
+dnl a user will want packages to use other packages he previously installed
+dnl with the same --prefix option.
+dnl This macro is not needed if only AC_LIB_LINKFLAGS is used to locate
+dnl libraries, but is otherwise very convenient.
+AC_DEFUN([AC_LIB_PREFIX],
+[
+  AC_BEFORE([$0], [AC_LIB_LINKFLAGS])
+  AC_REQUIRE([AC_PROG_CC])
+  AC_REQUIRE([AC_CANONICAL_HOST])
+  AC_REQUIRE([AC_LIB_PREPARE_MULTILIB])
+  AC_REQUIRE([AC_LIB_PREPARE_PREFIX])
+  dnl By default, look in $includedir and $libdir.
+  use_additional=yes
+  AC_LIB_WITH_FINAL_PREFIX([
+    eval additional_includedir=\"$includedir\"
+    eval additional_libdir=\"$libdir\"
+  ])
+  AC_LIB_ARG_WITH([lib-prefix],
+[  --with-lib-prefix[=DIR] search for libraries in DIR/include and DIR/lib
+  --without-lib-prefix    don't search for libraries in includedir and libdir],
+[
+    if test "X$withval" = "Xno"; then
+      use_additional=no
+    else
+      if test "X$withval" = "X"; then
+        AC_LIB_WITH_FINAL_PREFIX([
+          eval additional_includedir=\"$includedir\"
+          eval additional_libdir=\"$libdir\"
+        ])
+      else
+        additional_includedir="$withval/include"
+        additional_libdir="$withval/$acl_libdirstem"
+      fi
+    fi
+])
+  if test $use_additional = yes; then
+    dnl Potentially add $additional_includedir to $CPPFLAGS.
+    dnl But don't add it
+    dnl   1. if it's the standard /usr/include,
+    dnl   2. if it's already present in $CPPFLAGS,
+    dnl   3. if it's /usr/local/include and we are using GCC on Linux,
+    dnl   4. if it doesn't exist as a directory.
+    if test "X$additional_includedir" != "X/usr/include"; then
+      haveit=
+      for x in $CPPFLAGS; do
+        AC_LIB_WITH_FINAL_PREFIX([eval x=\"$x\"])
+        if test "X$x" = "X-I$additional_includedir"; then
+          haveit=yes
+          break
+        fi
+      done
+      if test -z "$haveit"; then
+        if test "X$additional_includedir" = "X/usr/local/include"; then
+          if test -n "$GCC"; then
+            case $host_os in
+              linux* | gnu* | k*bsd*-gnu) haveit=yes;;
+            esac
+          fi
+        fi
+        if test -z "$haveit"; then
+          if test -d "$additional_includedir"; then
+            dnl Really add $additional_includedir to $CPPFLAGS.
+            CPPFLAGS="${CPPFLAGS}${CPPFLAGS:+ }-I$additional_includedir"
+          fi
+        fi
+      fi
+    fi
+    dnl Potentially add $additional_libdir to $LDFLAGS.
+    dnl But don't add it
+    dnl   1. if it's the standard /usr/lib,
+    dnl   2. if it's already present in $LDFLAGS,
+    dnl   3. if it's /usr/local/lib and we are using GCC on Linux,
+    dnl   4. if it doesn't exist as a directory.
+    if test "X$additional_libdir" != "X/usr/$acl_libdirstem"; then
+      haveit=
+      for x in $LDFLAGS; do
+        AC_LIB_WITH_FINAL_PREFIX([eval x=\"$x\"])
+        if test "X$x" = "X-L$additional_libdir"; then
+          haveit=yes
+          break
+        fi
+      done
+      if test -z "$haveit"; then
+        if test "X$additional_libdir" = "X/usr/local/$acl_libdirstem"; then
+          if test -n "$GCC"; then
+            case $host_os in
+              linux*) haveit=yes;;
+            esac
+          fi
+        fi
+        if test -z "$haveit"; then
+          if test -d "$additional_libdir"; then
+            dnl Really add $additional_libdir to $LDFLAGS.
+            LDFLAGS="${LDFLAGS}${LDFLAGS:+ }-L$additional_libdir"
+          fi
+        fi
+      fi
+    fi
+  fi
+])
+
+dnl AC_LIB_PREPARE_PREFIX creates variables acl_final_prefix,
+dnl acl_final_exec_prefix, containing the values to which $prefix and
+dnl $exec_prefix will expand at the end of the configure script.
+AC_DEFUN([AC_LIB_PREPARE_PREFIX],
+[
+  dnl Unfortunately, prefix and exec_prefix get only finally determined
+  dnl at the end of configure.
+  if test "X$prefix" = "XNONE"; then
+    acl_final_prefix="$ac_default_prefix"
+  else
+    acl_final_prefix="$prefix"
+  fi
+  if test "X$exec_prefix" = "XNONE"; then
+    acl_final_exec_prefix='${prefix}'
+  else
+    acl_final_exec_prefix="$exec_prefix"
+  fi
+  acl_save_prefix="$prefix"
+  prefix="$acl_final_prefix"
+  eval acl_final_exec_prefix=\"$acl_final_exec_prefix\"
+  prefix="$acl_save_prefix"
+])
+
+dnl AC_LIB_WITH_FINAL_PREFIX([statement]) evaluates statement, with the
+dnl variables prefix and exec_prefix bound to the values they will have
+dnl at the end of the configure script.
+AC_DEFUN([AC_LIB_WITH_FINAL_PREFIX],
+[
+  acl_save_prefix="$prefix"
+  prefix="$acl_final_prefix"
+  acl_save_exec_prefix="$exec_prefix"
+  exec_prefix="$acl_final_exec_prefix"
+  $1
+  exec_prefix="$acl_save_exec_prefix"
+  prefix="$acl_save_prefix"
+])
+
+dnl AC_LIB_PREPARE_MULTILIB creates a variable acl_libdirstem, containing
+dnl the basename of the libdir, either "lib" or "lib64".
+AC_DEFUN([AC_LIB_PREPARE_MULTILIB],
+[
+  dnl There is no formal standard regarding lib and lib64. The current
+  dnl practice is that on a system supporting 32-bit and 64-bit instruction
+  dnl sets or ABIs, 64-bit libraries go under $prefix/lib64 and 32-bit
+  dnl libraries go under $prefix/lib. We determine the compiler's default
+  dnl mode by looking at the compiler's library search path. If at least
+  dnl of its elements ends in /lib64 or points to a directory whose absolute
+  dnl pathname ends in /lib64, we assume a 64-bit ABI. Otherwise we use the
+  dnl default, namely "lib".
+  acl_libdirstem=lib
+  searchpath=`(LC_ALL=C $CC -print-search-dirs) 2>/dev/null | sed -n -e 's,^libraries: ,,p' | sed -e 's,^=,,'`
+  if test -n "$searchpath"; then
+    acl_save_IFS="${IFS= 	}"; IFS=":"
+    for searchdir in $searchpath; do
+      if test -d "$searchdir"; then
+        case "$searchdir" in
+          */lib64/ | */lib64 ) acl_libdirstem=lib64 ;;
+          *) searchdir=`cd "$searchdir" && pwd`
+             case "$searchdir" in
+               */lib64 ) acl_libdirstem=lib64 ;;
+             esac ;;
+        esac
+      fi
+    done
+    IFS="$acl_save_IFS"
+  fi
+])
--- /dev/null
+++ b/m4/nls.m4
@@ -0,0 +1,31 @@
+# nls.m4 serial 3 (gettext-0.15)
+dnl Copyright (C) 1995-2003, 2005-2006 Free Software Foundation, Inc.
+dnl This file is free software; the Free Software Foundation
+dnl gives unlimited permission to copy and/or distribute it,
+dnl with or without modifications, as long as this notice is preserved.
+dnl
+dnl This file can can be used in projects which are not available under
+dnl the GNU General Public License or the GNU Library General Public
+dnl License but which still want to provide support for the GNU gettext
+dnl functionality.
+dnl Please note that the actual code of the GNU gettext library is covered
+dnl by the GNU Library General Public License, and the rest of the GNU
+dnl gettext package package is covered by the GNU General Public License.
+dnl They are *not* in the public domain.
+
+dnl Authors:
+dnl   Ulrich Drepper <drepper@cygnus.com>, 1995-2000.
+dnl   Bruno Haible <haible@clisp.cons.org>, 2000-2003.
+
+AC_PREREQ(2.50)
+
+AC_DEFUN([AM_NLS],
+[
+  AC_MSG_CHECKING([whether NLS is requested])
+  dnl Default is enabled NLS
+  AC_ARG_ENABLE(nls,
+    [  --disable-nls           do not use Native Language Support],
+    USE_NLS=$enableval, USE_NLS=yes)
+  AC_MSG_RESULT($USE_NLS)
+  AC_SUBST(USE_NLS)
+])
--- /dev/null
+++ b/m4/po.m4
@@ -0,0 +1,449 @@
+# po.m4 serial 15 (gettext-0.17)
+dnl Copyright (C) 1995-2007 Free Software Foundation, Inc.
+dnl This file is free software; the Free Software Foundation
+dnl gives unlimited permission to copy and/or distribute it,
+dnl with or without modifications, as long as this notice is preserved.
+dnl
+dnl This file can can be used in projects which are not available under
+dnl the GNU General Public License or the GNU Library General Public
+dnl License but which still want to provide support for the GNU gettext
+dnl functionality.
+dnl Please note that the actual code of the GNU gettext library is covered
+dnl by the GNU Library General Public License, and the rest of the GNU
+dnl gettext package package is covered by the GNU General Public License.
+dnl They are *not* in the public domain.
+
+dnl Authors:
+dnl   Ulrich Drepper <drepper@cygnus.com>, 1995-2000.
+dnl   Bruno Haible <haible@clisp.cons.org>, 2000-2003.
+
+AC_PREREQ(2.50)
+
+dnl Checks for all prerequisites of the po subdirectory.
+AC_DEFUN([AM_PO_SUBDIRS],
+[
+  AC_REQUIRE([AC_PROG_MAKE_SET])dnl
+  AC_REQUIRE([AC_PROG_INSTALL])dnl
+  AC_REQUIRE([AM_PROG_MKDIR_P])dnl defined by automake
+  AC_REQUIRE([AM_NLS])dnl
+
+  dnl Release version of the gettext macros. This is used to ensure that
+  dnl the gettext macros and po/Makefile.in.in are in sync.
+  AC_SUBST([GETTEXT_MACRO_VERSION], [0.17])
+
+  dnl Perform the following tests also if --disable-nls has been given,
+  dnl because they are needed for "make dist" to work.
+
+  dnl Search for GNU msgfmt in the PATH.
+  dnl The first test excludes Solaris msgfmt and early GNU msgfmt versions.
+  dnl The second test excludes FreeBSD msgfmt.
+  AM_PATH_PROG_WITH_TEST(MSGFMT, msgfmt,
+    [$ac_dir/$ac_word --statistics /dev/null >&]AS_MESSAGE_LOG_FD[ 2>&1 &&
+     (if $ac_dir/$ac_word --statistics /dev/null 2>&1 >/dev/null | grep usage >/dev/null; then exit 1; else exit 0; fi)],
+    :)
+  AC_PATH_PROG(GMSGFMT, gmsgfmt, $MSGFMT)
+
+  dnl Test whether it is GNU msgfmt >= 0.15.
+changequote(,)dnl
+  case `$MSGFMT --version | sed 1q | sed -e 's,^[^0-9]*,,'` in
+    '' | 0.[0-9] | 0.[0-9].* | 0.1[0-4] | 0.1[0-4].*) MSGFMT_015=: ;;
+    *) MSGFMT_015=$MSGFMT ;;
+  esac
+changequote([,])dnl
+  AC_SUBST([MSGFMT_015])
+changequote(,)dnl
+  case `$GMSGFMT --version | sed 1q | sed -e 's,^[^0-9]*,,'` in
+    '' | 0.[0-9] | 0.[0-9].* | 0.1[0-4] | 0.1[0-4].*) GMSGFMT_015=: ;;
+    *) GMSGFMT_015=$GMSGFMT ;;
+  esac
+changequote([,])dnl
+  AC_SUBST([GMSGFMT_015])
+
+  dnl Search for GNU xgettext 0.12 or newer in the PATH.
+  dnl The first test excludes Solaris xgettext and early GNU xgettext versions.
+  dnl The second test excludes FreeBSD xgettext.
+  AM_PATH_PROG_WITH_TEST(XGETTEXT, xgettext,
+    [$ac_dir/$ac_word --omit-header --copyright-holder= --msgid-bugs-address= /dev/null >&]AS_MESSAGE_LOG_FD[ 2>&1 &&
+     (if $ac_dir/$ac_word --omit-header --copyright-holder= --msgid-bugs-address= /dev/null 2>&1 >/dev/null | grep usage >/dev/null; then exit 1; else exit 0; fi)],
+    :)
+  dnl Remove leftover from FreeBSD xgettext call.
+  rm -f messages.po
+
+  dnl Test whether it is GNU xgettext >= 0.15.
+changequote(,)dnl
+  case `$XGETTEXT --version | sed 1q | sed -e 's,^[^0-9]*,,'` in
+    '' | 0.[0-9] | 0.[0-9].* | 0.1[0-4] | 0.1[0-4].*) XGETTEXT_015=: ;;
+    *) XGETTEXT_015=$XGETTEXT ;;
+  esac
+changequote([,])dnl
+  AC_SUBST([XGETTEXT_015])
+
+  dnl Search for GNU msgmerge 0.11 or newer in the PATH.
+  AM_PATH_PROG_WITH_TEST(MSGMERGE, msgmerge,
+    [$ac_dir/$ac_word --update -q /dev/null /dev/null >&]AS_MESSAGE_LOG_FD[ 2>&1], :)
+
+  dnl Installation directories.
+  dnl Autoconf >= 2.60 defines localedir. For older versions of autoconf, we
+  dnl have to define it here, so that it can be used in po/Makefile.
+  test -n "$localedir" || localedir='${datadir}/locale'
+  AC_SUBST([localedir])
+
+  dnl Support for AM_XGETTEXT_OPTION.
+  test -n "${XGETTEXT_EXTRA_OPTIONS+set}" || XGETTEXT_EXTRA_OPTIONS=
+  AC_SUBST([XGETTEXT_EXTRA_OPTIONS])
+
+  AC_CONFIG_COMMANDS([po-directories], [[
+    for ac_file in $CONFIG_FILES; do
+      # Support "outfile[:infile[:infile...]]"
+      case "$ac_file" in
+        *:*) ac_file=`echo "$ac_file"|sed 's%:.*%%'` ;;
+      esac
+      # PO directories have a Makefile.in generated from Makefile.in.in.
+      case "$ac_file" in */Makefile.in)
+        # Adjust a relative srcdir.
+        ac_dir=`echo "$ac_file"|sed 's%/[^/][^/]*$%%'`
+        ac_dir_suffix="/`echo "$ac_dir"|sed 's%^\./%%'`"
+        ac_dots=`echo "$ac_dir_suffix"|sed 's%/[^/]*%../%g'`
+        # In autoconf-2.13 it is called $ac_given_srcdir.
+        # In autoconf-2.50 it is called $srcdir.
+        test -n "$ac_given_srcdir" || ac_given_srcdir="$srcdir"
+        case "$ac_given_srcdir" in
+          .)  top_srcdir=`echo $ac_dots|sed 's%/$%%'` ;;
+          /*) top_srcdir="$ac_given_srcdir" ;;
+          *)  top_srcdir="$ac_dots$ac_given_srcdir" ;;
+        esac
+        # Treat a directory as a PO directory if and only if it has a
+        # POTFILES.in file. This allows packages to have multiple PO
+        # directories under different names or in different locations.
+        if test -f "$ac_given_srcdir/$ac_dir/POTFILES.in"; then
+          rm -f "$ac_dir/POTFILES"
+          test -n "$as_me" && echo "$as_me: creating $ac_dir/POTFILES" || echo "creating $ac_dir/POTFILES"
+          cat "$ac_given_srcdir/$ac_dir/POTFILES.in" | sed -e "/^#/d" -e "/^[ 	]*\$/d" -e "s,.*,     $top_srcdir/& \\\\," | sed -e "\$s/\(.*\) \\\\/\1/" > "$ac_dir/POTFILES"
+          POMAKEFILEDEPS="POTFILES.in"
+          # ALL_LINGUAS, POFILES, UPDATEPOFILES, DUMMYPOFILES, GMOFILES depend
+          # on $ac_dir but don't depend on user-specified configuration
+          # parameters.
+          if test -f "$ac_given_srcdir/$ac_dir/LINGUAS"; then
+            # The LINGUAS file contains the set of available languages.
+            if test -n "$OBSOLETE_ALL_LINGUAS"; then
+              test -n "$as_me" && echo "$as_me: setting ALL_LINGUAS in configure.in is obsolete" || echo "setting ALL_LINGUAS in configure.in is obsolete"
+            fi
+            ALL_LINGUAS_=`sed -e "/^#/d" -e "s/#.*//" "$ac_given_srcdir/$ac_dir/LINGUAS"`
+            # Hide the ALL_LINGUAS assigment from automake < 1.5.
+            eval 'ALL_LINGUAS''=$ALL_LINGUAS_'
+            POMAKEFILEDEPS="$POMAKEFILEDEPS LINGUAS"
+          else
+            # The set of available languages was given in configure.in.
+            # Hide the ALL_LINGUAS assigment from automake < 1.5.
+            eval 'ALL_LINGUAS''=$OBSOLETE_ALL_LINGUAS'
+          fi
+          # Compute POFILES
+          # as      $(foreach lang, $(ALL_LINGUAS), $(srcdir)/$(lang).po)
+          # Compute UPDATEPOFILES
+          # as      $(foreach lang, $(ALL_LINGUAS), $(lang).po-update)
+          # Compute DUMMYPOFILES
+          # as      $(foreach lang, $(ALL_LINGUAS), $(lang).nop)
+          # Compute GMOFILES
+          # as      $(foreach lang, $(ALL_LINGUAS), $(srcdir)/$(lang).gmo)
+          case "$ac_given_srcdir" in
+            .) srcdirpre= ;;
+            *) srcdirpre='$(srcdir)/' ;;
+          esac
+          POFILES=
+          UPDATEPOFILES=
+          DUMMYPOFILES=
+          GMOFILES=
+          for lang in $ALL_LINGUAS; do
+            POFILES="$POFILES $srcdirpre$lang.po"
+            UPDATEPOFILES="$UPDATEPOFILES $lang.po-update"
+            DUMMYPOFILES="$DUMMYPOFILES $lang.nop"
+            GMOFILES="$GMOFILES $srcdirpre$lang.gmo"
+          done
+          # CATALOGS depends on both $ac_dir and the user's LINGUAS
+          # environment variable.
+          INST_LINGUAS=
+          if test -n "$ALL_LINGUAS"; then
+            for presentlang in $ALL_LINGUAS; do
+              useit=no
+              if test "%UNSET%" != "$LINGUAS"; then
+                desiredlanguages="$LINGUAS"
+              else
+                desiredlanguages="$ALL_LINGUAS"
+              fi
+              for desiredlang in $desiredlanguages; do
+                # Use the presentlang catalog if desiredlang is
+                #   a. equal to presentlang, or
+                #   b. a variant of presentlang (because in this case,
+                #      presentlang can be used as a fallback for messages
+                #      which are not translated in the desiredlang catalog).
+                case "$desiredlang" in
+                  "$presentlang"*) useit=yes;;
+                esac
+              done
+              if test $useit = yes; then
+                INST_LINGUAS="$INST_LINGUAS $presentlang"
+              fi
+            done
+          fi
+          CATALOGS=
+          if test -n "$INST_LINGUAS"; then
+            for lang in $INST_LINGUAS; do
+              CATALOGS="$CATALOGS $lang.gmo"
+            done
+          fi
+          test -n "$as_me" && echo "$as_me: creating $ac_dir/Makefile" || echo "creating $ac_dir/Makefile"
+          sed -e "/^POTFILES =/r $ac_dir/POTFILES" -e "/^# Makevars/r $ac_given_srcdir/$ac_dir/Makevars" -e "s|@POFILES@|$POFILES|g" -e "s|@UPDATEPOFILES@|$UPDATEPOFILES|g" -e "s|@DUMMYPOFILES@|$DUMMYPOFILES|g" -e "s|@GMOFILES@|$GMOFILES|g" -e "s|@CATALOGS@|$CATALOGS|g" -e "s|@POMAKEFILEDEPS@|$POMAKEFILEDEPS|g" "$ac_dir/Makefile.in" > "$ac_dir/Makefile"
+          for f in "$ac_given_srcdir/$ac_dir"/Rules-*; do
+            if test -f "$f"; then
+              case "$f" in
+                *.orig | *.bak | *~) ;;
+                *) cat "$f" >> "$ac_dir/Makefile" ;;
+              esac
+            fi
+          done
+        fi
+        ;;
+      esac
+    done]],
+   [# Capture the value of obsolete ALL_LINGUAS because we need it to compute
+    # POFILES, UPDATEPOFILES, DUMMYPOFILES, GMOFILES, CATALOGS. But hide it
+    # from automake < 1.5.
+    eval 'OBSOLETE_ALL_LINGUAS''="$ALL_LINGUAS"'
+    # Capture the value of LINGUAS because we need it to compute CATALOGS.
+    LINGUAS="${LINGUAS-%UNSET%}"
+   ])
+])
+
+dnl Postprocesses a Makefile in a directory containing PO files.
+AC_DEFUN([AM_POSTPROCESS_PO_MAKEFILE],
+[
+  # When this code is run, in config.status, two variables have already been
+  # set:
+  # - OBSOLETE_ALL_LINGUAS is the value of LINGUAS set in configure.in,
+  # - LINGUAS is the value of the environment variable LINGUAS at configure
+  #   time.
+
+changequote(,)dnl
+  # Adjust a relative srcdir.
+  ac_dir=`echo "$ac_file"|sed 's%/[^/][^/]*$%%'`
+  ac_dir_suffix="/`echo "$ac_dir"|sed 's%^\./%%'`"
+  ac_dots=`echo "$ac_dir_suffix"|sed 's%/[^/]*%../%g'`
+  # In autoconf-2.13 it is called $ac_given_srcdir.
+  # In autoconf-2.50 it is called $srcdir.
+  test -n "$ac_given_srcdir" || ac_given_srcdir="$srcdir"
+  case "$ac_given_srcdir" in
+    .)  top_srcdir=`echo $ac_dots|sed 's%/$%%'` ;;
+    /*) top_srcdir="$ac_given_srcdir" ;;
+    *)  top_srcdir="$ac_dots$ac_given_srcdir" ;;
+  esac
+
+  # Find a way to echo strings without interpreting backslash.
+  if test "X`(echo '\t') 2>/dev/null`" = 'X\t'; then
+    gt_echo='echo'
+  else
+    if test "X`(printf '%s\n' '\t') 2>/dev/null`" = 'X\t'; then
+      gt_echo='printf %s\n'
+    else
+      echo_func () {
+        cat <<EOT
+$*
+EOT
+      }
+      gt_echo='echo_func'
+    fi
+  fi
+
+  # A sed script that extracts the value of VARIABLE from a Makefile.
+  sed_x_variable='
+# Test if the hold space is empty.
+x
+s/P/P/
+x
+ta
+# Yes it was empty. Look if we have the expected variable definition.
+/^[	 ]*VARIABLE[	 ]*=/{
+  # Seen the first line of the variable definition.
+  s/^[	 ]*VARIABLE[	 ]*=//
+  ba
+}
+bd
+:a
+# Here we are processing a line from the variable definition.
+# Remove comment, more precisely replace it with a space.
+s/#.*$/ /
+# See if the line ends in a backslash.
+tb
+:b
+s/\\$//
+# Print the line, without the trailing backslash.
+p
+tc
+# There was no trailing backslash. The end of the variable definition is
+# reached. Clear the hold space.
+s/^.*$//
+x
+bd
+:c
+# A trailing backslash means that the variable definition continues in the
+# next line. Put a nonempty string into the hold space to indicate this.
+s/^.*$/P/
+x
+:d
+'
+changequote([,])dnl
+
+  # Set POTFILES to the value of the Makefile variable POTFILES.
+  sed_x_POTFILES=`$gt_echo "$sed_x_variable" | sed -e '/^ *#/d' -e 's/VARIABLE/POTFILES/g'`
+  POTFILES=`sed -n -e "$sed_x_POTFILES" < "$ac_file"`
+  # Compute POTFILES_DEPS as
+  #   $(foreach file, $(POTFILES), $(top_srcdir)/$(file))
+  POTFILES_DEPS=
+  for file in $POTFILES; do
+    POTFILES_DEPS="$POTFILES_DEPS "'$(top_srcdir)/'"$file"
+  done
+  POMAKEFILEDEPS=""
+
+  if test -n "$OBSOLETE_ALL_LINGUAS"; then
+    test -n "$as_me" && echo "$as_me: setting ALL_LINGUAS in configure.in is obsolete" || echo "setting ALL_LINGUAS in configure.in is obsolete"
+  fi
+  if test -f "$ac_given_srcdir/$ac_dir/LINGUAS"; then
+    # The LINGUAS file contains the set of available languages.
+    ALL_LINGUAS_=`sed -e "/^#/d" -e "s/#.*//" "$ac_given_srcdir/$ac_dir/LINGUAS"`
+    POMAKEFILEDEPS="$POMAKEFILEDEPS LINGUAS"
+  else
+    # Set ALL_LINGUAS to the value of the Makefile variable LINGUAS.
+    sed_x_LINGUAS=`$gt_echo "$sed_x_variable" | sed -e '/^ *#/d' -e 's/VARIABLE/LINGUAS/g'`
+    ALL_LINGUAS_=`sed -n -e "$sed_x_LINGUAS" < "$ac_file"`
+  fi
+  # Hide the ALL_LINGUAS assigment from automake < 1.5.
+  eval 'ALL_LINGUAS''=$ALL_LINGUAS_'
+  # Compute POFILES
+  # as      $(foreach lang, $(ALL_LINGUAS), $(srcdir)/$(lang).po)
+  # Compute UPDATEPOFILES
+  # as      $(foreach lang, $(ALL_LINGUAS), $(lang).po-update)
+  # Compute DUMMYPOFILES
+  # as      $(foreach lang, $(ALL_LINGUAS), $(lang).nop)
+  # Compute GMOFILES
+  # as      $(foreach lang, $(ALL_LINGUAS), $(srcdir)/$(lang).gmo)
+  # Compute PROPERTIESFILES
+  # as      $(foreach lang, $(ALL_LINGUAS), $(top_srcdir)/$(DOMAIN)_$(lang).properties)
+  # Compute CLASSFILES
+  # as      $(foreach lang, $(ALL_LINGUAS), $(top_srcdir)/$(DOMAIN)_$(lang).class)
+  # Compute QMFILES
+  # as      $(foreach lang, $(ALL_LINGUAS), $(srcdir)/$(lang).qm)
+  # Compute MSGFILES
+  # as      $(foreach lang, $(ALL_LINGUAS), $(srcdir)/$(frob $(lang)).msg)
+  # Compute RESOURCESDLLFILES
+  # as      $(foreach lang, $(ALL_LINGUAS), $(srcdir)/$(frob $(lang))/$(DOMAIN).resources.dll)
+  case "$ac_given_srcdir" in
+    .) srcdirpre= ;;
+    *) srcdirpre='$(srcdir)/' ;;
+  esac
+  POFILES=
+  UPDATEPOFILES=
+  DUMMYPOFILES=
+  GMOFILES=
+  PROPERTIESFILES=
+  CLASSFILES=
+  QMFILES=
+  MSGFILES=
+  RESOURCESDLLFILES=
+  for lang in $ALL_LINGUAS; do
+    POFILES="$POFILES $srcdirpre$lang.po"
+    UPDATEPOFILES="$UPDATEPOFILES $lang.po-update"
+    DUMMYPOFILES="$DUMMYPOFILES $lang.nop"
+    GMOFILES="$GMOFILES $srcdirpre$lang.gmo"
+    PROPERTIESFILES="$PROPERTIESFILES \$(top_srcdir)/\$(DOMAIN)_$lang.properties"
+    CLASSFILES="$CLASSFILES \$(top_srcdir)/\$(DOMAIN)_$lang.class"
+    QMFILES="$QMFILES $srcdirpre$lang.qm"
+    frobbedlang=`echo $lang | sed -e 's/\..*$//' -e 'y/ABCDEFGHIJKLMNOPQRSTUVWXYZ/abcdefghijklmnopqrstuvwxyz/'`
+    MSGFILES="$MSGFILES $srcdirpre$frobbedlang.msg"
+    frobbedlang=`echo $lang | sed -e 's/_/-/g' -e 's/^sr-CS/sr-SP/' -e 's/@latin$/-Latn/' -e 's/@cyrillic$/-Cyrl/' -e 's/^sr-SP$/sr-SP-Latn/' -e 's/^uz-UZ$/uz-UZ-Latn/'`
+    RESOURCESDLLFILES="$RESOURCESDLLFILES $srcdirpre$frobbedlang/\$(DOMAIN).resources.dll"
+  done
+  # CATALOGS depends on both $ac_dir and the user's LINGUAS
+  # environment variable.
+  INST_LINGUAS=
+  if test -n "$ALL_LINGUAS"; then
+    for presentlang in $ALL_LINGUAS; do
+      useit=no
+      if test "%UNSET%" != "$LINGUAS"; then
+        desiredlanguages="$LINGUAS"
+      else
+        desiredlanguages="$ALL_LINGUAS"
+      fi
+      for desiredlang in $desiredlanguages; do
+        # Use the presentlang catalog if desiredlang is
+        #   a. equal to presentlang, or
+        #   b. a variant of presentlang (because in this case,
+        #      presentlang can be used as a fallback for messages
+        #      which are not translated in the desiredlang catalog).
+        case "$desiredlang" in
+          "$presentlang"*) useit=yes;;
+        esac
+      done
+      if test $useit = yes; then
+        INST_LINGUAS="$INST_LINGUAS $presentlang"
+      fi
+    done
+  fi
+  CATALOGS=
+  JAVACATALOGS=
+  QTCATALOGS=
+  TCLCATALOGS=
+  CSHARPCATALOGS=
+  if test -n "$INST_LINGUAS"; then
+    for lang in $INST_LINGUAS; do
+      CATALOGS="$CATALOGS $lang.gmo"
+      JAVACATALOGS="$JAVACATALOGS \$(DOMAIN)_$lang.properties"
+      QTCATALOGS="$QTCATALOGS $lang.qm"
+      frobbedlang=`echo $lang | sed -e 's/\..*$//' -e 'y/ABCDEFGHIJKLMNOPQRSTUVWXYZ/abcdefghijklmnopqrstuvwxyz/'`
+      TCLCATALOGS="$TCLCATALOGS $frobbedlang.msg"
+      frobbedlang=`echo $lang | sed -e 's/_/-/g' -e 's/^sr-CS/sr-SP/' -e 's/@latin$/-Latn/' -e 's/@cyrillic$/-Cyrl/' -e 's/^sr-SP$/sr-SP-Latn/' -e 's/^uz-UZ$/uz-UZ-Latn/'`
+      CSHARPCATALOGS="$CSHARPCATALOGS $frobbedlang/\$(DOMAIN).resources.dll"
+    done
+  fi
+
+  sed -e "s|@POTFILES_DEPS@|$POTFILES_DEPS|g" -e "s|@POFILES@|$POFILES|g" -e "s|@UPDATEPOFILES@|$UPDATEPOFILES|g" -e "s|@DUMMYPOFILES@|$DUMMYPOFILES|g" -e "s|@GMOFILES@|$GMOFILES|g" -e "s|@PROPERTIESFILES@|$PROPERTIESFILES|g" -e "s|@CLASSFILES@|$CLASSFILES|g" -e "s|@QMFILES@|$QMFILES|g" -e "s|@MSGFILES@|$MSGFILES|g" -e "s|@RESOURCESDLLFILES@|$RESOURCESDLLFILES|g" -e "s|@CATALOGS@|$CATALOGS|g" -e "s|@JAVACATALOGS@|$JAVACATALOGS|g" -e "s|@QTCATALOGS@|$QTCATALOGS|g" -e "s|@TCLCATALOGS@|$TCLCATALOGS|g" -e "s|@CSHARPCATALOGS@|$CSHARPCATALOGS|g" -e 's,^#distdir:,distdir:,' < "$ac_file" > "$ac_file.tmp"
+  if grep -l '@TCLCATALOGS@' "$ac_file" > /dev/null; then
+    # Add dependencies that cannot be formulated as a simple suffix rule.
+    for lang in $ALL_LINGUAS; do
+      frobbedlang=`echo $lang | sed -e 's/\..*$//' -e 'y/ABCDEFGHIJKLMNOPQRSTUVWXYZ/abcdefghijklmnopqrstuvwxyz/'`
+      cat >> "$ac_file.tmp" <<EOF
+$frobbedlang.msg: $lang.po
+	@echo "\$(MSGFMT) -c --tcl -d \$(srcdir) -l $lang $srcdirpre$lang.po"; \
+	\$(MSGFMT) -c --tcl -d "\$(srcdir)" -l $lang $srcdirpre$lang.po || { rm -f "\$(srcdir)/$frobbedlang.msg"; exit 1; }
+EOF
+    done
+  fi
+  if grep -l '@CSHARPCATALOGS@' "$ac_file" > /dev/null; then
+    # Add dependencies that cannot be formulated as a simple suffix rule.
+    for lang in $ALL_LINGUAS; do
+      frobbedlang=`echo $lang | sed -e 's/_/-/g' -e 's/^sr-CS/sr-SP/' -e 's/@latin$/-Latn/' -e 's/@cyrillic$/-Cyrl/' -e 's/^sr-SP$/sr-SP-Latn/' -e 's/^uz-UZ$/uz-UZ-Latn/'`
+      cat >> "$ac_file.tmp" <<EOF
+$frobbedlang/\$(DOMAIN).resources.dll: $lang.po
+	@echo "\$(MSGFMT) -c --csharp -d \$(srcdir) -l $lang $srcdirpre$lang.po -r \$(DOMAIN)"; \
+	\$(MSGFMT) -c --csharp -d "\$(srcdir)" -l $lang $srcdirpre$lang.po -r "\$(DOMAIN)" || { rm -f "\$(srcdir)/$frobbedlang.msg"; exit 1; }
+EOF
+    done
+  fi
+  if test -n "$POMAKEFILEDEPS"; then
+    cat >> "$ac_file.tmp" <<EOF
+Makefile: $POMAKEFILEDEPS
+EOF
+  fi
+  mv "$ac_file.tmp" "$ac_file"
+])
+
+dnl Initializes the accumulator used by AM_XGETTEXT_OPTION.
+AC_DEFUN([AM_XGETTEXT_OPTION_INIT],
+[
+  XGETTEXT_EXTRA_OPTIONS=
+])
+
+dnl Registers an option to be passed to xgettext in the po subdirectory.
+AC_DEFUN([AM_XGETTEXT_OPTION],
+[
+  AC_REQUIRE([AM_XGETTEXT_OPTION_INIT])
+  XGETTEXT_EXTRA_OPTIONS="$XGETTEXT_EXTRA_OPTIONS $1"
+])
--- /dev/null
+++ b/m4/progtest.m4
@@ -0,0 +1,92 @@
+# progtest.m4 serial 4 (gettext-0.14.2)
+dnl Copyright (C) 1996-2003, 2005 Free Software Foundation, Inc.
+dnl This file is free software; the Free Software Foundation
+dnl gives unlimited permission to copy and/or distribute it,
+dnl with or without modifications, as long as this notice is preserved.
+dnl
+dnl This file can can be used in projects which are not available under
+dnl the GNU General Public License or the GNU Library General Public
+dnl License but which still want to provide support for the GNU gettext
+dnl functionality.
+dnl Please note that the actual code of the GNU gettext library is covered
+dnl by the GNU Library General Public License, and the rest of the GNU
+dnl gettext package package is covered by the GNU General Public License.
+dnl They are *not* in the public domain.
+
+dnl Authors:
+dnl   Ulrich Drepper <drepper@cygnus.com>, 1996.
+
+AC_PREREQ(2.50)
+
+# Search path for a program which passes the given test.
+
+dnl AM_PATH_PROG_WITH_TEST(VARIABLE, PROG-TO-CHECK-FOR,
+dnl   TEST-PERFORMED-ON-FOUND_PROGRAM [, VALUE-IF-NOT-FOUND [, PATH]])
+AC_DEFUN([AM_PATH_PROG_WITH_TEST],
+[
+# Prepare PATH_SEPARATOR.
+# The user is always right.
+if test "${PATH_SEPARATOR+set}" != set; then
+  echo "#! /bin/sh" >conf$$.sh
+  echo  "exit 0"   >>conf$$.sh
+  chmod +x conf$$.sh
+  if (PATH="/nonexistent;."; conf$$.sh) >/dev/null 2>&1; then
+    PATH_SEPARATOR=';'
+  else
+    PATH_SEPARATOR=:
+  fi
+  rm -f conf$$.sh
+fi
+
+# Find out how to test for executable files. Don't use a zero-byte file,
+# as systems may use methods other than mode bits to determine executability.
+cat >conf$$.file <<_ASEOF
+#! /bin/sh
+exit 0
+_ASEOF
+chmod +x conf$$.file
+if test -x conf$$.file >/dev/null 2>&1; then
+  ac_executable_p="test -x"
+else
+  ac_executable_p="test -f"
+fi
+rm -f conf$$.file
+
+# Extract the first word of "$2", so it can be a program name with args.
+set dummy $2; ac_word=[$]2
+AC_MSG_CHECKING([for $ac_word])
+AC_CACHE_VAL(ac_cv_path_$1,
+[case "[$]$1" in
+  [[\\/]]* | ?:[[\\/]]*)
+    ac_cv_path_$1="[$]$1" # Let the user override the test with a path.
+    ;;
+  *)
+    ac_save_IFS="$IFS"; IFS=$PATH_SEPARATOR
+    for ac_dir in ifelse([$5], , $PATH, [$5]); do
+      IFS="$ac_save_IFS"
+      test -z "$ac_dir" && ac_dir=.
+      for ac_exec_ext in '' $ac_executable_extensions; do
+        if $ac_executable_p "$ac_dir/$ac_word$ac_exec_ext"; then
+          echo "$as_me: trying $ac_dir/$ac_word..." >&AS_MESSAGE_LOG_FD
+          if [$3]; then
+            ac_cv_path_$1="$ac_dir/$ac_word$ac_exec_ext"
+            break 2
+          fi
+        fi
+      done
+    done
+    IFS="$ac_save_IFS"
+dnl If no 4th arg is given, leave the cache variable unset,
+dnl so AC_PATH_PROGS will keep looking.
+ifelse([$4], , , [  test -z "[$]ac_cv_path_$1" && ac_cv_path_$1="$4"
+])dnl
+    ;;
+esac])dnl
+$1="$ac_cv_path_$1"
+if test ifelse([$4], , [-n "[$]$1"], ["[$]$1" != "$4"]); then
+  AC_MSG_RESULT([$]$1)
+else
+  AC_MSG_RESULT(no)
+fi
+AC_SUBST($1)dnl
+])
--- /dev/null
+++ b/rygel.doap
@@ -0,0 +1,26 @@
+<Project xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
+         xmlns:rdfs="http://www.w3.org/2000/01/rdf-schema#"
+         xmlns:foaf="http://xmlns.com/foaf/0.1/"
+         xmlns:gnome="http://api.gnome.org/doap-extensions#"
+         xmlns="http://usefulinc.com/ns/doap#">
+
+  <name xml:lang="en">rygel</name>
+  <shortdesc xml:lang="en">Rygel is a collection of UPnP/DLNA devices, implemented through a plug-in mechanism.</shortdesc>
+
+  <homepage
+  rdf:resource="http://live.gnome.org/Rygel" />
+  <mailing-list
+  rdf:resource="http://mail.gnome.org/mailman/listinfo/rygel-list" />
+  <download-page
+  rdf:resource="http://download.gnome.org/sources/rygel/"/>
+  <bug-database
+  rdf:resource="http://bugzilla.gnome.org/browse.cgi?product=rygel"/>
+
+  <maintainer>
+    <foaf:Person>
+      <foaf:name>Zeeshan Ali (Khattak)</foaf:name>
+      <foaf:mbox rdf:resource="mailto:zeeshanak@gnome.org" />
+      <gnome:userid>zeeshanak</gnome:userid>
+    </foaf:Person>
+  </maintainer>
+</Project>
--- a/src/rygel/rygel-1.0.vapi
+++ b/src/rygel/rygel-1.0.vapi
@@ -1,8 +1,5 @@
 /* rygel-1.0.vapi generated by valac, do not modify. */
 
-[CCode (cprefix = "Gst", lower_case_cprefix = "gst_")]
-namespace Gst {
-}
 [CCode (cprefix = "Rygel", lower_case_cprefix = "rygel_")]
 namespace Rygel {
 	[CCode (cheader_filename = "rygel.h")]
@@ -20,6 +17,7 @@ namespace Rygel {
 		public const string UPNP_TYPE;
 		public ConnectionManager ();
 		public override void constructed ();
+		protected virtual void get_current_connection_info_cb (Rygel.ConnectionManager cm, owned GUPnP.ServiceAction action);
 		protected string source_protocol_info { owned get; }
 	}
 	[CCode (cheader_filename = "rygel.h")]
@@ -39,8 +37,13 @@ namespace Rygel {
 	[CCode (cheader_filename = "rygel.h")]
 	[DBus (name = "org.gnome.Rygel1")]
 	public class DBusService : GLib.Object {
-		public DBusService (Rygel.Main main) throws DBus.Error;
+		public int ChangeFriendlyName (string friendlyname);
 		public void Shutdown ();
+		public static Rygel.DBusService get_default ();
+		public signal void PlayerPlaying (string artist, string title);
+		public signal void PlayerStopped ();
+		public signal void UdnChanged (string new_udn);
+		public signal void Volume (uint volume, bool mute);
 	}
 	[CCode (ref_function = "rygel_icon_info_ref", unref_function = "rygel_icon_info_unref", cheader_filename = "rygel.h")]
 	public class IconInfo {
@@ -60,6 +63,8 @@ namespace Rygel {
 	[CCode (cheader_filename = "rygel.h")]
 	public class Main : GLib.Object {
 		public void exit (int exit_code);
+		public static Rygel.Main get_default ();
+		public Rygel.RootDevice get_root_device_by_desc_path (string device_desc_path);
 	}
 	[CCode (cheader_filename = "rygel.h")]
 	public abstract class MediaContainer : Rygel.MediaObject {
@@ -143,7 +148,6 @@ namespace Rygel {
 		public const string VIDEO_CLASS;
 		public MediaItem (string id, Rygel.MediaContainer parent, string title, string upnp_class);
 		public void add_uri (string uri, Rygel.Thumbnail? thumbnail);
-		public virtual Gst.Element? create_stream_source ();
 		public virtual bool should_stream ();
 	}
 	[CCode (cheader_filename = "rygel.h")]
@@ -162,20 +166,19 @@ namespace Rygel {
 		public static Rygel.MetaConfig get_default ();
 	}
 	[CCode (cheader_filename = "rygel.h")]
-	public class MetadataExtractor : GLib.Object {
-		public const string TAG_RYGEL_CHANNELS;
-		public const string TAG_RYGEL_DEPTH;
-		public const string TAG_RYGEL_DURATION;
-		public const string TAG_RYGEL_HEIGHT;
-		public const string TAG_RYGEL_MIME;
-		public const string TAG_RYGEL_MTIME;
-		public const string TAG_RYGEL_RATE;
-		public const string TAG_RYGEL_SIZE;
-		public const string TAG_RYGEL_WIDTH;
-		public MetadataExtractor ();
-		public void extract (GLib.File file);
-		public signal void error (GLib.File file, GLib.Error err);
-		public signal void extraction_done (GLib.File file, Gst.TagList tag_list);
+	[DBus (name = "org.freedesktop.NetworkManager.Device")]
+	public class NetworkManagerDevice : GLib.Object {
+		public NetworkManagerDevice (string interface_name);
+		public string Interface { get; set; }
+		public uint State { get; set; }
+		public signal void ConnectionStatus (bool connection);
+		public signal void StateChanged (uint new_state, uint old_state, uint reason);
+	}
+	[CCode (cheader_filename = "rygel.h")]
+	[DBus (name = "org.freedesktop.NetworkManager")]
+	public class NetworkManagerService : GLib.Object {
+		public NetworkManagerService () throws DBus.Error;
+		public DBus.ObjectPath[] GetDevices ();
 	}
 	[CCode (cheader_filename = "rygel.h")]
 	public class Plugin : GUPnP.ResourceFactory {
@@ -209,6 +212,7 @@ namespace Rygel {
 	}
 	[CCode (cheader_filename = "rygel.h")]
 	public class RootDevice : GUPnP.RootDevice {
+		protected Gee.ArrayList<GUPnP.ServiceInfo> services;
 		public RootDevice (GUPnP.Context context, Rygel.Plugin plugin, GUPnP.XMLDoc description_doc, string description_path, string description_dir);
 	}
 	[CCode (ref_function = "rygel_root_device_factory_ref", unref_function = "rygel_root_device_factory_unref", cheader_filename = "rygel.h")]
--- a/src/rygel/rygel-browse.c
+++ b/src/rygel/rygel-browse.c
@@ -97,16 +97,6 @@ typedef struct _RygelContentDirectory Ry
 typedef struct _RygelContentDirectoryClass RygelContentDirectoryClass;
 typedef struct _RygelContentDirectoryPrivate RygelContentDirectoryPrivate;
 
-#define RYGEL_TYPE_TRANSCODE_MANAGER (rygel_transcode_manager_get_type ())
-#define RYGEL_TRANSCODE_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_TRANSCODE_MANAGER, RygelTranscodeManager))
-#define RYGEL_TRANSCODE_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_TRANSCODE_MANAGER, RygelTranscodeManagerClass))
-#define RYGEL_IS_TRANSCODE_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_TRANSCODE_MANAGER))
-#define RYGEL_IS_TRANSCODE_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_TRANSCODE_MANAGER))
-#define RYGEL_TRANSCODE_MANAGER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_TRANSCODE_MANAGER, RygelTranscodeManagerClass))
-
-typedef struct _RygelTranscodeManager RygelTranscodeManager;
-typedef struct _RygelTranscodeManagerClass RygelTranscodeManagerClass;
-
 #define RYGEL_TYPE_HTTP_SERVER (rygel_http_server_get_type ())
 #define RYGEL_HTTP_SERVER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_HTTP_SERVER, RygelHTTPServer))
 #define RYGEL_HTTP_SERVER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_HTTP_SERVER, RygelHTTPServerClass))
@@ -223,7 +213,6 @@ enum  {
 	RYGEL_BROWSE_CANCELLABLE
 };
 GType rygel_content_directory_get_type (void);
-GType rygel_transcode_manager_get_type (void);
 GType rygel_http_server_get_type (void);
 void rygel_state_machine_set_cancellable (RygelStateMachine* self, GCancellable* value);
 RygelDIDLLiteWriter* rygel_didl_lite_writer_new (RygelHTTPServer* http_server);
@@ -337,13 +326,13 @@ static void rygel_browse_on_media_object
 		RygelMediaObject* _tmp1_;
 		_tmp0_ = rygel_media_container_find_object_finish (container, res, &_inner_error_);
 		if (_inner_error_ != NULL) {
-			goto __catch35_g_error;
-			goto __finally35;
+			goto __catch31_g_error;
+			goto __finally31;
 		}
 		self->priv->media_object = (_tmp1_ = _tmp0_, _g_object_unref0 (self->priv->media_object), _tmp1_);
 	}
-	goto __finally35;
-	__catch35_g_error:
+	goto __finally31;
+	__catch31_g_error:
 	{
 		GError * err;
 		err = _inner_error_;
@@ -355,10 +344,10 @@ static void rygel_browse_on_media_object
 			return;
 		}
 	}
-	__finally35:
+	__finally31:
 	if (_inner_error_ != NULL) {
 		_g_object_unref0 (container);
-		g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
+		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
 		g_clear_error (&_inner_error_);
 		return;
 	}
@@ -379,12 +368,12 @@ static void rygel_browse_handle_metadata
 	{
 		rygel_didl_lite_writer_serialize (self->priv->didl_writer, self->priv->media_object, &_inner_error_);
 		if (_inner_error_ != NULL) {
-			goto __catch36_g_error;
-			goto __finally36;
+			goto __catch32_g_error;
+			goto __finally32;
 		}
 	}
-	goto __finally36;
-	__catch36_g_error:
+	goto __finally32;
+	__catch32_g_error:
 	{
 		GError * err;
 		err = _inner_error_;
@@ -395,9 +384,9 @@ static void rygel_browse_handle_metadata
 			return;
 		}
 	}
-	__finally36:
+	__finally32:
 	if (_inner_error_ != NULL) {
-		g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
+		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
 		g_clear_error (&_inner_error_);
 		return;
 	}
@@ -524,13 +513,13 @@ static void rygel_browse_serialize_child
 					RygelMediaObject* _tmp2_;
 					rygel_didl_lite_writer_serialize (self->priv->didl_writer, _tmp2_ = (RygelMediaObject*) gee_list_get (children, i), &_inner_error_);
 					if (_inner_error_ != NULL) {
-						goto __catch37_g_error;
-						goto __finally37;
+						goto __catch33_g_error;
+						goto __finally33;
 					}
 					_g_object_unref0 (_tmp2_);
 				}
-				goto __finally37;
-				__catch37_g_error:
+				goto __finally33;
+				__catch33_g_error:
 				{
 					GError * err;
 					err = _inner_error_;
@@ -541,9 +530,9 @@ static void rygel_browse_serialize_child
 						return;
 					}
 				}
-				__finally37:
+				__finally33:
 				if (_inner_error_ != NULL) {
-					g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
+					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
 					g_clear_error (&_inner_error_);
 					return;
 				}
@@ -579,15 +568,15 @@ static void rygel_browse_on_children_fet
 		GeeList* children;
 		children = rygel_media_container_get_children_finish (container, res, &_inner_error_);
 		if (_inner_error_ != NULL) {
-			goto __catch38_g_error;
-			goto __finally38;
+			goto __catch34_g_error;
+			goto __finally34;
 		}
 		self->number_returned = (guint) gee_collection_get_size ((GeeCollection*) children);
 		rygel_browse_serialize_children (self, children);
 		_g_object_unref0 (children);
 	}
-	goto __finally38;
-	__catch38_g_error:
+	goto __finally34;
+	__catch34_g_error:
 	{
 		GError * err;
 		err = _inner_error_;
@@ -597,10 +586,10 @@ static void rygel_browse_on_children_fet
 			_g_error_free0 (err);
 		}
 	}
-	__finally38:
+	__finally34:
 	if (_inner_error_ != NULL) {
 		_g_object_unref0 (container);
-		g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
+		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
 		g_clear_error (&_inner_error_);
 		return;
 	}
--- a/src/rygel/rygel-cmdline-config.c
+++ b/src/rygel/rygel-cmdline-config.c
@@ -30,7 +30,6 @@
 #include <stdlib.h>
 #include <string.h>
 #include <gee.h>
-#include <gst/gst.h>
 #include <stdio.h>
 
 
@@ -199,7 +198,6 @@ void rygel_cmdline_config_parse_args (ch
 	opt_context = g_option_context_new (parameter_string);
 	g_option_context_set_help_enabled (opt_context, TRUE);
 	g_option_context_add_main_entries (opt_context, RYGEL_CMDLINE_CONFIG_options, NULL);
-	g_option_context_add_group (opt_context, gst_init_get_option_group ());
 	g_option_context_parse (opt_context, args_length1, args, &_inner_error_);
 	if (_inner_error_ != NULL) {
 		if ((_inner_error_->domain == RYGEL_CMDLINE_CONFIG_ERROR) || (_inner_error_->domain == G_OPTION_ERROR)) {
@@ -210,7 +208,7 @@ void rygel_cmdline_config_parse_args (ch
 		} else {
 			_g_free0 (parameter_string);
 			_g_option_context_free0 (opt_context);
-			g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
+			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
 			g_clear_error (&_inner_error_);
 			return;
 		}
@@ -227,7 +225,7 @@ void rygel_cmdline_config_parse_args (ch
 			} else {
 				_g_free0 (parameter_string);
 				_g_option_context_free0 (opt_context);
-				g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
+				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
 				g_clear_error (&_inner_error_);
 				return;
 			}
@@ -576,7 +574,7 @@ static GeeArrayList* rygel_cmdline_confi
 				}
 				if (_tmp2_) {
 					GeeArrayList* _tmp6_;
-					value = (_tmp6_ = gee_array_list_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, g_direct_equal), _g_object_unref0 (value), _tmp6_);
+					value = (_tmp6_ = gee_array_list_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, NULL), _g_object_unref0 (value), _tmp6_);
 					{
 						char** _tmp7_;
 						char** val_token_collection;
@@ -755,7 +753,7 @@ static GeeArrayList* rygel_cmdline_confi
 				}
 				if (_tmp2_) {
 					GeeArrayList* _tmp6_;
-					value = (_tmp6_ = gee_array_list_new (G_TYPE_INT, NULL, NULL, g_direct_equal), _g_object_unref0 (value), _tmp6_);
+					value = (_tmp6_ = gee_array_list_new (G_TYPE_INT, NULL, NULL, NULL), _g_object_unref0 (value), _tmp6_);
 					{
 						char** _tmp7_;
 						char** val_token_collection;
--- a/src/rygel/rygel-connection-manager.c
+++ b/src/rygel/rygel-connection-manager.c
@@ -46,16 +46,6 @@ typedef struct _RygelConnectionManagerCl
 typedef struct _RygelConnectionManagerPrivate RygelConnectionManagerPrivate;
 #define _g_free0(var) (var = (g_free (var), NULL))
 
-#define RYGEL_TYPE_TRANSCODE_MANAGER (rygel_transcode_manager_get_type ())
-#define RYGEL_TRANSCODE_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_TRANSCODE_MANAGER, RygelTranscodeManager))
-#define RYGEL_TRANSCODE_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_TRANSCODE_MANAGER, RygelTranscodeManagerClass))
-#define RYGEL_IS_TRANSCODE_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_TRANSCODE_MANAGER))
-#define RYGEL_IS_TRANSCODE_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_TRANSCODE_MANAGER))
-#define RYGEL_TRANSCODE_MANAGER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_TRANSCODE_MANAGER, RygelTranscodeManagerClass))
-
-typedef struct _RygelTranscodeManager RygelTranscodeManager;
-typedef struct _RygelTranscodeManagerClass RygelTranscodeManagerClass;
-
 #define RYGEL_TYPE_HTTP_SERVER (rygel_http_server_get_type ())
 #define RYGEL_HTTP_SERVER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_HTTP_SERVER, RygelHTTPServer))
 #define RYGEL_HTTP_SERVER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_HTTP_SERVER, RygelHTTPServerClass))
@@ -118,6 +108,7 @@ struct _RygelConnectionManager {
 
 struct _RygelConnectionManagerClass {
 	GUPnPServiceClass parent_class;
+	void (*get_current_connection_info_cb) (RygelConnectionManager* self, RygelConnectionManager* cm, GUPnPServiceAction* action);
 };
 
 struct _RygelRootDevice {
@@ -157,7 +148,7 @@ enum  {
 	RYGEL_CONNECTION_MANAGER_SOURCE_PROTOCOL_INFO
 };
 #define RYGEL_CONNECTION_MANAGER_UPNP_ID "urn:upnp-org:serviceId:ConnectionManager"
-#define RYGEL_CONNECTION_MANAGER_UPNP_TYPE "urn:schemas-upnp-org:service:ConnectionManager:2"
+#define RYGEL_CONNECTION_MANAGER_UPNP_TYPE "urn:schemas-upnp-org:service:ConnectionManager:1"
 #define RYGEL_CONNECTION_MANAGER_DESCRIPTION_PATH "xml/ConnectionManager.xml"
 static void rygel_connection_manager_query_source_protocol_info_cb (RygelConnectionManager* self, RygelConnectionManager* cm, const char* var, GValue* val);
 static void _rygel_connection_manager_query_source_protocol_info_cb_gupnp_service_query_variable (RygelConnectionManager* _sender, const char* variable, GValue* value, gpointer self);
@@ -169,11 +160,11 @@ static void rygel_connection_manager_get
 static void _rygel_connection_manager_get_protocol_info_cb_gupnp_service_action_invoked (RygelConnectionManager* _sender, GUPnPServiceAction* action, gpointer self);
 static void rygel_connection_manager_get_current_connection_ids_cb (RygelConnectionManager* self, RygelConnectionManager* cm, GUPnPServiceAction* action);
 static void _rygel_connection_manager_get_current_connection_ids_cb_gupnp_service_action_invoked (RygelConnectionManager* _sender, GUPnPServiceAction* action, gpointer self);
-static void rygel_connection_manager_get_current_connection_info_cb (RygelConnectionManager* self, RygelConnectionManager* cm, GUPnPServiceAction* action);
+void rygel_connection_manager_get_current_connection_info_cb (RygelConnectionManager* self, RygelConnectionManager* cm, GUPnPServiceAction* action);
 static void _rygel_connection_manager_get_current_connection_info_cb_gupnp_service_action_invoked (RygelConnectionManager* _sender, GUPnPServiceAction* action, gpointer self);
 static void rygel_connection_manager_real_constructed (GObject* base);
 char* rygel_connection_manager_get_source_protocol_info (RygelConnectionManager* self);
-GType rygel_transcode_manager_get_type (void);
+static void rygel_connection_manager_real_get_current_connection_info_cb (RygelConnectionManager* self, RygelConnectionManager* cm, GUPnPServiceAction* action);
 GType rygel_http_server_get_type (void);
 GType rygel_root_device_get_type (void);
 GType rygel_content_directory_get_type (void);
@@ -182,7 +173,7 @@ GType rygel_media_container_get_type (vo
 static RygelHTTPServer* rygel_connection_manager_get_http_server (RygelConnectionManager* self);
 RygelConnectionManager* rygel_connection_manager_new (void);
 RygelConnectionManager* rygel_connection_manager_construct (GType object_type);
-char* rygel_transcode_manager_get_protocol_info (RygelTranscodeManager* self);
+char* rygel_http_server_get_protocol_info (RygelHTTPServer* self);
 static void rygel_connection_manager_finalize (GObject* obj);
 static void rygel_connection_manager_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
 
@@ -283,7 +274,7 @@ static void rygel_connection_manager_get
 }
 
 
-static void rygel_connection_manager_get_current_connection_info_cb (RygelConnectionManager* self, RygelConnectionManager* cm, GUPnPServiceAction* action) {
+static void rygel_connection_manager_real_get_current_connection_info_cb (RygelConnectionManager* self, RygelConnectionManager* cm, GUPnPServiceAction* action) {
 	gint connection_id = 0;
 	g_return_if_fail (self != NULL);
 	g_return_if_fail (cm != NULL);
@@ -293,11 +284,16 @@ static void rygel_connection_manager_get
 		gupnp_service_action_return_error (action, (guint) 706, "Invalid connection reference");
 		return;
 	}
-	gupnp_service_action_set (action, "ResID", G_TYPE_INT, -1, "AVTransportID", G_TYPE_INT, -1, "ProtocolInfo", G_TYPE_STRING, "", "PeerConnectionManager", G_TYPE_STRING, "", "PeerConnectionID", G_TYPE_INT, -1, "Direction", G_TYPE_STRING, "Input", "Status", G_TYPE_STRING, "Unknown", NULL);
+	gupnp_service_action_set (action, "RcsID", G_TYPE_INT, 0, "AVTransportID", G_TYPE_INT, 0, "ProtocolInfo", G_TYPE_STRING, "", "PeerConnectionManager", G_TYPE_STRING, "", "PeerConnectionID", G_TYPE_INT, -1, "Direction", G_TYPE_STRING, "Input", "Status", G_TYPE_STRING, "Unknown", NULL);
 	gupnp_service_action_return (action);
 }
 
 
+void rygel_connection_manager_get_current_connection_info_cb (RygelConnectionManager* self, RygelConnectionManager* cm, GUPnPServiceAction* action) {
+	RYGEL_CONNECTION_MANAGER_GET_CLASS (self)->get_current_connection_info_cb (self, cm, action);
+}
+
+
 static gpointer _g_object_ref0 (gpointer self) {
 	return self ? g_object_ref (self) : NULL;
 }
@@ -351,10 +347,16 @@ RygelConnectionManager* rygel_connection
 
 char* rygel_connection_manager_get_source_protocol_info (RygelConnectionManager* self) {
 	char* result;
-	RygelHTTPServer* _tmp0_;
-	char* _tmp1_;
+	RygelHTTPServer* server;
 	g_return_val_if_fail (self != NULL, NULL);
-	result = (_tmp1_ = rygel_transcode_manager_get_protocol_info ((RygelTranscodeManager*) (_tmp0_ = rygel_connection_manager_get_http_server (self))), _g_object_unref0 (_tmp0_), _tmp1_);
+	server = rygel_connection_manager_get_http_server (self);
+	if (server != NULL) {
+		result = rygel_http_server_get_protocol_info (server);
+		_g_object_unref0 (server);
+		return result;
+	}
+	result = g_strdup ("");
+	_g_object_unref0 (server);
 	return result;
 }
 
@@ -362,6 +364,7 @@ char* rygel_connection_manager_get_sourc
 static void rygel_connection_manager_class_init (RygelConnectionManagerClass * klass) {
 	rygel_connection_manager_parent_class = g_type_class_peek_parent (klass);
 	G_OBJECT_CLASS (klass)->constructed = rygel_connection_manager_real_constructed;
+	RYGEL_CONNECTION_MANAGER_CLASS (klass)->get_current_connection_info_cb = rygel_connection_manager_real_get_current_connection_info_cb;
 	G_OBJECT_CLASS (klass)->get_property = rygel_connection_manager_get_property;
 	G_OBJECT_CLASS (klass)->finalize = rygel_connection_manager_finalize;
 	g_object_class_install_property (G_OBJECT_CLASS (klass), RYGEL_CONNECTION_MANAGER_SOURCE_PROTOCOL_INFO, g_param_spec_string ("source-protocol-info", "source-protocol-info", "source-protocol-info", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
--- a/src/rygel/rygel-content-directory.c
+++ b/src/rygel/rygel-content-directory.c
@@ -65,16 +65,6 @@ typedef struct _RygelMediaObjectClass Ry
 typedef struct _RygelMediaContainer RygelMediaContainer;
 typedef struct _RygelMediaContainerClass RygelMediaContainerClass;
 
-#define RYGEL_TYPE_TRANSCODE_MANAGER (rygel_transcode_manager_get_type ())
-#define RYGEL_TRANSCODE_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_TRANSCODE_MANAGER, RygelTranscodeManager))
-#define RYGEL_TRANSCODE_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_TRANSCODE_MANAGER, RygelTranscodeManagerClass))
-#define RYGEL_IS_TRANSCODE_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_TRANSCODE_MANAGER))
-#define RYGEL_IS_TRANSCODE_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_TRANSCODE_MANAGER))
-#define RYGEL_TRANSCODE_MANAGER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_TRANSCODE_MANAGER, RygelTranscodeManagerClass))
-
-typedef struct _RygelTranscodeManager RygelTranscodeManager;
-typedef struct _RygelTranscodeManagerClass RygelTranscodeManagerClass;
-
 #define RYGEL_TYPE_HTTP_SERVER (rygel_http_server_get_type ())
 #define RYGEL_HTTP_SERVER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_HTTP_SERVER, RygelHTTPServer))
 #define RYGEL_HTTP_SERVER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_HTTP_SERVER, RygelHTTPServerClass))
@@ -182,7 +172,6 @@ GQuark rygel_content_directory_error_qua
 GType rygel_content_directory_get_type (void);
 GType rygel_media_object_get_type (void);
 GType rygel_media_container_get_type (void);
-GType rygel_transcode_manager_get_type (void);
 GType rygel_http_server_get_type (void);
 GType rygel_browse_get_type (void);
 #define RYGEL_CONTENT_DIRECTORY_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), RYGEL_TYPE_CONTENT_DIRECTORY, RygelContentDirectoryPrivate))
@@ -347,12 +336,12 @@ static void rygel_content_directory_real
 	}
 	__finally21:
 	if (_inner_error_ != NULL) {
-		g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
+		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
 		g_clear_error (&_inner_error_);
 		return;
 	}
-	self->priv->browses = (_tmp4_ = gee_array_list_new (RYGEL_TYPE_BROWSE, (GBoxedCopyFunc) g_object_ref, g_object_unref, g_direct_equal), _g_object_unref0 (self->priv->browses), _tmp4_);
-	self->priv->updated_containers = (_tmp5_ = gee_array_list_new (RYGEL_TYPE_MEDIA_CONTAINER, (GBoxedCopyFunc) g_object_ref, g_object_unref, g_direct_equal), _g_object_unref0 (self->priv->updated_containers), _tmp5_);
+	self->priv->browses = (_tmp4_ = gee_array_list_new (RYGEL_TYPE_BROWSE, (GBoxedCopyFunc) g_object_ref, g_object_unref, NULL), _g_object_unref0 (self->priv->browses), _tmp4_);
+	self->priv->updated_containers = (_tmp5_ = gee_array_list_new (RYGEL_TYPE_MEDIA_CONTAINER, (GBoxedCopyFunc) g_object_ref, g_object_unref, NULL), _g_object_unref0 (self->priv->updated_containers), _tmp5_);
 	g_signal_connect_object (self->root_container, "container-updated", (GCallback) _rygel_content_directory_on_container_updated_rygel_media_container_container_updated, self, 0);
 	self->feature_list = (_tmp6_ = g_strdup ("<?xml version=\"1.0\" encoding=\"UTF-8\"?>" "<Features xmlns=\"urn:schemas-upnp-org:av:avs\" " "xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" " "xsi:schemaLocation=\"urn:schemas-upnp-org:av:avs" "http://www.upnp.org/schemas/av/avs-v1-20060531.xsd\">" "</Features>"), _g_free0 (self->feature_list), _tmp6_);
 	self->search_caps = (_tmp7_ = g_strdup (""), _g_free0 (self->search_caps), _tmp7_);
--- a/src/rygel/rygel-dbus-service.c
+++ b/src/rygel/rygel-dbus-service.c
@@ -30,6 +30,11 @@
 #include <string.h>
 #include <dbus/dbus-glib-lowlevel.h>
 #include <dbus/dbus-glib.h>
+#include <libgupnp/gupnp.h>
+#include <libxml/tree.h>
+#include <cstuff.h>
+#include <stdio.h>
+#include <libxml/parser.h>
 #include <dbus/dbus.h>
 
 
@@ -54,7 +59,20 @@ typedef struct _RygelDBusServicePrivate
 typedef struct _RygelMain RygelMain;
 typedef struct _RygelMainClass RygelMainClass;
 #define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
+#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
 #define _dbus_g_connection_unref0(var) ((var == NULL) ? NULL : (var = (dbus_g_connection_unref (var), NULL)))
+
+#define RYGEL_TYPE_ROOT_DEVICE (rygel_root_device_get_type ())
+#define RYGEL_ROOT_DEVICE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_ROOT_DEVICE, RygelRootDevice))
+#define RYGEL_ROOT_DEVICE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_ROOT_DEVICE, RygelRootDeviceClass))
+#define RYGEL_IS_ROOT_DEVICE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_ROOT_DEVICE))
+#define RYGEL_IS_ROOT_DEVICE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_ROOT_DEVICE))
+#define RYGEL_ROOT_DEVICE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_ROOT_DEVICE, RygelRootDeviceClass))
+
+typedef struct _RygelRootDevice RygelRootDevice;
+typedef struct _RygelRootDeviceClass RygelRootDeviceClass;
+#define _g_free0(var) (var = (g_free (var), NULL))
+#define _fclose0(var) ((var == NULL) ? NULL : (var = (fclose (var), NULL)))
 typedef struct _DBusObjectVTable _DBusObjectVTable;
 
 struct _RygelDBusService {
@@ -79,6 +97,8 @@ static char* rygel_dbus_service_RYGEL_SE
 static char* rygel_dbus_service_RYGEL_SERVICE = NULL;
 static char* rygel_dbus_service_RYGEL_PATH;
 static char* rygel_dbus_service_RYGEL_PATH = NULL;
+static RygelDBusService* rygel_dbus_service_instance;
+static RygelDBusService* rygel_dbus_service_instance = NULL;
 static gpointer rygel_dbus_service_parent_class = NULL;
 
 GType rygel_dbus_service_get_type (void);
@@ -87,31 +107,88 @@ GType rygel_main_get_type (void);
 enum  {
 	RYGEL_DBUS_SERVICE_DUMMY_PROPERTY
 };
-guint _dynamic_request_name2 (DBusGProxy* self, const char* param1, guint param2, GError** error);
-RygelDBusService* rygel_dbus_service_new (RygelMain* main, GError** error);
-RygelDBusService* rygel_dbus_service_construct (GType object_type, RygelMain* main, GError** error);
+static RygelDBusService* rygel_dbus_service_new (GError** error);
+static RygelDBusService* rygel_dbus_service_construct (GType object_type, GError** error);
+RygelDBusService* rygel_dbus_service_get_default (void);
+RygelMain* rygel_main_get_default (void);
+static guint _dynamic_request_name3 (DBusGProxy* self, const char* param1, guint param2, GError** error);
 void rygel_main_exit (RygelMain* self, gint exit_code);
 void rygel_dbus_service_Shutdown (RygelDBusService* self);
+GType rygel_root_device_get_type (void);
+RygelRootDevice* rygel_main_get_root_device_by_desc_path (RygelMain* self, const char* device_desc_path);
+gint rygel_dbus_service_ChangeFriendlyName (RygelDBusService* self, const char* friendlyname);
 void rygel_dbus_service_dbus_register_object (DBusConnection* connection, const char* path, void* object);
 void _rygel_dbus_service_dbus_unregister (DBusConnection* connection, void* _user_data_);
 DBusHandlerResult rygel_dbus_service_dbus_message (DBusConnection* connection, DBusMessage* message, void* object);
 static DBusHandlerResult _dbus_rygel_dbus_service_introspect (RygelDBusService* self, DBusConnection* connection, DBusMessage* message);
 static DBusHandlerResult _dbus_rygel_dbus_service_property_get_all (RygelDBusService* self, DBusConnection* connection, DBusMessage* message);
 static DBusHandlerResult _dbus_rygel_dbus_service_Shutdown (RygelDBusService* self, DBusConnection* connection, DBusMessage* message);
+static DBusHandlerResult _dbus_rygel_dbus_service_ChangeFriendlyName (RygelDBusService* self, DBusConnection* connection, DBusMessage* message);
+static void _dbus_rygel_dbus_service_udn_changed (GObject* _sender, const char* new_udn, DBusConnection* _connection);
+static void _dbus_rygel_dbus_service_player_stopped (GObject* _sender, DBusConnection* _connection);
+static void _dbus_rygel_dbus_service_player_playing (GObject* _sender, const char* artist, const char* title, DBusConnection* _connection);
+static void _dbus_rygel_dbus_service_volume (GObject* _sender, guint volume, gboolean mute, DBusConnection* _connection);
 static void rygel_dbus_service_finalize (GObject* obj);
+static int _vala_strcmp0 (const char * str1, const char * str2);
 static void _vala_dbus_register_object (DBusConnection* connection, const char* path, void* object);
 static void _vala_dbus_unregister_object (gpointer connection, GObject* object);
 
 static const DBusObjectPathVTable _rygel_dbus_service_dbus_path_vtable = {_rygel_dbus_service_dbus_unregister, rygel_dbus_service_dbus_message};
 static const _DBusObjectVTable _rygel_dbus_service_dbus_vtable = {rygel_dbus_service_dbus_register_object};
 
+static void g_cclosure_user_marshal_VOID__STRING_STRING (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data);
+static void g_cclosure_user_marshal_VOID__UINT_BOOLEAN (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data);
 
 static gpointer _g_object_ref0 (gpointer self) {
 	return self ? g_object_ref (self) : NULL;
 }
 
 
-guint _dynamic_request_name2 (DBusGProxy* self, const char* param1, guint param2, GError** error) {
+RygelDBusService* rygel_dbus_service_get_default (void) {
+	RygelDBusService* result;
+	GError * _inner_error_;
+	_inner_error_ = NULL;
+	if (rygel_dbus_service_instance != NULL) {
+		result = _g_object_ref0 (rygel_dbus_service_instance);
+		return result;
+	}
+	{
+		RygelDBusService* _tmp0_;
+		RygelDBusService* _tmp1_;
+		_tmp0_ = rygel_dbus_service_new (&_inner_error_);
+		if (_inner_error_ != NULL) {
+			if (_inner_error_->domain == DBUS_GERROR) {
+				goto __catch41_dbus_gerror;
+			}
+			goto __finally41;
+		}
+		rygel_dbus_service_instance = (_tmp1_ = _tmp0_, _g_object_unref0 (rygel_dbus_service_instance), _tmp1_);
+	}
+	goto __finally41;
+	__catch41_dbus_gerror:
+	{
+		GError * err;
+		err = _inner_error_;
+		_inner_error_ = NULL;
+		{
+			g_warning ("rygel-dbus-service.vala:54: Failed to create D-Bus service: %s", err->message);
+			result = NULL;
+			_g_error_free0 (err);
+			return result;
+		}
+	}
+	__finally41:
+	if (_inner_error_ != NULL) {
+		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
+		g_clear_error (&_inner_error_);
+		return NULL;
+	}
+	result = _g_object_ref0 (rygel_dbus_service_instance);
+	return result;
+}
+
+
+static guint _dynamic_request_name3 (DBusGProxy* self, const char* param1, guint param2, GError** error) {
 	guint result;
 	dbus_g_proxy_call (self, "RequestName", error, G_TYPE_STRING, param1, G_TYPE_UINT, param2, G_TYPE_INVALID, G_TYPE_UINT, &result, G_TYPE_INVALID);
 	if (*error) {
@@ -121,46 +198,45 @@ guint _dynamic_request_name2 (DBusGProxy
 }
 
 
-RygelDBusService* rygel_dbus_service_construct (GType object_type, RygelMain* main, GError** error) {
+static RygelDBusService* rygel_dbus_service_construct (GType object_type, GError** error) {
 	GError * _inner_error_;
 	RygelDBusService * self;
 	RygelMain* _tmp0_;
 	DBusGConnection* conn;
 	DBusGProxy* bus;
 	guint request_name_result;
-	g_return_val_if_fail (main != NULL, NULL);
 	_inner_error_ = NULL;
 	self = (RygelDBusService*) g_object_new (object_type, NULL);
-	self->priv->main = (_tmp0_ = _g_object_ref0 (main), _g_object_unref0 (self->priv->main), _tmp0_);
+	self->priv->main = (_tmp0_ = rygel_main_get_default (), _g_object_unref0 (self->priv->main), _tmp0_);
 	conn = dbus_g_bus_get (DBUS_BUS_SESSION, &_inner_error_);
 	if (_inner_error_ != NULL) {
 		if (_inner_error_->domain == DBUS_GERROR) {
 			g_propagate_error (error, _inner_error_);
-			return;
+			return NULL;
 		} else {
-			g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
+			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
 			g_clear_error (&_inner_error_);
 			return NULL;
 		}
 	}
 	bus = dbus_g_proxy_new_for_name (conn, "org.freedesktop.DBus", "/org/freedesktop/DBus", "org.freedesktop.DBus");
-	request_name_result = _dynamic_request_name2 (bus, rygel_dbus_service_RYGEL_SERVICE, (guint) 0, &_inner_error_);
+	request_name_result = _dynamic_request_name3 (bus, rygel_dbus_service_RYGEL_SERVICE, (guint) 0, &_inner_error_);
 	if (_inner_error_ != NULL) {
 		if (_inner_error_->domain == DBUS_GERROR) {
 			g_propagate_error (error, _inner_error_);
 			_dbus_g_connection_unref0 (conn);
 			_g_object_unref0 (bus);
-			return;
+			return NULL;
 		} else {
 			_dbus_g_connection_unref0 (conn);
 			_g_object_unref0 (bus);
-			g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
+			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
 			g_clear_error (&_inner_error_);
 			return NULL;
 		}
 	}
 	if (request_name_result != DBUS_REQUEST_NAME_REPLY_PRIMARY_OWNER) {
-		g_warning ("rygel-dbus-service.vala:45: Failed to start D-Bus service, name '%s' already taken", rygel_dbus_service_RYGEL_SERVICE);
+		g_warning ("rygel-dbus-service.vala:74: Failed to start D-Bus service, name '%s' already taken", rygel_dbus_service_RYGEL_SERVICE);
 	} else {
 		_vala_dbus_register_object (dbus_g_connection_get_connection (conn), rygel_dbus_service_RYGEL_PATH, (GObject*) self);
 	}
@@ -170,8 +246,8 @@ RygelDBusService* rygel_dbus_service_con
 }
 
 
-RygelDBusService* rygel_dbus_service_new (RygelMain* main, GError** error) {
-	return rygel_dbus_service_construct (RYGEL_TYPE_DBUS_SERVICE, main, error);
+static RygelDBusService* rygel_dbus_service_new (GError** error) {
+	return rygel_dbus_service_construct (RYGEL_TYPE_DBUS_SERVICE, error);
 }
 
 
@@ -181,6 +257,99 @@ void rygel_dbus_service_Shutdown (RygelD
 }
 
 
+gint rygel_dbus_service_ChangeFriendlyName (RygelDBusService* self, const char* friendlyname) {
+	gint result;
+	GError * _inner_error_;
+	char* device_desc_path;
+	RygelRootDevice* root_device;
+	GUPnPXMLDoc* doc;
+	xmlNode* device_element = NULL;
+	xmlNode* element;
+	char* cur_name;
+	FILE* fs;
+	gint res;
+	g_return_val_if_fail (self != NULL, 0);
+	g_return_val_if_fail (friendlyname != NULL, 0);
+	_inner_error_ = NULL;
+	if (_vala_strcmp0 (friendlyname, "") == 0) {
+		g_warning ("rygel-dbus-service.vala:87: %p: Received empty friendly name!", self);
+		result = -1;
+		return result;
+	}
+	device_desc_path = g_strdup ("/root/.config/Rygel/GstRenderer.xml");
+	root_device = rygel_main_get_root_device_by_desc_path (self->priv->main, device_desc_path);
+	if (root_device == NULL) {
+		g_warning ("rygel-dbus-service.vala:94: %p: No root device with description path %s", self, device_desc_path);
+		result = -1;
+		_g_free0 (device_desc_path);
+		_g_object_unref0 (root_device);
+		return result;
+	}
+	doc = gupnp_xml_doc_new_from_path (device_desc_path, &_inner_error_);
+	if (_inner_error_ != NULL) {
+		_g_free0 (device_desc_path);
+		_g_object_unref0 (root_device);
+		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
+		g_clear_error (&_inner_error_);
+		return 0;
+	}
+	device_element = get_xml_element ((xmlNode*) doc->doc, "root", "device", NULL, NULL);
+	if (device_element == NULL) {
+		g_warning ("rygel-dbus-service.vala:105: %p: Element /root/device not found.", self);
+		result = -1;
+		_g_free0 (device_desc_path);
+		_g_object_unref0 (root_device);
+		_g_object_unref0 (doc);
+		return result;
+	}
+	element = get_xml_element (device_element, "friendlyName", NULL, NULL);
+	if (element == NULL) {
+		g_warning ("rygel-dbus-service.vala:111: %p: Element /root/device/friendlyName not found.", self);
+		result = -1;
+		_g_free0 (device_desc_path);
+		_g_object_unref0 (root_device);
+		_g_object_unref0 (doc);
+		return result;
+	}
+	cur_name = xmlNodeGetContent (element);
+	g_debug ("rygel-dbus-service.vala:116: %p: current friendly name : %s New: %s", self, cur_name, friendlyname);
+	xmlNodeSetContent (element, friendlyname);
+	fs = fopen (device_desc_path, "w+");
+	if (fs == NULL) {
+		g_warning ("rygel-dbus-service.vala:124: %p: Could not open file: %s.\n", self, device_desc_path);
+		result = -1;
+		_g_free0 (device_desc_path);
+		_g_object_unref0 (root_device);
+		_g_object_unref0 (doc);
+		_g_free0 (cur_name);
+		_fclose0 (fs);
+		return result;
+	}
+	res = xmlDocDump (fs, doc->doc);
+	if (res == (-1)) {
+		g_warning ("rygel-dbus-service.vala:130: %p: Failed to write modified description to %s.\n", self, device_desc_path);
+		result = -1;
+		_g_free0 (device_desc_path);
+		_g_object_unref0 (root_device);
+		_g_object_unref0 (doc);
+		_g_free0 (cur_name);
+		_fclose0 (fs);
+		return result;
+	}
+	g_debug ("rygel-dbus-service.vala:134: %p: Sending byebye messages", self);
+	gupnp_root_device_set_available ((GUPnPRootDevice*) root_device, FALSE);
+	g_debug ("rygel-dbus-service.vala:136: %p: Sending alive messages", self);
+	gupnp_root_device_set_available ((GUPnPRootDevice*) root_device, TRUE);
+	result = 1;
+	_g_free0 (device_desc_path);
+	_g_object_unref0 (root_device);
+	_g_object_unref0 (doc);
+	_g_free0 (cur_name);
+	_fclose0 (fs);
+	return result;
+}
+
+
 void _rygel_dbus_service_dbus_unregister (DBusConnection* connection, void* _user_data_) {
 }
 
@@ -194,7 +363,7 @@ static DBusHandlerResult _dbus_rygel_dbu
 	reply = dbus_message_new_method_return (message);
 	dbus_message_iter_init_append (reply, &iter);
 	xml_data = g_string_new ("<!DOCTYPE node PUBLIC \"-//freedesktop//DTD D-BUS Object Introspection 1.0//EN\" \"http://www.freedesktop.org/standards/dbus/1.0/introspect.dtd\">\n");
-	g_string_append (xml_data, "<node>\n<interface name=\"org.freedesktop.DBus.Introspectable\">\n  <method name=\"Introspect\">\n    <arg name=\"data\" direction=\"out\" type=\"s\"/>\n  </method>\n</interface>\n<interface name=\"org.freedesktop.DBus.Properties\">\n  <method name=\"Get\">\n    <arg name=\"interface\" direction=\"in\" type=\"s\"/>\n    <arg name=\"propname\" direction=\"in\" type=\"s\"/>\n    <arg name=\"value\" direction=\"out\" type=\"v\"/>\n  </method>\n  <method name=\"Set\">\n    <arg name=\"interface\" direction=\"in\" type=\"s\"/>\n    <arg name=\"propname\" direction=\"in\" type=\"s\"/>\n    <arg name=\"value\" direction=\"in\" type=\"v\"/>\n  </method>\n  <method name=\"GetAll\">\n    <arg name=\"interface\" direction=\"in\" type=\"s\"/>\n    <arg name=\"props\" direction=\"out\" type=\"a{sv}\"/>\n  </method>\n</interface>\n<interface name=\"org.gnome.Rygel1\">\n  <method name=\"Shutdown\">\n  </method>\n</interface>\n");
+	g_string_append (xml_data, "<node>\n<interface name=\"org.freedesktop.DBus.Introspectable\">\n  <method name=\"Introspect\">\n    <arg name=\"data\" direction=\"out\" type=\"s\"/>\n  </method>\n</interface>\n<interface name=\"org.freedesktop.DBus.Properties\">\n  <method name=\"Get\">\n    <arg name=\"interface\" direction=\"in\" type=\"s\"/>\n    <arg name=\"propname\" direction=\"in\" type=\"s\"/>\n    <arg name=\"value\" direction=\"out\" type=\"v\"/>\n  </method>\n  <method name=\"Set\">\n    <arg name=\"interface\" direction=\"in\" type=\"s\"/>\n    <arg name=\"propname\" direction=\"in\" type=\"s\"/>\n    <arg name=\"value\" direction=\"in\" type=\"v\"/>\n  </method>\n  <method name=\"GetAll\">\n    <arg name=\"interface\" direction=\"in\" type=\"s\"/>\n    <arg name=\"props\" direction=\"out\" type=\"a{sv}\"/>\n  </method>\n</interface>\n<interface name=\"org.gnome.Rygel1\">\n  <method name=\"Shutdown\">\n  </method>\n  <method name=\"ChangeFriendlyName\">\n    <arg name=\"friendlyname\" type=\"s\" direction=\"in\"/>\n    <arg name=\"result\" type=\"i\" direction=\"out\"/>\n  </method>\n  <signal name=\"UdnChanged\">\n    <arg name=\"new_udn\" type=\"s\"/>\n  </signal>\n  <signal name=\"PlayerStopped\">\n  </signal>\n  <signal name=\"PlayerPlaying\">\n    <arg name=\"artist\" type=\"s\"/>\n    <arg name=\"title\" type=\"s\"/>\n  </signal>\n  <signal name=\"Volume\">\n    <arg name=\"volume\" type=\"u\"/>\n    <arg name=\"mute\" type=\"b\"/>\n  </signal>\n</interface>\n");
 	dbus_connection_list_registered (connection, g_object_get_data ((GObject *) self, "dbus_object_path"), &children);
 	for (i = 0; children[i]; i++) {
 		g_string_append_printf (xml_data, "<node name=\"%s\"/>\n", children[i]);
@@ -267,6 +436,38 @@ static DBusHandlerResult _dbus_rygel_dbu
 }
 
 
+static DBusHandlerResult _dbus_rygel_dbus_service_ChangeFriendlyName (RygelDBusService* self, DBusConnection* connection, DBusMessage* message) {
+	DBusMessageIter iter;
+	GError* error;
+	char* friendlyname = NULL;
+	const char* _tmp1_;
+	gint result;
+	DBusMessage* reply;
+	dbus_int32_t _tmp2_;
+	error = NULL;
+	if (strcmp (dbus_message_get_signature (message), "s")) {
+		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
+	}
+	dbus_message_iter_init (message, &iter);
+	dbus_message_iter_get_basic (&iter, &_tmp1_);
+	dbus_message_iter_next (&iter);
+	friendlyname = g_strdup (_tmp1_);
+	result = rygel_dbus_service_ChangeFriendlyName (self, friendlyname);
+	reply = dbus_message_new_method_return (message);
+	dbus_message_iter_init_append (reply, &iter);
+	_g_free0 (friendlyname);
+	_tmp2_ = result;
+	dbus_message_iter_append_basic (&iter, DBUS_TYPE_INT32, &_tmp2_);
+	if (reply) {
+		dbus_connection_send (connection, reply, NULL);
+		dbus_message_unref (reply);
+		return DBUS_HANDLER_RESULT_HANDLED;
+	} else {
+		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
+	}
+}
+
+
 DBusHandlerResult rygel_dbus_service_dbus_message (DBusConnection* connection, DBusMessage* message, void* object) {
 	DBusHandlerResult result;
 	result = DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
@@ -276,6 +477,8 @@ DBusHandlerResult rygel_dbus_service_dbu
 		result = _dbus_rygel_dbus_service_property_get_all (object, connection, message);
 	} else if (dbus_message_is_method_call (message, "org.gnome.Rygel1", "Shutdown")) {
 		result = _dbus_rygel_dbus_service_Shutdown (object, connection, message);
+	} else if (dbus_message_is_method_call (message, "org.gnome.Rygel1", "ChangeFriendlyName")) {
+		result = _dbus_rygel_dbus_service_ChangeFriendlyName (object, connection, message);
 	}
 	if (result == DBUS_HANDLER_RESULT_HANDLED) {
 		return result;
@@ -285,12 +488,79 @@ DBusHandlerResult rygel_dbus_service_dbu
 }
 
 
+static void _dbus_rygel_dbus_service_udn_changed (GObject* _sender, const char* new_udn, DBusConnection* _connection) {
+	const char * _path;
+	DBusMessage *_message;
+	DBusMessageIter _iter;
+	const char* _tmp3_;
+	_path = g_object_get_data (_sender, "dbus_object_path");
+	_message = dbus_message_new_signal (_path, "org.gnome.Rygel1", "UdnChanged");
+	dbus_message_iter_init_append (_message, &_iter);
+	_tmp3_ = new_udn;
+	dbus_message_iter_append_basic (&_iter, DBUS_TYPE_STRING, &_tmp3_);
+	dbus_connection_send (_connection, _message, NULL);
+	dbus_message_unref (_message);
+}
+
+
+static void _dbus_rygel_dbus_service_player_stopped (GObject* _sender, DBusConnection* _connection) {
+	const char * _path;
+	DBusMessage *_message;
+	DBusMessageIter _iter;
+	_path = g_object_get_data (_sender, "dbus_object_path");
+	_message = dbus_message_new_signal (_path, "org.gnome.Rygel1", "PlayerStopped");
+	dbus_message_iter_init_append (_message, &_iter);
+	dbus_connection_send (_connection, _message, NULL);
+	dbus_message_unref (_message);
+}
+
+
+static void _dbus_rygel_dbus_service_player_playing (GObject* _sender, const char* artist, const char* title, DBusConnection* _connection) {
+	const char * _path;
+	DBusMessage *_message;
+	DBusMessageIter _iter;
+	const char* _tmp4_;
+	const char* _tmp5_;
+	_path = g_object_get_data (_sender, "dbus_object_path");
+	_message = dbus_message_new_signal (_path, "org.gnome.Rygel1", "PlayerPlaying");
+	dbus_message_iter_init_append (_message, &_iter);
+	_tmp4_ = artist;
+	dbus_message_iter_append_basic (&_iter, DBUS_TYPE_STRING, &_tmp4_);
+	_tmp5_ = title;
+	dbus_message_iter_append_basic (&_iter, DBUS_TYPE_STRING, &_tmp5_);
+	dbus_connection_send (_connection, _message, NULL);
+	dbus_message_unref (_message);
+}
+
+
+static void _dbus_rygel_dbus_service_volume (GObject* _sender, guint volume, gboolean mute, DBusConnection* _connection) {
+	const char * _path;
+	DBusMessage *_message;
+	DBusMessageIter _iter;
+	dbus_uint32_t _tmp6_;
+	dbus_bool_t _tmp7_;
+	_path = g_object_get_data (_sender, "dbus_object_path");
+	_message = dbus_message_new_signal (_path, "org.gnome.Rygel1", "Volume");
+	dbus_message_iter_init_append (_message, &_iter);
+	_tmp6_ = volume;
+	dbus_message_iter_append_basic (&_iter, DBUS_TYPE_UINT32, &_tmp6_);
+	_tmp7_ = mute;
+	dbus_message_iter_append_basic (&_iter, DBUS_TYPE_BOOLEAN, &_tmp7_);
+	dbus_connection_send (_connection, _message, NULL);
+	dbus_message_unref (_message);
+}
+
+
 void rygel_dbus_service_dbus_register_object (DBusConnection* connection, const char* path, void* object) {
 	if (!g_object_get_data (object, "dbus_object_path")) {
 		g_object_set_data (object, "dbus_object_path", g_strdup (path));
 		dbus_connection_register_object_path (connection, path, &_rygel_dbus_service_dbus_path_vtable, object);
 		g_object_weak_ref (object, _vala_dbus_unregister_object, connection);
 	}
+	g_signal_connect (object, "udn-changed", (GCallback) _dbus_rygel_dbus_service_udn_changed, connection);
+	g_signal_connect (object, "player-stopped", (GCallback) _dbus_rygel_dbus_service_player_stopped, connection);
+	g_signal_connect (object, "player-playing", (GCallback) _dbus_rygel_dbus_service_player_playing, connection);
+	g_signal_connect (object, "volume", (GCallback) _dbus_rygel_dbus_service_volume, connection);
 }
 
 
@@ -298,6 +568,10 @@ static void rygel_dbus_service_class_ini
 	rygel_dbus_service_parent_class = g_type_class_peek_parent (klass);
 	g_type_class_add_private (klass, sizeof (RygelDBusServicePrivate));
 	G_OBJECT_CLASS (klass)->finalize = rygel_dbus_service_finalize;
+	g_signal_new ("udn_changed", RYGEL_TYPE_DBUS_SERVICE, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__STRING, G_TYPE_NONE, 1, G_TYPE_STRING);
+	g_signal_new ("player_stopped", RYGEL_TYPE_DBUS_SERVICE, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, 0);
+	g_signal_new ("player_playing", RYGEL_TYPE_DBUS_SERVICE, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_user_marshal_VOID__STRING_STRING, G_TYPE_NONE, 2, G_TYPE_STRING, G_TYPE_STRING);
+	g_signal_new ("volume", RYGEL_TYPE_DBUS_SERVICE, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_user_marshal_VOID__UINT_BOOLEAN, G_TYPE_NONE, 2, G_TYPE_UINT, G_TYPE_BOOLEAN);
 	g_type_set_qdata (RYGEL_TYPE_DBUS_SERVICE, g_quark_from_static_string ("DBusObjectVTable"), (void*) (&_rygel_dbus_service_dbus_vtable));
 	rygel_dbus_service_RYGEL_SERVICE = g_strdup ("org.gnome.Rygel1");
 	rygel_dbus_service_RYGEL_PATH = g_strdup ("/org/gnome/Rygel1");
@@ -327,6 +601,17 @@ GType rygel_dbus_service_get_type (void)
 }
 
 
+static int _vala_strcmp0 (const char * str1, const char * str2) {
+	if (str1 == NULL) {
+		return -(str1 != str2);
+	}
+	if (str2 == NULL) {
+		return str1 != str2;
+	}
+	return strcmp (str1, str2);
+}
+
+
 static void _vala_dbus_register_object (DBusConnection* connection, const char* path, void* object) {
 	const _DBusObjectVTable * vtable;
 	vtable = g_type_get_qdata (G_TYPE_FROM_INSTANCE (object), g_quark_from_static_string ("DBusObjectVTable"));
@@ -347,4 +632,42 @@ static void _vala_dbus_unregister_object
 
 
 
+static void g_cclosure_user_marshal_VOID__STRING_STRING (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data) {
+	typedef void (*GMarshalFunc_VOID__STRING_STRING) (gpointer data1, const char* arg_1, const char* arg_2, gpointer data2);
+	register GMarshalFunc_VOID__STRING_STRING callback;
+	register GCClosure * cc;
+	register gpointer data1, data2;
+	cc = (GCClosure *) closure;
+	g_return_if_fail (n_param_values == 3);
+	if (G_CCLOSURE_SWAP_DATA (closure)) {
+		data1 = closure->data;
+		data2 = param_values->data[0].v_pointer;
+	} else {
+		data1 = param_values->data[0].v_pointer;
+		data2 = closure->data;
+	}
+	callback = (GMarshalFunc_VOID__STRING_STRING) (marshal_data ? marshal_data : cc->callback);
+	callback (data1, g_value_get_string (param_values + 1), g_value_get_string (param_values + 2), data2);
+}
+
+
+static void g_cclosure_user_marshal_VOID__UINT_BOOLEAN (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data) {
+	typedef void (*GMarshalFunc_VOID__UINT_BOOLEAN) (gpointer data1, guint arg_1, gboolean arg_2, gpointer data2);
+	register GMarshalFunc_VOID__UINT_BOOLEAN callback;
+	register GCClosure * cc;
+	register gpointer data1, data2;
+	cc = (GCClosure *) closure;
+	g_return_if_fail (n_param_values == 3);
+	if (G_CCLOSURE_SWAP_DATA (closure)) {
+		data1 = closure->data;
+		data2 = param_values->data[0].v_pointer;
+	} else {
+		data1 = param_values->data[0].v_pointer;
+		data2 = closure->data;
+	}
+	callback = (GMarshalFunc_VOID__UINT_BOOLEAN) (marshal_data ? marshal_data : cc->callback);
+	callback (data1, g_value_get_uint (param_values + 1), g_value_get_boolean (param_values + 2), data2);
+}
+
+
 
--- a/src/rygel/rygel-didl-lite-writer.c
+++ b/src/rygel/rygel-didl-lite-writer.c
@@ -30,7 +30,6 @@
 #include <stdlib.h>
 #include <string.h>
 #include <gee.h>
-#include <gst/gst.h>
 #include <gio/gio.h>
 #include <libgupnp/gupnp.h>
 #include <libgssdp/gssdp.h>
@@ -47,16 +46,6 @@ typedef struct _RygelDIDLLiteWriter Ryge
 typedef struct _RygelDIDLLiteWriterClass RygelDIDLLiteWriterClass;
 typedef struct _RygelDIDLLiteWriterPrivate RygelDIDLLiteWriterPrivate;
 
-#define RYGEL_TYPE_TRANSCODE_MANAGER (rygel_transcode_manager_get_type ())
-#define RYGEL_TRANSCODE_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_TRANSCODE_MANAGER, RygelTranscodeManager))
-#define RYGEL_TRANSCODE_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_TRANSCODE_MANAGER, RygelTranscodeManagerClass))
-#define RYGEL_IS_TRANSCODE_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_TRANSCODE_MANAGER))
-#define RYGEL_IS_TRANSCODE_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_TRANSCODE_MANAGER))
-#define RYGEL_TRANSCODE_MANAGER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_TRANSCODE_MANAGER, RygelTranscodeManagerClass))
-
-typedef struct _RygelTranscodeManager RygelTranscodeManager;
-typedef struct _RygelTranscodeManagerClass RygelTranscodeManagerClass;
-
 #define RYGEL_TYPE_HTTP_SERVER (rygel_http_server_get_type ())
 #define RYGEL_HTTP_SERVER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_HTTP_SERVER, RygelHTTPServer))
 #define RYGEL_HTTP_SERVER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_HTTP_SERVER, RygelHTTPServerClass))
@@ -119,7 +108,6 @@ typedef struct _RygelIconInfoClass Rygel
 
 typedef struct _RygelThumbnail RygelThumbnail;
 typedef struct _RygelThumbnailClass RygelThumbnailClass;
-typedef struct _RygelTranscodeManagerPrivate RygelTranscodeManagerPrivate;
 
 #define RYGEL_TYPE_STATE_MACHINE (rygel_state_machine_get_type ())
 #define RYGEL_STATE_MACHINE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_STATE_MACHINE, RygelStateMachine))
@@ -189,23 +177,9 @@ struct _RygelMediaItem {
 
 struct _RygelMediaItemClass {
 	RygelMediaObjectClass parent_class;
-	GstElement* (*create_stream_source) (RygelMediaItem* self);
 	gboolean (*should_stream) (RygelMediaItem* self);
 };
 
-struct _RygelTranscodeManager {
-	GObject parent_instance;
-	RygelTranscodeManagerPrivate * priv;
-};
-
-struct _RygelTranscodeManagerClass {
-	GObjectClass parent_class;
-	char* (*create_uri_for_item) (RygelTranscodeManager* self, RygelMediaItem* item, gint thumbnail_index, const char* transcode_target, char** protocol);
-	void (*add_resources) (RygelTranscodeManager* self, GUPnPDIDLLiteItem* didl_item, RygelMediaItem* item, GError** error);
-	char* (*get_protocol) (RygelTranscodeManager* self);
-	char* (*get_protocol_info) (RygelTranscodeManager* self);
-};
-
 struct _RygelStateMachineIface {
 	GTypeInterface parent_iface;
 	void (*run) (RygelStateMachine* self);
@@ -214,14 +188,14 @@ struct _RygelStateMachineIface {
 };
 
 struct _RygelHTTPServer {
-	RygelTranscodeManager parent_instance;
+	GObject parent_instance;
 	RygelHTTPServerPrivate * priv;
 	RygelMediaContainer* root_container;
 	GUPnPContext* context;
 };
 
 struct _RygelHTTPServerClass {
-	RygelTranscodeManagerClass parent_class;
+	GObjectClass parent_class;
 };
 
 struct _RygelMediaContainer {
@@ -244,7 +218,6 @@ static gpointer rygel_didl_lite_writer_p
 
 GQuark rygel_didl_lite_writer_error_quark (void);
 GType rygel_didl_lite_writer_get_type (void);
-GType rygel_transcode_manager_get_type (void);
 GType rygel_http_server_get_type (void);
 #define RYGEL_DIDL_LITE_WRITER_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), RYGEL_TYPE_DIDL_LITE_WRITER, RygelDIDLLiteWriterPrivate))
 enum  {
@@ -267,7 +240,7 @@ GType rygel_icon_info_get_type (void);
 GType rygel_thumbnail_get_type (void);
 #define RYGEL_MEDIA_ITEM_VIDEO_CLASS "object.item.videoItem"
 #define RYGEL_MEDIA_ITEM_MUSIC_CLASS "object.item.audioItem.musicTrack"
-void rygel_transcode_manager_add_resources (RygelTranscodeManager* self, GUPnPDIDLLiteItem* didl_item, RygelMediaItem* item, GError** error);
+void rygel_http_server_add_resources (RygelHTTPServer* self, GUPnPDIDLLiteItem* didl_item, RygelMediaItem* item, GError** error);
 GType rygel_state_machine_get_type (void);
 void rygel_media_item_add_resources (RygelMediaItem* self, GUPnPDIDLLiteItem* didl_item, gboolean allow_internal, GError** error);
 static void rygel_didl_lite_writer_finalize (GObject* obj);
@@ -384,7 +357,7 @@ static void rygel_didl_lite_writer_seria
 	if (_tmp2_) {
 		gupnp_didl_lite_object_set_date ((GUPnPDIDLLiteObject*) didl_item, item->date);
 	}
-	rygel_transcode_manager_add_resources ((RygelTranscodeManager*) self->priv->http_server, didl_item, item, &_inner_error_);
+	rygel_http_server_add_resources (self->priv->http_server, didl_item, item, &_inner_error_);
 	if (_inner_error_ != NULL) {
 		g_propagate_error (error, _inner_error_);
 		_g_object_unref0 (didl_item);
--- a/src/rygel/rygel-http-identity-handler.c
+++ b/src/rygel/rygel-http-identity-handler.c
@@ -32,7 +32,6 @@
 #include <stdlib.h>
 #include <string.h>
 #include <gee.h>
-#include <gst/gst.h>
 
 
 #define RYGEL_TYPE_HTTP_REQUEST_HANDLER (rygel_http_request_handler_get_type ())
@@ -86,16 +85,6 @@ typedef struct _RygelStateMachine RygelS
 typedef struct _RygelStateMachineIface RygelStateMachineIface;
 typedef struct _RygelHTTPRequestPrivate RygelHTTPRequestPrivate;
 
-#define RYGEL_TYPE_TRANSCODE_MANAGER (rygel_transcode_manager_get_type ())
-#define RYGEL_TRANSCODE_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_TRANSCODE_MANAGER, RygelTranscodeManager))
-#define RYGEL_TRANSCODE_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_TRANSCODE_MANAGER, RygelTranscodeManagerClass))
-#define RYGEL_IS_TRANSCODE_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_TRANSCODE_MANAGER))
-#define RYGEL_IS_TRANSCODE_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_TRANSCODE_MANAGER))
-#define RYGEL_TRANSCODE_MANAGER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_TRANSCODE_MANAGER, RygelTranscodeManagerClass))
-
-typedef struct _RygelTranscodeManager RygelTranscodeManager;
-typedef struct _RygelTranscodeManagerClass RygelTranscodeManagerClass;
-
 #define RYGEL_TYPE_HTTP_SERVER (rygel_http_server_get_type ())
 #define RYGEL_HTTP_SERVER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_HTTP_SERVER, RygelHTTPServer))
 #define RYGEL_HTTP_SERVER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_HTTP_SERVER, RygelHTTPServerClass))
@@ -145,16 +134,6 @@ typedef struct _RygelIconInfoClass Rygel
 
 typedef struct _RygelThumbnail RygelThumbnail;
 typedef struct _RygelThumbnailClass RygelThumbnailClass;
-
-#define RYGEL_TYPE_HTTP_SEEK (rygel_http_seek_get_type ())
-#define RYGEL_HTTP_SEEK(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_HTTP_SEEK, RygelHTTPSeek))
-#define RYGEL_HTTP_SEEK_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_HTTP_SEEK, RygelHTTPSeekClass))
-#define RYGEL_IS_HTTP_SEEK(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_HTTP_SEEK))
-#define RYGEL_IS_HTTP_SEEK_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_HTTP_SEEK))
-#define RYGEL_HTTP_SEEK_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_HTTP_SEEK, RygelHTTPSeekClass))
-
-typedef struct _RygelHTTPSeek RygelHTTPSeek;
-typedef struct _RygelHTTPSeekClass RygelHTTPSeekClass;
 typedef struct _RygelIconInfoPrivate RygelIconInfoPrivate;
 #define _g_free0(var) (var = (g_free (var), NULL))
 typedef struct _RygelMediaObjectPrivate RygelMediaObjectPrivate;
@@ -169,30 +148,8 @@ typedef struct _RygelMediaObjectPrivate
 typedef struct _RygelMediaContainer RygelMediaContainer;
 typedef struct _RygelMediaContainerClass RygelMediaContainerClass;
 typedef struct _RygelMediaItemPrivate RygelMediaItemPrivate;
-typedef struct _RygelThumbnailPrivate RygelThumbnailPrivate;
-
-#define RYGEL_TYPE_SEEKABLE_RESPONSE (rygel_seekable_response_get_type ())
-#define RYGEL_SEEKABLE_RESPONSE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_SEEKABLE_RESPONSE, RygelSeekableResponse))
-#define RYGEL_SEEKABLE_RESPONSE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_SEEKABLE_RESPONSE, RygelSeekableResponseClass))
-#define RYGEL_IS_SEEKABLE_RESPONSE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_SEEKABLE_RESPONSE))
-#define RYGEL_IS_SEEKABLE_RESPONSE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_SEEKABLE_RESPONSE))
-#define RYGEL_SEEKABLE_RESPONSE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_SEEKABLE_RESPONSE, RygelSeekableResponseClass))
-
-typedef struct _RygelSeekableResponse RygelSeekableResponse;
-typedef struct _RygelSeekableResponseClass RygelSeekableResponseClass;
-#define _gst_object_unref0(var) ((var == NULL) ? NULL : (var = (gst_object_unref (var), NULL)))
 #define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
 
-#define RYGEL_TYPE_LIVE_RESPONSE (rygel_live_response_get_type ())
-#define RYGEL_LIVE_RESPONSE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_LIVE_RESPONSE, RygelLiveResponse))
-#define RYGEL_LIVE_RESPONSE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_LIVE_RESPONSE, RygelLiveResponseClass))
-#define RYGEL_IS_LIVE_RESPONSE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_LIVE_RESPONSE))
-#define RYGEL_IS_LIVE_RESPONSE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_LIVE_RESPONSE))
-#define RYGEL_LIVE_RESPONSE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_LIVE_RESPONSE, RygelLiveResponseClass))
-
-typedef struct _RygelLiveResponse RygelLiveResponse;
-typedef struct _RygelLiveResponseClass RygelLiveResponseClass;
-
 typedef enum  {
 	RYGEL_HTTP_REQUEST_ERROR_UNACCEPTABLE = SOUP_STATUS_NOT_ACCEPTABLE,
 	RYGEL_HTTP_REQUEST_ERROR_BAD_REQUEST = SOUP_STATUS_BAD_REQUEST,
@@ -235,8 +192,6 @@ struct _RygelHTTPRequest {
 	SoupMessage* msg;
 	RygelMediaItem* item;
 	RygelThumbnail* thumbnail;
-	RygelHTTPSeek* byte_range;
-	RygelHTTPSeek* time_range;
 };
 
 struct _RygelHTTPRequestClass {
@@ -301,21 +256,9 @@ struct _RygelMediaItem {
 
 struct _RygelMediaItemClass {
 	RygelMediaObjectClass parent_class;
-	GstElement* (*create_stream_source) (RygelMediaItem* self);
 	gboolean (*should_stream) (RygelMediaItem* self);
 };
 
-struct _RygelThumbnail {
-	RygelIconInfo parent_instance;
-	RygelThumbnailPrivate * priv;
-	char* uri;
-	char* dlna_profile;
-};
-
-struct _RygelThumbnailClass {
-	RygelIconInfoClass parent_class;
-};
-
 
 static gpointer rygel_http_identity_handler_parent_class = NULL;
 
@@ -332,7 +275,6 @@ void rygel_http_request_handler_set_canc
 RygelHTTPIdentityHandler* rygel_http_identity_handler_new (GCancellable* cancellable);
 RygelHTTPIdentityHandler* rygel_http_identity_handler_construct (GType object_type, GCancellable* cancellable);
 GType rygel_state_machine_get_type (void);
-GType rygel_transcode_manager_get_type (void);
 GType rygel_http_server_get_type (void);
 GType rygel_media_object_get_type (void);
 GType rygel_media_item_get_type (void);
@@ -343,22 +285,12 @@ void rygel_value_set_icon_info (GValue*
 gpointer rygel_value_get_icon_info (const GValue* value);
 GType rygel_icon_info_get_type (void);
 GType rygel_thumbnail_get_type (void);
-GType rygel_http_seek_get_type (void);
 GType rygel_media_container_get_type (void);
 gboolean rygel_media_item_should_stream (RygelMediaItem* self);
-void rygel_http_seek_add_response_header (RygelHTTPSeek* self, SoupMessage* msg, gint64 length);
 void rygel_http_request_handler_add_response_headers (RygelHTTPRequestHandler* self, RygelHTTPRequest* request, GError** error);
 static void rygel_http_identity_handler_real_add_response_headers (RygelHTTPRequestHandler* base, RygelHTTPRequest* request, GError** error);
-GCancellable* rygel_http_request_handler_get_cancellable (RygelHTTPRequestHandler* self);
-RygelSeekableResponse* rygel_seekable_response_new (SoupServer* server, SoupMessage* msg, const char* uri, RygelHTTPSeek* seek, gsize file_length, GCancellable* cancellable);
-RygelSeekableResponse* rygel_seekable_response_construct (GType object_type, SoupServer* server, SoupMessage* msg, const char* uri, RygelHTTPSeek* seek, gsize file_length, GCancellable* cancellable);
-GType rygel_seekable_response_get_type (void);
-GstElement* rygel_media_item_create_stream_source (RygelMediaItem* self);
-RygelLiveResponse* rygel_live_response_new (SoupServer* server, SoupMessage* msg, const char* name, GstElement* src, RygelHTTPSeek* time_range, GCancellable* cancellable, GError** error);
-RygelLiveResponse* rygel_live_response_construct (GType object_type, SoupServer* server, SoupMessage* msg, const char* name, GstElement* src, RygelHTTPSeek* time_range, GCancellable* cancellable, GError** error);
-GType rygel_live_response_get_type (void);
 static RygelHTTPResponse* rygel_http_identity_handler_real_render_body (RygelHTTPRequestHandler* base, RygelHTTPRequest* request, GError** error);
-char* rygel_transcode_manager_get_protocol (RygelTranscodeManager* self);
+char* rygel_http_server_get_protocol (RygelHTTPServer* self);
 GUPnPDIDLLiteResource* rygel_thumbnail_add_resource (RygelThumbnail* self, GUPnPDIDLLiteItem* didl_item, const char* protocol);
 GUPnPDIDLLiteResource* rygel_media_item_add_resource (RygelMediaItem* self, GUPnPDIDLLiteItem* didl_item, const char* uri, const char* protocol, GError** error);
 static GUPnPDIDLLiteResource* rygel_http_identity_handler_real_add_resource (RygelHTTPRequestHandler* base, GUPnPDIDLLiteItem* didl_item, RygelHTTPRequest* request, GError** error);
@@ -407,14 +339,7 @@ static void rygel_http_identity_handler_
 		_tmp2_ = FALSE;
 	}
 	if (_tmp2_) {
-		if (request->time_range != NULL) {
-			rygel_http_seek_add_response_header (request->time_range, request->msg, (gint64) request->item->duration);
-		}
 	} else {
-		soup_message_headers_append (request->msg->response_headers, "Accept-Ranges", "bytes");
-		if (request->byte_range != NULL) {
-			rygel_http_seek_add_response_header (request->byte_range, request->msg, (gint64) size);
-		}
 	}
 	RYGEL_HTTP_REQUEST_HANDLER_CLASS (rygel_http_identity_handler_parent_class)->add_response_headers (RYGEL_HTTP_REQUEST_HANDLER (self), request, &_inner_error_);
 	if (_inner_error_ != NULL) {
@@ -424,7 +349,7 @@ static void rygel_http_identity_handler_
 			return;
 		} else {
 			_g_free0 (mime_type);
-			g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
+			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
 			g_clear_error (&_inner_error_);
 			return;
 		}
@@ -447,53 +372,34 @@ static RygelHTTPResponse* rygel_http_ide
 	g_return_val_if_fail (request != NULL, NULL);
 	_inner_error_ = NULL;
 	if (request->thumbnail != NULL) {
-		result = (RygelHTTPResponse*) rygel_seekable_response_new (request->server, request->msg, request->thumbnail->uri, request->byte_range, (gsize) ((RygelIconInfo*) request->thumbnail)->size, rygel_http_request_handler_get_cancellable ((RygelHTTPRequestHandler*) self));
-		return result;
+		_inner_error_ = g_error_new_literal (RYGEL_HTTP_REQUEST_ERROR, RYGEL_HTTP_REQUEST_ERROR_NOT_FOUND, "Not found");
+		if (_inner_error_ != NULL) {
+			if (_inner_error_->domain == RYGEL_HTTP_REQUEST_ERROR) {
+				g_propagate_error (error, _inner_error_);
+				return NULL;
+			} else {
+				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
+				g_clear_error (&_inner_error_);
+				return NULL;
+			}
+		}
 	}
 	item = _g_object_ref0 (request->item);
 	if (rygel_media_item_should_stream (item)) {
-		GstElement* src;
-		RygelLiveResponse* _tmp0_;
-		src = rygel_media_item_create_stream_source (item);
-		if (src == NULL) {
-			_inner_error_ = g_error_new_literal (RYGEL_HTTP_REQUEST_ERROR, RYGEL_HTTP_REQUEST_ERROR_NOT_FOUND, "Not found");
-			if (_inner_error_ != NULL) {
-				if (_inner_error_->domain == RYGEL_HTTP_REQUEST_ERROR) {
-					g_propagate_error (error, _inner_error_);
-					_gst_object_unref0 (src);
-					_g_object_unref0 (item);
-					return NULL;
-				} else {
-					_gst_object_unref0 (src);
-					_g_object_unref0 (item);
-					g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
-					g_clear_error (&_inner_error_);
-					return NULL;
-				}
-			}
-		}
-		_tmp0_ = rygel_live_response_new (request->server, request->msg, "RygelLiveResponse", src, request->time_range, rygel_http_request_handler_get_cancellable ((RygelHTTPRequestHandler*) self), &_inner_error_);
+		_inner_error_ = g_error_new_literal (RYGEL_HTTP_REQUEST_ERROR, RYGEL_HTTP_REQUEST_ERROR_NOT_FOUND, "Not found");
 		if (_inner_error_ != NULL) {
 			if (_inner_error_->domain == RYGEL_HTTP_REQUEST_ERROR) {
 				g_propagate_error (error, _inner_error_);
-				_gst_object_unref0 (src);
 				_g_object_unref0 (item);
 				return NULL;
 			} else {
-				_gst_object_unref0 (src);
 				_g_object_unref0 (item);
-				g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
+				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
 				g_clear_error (&_inner_error_);
 				return NULL;
 			}
 		}
-		result = (RygelHTTPResponse*) _tmp0_;
-		_gst_object_unref0 (src);
-		_g_object_unref0 (item);
-		return result;
 	} else {
-		char* _tmp1_;
-		RygelHTTPResponse* _tmp2_;
 		if (gee_collection_get_size ((GeeCollection*) ((RygelMediaObject*) item)->uris) == 0) {
 			_inner_error_ = g_error_new (RYGEL_HTTP_REQUEST_ERROR, RYGEL_HTTP_REQUEST_ERROR_NOT_FOUND, "Requested item '%s' didn't provide a URI\n", ((RygelMediaObject*) item)->id);
 			if (_inner_error_ != NULL) {
@@ -503,15 +409,25 @@ static RygelHTTPResponse* rygel_http_ide
 					return NULL;
 				} else {
 					_g_object_unref0 (item);
-					g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
+					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
 					g_clear_error (&_inner_error_);
 					return NULL;
 				}
 			}
 		}
-		result = (_tmp2_ = (RygelHTTPResponse*) rygel_seekable_response_new (request->server, request->msg, _tmp1_ = (char*) gee_abstract_list_get ((GeeAbstractList*) ((RygelMediaObject*) item)->uris, 0), request->byte_range, (gsize) item->size, rygel_http_request_handler_get_cancellable ((RygelHTTPRequestHandler*) self)), _g_free0 (_tmp1_), _tmp2_);
-		_g_object_unref0 (item);
-		return result;
+		_inner_error_ = g_error_new_literal (RYGEL_HTTP_REQUEST_ERROR, RYGEL_HTTP_REQUEST_ERROR_NOT_FOUND, "Not found");
+		if (_inner_error_ != NULL) {
+			if (_inner_error_->domain == RYGEL_HTTP_REQUEST_ERROR) {
+				g_propagate_error (error, _inner_error_);
+				_g_object_unref0 (item);
+				return NULL;
+			} else {
+				_g_object_unref0 (item);
+				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
+				g_clear_error (&_inner_error_);
+				return NULL;
+			}
+		}
 	}
 	_g_object_unref0 (item);
 }
@@ -526,7 +442,7 @@ static GUPnPDIDLLiteResource* rygel_http
 	g_return_val_if_fail (didl_item != NULL, NULL);
 	g_return_val_if_fail (request != NULL, NULL);
 	_inner_error_ = NULL;
-	protocol = rygel_transcode_manager_get_protocol ((RygelTranscodeManager*) request->http_server);
+	protocol = rygel_http_server_get_protocol (request->http_server);
 	if (request->thumbnail != NULL) {
 		result = rygel_thumbnail_add_resource (request->thumbnail, didl_item, protocol);
 		_g_free0 (protocol);
@@ -541,7 +457,7 @@ static GUPnPDIDLLiteResource* rygel_http
 				return NULL;
 			} else {
 				_g_free0 (protocol);
-				g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
+				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
 				g_clear_error (&_inner_error_);
 				return NULL;
 			}
--- a/src/rygel/rygel-http-request-handler.c
+++ b/src/rygel/rygel-http-request-handler.c
@@ -74,16 +74,6 @@ typedef struct _RygelStateMachine RygelS
 typedef struct _RygelStateMachineIface RygelStateMachineIface;
 typedef struct _RygelHTTPRequestPrivate RygelHTTPRequestPrivate;
 
-#define RYGEL_TYPE_TRANSCODE_MANAGER (rygel_transcode_manager_get_type ())
-#define RYGEL_TRANSCODE_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_TRANSCODE_MANAGER, RygelTranscodeManager))
-#define RYGEL_TRANSCODE_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_TRANSCODE_MANAGER, RygelTranscodeManagerClass))
-#define RYGEL_IS_TRANSCODE_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_TRANSCODE_MANAGER))
-#define RYGEL_IS_TRANSCODE_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_TRANSCODE_MANAGER))
-#define RYGEL_TRANSCODE_MANAGER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_TRANSCODE_MANAGER, RygelTranscodeManagerClass))
-
-typedef struct _RygelTranscodeManager RygelTranscodeManager;
-typedef struct _RygelTranscodeManagerClass RygelTranscodeManagerClass;
-
 #define RYGEL_TYPE_HTTP_SERVER (rygel_http_server_get_type ())
 #define RYGEL_HTTP_SERVER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_HTTP_SERVER, RygelHTTPServer))
 #define RYGEL_HTTP_SERVER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_HTTP_SERVER, RygelHTTPServerClass))
@@ -133,16 +123,6 @@ typedef struct _RygelIconInfoClass Rygel
 
 typedef struct _RygelThumbnail RygelThumbnail;
 typedef struct _RygelThumbnailClass RygelThumbnailClass;
-
-#define RYGEL_TYPE_HTTP_SEEK (rygel_http_seek_get_type ())
-#define RYGEL_HTTP_SEEK(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_HTTP_SEEK, RygelHTTPSeek))
-#define RYGEL_HTTP_SEEK_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_HTTP_SEEK, RygelHTTPSeekClass))
-#define RYGEL_IS_HTTP_SEEK(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_HTTP_SEEK))
-#define RYGEL_IS_HTTP_SEEK_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_HTTP_SEEK))
-#define RYGEL_HTTP_SEEK_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_HTTP_SEEK, RygelHTTPSeekClass))
-
-typedef struct _RygelHTTPSeek RygelHTTPSeek;
-typedef struct _RygelHTTPSeekClass RygelHTTPSeekClass;
 #define _g_free0(var) (var = (g_free (var), NULL))
 
 typedef enum  {
@@ -182,8 +162,6 @@ struct _RygelHTTPRequest {
 	SoupMessage* msg;
 	RygelMediaItem* item;
 	RygelThumbnail* thumbnail;
-	RygelHTTPSeek* byte_range;
-	RygelHTTPSeek* time_range;
 };
 
 struct _RygelHTTPRequestClass {
@@ -203,7 +181,6 @@ enum  {
 	RYGEL_HTTP_REQUEST_HANDLER_CANCELLABLE
 };
 GType rygel_state_machine_get_type (void);
-GType rygel_transcode_manager_get_type (void);
 GType rygel_http_server_get_type (void);
 GType rygel_media_object_get_type (void);
 GType rygel_media_item_get_type (void);
@@ -214,7 +191,6 @@ void rygel_value_set_icon_info (GValue*
 gpointer rygel_value_get_icon_info (const GValue* value);
 GType rygel_icon_info_get_type (void);
 GType rygel_thumbnail_get_type (void);
-GType rygel_http_seek_get_type (void);
 GUPnPDIDLLiteResource* rygel_http_request_handler_add_resource (RygelHTTPRequestHandler* self, GUPnPDIDLLiteItem* didl_item, RygelHTTPRequest* request, GError** error);
 void rygel_http_request_handler_add_response_headers (RygelHTTPRequestHandler* self, RygelHTTPRequest* request, GError** error);
 static void rygel_http_request_handler_real_add_response_headers (RygelHTTPRequestHandler* self, RygelHTTPRequest* request, GError** error);
@@ -267,7 +243,7 @@ static void rygel_http_request_handler_r
 			_g_free0 (mode);
 			_g_object_unref0 (didl_writer);
 			_g_object_unref0 (didl_item);
-			g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
+			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
 			g_clear_error (&_inner_error_);
 			return;
 		}
--- a/src/rygel/rygel-http-request.c
+++ b/src/rygel/rygel-http-request.c
@@ -32,10 +32,8 @@
 #include <gio/gio.h>
 #include <stdlib.h>
 #include <string.h>
-#include <libgupnp-av/gupnp-av.h>
 #include <libgupnp/gupnp.h>
 #include <gee.h>
-#include <gst/gst.h>
 
 
 #define RYGEL_TYPE_STATE_MACHINE (rygel_state_machine_get_type ())
@@ -57,16 +55,6 @@ typedef struct _RygelHTTPRequest RygelHT
 typedef struct _RygelHTTPRequestClass RygelHTTPRequestClass;
 typedef struct _RygelHTTPRequestPrivate RygelHTTPRequestPrivate;
 
-#define RYGEL_TYPE_TRANSCODE_MANAGER (rygel_transcode_manager_get_type ())
-#define RYGEL_TRANSCODE_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_TRANSCODE_MANAGER, RygelTranscodeManager))
-#define RYGEL_TRANSCODE_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_TRANSCODE_MANAGER, RygelTranscodeManagerClass))
-#define RYGEL_IS_TRANSCODE_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_TRANSCODE_MANAGER))
-#define RYGEL_IS_TRANSCODE_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_TRANSCODE_MANAGER))
-#define RYGEL_TRANSCODE_MANAGER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_TRANSCODE_MANAGER, RygelTranscodeManagerClass))
-
-typedef struct _RygelTranscodeManager RygelTranscodeManager;
-typedef struct _RygelTranscodeManagerClass RygelTranscodeManagerClass;
-
 #define RYGEL_TYPE_HTTP_SERVER (rygel_http_server_get_type ())
 #define RYGEL_HTTP_SERVER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_HTTP_SERVER, RygelHTTPServer))
 #define RYGEL_HTTP_SERVER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_HTTP_SERVER, RygelHTTPServerClass))
@@ -117,16 +105,6 @@ typedef struct _RygelIconInfoClass Rygel
 typedef struct _RygelThumbnail RygelThumbnail;
 typedef struct _RygelThumbnailClass RygelThumbnailClass;
 
-#define RYGEL_TYPE_HTTP_SEEK (rygel_http_seek_get_type ())
-#define RYGEL_HTTP_SEEK(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_HTTP_SEEK, RygelHTTPSeek))
-#define RYGEL_HTTP_SEEK_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_HTTP_SEEK, RygelHTTPSeekClass))
-#define RYGEL_IS_HTTP_SEEK(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_HTTP_SEEK))
-#define RYGEL_IS_HTTP_SEEK_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_HTTP_SEEK))
-#define RYGEL_HTTP_SEEK_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_HTTP_SEEK, RygelHTTPSeekClass))
-
-typedef struct _RygelHTTPSeek RygelHTTPSeek;
-typedef struct _RygelHTTPSeekClass RygelHTTPSeekClass;
-
 #define RYGEL_TYPE_MEDIA_CONTAINER (rygel_media_container_get_type ())
 #define RYGEL_MEDIA_CONTAINER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_MEDIA_CONTAINER, RygelMediaContainer))
 #define RYGEL_MEDIA_CONTAINER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_MEDIA_CONTAINER, RygelMediaContainerClass))
@@ -160,7 +138,6 @@ typedef struct _RygelHTTPRequestHandlerC
 #define _g_hash_table_unref0(var) ((var == NULL) ? NULL : (var = (g_hash_table_unref (var), NULL)))
 #define _g_free0(var) (var = (g_free (var), NULL))
 #define _rygel_icon_info_unref0(var) ((var == NULL) ? NULL : (var = (rygel_icon_info_unref (var), NULL)))
-typedef struct _RygelTranscodeManagerPrivate RygelTranscodeManagerPrivate;
 typedef struct _RygelHTTPServerPrivate RygelHTTPServerPrivate;
 #define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
 
@@ -176,26 +153,6 @@ typedef struct _RygelHTTPIdentityHandler
 typedef struct _RygelMediaObjectPrivate RygelMediaObjectPrivate;
 typedef struct _RygelMediaItemPrivate RygelMediaItemPrivate;
 
-#define RYGEL_TYPE_TRANSCODER (rygel_transcoder_get_type ())
-#define RYGEL_TRANSCODER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_TRANSCODER, RygelTranscoder))
-#define RYGEL_TRANSCODER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_TRANSCODER, RygelTranscoderClass))
-#define RYGEL_IS_TRANSCODER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_TRANSCODER))
-#define RYGEL_IS_TRANSCODER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_TRANSCODER))
-#define RYGEL_TRANSCODER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_TRANSCODER, RygelTranscoderClass))
-
-typedef struct _RygelTranscoder RygelTranscoder;
-typedef struct _RygelTranscoderClass RygelTranscoderClass;
-
-#define RYGEL_TYPE_HTTP_TRANSCODE_HANDLER (rygel_http_transcode_handler_get_type ())
-#define RYGEL_HTTP_TRANSCODE_HANDLER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_HTTP_TRANSCODE_HANDLER, RygelHTTPTranscodeHandler))
-#define RYGEL_HTTP_TRANSCODE_HANDLER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_HTTP_TRANSCODE_HANDLER, RygelHTTPTranscodeHandlerClass))
-#define RYGEL_IS_HTTP_TRANSCODE_HANDLER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_HTTP_TRANSCODE_HANDLER))
-#define RYGEL_IS_HTTP_TRANSCODE_HANDLER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_HTTP_TRANSCODE_HANDLER))
-#define RYGEL_HTTP_TRANSCODE_HANDLER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_HTTP_TRANSCODE_HANDLER, RygelHTTPTranscodeHandlerClass))
-
-typedef struct _RygelHTTPTranscodeHandler RygelHTTPTranscodeHandler;
-typedef struct _RygelHTTPTranscodeHandlerClass RygelHTTPTranscodeHandlerClass;
-
 typedef enum  {
 	RYGEL_HTTP_REQUEST_ERROR_UNACCEPTABLE = SOUP_STATUS_NOT_ACCEPTABLE,
 	RYGEL_HTTP_REQUEST_ERROR_BAD_REQUEST = SOUP_STATUS_BAD_REQUEST,
@@ -217,8 +174,6 @@ struct _RygelHTTPRequest {
 	SoupMessage* msg;
 	RygelMediaItem* item;
 	RygelThumbnail* thumbnail;
-	RygelHTTPSeek* byte_range;
-	RygelHTTPSeek* time_range;
 };
 
 struct _RygelHTTPRequestClass {
@@ -235,35 +190,17 @@ struct _RygelHTTPRequestPrivate {
 	RygelHTTPRequestHandler* request_handler;
 };
 
-struct _RygelTranscodeManager {
-	GObject parent_instance;
-	RygelTranscodeManagerPrivate * priv;
-};
-
-struct _RygelTranscodeManagerClass {
-	GObjectClass parent_class;
-	char* (*create_uri_for_item) (RygelTranscodeManager* self, RygelMediaItem* item, gint thumbnail_index, const char* transcode_target, char** protocol);
-	void (*add_resources) (RygelTranscodeManager* self, GUPnPDIDLLiteItem* didl_item, RygelMediaItem* item, GError** error);
-	char* (*get_protocol) (RygelTranscodeManager* self);
-	char* (*get_protocol_info) (RygelTranscodeManager* self);
-};
-
 struct _RygelHTTPServer {
-	RygelTranscodeManager parent_instance;
+	GObject parent_instance;
 	RygelHTTPServerPrivate * priv;
 	RygelMediaContainer* root_container;
 	GUPnPContext* context;
 };
 
 struct _RygelHTTPServerClass {
-	RygelTranscodeManagerClass parent_class;
+	GObjectClass parent_class;
 };
 
-typedef enum  {
-	RYGEL_HTTP_SEEK_ERROR_INVALID_RANGE = SOUP_STATUS_BAD_REQUEST,
-	RYGEL_HTTP_SEEK_ERROR_OUT_OF_RANGE = SOUP_STATUS_REQUESTED_RANGE_NOT_SATISFIABLE
-} RygelHTTPSeekError;
-#define RYGEL_HTTP_SEEK_ERROR rygel_http_seek_error_quark ()
 struct _RygelMediaObject {
 	GObject parent_instance;
 	RygelMediaObjectPrivate * priv;
@@ -305,7 +242,6 @@ struct _RygelMediaItem {
 
 struct _RygelMediaItemClass {
 	RygelMediaObjectClass parent_class;
-	GstElement* (*create_stream_source) (RygelMediaItem* self);
 	gboolean (*should_stream) (RygelMediaItem* self);
 };
 
@@ -316,7 +252,6 @@ static RygelStateMachineIface* rygel_htt
 GQuark rygel_http_request_error_quark (void);
 GType rygel_state_machine_get_type (void);
 GType rygel_http_request_get_type (void);
-GType rygel_transcode_manager_get_type (void);
 GType rygel_http_server_get_type (void);
 GType rygel_media_object_get_type (void);
 GType rygel_media_item_get_type (void);
@@ -327,7 +262,6 @@ void rygel_value_set_icon_info (GValue*
 gpointer rygel_value_get_icon_info (const GValue* value);
 GType rygel_icon_info_get_type (void);
 GType rygel_thumbnail_get_type (void);
-GType rygel_http_seek_get_type (void);
 GType rygel_media_container_get_type (void);
 GType rygel_http_response_get_type (void);
 GType rygel_http_request_handler_get_type (void);
@@ -351,22 +285,12 @@ static void _rygel_http_request_on_item_
 static void rygel_http_request_real_run (RygelStateMachine* base);
 void rygel_http_request_end (RygelHTTPRequest* self, guint status);
 static void rygel_http_request_on_response_completed (RygelHTTPRequest* self, RygelHTTPResponse* response);
-GQuark rygel_http_seek_error_quark (void);
-RygelHTTPSeek* rygel_http_seek_from_byte_range (SoupMessage* msg, GError** error);
-RygelHTTPSeek* rygel_http_seek_from_time_range (SoupMessage* msg, GError** error);
 void rygel_http_request_handler_add_response_headers (RygelHTTPRequestHandler* self, RygelHTTPRequest* request, GError** error);
-static void _lambda0_ (const char* name, const char* value, RygelHTTPRequest* self);
-static void __lambda0__soup_message_headers_foreach_func (const char* name, const char* value, gpointer self);
 RygelHTTPResponse* rygel_http_request_handler_render_body (RygelHTTPRequestHandler* self, RygelHTTPRequest* request, GError** error);
 static void _rygel_http_request_on_response_completed_rygel_state_machine_completed (RygelHTTPResponse* _sender, gpointer self);
 void rygel_http_response_run (RygelHTTPResponse* self);
 static void rygel_http_request_handle_item_request (RygelHTTPRequest* self);
 RygelMediaObject* rygel_media_container_find_object_finish (RygelMediaContainer* self, GAsyncResult* res, GError** error);
-GType rygel_transcoder_get_type (void);
-RygelTranscoder* rygel_transcode_manager_get_transcoder (RygelTranscodeManager* self, const char* target, GError** error);
-RygelHTTPTranscodeHandler* rygel_http_transcode_handler_new (RygelTranscoder* transcoder, GCancellable* cancellable);
-RygelHTTPTranscodeHandler* rygel_http_transcode_handler_construct (GType object_type, RygelTranscoder* transcoder, GCancellable* cancellable);
-GType rygel_http_transcode_handler_get_type (void);
 static void rygel_http_request_finalize (GObject* obj);
 static void rygel_http_request_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
 static void rygel_http_request_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);
@@ -473,14 +397,14 @@ static void rygel_http_request_real_run
 		err = _inner_error_;
 		_inner_error_ = NULL;
 		{
-			g_warning ("rygel-http-request.vala:87: Failed to parse query: %s", err->message);
+			g_warning ("rygel-http-request.vala:84: Failed to parse query: %s", err->message);
 			_g_error_free0 (err);
 		}
 	}
 	__finally22:
 	if (_inner_error_ != NULL) {
 		_g_free0 (header);
-		g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
+		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
 		g_clear_error (&_inner_error_);
 		return;
 	}
@@ -507,18 +431,6 @@ static void rygel_http_request_on_respon
 }
 
 
-static void _lambda0_ (const char* name, const char* value, RygelHTTPRequest* self) {
-	g_return_if_fail (name != NULL);
-	g_return_if_fail (value != NULL);
-	g_debug ("rygel-http-request.vala:118: %s : %s", name, value);
-}
-
-
-static void __lambda0__soup_message_headers_foreach_func (const char* name, const char* value, gpointer self) {
-	_lambda0_ (name, value, self);
-}
-
-
 static void _rygel_http_request_on_response_completed_rygel_state_machine_completed (RygelHTTPResponse* _sender, gpointer self) {
 	rygel_http_request_on_response_completed (self, _sender);
 }
@@ -529,45 +441,27 @@ static void rygel_http_request_handle_it
 	g_return_if_fail (self != NULL);
 	_inner_error_ = NULL;
 	{
-		RygelHTTPSeek* _tmp0_;
-		RygelHTTPSeek* _tmp1_;
-		RygelHTTPSeek* _tmp2_;
-		RygelHTTPSeek* _tmp3_;
-		char* _tmp5_;
-		char* _tmp4_ = NULL;
-		gboolean _tmp6_;
-		RygelHTTPResponse* _tmp7_;
-		RygelHTTPResponse* _tmp8_;
-		_tmp0_ = rygel_http_seek_from_byte_range (self->msg, &_inner_error_);
-		if (_inner_error_ != NULL) {
-			goto __catch23_g_error;
-			goto __finally23;
-		}
-		self->byte_range = (_tmp1_ = _tmp0_, _g_object_unref0 (self->byte_range), _tmp1_);
-		_tmp2_ = rygel_http_seek_from_time_range (self->msg, &_inner_error_);
-		if (_inner_error_ != NULL) {
-			goto __catch23_g_error;
-			goto __finally23;
-		}
-		self->time_range = (_tmp3_ = _tmp2_, _g_object_unref0 (self->time_range), _tmp3_);
+		char* _tmp1_;
+		char* _tmp0_ = NULL;
+		gboolean _tmp2_;
+		RygelHTTPResponse* _tmp3_;
+		RygelHTTPResponse* _tmp4_;
 		rygel_http_request_handler_add_response_headers (self->priv->request_handler, self, &_inner_error_);
 		if (_inner_error_ != NULL) {
 			goto __catch23_g_error;
 			goto __finally23;
 		}
-		g_debug ("rygel-http-request.vala:116: Following HTTP headers appended to response:");
-		soup_message_headers_foreach (self->msg->response_headers, __lambda0__soup_message_headers_foreach_func, self);
-		if ((_tmp6_ = _vala_strcmp0 (_tmp5_ = (g_object_get (self->msg, "method", &_tmp4_, NULL), _tmp4_), "HEAD") == 0, _g_free0 (_tmp5_), _tmp6_)) {
+		if ((_tmp2_ = _vala_strcmp0 (_tmp1_ = (g_object_get (self->msg, "method", &_tmp0_, NULL), _tmp0_), "HEAD") == 0, _g_free0 (_tmp1_), _tmp2_)) {
 			soup_server_unpause_message (self->server, self->msg);
 			rygel_http_request_end (self, (guint) SOUP_STATUS_OK);
 			return;
 		}
-		_tmp7_ = rygel_http_request_handler_render_body (self->priv->request_handler, self, &_inner_error_);
+		_tmp3_ = rygel_http_request_handler_render_body (self->priv->request_handler, self, &_inner_error_);
 		if (_inner_error_ != NULL) {
 			goto __catch23_g_error;
 			goto __finally23;
 		}
-		self->priv->response = (_tmp8_ = _tmp7_, _g_object_unref0 (self->priv->response), _tmp8_);
+		self->priv->response = (_tmp4_ = _tmp3_, _g_object_unref0 (self->priv->response), _tmp4_);
 		g_signal_connect_object ((RygelStateMachine*) self->priv->response, "completed", (GCallback) _rygel_http_request_on_response_completed_rygel_state_machine_completed, self, 0);
 		rygel_http_response_run (self->priv->response);
 	}
@@ -584,7 +478,7 @@ static void rygel_http_request_handle_it
 	}
 	__finally23:
 	if (_inner_error_ != NULL) {
-		g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
+		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
 		g_clear_error (&_inner_error_);
 		return;
 	}
@@ -630,7 +524,7 @@ static void rygel_http_request_on_item_f
 	if (_inner_error_ != NULL) {
 		_g_object_unref0 (container);
 		_g_object_unref0 (media_object);
-		g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
+		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
 		g_clear_error (&_inner_error_);
 		return;
 	}
@@ -659,35 +553,17 @@ static void rygel_http_request_on_item_f
 
 
 static void rygel_http_request_parse_query (RygelHTTPRequest* self, GError** error) {
-	GError * _inner_error_;
 	char* _tmp0_;
-	char* target;
 	char* index;
 	g_return_if_fail (self != NULL);
-	_inner_error_ = NULL;
 	if (self->priv->query == NULL) {
 		return;
 	}
 	self->priv->item_id = (_tmp0_ = g_strdup ((const char*) g_hash_table_lookup (self->priv->query, "itemid")), _g_free0 (self->priv->item_id), _tmp0_);
-	target = g_strdup ((const char*) g_hash_table_lookup (self->priv->query, "transcode"));
-	if (target != NULL) {
-		RygelTranscoder* transcoder;
-		RygelHTTPRequestHandler* _tmp1_;
-		g_debug ("rygel-http-request.vala:172: Transcoding target: %s", target);
-		transcoder = rygel_transcode_manager_get_transcoder ((RygelTranscodeManager*) self->http_server, target, &_inner_error_);
-		if (_inner_error_ != NULL) {
-			g_propagate_error (error, _inner_error_);
-			_g_free0 (target);
-			return;
-		}
-		self->priv->request_handler = (_tmp1_ = (RygelHTTPRequestHandler*) rygel_http_transcode_handler_new (transcoder, rygel_state_machine_get_cancellable ((RygelStateMachine*) self)), _g_object_unref0 (self->priv->request_handler), _tmp1_);
-		_g_object_unref0 (transcoder);
-	}
 	index = g_strdup ((const char*) g_hash_table_lookup (self->priv->query, "thumbnail"));
 	if (index != NULL) {
 		self->priv->thumbnail_index = atoi (index);
 	}
-	_g_free0 (target);
 	_g_free0 (index);
 }
 
@@ -695,7 +571,7 @@ static void rygel_http_request_parse_que
 static void rygel_http_request_handle_error (RygelHTTPRequest* self, GError* _error_) {
 	guint status = 0U;
 	g_return_if_fail (self != NULL);
-	g_warning ("rygel-http-request.vala:186: %s", _error_->message);
+	g_warning ("rygel-http-request.vala:168: %s", _error_->message);
 	if (_error_->domain == RYGEL_HTTP_REQUEST_ERROR) {
 		status = (guint) _error_->code;
 	} else {
@@ -768,8 +644,6 @@ static void rygel_http_request_finalize
 	_g_free0 (self->priv->item_id);
 	_g_object_unref0 (self->item);
 	_rygel_icon_info_unref0 (self->thumbnail);
-	_g_object_unref0 (self->byte_range);
-	_g_object_unref0 (self->time_range);
 	_g_object_unref0 (self->priv->request_handler);
 	G_OBJECT_CLASS (rygel_http_request_parent_class)->finalize (obj);
 }
--- a/src/rygel/rygel-http-server.c
+++ b/src/rygel/rygel-http-server.c
@@ -26,48 +26,16 @@
 
 #include <glib.h>
 #include <glib-object.h>
-#include <stdlib.h>
-#include <string.h>
-#include <libgupnp-av/gupnp-av.h>
 #include <gio/gio.h>
 #include <libgupnp/gupnp.h>
+#include <stdlib.h>
+#include <string.h>
 #include <gee.h>
 #include <libsoup/soup.h>
-#include <gst/gst.h>
+#include <libgupnp-av/gupnp-av.h>
 #include <libgssdp/gssdp.h>
 
 
-#define RYGEL_TYPE_TRANSCODE_MANAGER (rygel_transcode_manager_get_type ())
-#define RYGEL_TRANSCODE_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_TRANSCODE_MANAGER, RygelTranscodeManager))
-#define RYGEL_TRANSCODE_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_TRANSCODE_MANAGER, RygelTranscodeManagerClass))
-#define RYGEL_IS_TRANSCODE_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_TRANSCODE_MANAGER))
-#define RYGEL_IS_TRANSCODE_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_TRANSCODE_MANAGER))
-#define RYGEL_TRANSCODE_MANAGER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_TRANSCODE_MANAGER, RygelTranscodeManagerClass))
-
-typedef struct _RygelTranscodeManager RygelTranscodeManager;
-typedef struct _RygelTranscodeManagerClass RygelTranscodeManagerClass;
-typedef struct _RygelTranscodeManagerPrivate RygelTranscodeManagerPrivate;
-
-#define RYGEL_TYPE_MEDIA_OBJECT (rygel_media_object_get_type ())
-#define RYGEL_MEDIA_OBJECT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_MEDIA_OBJECT, RygelMediaObject))
-#define RYGEL_MEDIA_OBJECT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_MEDIA_OBJECT, RygelMediaObjectClass))
-#define RYGEL_IS_MEDIA_OBJECT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_MEDIA_OBJECT))
-#define RYGEL_IS_MEDIA_OBJECT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_MEDIA_OBJECT))
-#define RYGEL_MEDIA_OBJECT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_MEDIA_OBJECT, RygelMediaObjectClass))
-
-typedef struct _RygelMediaObject RygelMediaObject;
-typedef struct _RygelMediaObjectClass RygelMediaObjectClass;
-
-#define RYGEL_TYPE_MEDIA_ITEM (rygel_media_item_get_type ())
-#define RYGEL_MEDIA_ITEM(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_MEDIA_ITEM, RygelMediaItem))
-#define RYGEL_MEDIA_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_MEDIA_ITEM, RygelMediaItemClass))
-#define RYGEL_IS_MEDIA_ITEM(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_MEDIA_ITEM))
-#define RYGEL_IS_MEDIA_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_MEDIA_ITEM))
-#define RYGEL_MEDIA_ITEM_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_MEDIA_ITEM, RygelMediaItemClass))
-
-typedef struct _RygelMediaItem RygelMediaItem;
-typedef struct _RygelMediaItemClass RygelMediaItemClass;
-
 #define RYGEL_TYPE_STATE_MACHINE (rygel_state_machine_get_type ())
 #define RYGEL_STATE_MACHINE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_STATE_MACHINE, RygelStateMachine))
 #define RYGEL_IS_STATE_MACHINE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_STATE_MACHINE))
@@ -87,6 +55,16 @@ typedef struct _RygelHTTPServer RygelHTT
 typedef struct _RygelHTTPServerClass RygelHTTPServerClass;
 typedef struct _RygelHTTPServerPrivate RygelHTTPServerPrivate;
 
+#define RYGEL_TYPE_MEDIA_OBJECT (rygel_media_object_get_type ())
+#define RYGEL_MEDIA_OBJECT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_MEDIA_OBJECT, RygelMediaObject))
+#define RYGEL_MEDIA_OBJECT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_MEDIA_OBJECT, RygelMediaObjectClass))
+#define RYGEL_IS_MEDIA_OBJECT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_MEDIA_OBJECT))
+#define RYGEL_IS_MEDIA_OBJECT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_MEDIA_OBJECT))
+#define RYGEL_MEDIA_OBJECT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_MEDIA_OBJECT, RygelMediaObjectClass))
+
+typedef struct _RygelMediaObject RygelMediaObject;
+typedef struct _RygelMediaObjectClass RygelMediaObjectClass;
+
 #define RYGEL_TYPE_MEDIA_CONTAINER (rygel_media_container_get_type ())
 #define RYGEL_MEDIA_CONTAINER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_MEDIA_CONTAINER, RygelMediaContainer))
 #define RYGEL_MEDIA_CONTAINER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_MEDIA_CONTAINER, RygelMediaContainerClass))
@@ -119,6 +97,16 @@ typedef struct _RygelHTTPRequestClass Ry
 typedef struct _RygelContentDirectory RygelContentDirectory;
 typedef struct _RygelContentDirectoryClass RygelContentDirectoryClass;
 typedef struct _RygelContentDirectoryPrivate RygelContentDirectoryPrivate;
+
+#define RYGEL_TYPE_MEDIA_ITEM (rygel_media_item_get_type ())
+#define RYGEL_MEDIA_ITEM(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_MEDIA_ITEM, RygelMediaItem))
+#define RYGEL_MEDIA_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_MEDIA_ITEM, RygelMediaItemClass))
+#define RYGEL_IS_MEDIA_ITEM(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_MEDIA_ITEM))
+#define RYGEL_IS_MEDIA_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_MEDIA_ITEM))
+#define RYGEL_MEDIA_ITEM_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_MEDIA_ITEM, RygelMediaItemClass))
+
+typedef struct _RygelMediaItem RygelMediaItem;
+typedef struct _RygelMediaItemClass RygelMediaItemClass;
 typedef struct _RygelMediaObjectPrivate RygelMediaObjectPrivate;
 typedef struct _RygelMediaItemPrivate RygelMediaItemPrivate;
 
@@ -146,29 +134,6 @@ typedef struct _RygelThumbnailPrivate Ry
 #define _rygel_icon_info_unref0(var) ((var == NULL) ? NULL : (var = (rygel_icon_info_unref (var), NULL)))
 typedef struct _RygelHTTPRequestPrivate RygelHTTPRequestPrivate;
 
-#define RYGEL_TYPE_HTTP_SEEK (rygel_http_seek_get_type ())
-#define RYGEL_HTTP_SEEK(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_HTTP_SEEK, RygelHTTPSeek))
-#define RYGEL_HTTP_SEEK_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_HTTP_SEEK, RygelHTTPSeekClass))
-#define RYGEL_IS_HTTP_SEEK(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_HTTP_SEEK))
-#define RYGEL_IS_HTTP_SEEK_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_HTTP_SEEK))
-#define RYGEL_HTTP_SEEK_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_HTTP_SEEK, RygelHTTPSeekClass))
-
-typedef struct _RygelHTTPSeek RygelHTTPSeek;
-typedef struct _RygelHTTPSeekClass RygelHTTPSeekClass;
-
-struct _RygelTranscodeManager {
-	GObject parent_instance;
-	RygelTranscodeManagerPrivate * priv;
-};
-
-struct _RygelTranscodeManagerClass {
-	GObjectClass parent_class;
-	char* (*create_uri_for_item) (RygelTranscodeManager* self, RygelMediaItem* item, gint thumbnail_index, const char* transcode_target, char** protocol);
-	void (*add_resources) (RygelTranscodeManager* self, GUPnPDIDLLiteItem* didl_item, RygelMediaItem* item, GError** error);
-	char* (*get_protocol) (RygelTranscodeManager* self);
-	char* (*get_protocol_info) (RygelTranscodeManager* self);
-};
-
 struct _RygelStateMachineIface {
 	GTypeInterface parent_iface;
 	void (*run) (RygelStateMachine* self);
@@ -177,14 +142,14 @@ struct _RygelStateMachineIface {
 };
 
 struct _RygelHTTPServer {
-	RygelTranscodeManager parent_instance;
+	GObject parent_instance;
 	RygelHTTPServerPrivate * priv;
 	RygelMediaContainer* root_container;
 	GUPnPContext* context;
 };
 
 struct _RygelHTTPServerClass {
-	RygelTranscodeManagerClass parent_class;
+	GObjectClass parent_class;
 };
 
 struct _RygelHTTPServerPrivate {
@@ -252,7 +217,6 @@ struct _RygelMediaItem {
 
 struct _RygelMediaItemClass {
 	RygelMediaObjectClass parent_class;
-	GstElement* (*create_stream_source) (RygelMediaItem* self);
 	gboolean (*should_stream) (RygelMediaItem* self);
 };
 
@@ -292,8 +256,6 @@ struct _RygelHTTPRequest {
 	SoupMessage* msg;
 	RygelMediaItem* item;
 	RygelThumbnail* thumbnail;
-	RygelHTTPSeek* byte_range;
-	RygelHTTPSeek* time_range;
 };
 
 struct _RygelHTTPRequestClass {
@@ -304,11 +266,9 @@ struct _RygelHTTPRequestClass {
 static gpointer rygel_http_server_parent_class = NULL;
 static RygelStateMachineIface* rygel_http_server_rygel_state_machine_parent_iface = NULL;
 
-GType rygel_transcode_manager_get_type (void);
-GType rygel_media_object_get_type (void);
-GType rygel_media_item_get_type (void);
 GType rygel_state_machine_get_type (void);
 GType rygel_http_server_get_type (void);
+GType rygel_media_object_get_type (void);
 GType rygel_media_container_get_type (void);
 GType rygel_http_request_get_type (void);
 #define RYGEL_HTTP_SERVER_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), RYGEL_TYPE_HTTP_SERVER, RygelHTTPServerPrivate))
@@ -317,7 +277,6 @@ enum  {
 	RYGEL_HTTP_SERVER_CANCELLABLE
 };
 #define RYGEL_HTTP_SERVER_SERVER_PATH_PREFIX "/RygelHTTPServer"
-RygelTranscodeManager* rygel_transcode_manager_construct (GType object_type, GError** error);
 GType rygel_content_directory_get_type (void);
 void rygel_state_machine_set_cancellable (RygelStateMachine* self, GCancellable* value);
 RygelHTTPServer* rygel_http_server_new (RygelContentDirectory* content_dir, const char* name, GError** error);
@@ -328,10 +287,10 @@ GCancellable* rygel_state_machine_get_ca
 static void rygel_http_server_on_cancelled (RygelHTTPServer* self, GCancellable* cancellable);
 static void _rygel_http_server_on_cancelled_g_cancellable_cancelled (GCancellable* _sender, gpointer self);
 static void rygel_http_server_real_run (RygelStateMachine* base);
+GType rygel_media_item_get_type (void);
 static gboolean rygel_http_server_http_uri_present (RygelHTTPServer* self, RygelMediaItem* item);
-char* rygel_transcode_manager_create_uri_for_item (RygelTranscodeManager* self, RygelMediaItem* item, gint thumbnail_index, const char* transcode_target, char** protocol);
+char* rygel_http_server_create_uri_for_item (RygelHTTPServer* self, RygelMediaItem* item, gint thumbnail_index, const char* transcode_target, char** protocol);
 GUPnPDIDLLiteResource* rygel_media_item_add_resource (RygelMediaItem* self, GUPnPDIDLLiteItem* didl_item, const char* uri, const char* protocol, GError** error);
-void rygel_transcode_manager_add_resources (RygelTranscodeManager* self, GUPnPDIDLLiteItem* didl_item, RygelMediaItem* item, GError** error);
 gpointer rygel_icon_info_ref (gpointer instance);
 void rygel_icon_info_unref (gpointer instance);
 GParamSpec* rygel_param_spec_icon_info (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
@@ -341,17 +300,13 @@ GType rygel_icon_info_get_type (void);
 GType rygel_thumbnail_get_type (void);
 static gboolean rygel_http_server_is_http_uri (RygelHTTPServer* self, const char* uri);
 GUPnPDIDLLiteResource* rygel_thumbnail_add_resource (RygelThumbnail* self, GUPnPDIDLLiteItem* didl_item, const char* protocol);
-static void rygel_http_server_real_add_resources (RygelTranscodeManager* base, GUPnPDIDLLiteItem* didl_item, RygelMediaItem* item, GError** error);
+void rygel_http_server_add_resources (RygelHTTPServer* self, GUPnPDIDLLiteItem* didl_item, RygelMediaItem* item, GError** error);
 static char* rygel_http_server_create_uri_for_path (RygelHTTPServer* self, const char* path);
-static char* rygel_http_server_real_create_uri_for_item (RygelTranscodeManager* base, RygelMediaItem* item, gint thumbnail_index, const char* transcode_target, char** protocol);
-static char* rygel_http_server_real_get_protocol (RygelTranscodeManager* base);
-char* rygel_transcode_manager_get_protocol (RygelTranscodeManager* self);
-char* rygel_transcode_manager_get_protocol_info (RygelTranscodeManager* self);
-static char* rygel_http_server_real_get_protocol_info (RygelTranscodeManager* base);
-GType rygel_http_seek_get_type (void);
+char* rygel_http_server_get_protocol (RygelHTTPServer* self);
+char* rygel_http_server_get_protocol_info (RygelHTTPServer* self);
 static void rygel_http_server_on_request_completed (RygelHTTPServer* self, RygelHTTPRequest* request);
-static void _lambda1_ (const char* name, const char* value, RygelHTTPServer* self);
-static void __lambda1__soup_message_headers_foreach_func (const char* name, const char* value, gpointer self);
+static void _lambda0_ (const char* name, const char* value, RygelHTTPServer* self);
+static void __lambda0__soup_message_headers_foreach_func (const char* name, const char* value, gpointer self);
 RygelHTTPRequest* rygel_http_request_new (RygelHTTPServer* http_server, SoupServer* server, SoupMessage* msg, GHashTable* query);
 RygelHTTPRequest* rygel_http_request_construct (GType object_type, RygelHTTPServer* http_server, SoupServer* server, SoupMessage* msg, GHashTable* query);
 static void _rygel_http_server_on_request_completed_rygel_state_machine_completed (RygelHTTPRequest* _sender, gpointer self);
@@ -376,11 +331,11 @@ RygelHTTPServer* rygel_http_server_const
 	char* _tmp3_;
 	g_return_val_if_fail (content_dir != NULL, NULL);
 	g_return_val_if_fail (name != NULL, NULL);
-	self = (RygelHTTPServer*) rygel_transcode_manager_construct (object_type, error);
+	self = (RygelHTTPServer*) g_object_new (object_type, NULL);
 	self->root_container = (_tmp0_ = _g_object_ref0 (content_dir->root_container), _g_object_unref0 (self->root_container), _tmp0_);
 	self->context = (_tmp1_ = _g_object_ref0 (gupnp_service_info_get_context ((GUPnPServiceInfo*) content_dir)), _g_object_unref0 (self->context), _tmp1_);
 	rygel_state_machine_set_cancellable ((RygelStateMachine*) self, content_dir->cancellable);
-	self->priv->requests = (_tmp2_ = gee_array_list_new (RYGEL_TYPE_HTTP_REQUEST, (GBoxedCopyFunc) g_object_ref, g_object_unref, g_direct_equal), _g_object_unref0 (self->priv->requests), _tmp2_);
+	self->priv->requests = (_tmp2_ = gee_array_list_new (RYGEL_TYPE_HTTP_REQUEST, (GBoxedCopyFunc) g_object_ref, g_object_unref, NULL), _g_object_unref0 (self->priv->requests), _tmp2_);
 	self->priv->path_root = (_tmp3_ = g_strconcat (RYGEL_HTTP_SERVER_SERVER_PATH_PREFIX "/", name, NULL), _g_free0 (self->priv->path_root), _tmp3_);
 	return self;
 }
@@ -411,10 +366,9 @@ static void rygel_http_server_real_run (
 }
 
 
-static void rygel_http_server_real_add_resources (RygelTranscodeManager* base, GUPnPDIDLLiteItem* didl_item, RygelMediaItem* item, GError** error) {
-	RygelHTTPServer * self;
+void rygel_http_server_add_resources (RygelHTTPServer* self, GUPnPDIDLLiteItem* didl_item, RygelMediaItem* item, GError** error) {
 	GError * _inner_error_;
-	self = (RygelHTTPServer*) base;
+	g_return_if_fail (self != NULL);
 	g_return_if_fail (didl_item != NULL);
 	g_return_if_fail (item != NULL);
 	_inner_error_ = NULL;
@@ -426,7 +380,7 @@ static void rygel_http_server_real_add_r
 		char* uri;
 		GUPnPDIDLLiteResource* _tmp3_;
 		protocol = NULL;
-		uri = (_tmp1_ = rygel_transcode_manager_create_uri_for_item ((RygelTranscodeManager*) self, item, -1, NULL, &_tmp0_), protocol = (_tmp2_ = _tmp0_, _g_free0 (protocol), _tmp2_), _tmp1_);
+		uri = (_tmp1_ = rygel_http_server_create_uri_for_item (self, item, -1, NULL, &_tmp0_), protocol = (_tmp2_ = _tmp0_, _g_free0 (protocol), _tmp2_), _tmp1_);
 		_tmp3_ = rygel_media_item_add_resource (item, didl_item, uri, protocol, &_inner_error_);
 		if (_inner_error_ != NULL) {
 			g_propagate_error (error, _inner_error_);
@@ -438,11 +392,6 @@ static void rygel_http_server_real_add_r
 		_g_free0 (protocol);
 		_g_free0 (uri);
 	}
-	RYGEL_TRANSCODE_MANAGER_CLASS (rygel_http_server_parent_class)->add_resources (RYGEL_TRANSCODE_MANAGER (self), didl_item, item, &_inner_error_);
-	if (_inner_error_ != NULL) {
-		g_propagate_error (error, _inner_error_);
-		return;
-	}
 	{
 		GeeIterator* _thumbnail_it;
 		_thumbnail_it = gee_abstract_collection_iterator ((GeeAbstractCollection*) item->thumbnails);
@@ -465,7 +414,7 @@ static void rygel_http_server_real_add_r
 				uri = g_strdup (thumbnail->uri);
 				index = gee_abstract_list_index_of ((GeeAbstractList*) item->thumbnails, thumbnail);
 				protocol = NULL;
-				thumbnail->uri = (_tmp7_ = (_tmp5_ = rygel_transcode_manager_create_uri_for_item ((RygelTranscodeManager*) self, item, index, NULL, &_tmp4_), protocol = (_tmp6_ = _tmp4_, _g_free0 (protocol), _tmp6_), _tmp5_), _g_free0 (thumbnail->uri), _tmp7_);
+				thumbnail->uri = (_tmp7_ = (_tmp5_ = rygel_http_server_create_uri_for_item (self, item, index, NULL, &_tmp4_), protocol = (_tmp6_ = _tmp4_, _g_free0 (protocol), _tmp6_), _tmp5_), _g_free0 (thumbnail->uri), _tmp7_);
 				_tmp8_ = rygel_thumbnail_add_resource (thumbnail, didl_item, protocol);
 				_g_object_unref0 (_tmp8_);
 				thumbnail->uri = (_tmp9_ = g_strdup (uri), _g_free0 (thumbnail->uri), _tmp9_);
@@ -537,13 +486,12 @@ static char* rygel_http_server_create_ur
 }
 
 
-static char* rygel_http_server_real_create_uri_for_item (RygelTranscodeManager* base, RygelMediaItem* item, gint thumbnail_index, const char* transcode_target, char** protocol) {
-	RygelHTTPServer * self;
+char* rygel_http_server_create_uri_for_item (RygelHTTPServer* self, RygelMediaItem* item, gint thumbnail_index, const char* transcode_target, char** protocol) {
 	char* result;
 	char* escaped;
 	char* query;
 	char* _tmp6_;
-	self = (RygelHTTPServer*) base;
+	g_return_val_if_fail (self != NULL, NULL);
 	g_return_val_if_fail (item != NULL, NULL);
 	if (protocol != NULL) {
 		*protocol = NULL;
@@ -574,33 +522,22 @@ static char* rygel_http_server_real_crea
 }
 
 
-static char* rygel_http_server_real_get_protocol (RygelTranscodeManager* base) {
-	RygelHTTPServer * self;
+char* rygel_http_server_get_protocol (RygelHTTPServer* self) {
 	char* result;
-	self = (RygelHTTPServer*) base;
+	g_return_val_if_fail (self != NULL, NULL);
 	result = g_strdup ("http-get");
 	return result;
 }
 
 
-static char* rygel_http_server_real_get_protocol_info (RygelTranscodeManager* base) {
-	RygelHTTPServer * self;
+char* rygel_http_server_get_protocol_info (RygelHTTPServer* self) {
 	char* result;
 	char* _tmp0_;
 	char* _tmp1_;
 	char* protocol_info;
-	char* base_info;
-	self = (RygelHTTPServer*) base;
-	protocol_info = (_tmp1_ = g_strconcat (_tmp0_ = rygel_transcode_manager_get_protocol ((RygelTranscodeManager*) self), ":*:*:*", NULL), _g_free0 (_tmp0_), _tmp1_);
-	base_info = RYGEL_TRANSCODE_MANAGER_CLASS (rygel_http_server_parent_class)->get_protocol_info (RYGEL_TRANSCODE_MANAGER (self));
-	if (_vala_strcmp0 (base_info, "") != 0) {
-		char* _tmp3_;
-		char* _tmp2_;
-		protocol_info = (_tmp3_ = g_strconcat (protocol_info, _tmp2_ = g_strconcat (",", base_info, NULL), NULL), _g_free0 (protocol_info), _tmp3_);
-		_g_free0 (_tmp2_);
-	}
+	g_return_val_if_fail (self != NULL, NULL);
+	protocol_info = (_tmp1_ = g_strconcat (_tmp0_ = rygel_http_server_get_protocol (self), ":*:*:*", NULL), _g_free0 (_tmp0_), _tmp1_);
 	result = protocol_info;
-	_g_free0 (base_info);
 	return result;
 }
 
@@ -611,22 +548,22 @@ static void rygel_http_server_on_request
 	char* _tmp0_ = NULL;
 	g_return_if_fail (self != NULL);
 	g_return_if_fail (request != NULL);
-	g_debug ("rygel-http-server.vala:164: HTTP %s request for URI '%s' handled.", _tmp1_ = (g_object_get (request->msg, "method", &_tmp0_, NULL), _tmp0_), _tmp2_ = soup_uri_to_string (soup_message_get_uri (request->msg), FALSE));
+	g_debug ("rygel-http-server.vala:155: HTTP %s request for URI '%s' handled.", _tmp1_ = (g_object_get (request->msg, "method", &_tmp0_, NULL), _tmp0_), _tmp2_ = soup_uri_to_string (soup_message_get_uri (request->msg), FALSE));
 	_g_free0 (_tmp2_);
 	_g_free0 (_tmp1_);
 	gee_abstract_collection_remove ((GeeAbstractCollection*) self->priv->requests, request);
 }
 
 
-static void _lambda1_ (const char* name, const char* value, RygelHTTPServer* self) {
+static void _lambda0_ (const char* name, const char* value, RygelHTTPServer* self) {
 	g_return_if_fail (name != NULL);
 	g_return_if_fail (value != NULL);
-	g_debug ("rygel-http-server.vala:181: %s : %s", name, value);
+	g_debug ("rygel-http-server.vala:172: %s : %s", name, value);
 }
 
 
-static void __lambda1__soup_message_headers_foreach_func (const char* name, const char* value, gpointer self) {
-	_lambda1_ (name, value, self);
+static void __lambda0__soup_message_headers_foreach_func (const char* name, const char* value, gpointer self) {
+	_lambda0_ (name, value, self);
 }
 
 
@@ -645,10 +582,10 @@ static void rygel_http_server_server_han
 	g_return_if_fail (msg != NULL);
 	g_return_if_fail (server_path != NULL);
 	g_return_if_fail (soup_client != NULL);
-	g_debug ("rygel-http-server.vala:177: HTTP %s request for URI '%s'. Headers:", _tmp1_ = (g_object_get (msg, "method", &_tmp0_, NULL), _tmp0_), _tmp2_ = soup_uri_to_string (soup_message_get_uri (msg), FALSE));
+	g_debug ("rygel-http-server.vala:168: HTTP %s request for URI '%s'. Headers:", _tmp1_ = (g_object_get (msg, "method", &_tmp0_, NULL), _tmp0_), _tmp2_ = soup_uri_to_string (soup_message_get_uri (msg), FALSE));
 	_g_free0 (_tmp2_);
 	_g_free0 (_tmp1_);
-	soup_message_headers_foreach (msg->request_headers, __lambda1__soup_message_headers_foreach_func, self);
+	soup_message_headers_foreach (msg->request_headers, __lambda0__soup_message_headers_foreach_func, self);
 	request = rygel_http_request_new (self, server, msg, query);
 	g_signal_connect_object ((RygelStateMachine*) request, "completed", (GCallback) _rygel_http_server_on_request_completed_rygel_state_machine_completed, self, 0);
 	gee_abstract_collection_add ((GeeAbstractCollection*) self->priv->requests, request);
@@ -678,10 +615,6 @@ static void rygel_http_server_real_set_c
 static void rygel_http_server_class_init (RygelHTTPServerClass * klass) {
 	rygel_http_server_parent_class = g_type_class_peek_parent (klass);
 	g_type_class_add_private (klass, sizeof (RygelHTTPServerPrivate));
-	RYGEL_TRANSCODE_MANAGER_CLASS (klass)->add_resources = rygel_http_server_real_add_resources;
-	RYGEL_TRANSCODE_MANAGER_CLASS (klass)->create_uri_for_item = rygel_http_server_real_create_uri_for_item;
-	RYGEL_TRANSCODE_MANAGER_CLASS (klass)->get_protocol = rygel_http_server_real_get_protocol;
-	RYGEL_TRANSCODE_MANAGER_CLASS (klass)->get_protocol_info = rygel_http_server_real_get_protocol_info;
 	G_OBJECT_CLASS (klass)->get_property = rygel_http_server_get_property;
 	G_OBJECT_CLASS (klass)->set_property = rygel_http_server_set_property;
 	G_OBJECT_CLASS (klass)->finalize = rygel_http_server_finalize;
@@ -719,7 +652,7 @@ GType rygel_http_server_get_type (void)
 	if (rygel_http_server_type_id == 0) {
 		static const GTypeInfo g_define_type_info = { sizeof (RygelHTTPServerClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) rygel_http_server_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (RygelHTTPServer), 0, (GInstanceInitFunc) rygel_http_server_instance_init, NULL };
 		static const GInterfaceInfo rygel_state_machine_info = { (GInterfaceInitFunc) rygel_http_server_rygel_state_machine_interface_init, (GInterfaceFinalizeFunc) NULL, NULL};
-		rygel_http_server_type_id = g_type_register_static (RYGEL_TYPE_TRANSCODE_MANAGER, "RygelHTTPServer", &g_define_type_info, 0);
+		rygel_http_server_type_id = g_type_register_static (G_TYPE_OBJECT, "RygelHTTPServer", &g_define_type_info, 0);
 		g_type_add_interface_static (rygel_http_server_type_id, RYGEL_TYPE_STATE_MACHINE, &rygel_state_machine_info);
 	}
 	return rygel_http_server_type_id;
--- a/src/rygel/rygel-log-handler.c
+++ b/src/rygel/rygel-log-handler.c
@@ -171,7 +171,7 @@ static RygelLogHandler* rygel_log_handle
 	_tmp0_ = rygel_configuration_get_log_level ((RygelConfiguration*) config, &_inner_error_);
 	if (_inner_error_ != NULL) {
 		_g_object_unref0 (config);
-		g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
+		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
 		g_clear_error (&_inner_error_);
 		return NULL;
 	}
--- a/src/rygel/rygel-main.c
+++ b/src/rygel/rygel-main.c
@@ -33,7 +33,6 @@
 #include <glib/gi18n-lib.h>
 #include <cstuff.h>
 #include <libgssdp/gssdp.h>
-#include <gst/gst.h>
 #include <dbus/dbus-glib-lowlevel.h>
 #include <dbus/dbus-glib.h>
 
@@ -156,6 +155,16 @@ typedef struct _RygelIconInfoClass Rygel
 typedef struct _RygelDBusService RygelDBusService;
 typedef struct _RygelDBusServiceClass RygelDBusServiceClass;
 
+#define RYGEL_TYPE_NETWORK_MANAGER_SERVICE (rygel_network_manager_service_get_type ())
+#define RYGEL_NETWORK_MANAGER_SERVICE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_NETWORK_MANAGER_SERVICE, RygelNetworkManagerService))
+#define RYGEL_NETWORK_MANAGER_SERVICE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_NETWORK_MANAGER_SERVICE, RygelNetworkManagerServiceClass))
+#define RYGEL_IS_NETWORK_MANAGER_SERVICE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_NETWORK_MANAGER_SERVICE))
+#define RYGEL_IS_NETWORK_MANAGER_SERVICE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_NETWORK_MANAGER_SERVICE))
+#define RYGEL_NETWORK_MANAGER_SERVICE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_NETWORK_MANAGER_SERVICE, RygelNetworkManagerServiceClass))
+
+typedef struct _RygelNetworkManagerService RygelNetworkManagerService;
+typedef struct _RygelNetworkManagerServiceClass RygelNetworkManagerServiceClass;
+
 struct _RygelMain {
 	GObject parent_instance;
 	RygelMainPrivate * priv;
@@ -236,6 +245,8 @@ typedef enum  {
 } RygelCmdlineConfigError;
 #define RYGEL_CMDLINE_CONFIG_ERROR rygel_cmdline_config_error_quark ()
 
+static RygelMain* rygel_main_instance;
+static RygelMain* rygel_main_instance = NULL;
 static gpointer rygel_main_parent_class = NULL;
 
 GType rygel_main_get_type (void);
@@ -254,6 +265,9 @@ GType rygel_log_handler_get_type (void);
 enum  {
 	RYGEL_MAIN_DUMMY_PROPERTY
 };
+static RygelMain* rygel_main_new (GError** error);
+static RygelMain* rygel_main_construct (GType object_type, GError** error);
+RygelMain* rygel_main_get_default (void);
 RygelLogHandler* rygel_log_handler_get_default (void);
 GType rygel_meta_config_get_type (void);
 RygelMetaConfig* rygel_meta_config_get_default (void);
@@ -265,9 +279,8 @@ static void rygel_main_on_plugin_loaded
 static void _rygel_main_on_plugin_loaded_rygel_plugin_loader_plugin_available (RygelPluginLoader* _sender, RygelPlugin* plugin, gpointer self);
 static void rygel_main_application_exit_cb (RygelMain* self);
 static void _rygel_main_application_exit_cb_cstuff_utils_application_exit_cb (gpointer self);
-static RygelMain* rygel_main_new (GError** error);
-static RygelMain* rygel_main_construct (GType object_type, GError** error);
 void rygel_main_exit (RygelMain* self, gint exit_code);
+RygelRootDevice* rygel_main_get_root_device_by_desc_path (RygelMain* self, const char* device_desc_path);
 void rygel_plugin_loader_load_plugins (RygelPluginLoader* self);
 static gint rygel_main_run (RygelMain* self);
 static void rygel_main_create_device (RygelMain* self, RygelPlugin* plugin, RygelRootDeviceFactory* factory);
@@ -297,18 +310,43 @@ void rygel_value_set_icon_info (GValue*
 gpointer rygel_value_get_icon_info (const GValue* value);
 GType rygel_icon_info_get_type (void);
 GType rygel_dbus_service_get_type (void);
+GType rygel_network_manager_service_get_type (void);
+RygelNetworkManagerService* rygel_network_manager_service_new (GError** error);
+RygelNetworkManagerService* rygel_network_manager_service_construct (GType object_type, GError** error);
 GQuark rygel_cmdline_config_error_quark (void);
 void rygel_cmdline_config_parse_args (char*** args, int* args_length1, GError** error);
-RygelDBusService* rygel_dbus_service_new (RygelMain* main, GError** error);
-RygelDBusService* rygel_dbus_service_construct (GType object_type, RygelMain* main, GError** error);
+RygelDBusService* rygel_dbus_service_get_default (void);
 static gint rygel_main_main (char** args, int args_length1);
 static void rygel_main_finalize (GObject* obj);
-static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
-static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);
 static int _vala_strcmp0 (const char * str1, const char * str2);
 
 
 
+static gpointer _g_object_ref0 (gpointer self) {
+	return self ? g_object_ref (self) : NULL;
+}
+
+
+RygelMain* rygel_main_get_default (void) {
+	RygelMain* result;
+	GError * _inner_error_;
+	_inner_error_ = NULL;
+	if (rygel_main_instance == NULL) {
+		RygelMain* _tmp0_;
+		RygelMain* _tmp1_;
+		_tmp0_ = rygel_main_new (&_inner_error_);
+		if (_inner_error_ != NULL) {
+			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
+			g_clear_error (&_inner_error_);
+			return NULL;
+		}
+		rygel_main_instance = (_tmp1_ = _tmp0_, _g_object_unref0 (rygel_main_instance), _tmp1_);
+	}
+	result = _g_object_ref0 (rygel_main_instance);
+	return result;
+}
+
+
 static void _rygel_main_on_plugin_loaded_rygel_plugin_loader_plugin_available (RygelPluginLoader* _sender, RygelPlugin* plugin, gpointer self) {
 	rygel_main_on_plugin_loaded (self, _sender, plugin);
 }
@@ -333,8 +371,8 @@ static RygelMain* rygel_main_construct (
 	self->priv->log_handler = (_tmp0_ = rygel_log_handler_get_default (), _g_object_unref0 (self->priv->log_handler), _tmp0_);
 	self->priv->config = (_tmp1_ = (RygelConfiguration*) rygel_meta_config_get_default (), _g_object_unref0 (self->priv->config), _tmp1_);
 	self->priv->plugin_loader = (_tmp2_ = rygel_plugin_loader_new (), _g_object_unref0 (self->priv->plugin_loader), _tmp2_);
-	self->priv->root_devices = (_tmp3_ = gee_array_list_new (RYGEL_TYPE_ROOT_DEVICE, (GBoxedCopyFunc) g_object_ref, g_object_unref, g_direct_equal), _g_object_unref0 (self->priv->root_devices), _tmp3_);
-	self->priv->factories = (_tmp4_ = gee_array_list_new (RYGEL_TYPE_ROOT_DEVICE_FACTORY, (GBoxedCopyFunc) rygel_root_device_factory_ref, rygel_root_device_factory_unref, g_direct_equal), _g_object_unref0 (self->priv->factories), _tmp4_);
+	self->priv->root_devices = (_tmp3_ = gee_array_list_new (RYGEL_TYPE_ROOT_DEVICE, (GBoxedCopyFunc) g_object_ref, g_object_unref, NULL), _g_object_unref0 (self->priv->root_devices), _tmp3_);
+	self->priv->factories = (_tmp4_ = gee_array_list_new (RYGEL_TYPE_ROOT_DEVICE_FACTORY, (GBoxedCopyFunc) rygel_root_device_factory_ref, rygel_root_device_factory_unref, NULL), _g_object_unref0 (self->priv->factories), _tmp4_);
 	self->priv->context_manager = (_tmp5_ = rygel_main_create_context_manager (self), _g_object_unref0 (self->priv->context_manager), _tmp5_);
 	self->priv->main_loop = (_tmp6_ = g_main_loop_new (NULL, FALSE), _g_main_loop_unref0 (self->priv->main_loop), _tmp6_);
 	self->priv->exit_code = 0;
@@ -356,6 +394,38 @@ void rygel_main_exit (RygelMain* self, g
 }
 
 
+RygelRootDevice* rygel_main_get_root_device_by_desc_path (RygelMain* self, const char* device_desc_path) {
+	RygelRootDevice* result;
+	RygelRootDevice* root_device;
+	g_return_val_if_fail (self != NULL, NULL);
+	g_return_val_if_fail (device_desc_path != NULL, NULL);
+	g_debug ("rygel-main.vala:76: %p: requested device description path is %s", self, device_desc_path);
+	root_device = NULL;
+	{
+		GeeIterator* __root_device_it;
+		__root_device_it = gee_abstract_collection_iterator ((GeeAbstractCollection*) self->priv->root_devices);
+		while (TRUE) {
+			RygelRootDevice* _root_device;
+			if (!gee_iterator_next (__root_device_it)) {
+				break;
+			}
+			_root_device = (RygelRootDevice*) gee_iterator_get (__root_device_it);
+			g_debug ("rygel-main.vala:79: %p: device description path is %s", self, gupnp_root_device_get_description_path ((GUPnPRootDevice*) _root_device));
+			if (_vala_strcmp0 (gupnp_root_device_get_description_path ((GUPnPRootDevice*) _root_device), device_desc_path) == 0) {
+				RygelRootDevice* _tmp0_;
+				root_device = (_tmp0_ = _g_object_ref0 (_root_device), _g_object_unref0 (root_device), _tmp0_);
+				_g_object_unref0 (_root_device);
+				break;
+			}
+			_g_object_unref0 (_root_device);
+		}
+		_g_object_unref0 (__root_device_it);
+	}
+	result = root_device;
+	return result;
+}
+
+
 static gint rygel_main_run (RygelMain* self) {
 	gint result;
 	g_return_val_if_fail (self != NULL, 0);
@@ -377,7 +447,7 @@ static void rygel_main_on_plugin_loaded
 	g_return_if_fail (self != NULL);
 	g_return_if_fail (plugin_loader != NULL);
 	g_return_if_fail (plugin != NULL);
-	factories = gee_array_list_new (RYGEL_TYPE_ROOT_DEVICE_FACTORY, (GBoxedCopyFunc) rygel_root_device_factory_ref, rygel_root_device_factory_unref, g_direct_equal);
+	factories = gee_array_list_new (RYGEL_TYPE_ROOT_DEVICE_FACTORY, (GBoxedCopyFunc) rygel_root_device_factory_ref, rygel_root_device_factory_unref, NULL);
 	{
 		GeeIterator* _factory_it;
 		_factory_it = gee_abstract_collection_iterator ((GeeAbstractCollection*) self->priv->factories);
@@ -432,13 +502,13 @@ static GUPnPContextManager* rygel_main_c
 		gint _tmp0_;
 		_tmp0_ = rygel_configuration_get_port (self->priv->config, &_inner_error_);
 		if (_inner_error_ != NULL) {
-			goto __catch50_g_error;
-			goto __finally50;
+			goto __catch45_g_error;
+			goto __finally45;
 		}
 		port = _tmp0_;
 	}
-	goto __finally50;
-	__catch50_g_error:
+	goto __finally45;
+	__catch45_g_error:
 	{
 		GError * err;
 		err = _inner_error_;
@@ -447,9 +517,9 @@ static GUPnPContextManager* rygel_main_c
 			_g_error_free0 (err);
 		}
 	}
-	__finally50:
+	__finally45:
 	if (_inner_error_ != NULL) {
-		g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
+		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
 		g_clear_error (&_inner_error_);
 		return NULL;
 	}
@@ -470,19 +540,19 @@ static void rygel_main_on_context_availa
 	g_return_if_fail (context != NULL);
 	_inner_error_ = NULL;
 	iface = NULL;
-	g_debug ("rygel-main.vala:110: new network context %s (%s) available.", gssdp_client_get_interface ((GSSDPClient*) context), gssdp_client_get_host_ip ((GSSDPClient*) context));
+	g_debug ("rygel-main.vala:135: new network context %s (%s) available.", gssdp_client_get_interface ((GSSDPClient*) context), gssdp_client_get_host_ip ((GSSDPClient*) context));
 	{
 		char* _tmp0_;
 		char* _tmp1_;
 		_tmp0_ = rygel_configuration_get_interface (self->priv->config, &_inner_error_);
 		if (_inner_error_ != NULL) {
-			goto __catch51_g_error;
-			goto __finally51;
+			goto __catch46_g_error;
+			goto __finally46;
 		}
 		iface = (_tmp1_ = _tmp0_, _g_free0 (iface), _tmp1_);
 	}
-	goto __finally51;
-	__catch51_g_error:
+	goto __finally46;
+	__catch46_g_error:
 	{
 		GError * err;
 		err = _inner_error_;
@@ -491,10 +561,10 @@ static void rygel_main_on_context_availa
 			_g_error_free0 (err);
 		}
 	}
-	__finally51:
+	__finally46:
 	if (_inner_error_ != NULL) {
 		_g_free0 (iface);
-		g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
+		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
 		g_clear_error (&_inner_error_);
 		return;
 	}
@@ -509,12 +579,12 @@ static void rygel_main_on_context_availa
 		factory = rygel_root_device_factory_new (context, &_inner_error_);
 		if (_inner_error_ != NULL) {
 			_g_free0 (iface);
-			g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
+			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
 			g_clear_error (&_inner_error_);
 			return;
 		}
 		gee_abstract_collection_add ((GeeAbstractCollection*) self->priv->factories, factory);
-		plugins = gee_array_list_new (RYGEL_TYPE_PLUGIN, (GBoxedCopyFunc) g_object_ref, g_object_unref, g_direct_equal);
+		plugins = gee_array_list_new (RYGEL_TYPE_PLUGIN, (GBoxedCopyFunc) g_object_ref, g_object_unref, NULL);
 		{
 			GeeCollection* _tmp3_;
 			GeeIterator* _tmp4_;
@@ -548,7 +618,7 @@ static void rygel_main_on_context_availa
 		_rygel_root_device_factory_unref0 (factory);
 		_g_object_unref0 (plugins);
 	} else {
-		g_debug ("rygel-main.vala:132: Ignoring network context %s (%s).", gssdp_client_get_interface ((GSSDPClient*) context), gssdp_client_get_host_ip ((GSSDPClient*) context));
+		g_debug ("rygel-main.vala:157: Ignoring network context %s (%s).", gssdp_client_get_interface ((GSSDPClient*) context), gssdp_client_get_host_ip ((GSSDPClient*) context));
 	}
 	_g_free0 (iface);
 }
@@ -560,8 +630,8 @@ static void rygel_main_on_context_unavai
 	g_return_if_fail (self != NULL);
 	g_return_if_fail (manager != NULL);
 	g_return_if_fail (context != NULL);
-	g_debug ("rygel-main.vala:140: Network context %s (%s) now unavailable.", gssdp_client_get_interface ((GSSDPClient*) context), gssdp_client_get_host_ip ((GSSDPClient*) context));
-	factory_list = gee_array_list_new (RYGEL_TYPE_ROOT_DEVICE_FACTORY, (GBoxedCopyFunc) rygel_root_device_factory_ref, rygel_root_device_factory_unref, g_direct_equal);
+	g_debug ("rygel-main.vala:165: Network context %s (%s) now unavailable.", gssdp_client_get_interface ((GSSDPClient*) context), gssdp_client_get_host_ip ((GSSDPClient*) context));
+	factory_list = gee_array_list_new (RYGEL_TYPE_ROOT_DEVICE_FACTORY, (GBoxedCopyFunc) rygel_root_device_factory_ref, rygel_root_device_factory_unref, NULL);
 	{
 		GeeIterator* _factory_it;
 		_factory_it = gee_abstract_collection_iterator ((GeeAbstractCollection*) self->priv->factories);
@@ -592,7 +662,7 @@ static void rygel_main_on_context_unavai
 		}
 		_g_object_unref0 (_factory_it);
 	}
-	device_list = gee_array_list_new (RYGEL_TYPE_ROOT_DEVICE, (GBoxedCopyFunc) g_object_ref, g_object_unref, g_direct_equal);
+	device_list = gee_array_list_new (RYGEL_TYPE_ROOT_DEVICE, (GBoxedCopyFunc) g_object_ref, g_object_unref, NULL);
 	{
 		GeeIterator* _device_it;
 		_device_it = gee_abstract_collection_iterator ((GeeAbstractCollection*) self->priv->root_devices);
@@ -643,28 +713,28 @@ static void rygel_main_create_device (Ry
 		RygelRootDevice* device;
 		device = rygel_root_device_factory_create (factory, plugin, &_inner_error_);
 		if (_inner_error_ != NULL) {
-			goto __catch52_g_error;
-			goto __finally52;
+			goto __catch47_g_error;
+			goto __finally47;
 		}
 		gupnp_root_device_set_available ((GUPnPRootDevice*) device, rygel_plugin_get_available (plugin));
 		gee_abstract_collection_add ((GeeAbstractCollection*) self->priv->root_devices, device);
 		g_signal_connect_object ((GObject*) plugin, "notify::available", (GCallback) _rygel_main_on_plugin_notify_g_object_notify, self, 0);
 		_g_object_unref0 (device);
 	}
-	goto __finally52;
-	__catch52_g_error:
+	goto __finally47;
+	__catch47_g_error:
 	{
 		GError * _error_;
 		_error_ = _inner_error_;
 		_inner_error_ = NULL;
 		{
-			g_warning ("rygel-main.vala:178: Failed to create RootDevice for %s. Reason: %s\n", plugin->name, _error_->message);
+			g_warning ("rygel-main.vala:203: Failed to create RootDevice for %s. Reason: %s\n", plugin->name, _error_->message);
 			_g_error_free0 (_error_);
 		}
 	}
-	__finally52:
+	__finally47:
 	if (_inner_error_ != NULL) {
-		g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
+		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
 		g_clear_error (&_inner_error_);
 		return;
 	}
@@ -699,73 +769,74 @@ static gint rygel_main_main (char** args
 	GError * _inner_error_;
 	RygelMain* main;
 	RygelDBusService* service;
+	RygelNetworkManagerService* nm_service;
 	gint exit_code;
 	_inner_error_ = NULL;
 	main = NULL;
 	service = NULL;
+	nm_service = NULL;
 	{
-		char** _tmp0_;
-		gint dummy_args_size;
-		gint dummy_args_length1;
-		char** dummy_args;
-		RygelMain* _tmp1_;
-		RygelMain* _tmp2_;
-		RygelDBusService* _tmp3_;
-		RygelDBusService* _tmp4_;
-		rygel_cmdline_config_parse_args (&args, &args_length1, &_inner_error_);
+		RygelNetworkManagerService* _tmp0_;
+		RygelNetworkManagerService* _tmp1_;
+		_tmp0_ = rygel_network_manager_service_new (&_inner_error_);
 		if (_inner_error_ != NULL) {
 			if (_inner_error_->domain == DBUS_GERROR) {
-				goto __catch53_dbus_gerror;
-			}
-			if (g_error_matches (_inner_error_, RYGEL_CMDLINE_CONFIG_ERROR, RYGEL_CMDLINE_CONFIG_ERROR_VERSION_ONLY)) {
-				goto __catch53_rygel_cmdline_config_error_version_only;
+				goto __catch48_dbus_gerror;
 			}
-			goto __catch53_g_error;
-			goto __finally53;
+			goto __finally48;
 		}
-		dummy_args = (_tmp0_ = g_new0 (char*, 0 + 1), dummy_args_length1 = 0, dummy_args_size = dummy_args_length1, _tmp0_);
-		gst_init (&dummy_args_length1, &dummy_args);
-		_tmp1_ = rygel_main_new (&_inner_error_);
-		if (_inner_error_ != NULL) {
-			dummy_args = (_vala_array_free (dummy_args, dummy_args_length1, (GDestroyNotify) g_free), NULL);
-			if (_inner_error_->domain == DBUS_GERROR) {
-				goto __catch53_dbus_gerror;
-			}
-			if (g_error_matches (_inner_error_, RYGEL_CMDLINE_CONFIG_ERROR, RYGEL_CMDLINE_CONFIG_ERROR_VERSION_ONLY)) {
-				goto __catch53_rygel_cmdline_config_error_version_only;
-			}
-			goto __catch53_g_error;
-			goto __finally53;
+		nm_service = (_tmp1_ = _tmp0_, _g_object_unref0 (nm_service), _tmp1_);
+	}
+	goto __finally48;
+	__catch48_dbus_gerror:
+	{
+		GError * err;
+		err = _inner_error_;
+		_inner_error_ = NULL;
+		{
+			g_warning ("rygel-main.vala:226: Failed to start D-Bus service: %s", err->message);
+			_g_error_free0 (err);
 		}
-		main = (_tmp2_ = _tmp1_, _g_object_unref0 (main), _tmp2_);
-		_tmp3_ = rygel_dbus_service_new (main, &_inner_error_);
+	}
+	__finally48:
+	if (_inner_error_ != NULL) {
+		_g_object_unref0 (main);
+		_g_object_unref0 (service);
+		_g_object_unref0 (nm_service);
+		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
+		g_clear_error (&_inner_error_);
+		return 0;
+	}
+	{
+		RygelMain* _tmp2_;
+		RygelDBusService* _tmp3_;
+		rygel_cmdline_config_parse_args (&args, &args_length1, &_inner_error_);
 		if (_inner_error_ != NULL) {
-			dummy_args = (_vala_array_free (dummy_args, dummy_args_length1, (GDestroyNotify) g_free), NULL);
 			if (_inner_error_->domain == DBUS_GERROR) {
-				goto __catch53_dbus_gerror;
+				goto __catch49_dbus_gerror;
 			}
 			if (g_error_matches (_inner_error_, RYGEL_CMDLINE_CONFIG_ERROR, RYGEL_CMDLINE_CONFIG_ERROR_VERSION_ONLY)) {
-				goto __catch53_rygel_cmdline_config_error_version_only;
+				goto __catch49_rygel_cmdline_config_error_version_only;
 			}
-			goto __catch53_g_error;
-			goto __finally53;
+			goto __catch49_g_error;
+			goto __finally49;
 		}
-		service = (_tmp4_ = _tmp3_, _g_object_unref0 (service), _tmp4_);
-		dummy_args = (_vala_array_free (dummy_args, dummy_args_length1, (GDestroyNotify) g_free), NULL);
+		main = (_tmp2_ = rygel_main_get_default (), _g_object_unref0 (main), _tmp2_);
+		service = (_tmp3_ = rygel_dbus_service_get_default (), _g_object_unref0 (service), _tmp3_);
 	}
-	goto __finally53;
-	__catch53_dbus_gerror:
+	goto __finally49;
+	__catch49_dbus_gerror:
 	{
 		GError * err;
 		err = _inner_error_;
 		_inner_error_ = NULL;
 		{
-			g_warning ("rygel-main.vala:208: Failed to start D-Bus service: %s", err->message);
+			g_warning ("rygel-main.vala:236: Failed to start D-Bus service: %s", err->message);
 			_g_error_free0 (err);
 		}
 	}
-	goto __finally53;
-	__catch53_rygel_cmdline_config_error_version_only:
+	goto __finally49;
+	__catch49_rygel_cmdline_config_error_version_only:
 	{
 		GError * err;
 		err = _inner_error_;
@@ -775,29 +846,32 @@ static gint rygel_main_main (char** args
 			_g_error_free0 (err);
 			_g_object_unref0 (main);
 			_g_object_unref0 (service);
+			_g_object_unref0 (nm_service);
 			return result;
 		}
 	}
-	goto __finally53;
-	__catch53_g_error:
+	goto __finally49;
+	__catch49_g_error:
 	{
 		GError * err;
 		err = _inner_error_;
 		_inner_error_ = NULL;
 		{
-			g_error ("rygel-main.vala:212: %s", err->message);
+			g_error ("rygel-main.vala:240: %s", err->message);
 			result = -1;
 			_g_error_free0 (err);
 			_g_object_unref0 (main);
 			_g_object_unref0 (service);
+			_g_object_unref0 (nm_service);
 			return result;
 		}
 	}
-	__finally53:
+	__finally49:
 	if (_inner_error_ != NULL) {
 		_g_object_unref0 (main);
 		_g_object_unref0 (service);
-		g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
+		_g_object_unref0 (nm_service);
+		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
 		g_clear_error (&_inner_error_);
 		return 0;
 	}
@@ -805,6 +879,7 @@ static gint rygel_main_main (char** args
 	result = exit_code;
 	_g_object_unref0 (main);
 	_g_object_unref0 (service);
+	_g_object_unref0 (nm_service);
 	return result;
 }
 
@@ -852,24 +927,6 @@ GType rygel_main_get_type (void) {
 }
 
 
-static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
-	if ((array != NULL) && (destroy_func != NULL)) {
-		int i;
-		for (i = 0; i < array_length; i = i + 1) {
-			if (((gpointer*) array)[i] != NULL) {
-				destroy_func (((gpointer*) array)[i]);
-			}
-		}
-	}
-}
-
-
-static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
-	_vala_array_destroy (array, array_length, destroy_func);
-	g_free (array);
-}
-
-
 static int _vala_strcmp0 (const char * str1, const char * str2) {
 	if (str1 == NULL) {
 		return -(str1 != str2);
--- a/src/rygel/rygel-media-db-container.c
+++ b/src/rygel/rygel-media-db-container.c
@@ -203,14 +203,14 @@ RygelMediaDBContainer* rygel_media_db_co
 		_tmp0_ = rygel_media_db_get_child_count (media_db, id, &_inner_error_);
 		if (_inner_error_ != NULL) {
 			if (_inner_error_->domain == RYGEL_MEDIA_DB_ERROR) {
-				goto __catch46_rygel_media_db_error;
+				goto __catch40_rygel_media_db_error;
 			}
-			goto __finally46;
+			goto __finally40;
 		}
 		count = _tmp0_;
 	}
-	goto __finally46;
-	__catch46_rygel_media_db_error:
+	goto __finally40;
+	__catch40_rygel_media_db_error:
 	{
 		GError * e;
 		e = _inner_error_;
@@ -221,9 +221,9 @@ RygelMediaDBContainer* rygel_media_db_co
 			_g_error_free0 (e);
 		}
 	}
-	__finally46:
+	__finally40:
 	if (_inner_error_ != NULL) {
-		g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
+		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
 		g_clear_error (&_inner_error_);
 		return NULL;
 	}
@@ -248,7 +248,7 @@ static void rygel_media_db_container_on_
 	_inner_error_ = NULL;
 	_tmp0_ = rygel_media_db_get_child_count (self->media_db, ((RygelMediaObject*) self)->id, &_inner_error_);
 	if (_inner_error_ != NULL) {
-		g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
+		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
 		g_clear_error (&_inner_error_);
 		return;
 	}
@@ -308,7 +308,7 @@ static void rygel_media_db_container_rea
 	_tmp0_ = rygel_media_db_get_object (self->media_db, id, &_inner_error_);
 	if (_inner_error_ != NULL) {
 		_g_object_unref0 (res);
-		g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
+		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
 		g_clear_error (&_inner_error_);
 		return;
 	}
--- a/src/rygel/rygel-media-db.c
+++ b/src/rygel/rygel-media-db.c
@@ -29,7 +29,6 @@
 #include <stdlib.h>
 #include <string.h>
 #include <gee.h>
-#include <gst/gst.h>
 
 
 #define RYGEL_TYPE_MEDIA_DB_OBJECT_TYPE (rygel_media_db_object_type_get_type ())
@@ -178,7 +177,6 @@ struct _RygelMediaItem {
 
 struct _RygelMediaItemClass {
 	RygelMediaObjectClass parent_class;
-	GstElement* (*create_stream_source) (RygelMediaItem* self);
 	gboolean (*should_stream) (RygelMediaItem* self);
 };
 
@@ -480,7 +478,7 @@ RygelMediaDB* rygel_media_db_create (con
 			return NULL;
 		} else {
 			_g_object_unref0 (instance);
-			g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
+			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
 			g_clear_error (&_inner_error_);
 			return NULL;
 		}
@@ -509,7 +507,7 @@ RygelMediaDB* rygel_media_db_create_with
 			return NULL;
 		} else {
 			_g_object_unref0 (instance);
-			g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
+			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
 			g_clear_error (&_inner_error_);
 			return NULL;
 		}
@@ -566,7 +564,7 @@ void rygel_media_db_remove_by_id (RygelM
 					return;
 				} else {
 					_sqlite3_finalize0 (statement);
-					g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
+					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
 					g_clear_error (&_inner_error_);
 					return;
 				}
@@ -592,7 +590,7 @@ void rygel_media_db_remove_by_id (RygelM
 				return;
 			} else {
 				_sqlite3_finalize0 (statement);
-				g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
+				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
 				g_clear_error (&_inner_error_);
 				return;
 			}
@@ -613,7 +611,7 @@ void rygel_media_db_remove_object (Rygel
 			g_propagate_error (error, _inner_error_);
 			return;
 		} else {
-			g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
+			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
 			g_clear_error (&_inner_error_);
 			return;
 		}
@@ -630,7 +628,7 @@ void rygel_media_db_remove_object (Rygel
 					g_propagate_error (error, _inner_error_);
 					return;
 				} else {
-					g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
+					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
 					g_clear_error (&_inner_error_);
 					return;
 				}
@@ -684,13 +682,13 @@ void rygel_media_db_save_container (Ryge
 	{
 		rygel_media_db_create_object (self, (RygelMediaObject*) container, &_inner_error_);
 		if (_inner_error_ != NULL) {
-			goto __catch39_g_error;
-			goto __finally39;
+			goto __catch35_g_error;
+			goto __finally35;
 		}
 		rygel_media_db_save_uris (self, (RygelMediaObject*) container, &_inner_error_);
 		if (_inner_error_ != NULL) {
-			goto __catch39_g_error;
-			goto __finally39;
+			goto __catch35_g_error;
+			goto __finally35;
 		}
 		rc = sqlite3_exec (self->priv->db, "COMMIT", NULL, NULL, NULL);
 		if (rc == SQLITE_OK) {
@@ -698,8 +696,8 @@ void rygel_media_db_save_container (Ryge
 			g_signal_emit_by_name (self, "container-added", ((RygelMediaObject*) container)->id);
 		}
 	}
-	goto __finally39;
-	__catch39_g_error:
+	goto __finally35;
+	__catch35_g_error:
 	{
 		GError * _error_;
 		_error_ = _inner_error_;
@@ -709,12 +707,12 @@ void rygel_media_db_save_container (Ryge
 			_inner_error_ = _g_error_copy0 (_error_);
 			if (_inner_error_ != NULL) {
 				_g_error_free0 (_error_);
-				goto __finally39;
+				goto __finally35;
 			}
 			_g_error_free0 (_error_);
 		}
 	}
-	__finally39:
+	__finally35:
 	if (_inner_error_ != NULL) {
 		g_propagate_error (error, _inner_error_);
 		return;
@@ -732,18 +730,18 @@ void rygel_media_db_save_item (RygelMedi
 	{
 		rygel_media_db_save_metadata (self, item, RYGEL_MEDIA_DB_INSERT_META_DATA_STRING, &_inner_error_);
 		if (_inner_error_ != NULL) {
-			goto __catch40_g_error;
-			goto __finally40;
+			goto __catch36_g_error;
+			goto __finally36;
 		}
 		rygel_media_db_create_object (self, (RygelMediaObject*) item, &_inner_error_);
 		if (_inner_error_ != NULL) {
-			goto __catch40_g_error;
-			goto __finally40;
+			goto __catch36_g_error;
+			goto __finally36;
 		}
 		rygel_media_db_save_uris (self, (RygelMediaObject*) item, &_inner_error_);
 		if (_inner_error_ != NULL) {
-			goto __catch40_g_error;
-			goto __finally40;
+			goto __catch36_g_error;
+			goto __finally36;
 		}
 		rc = sqlite3_exec (self->priv->db, "COMMIT;", NULL, NULL, NULL);
 		if (rc == SQLITE_OK) {
@@ -751,8 +749,8 @@ void rygel_media_db_save_item (RygelMedi
 			g_signal_emit_by_name (self, "item-added", ((RygelMediaObject*) item)->id);
 		}
 	}
-	goto __finally40;
-	__catch40_g_error:
+	goto __finally36;
+	__catch36_g_error:
 	{
 		GError * _error_;
 		_error_ = _inner_error_;
@@ -763,12 +761,12 @@ void rygel_media_db_save_item (RygelMedi
 			_inner_error_ = _g_error_copy0 (_error_);
 			if (_inner_error_ != NULL) {
 				_g_error_free0 (_error_);
-				goto __finally40;
+				goto __finally36;
 			}
 			_g_error_free0 (_error_);
 		}
 	}
-	__finally40:
+	__finally36:
 	if (_inner_error_ != NULL) {
 		g_propagate_error (error, _inner_error_);
 		return;
@@ -786,25 +784,25 @@ void rygel_media_db_update_object (Rygel
 	{
 		rygel_media_db_remove_uris (self, obj, &_inner_error_);
 		if (_inner_error_ != NULL) {
-			goto __catch41_g_error;
-			goto __finally41;
+			goto __catch37_g_error;
+			goto __finally37;
 		}
 		if (RYGEL_IS_MEDIA_ITEM (obj)) {
 			rygel_media_db_save_metadata (self, RYGEL_MEDIA_ITEM (obj), RYGEL_MEDIA_DB_UPDATE_META_DATA_STRING, &_inner_error_);
 			if (_inner_error_ != NULL) {
-				goto __catch41_g_error;
-				goto __finally41;
+				goto __catch37_g_error;
+				goto __finally37;
 			}
 		}
 		rygel_media_db_update_object_internal (self, obj, &_inner_error_);
 		if (_inner_error_ != NULL) {
-			goto __catch41_g_error;
-			goto __finally41;
+			goto __catch37_g_error;
+			goto __finally37;
 		}
 		rygel_media_db_save_uris (self, obj, &_inner_error_);
 		if (_inner_error_ != NULL) {
-			goto __catch41_g_error;
-			goto __finally41;
+			goto __catch37_g_error;
+			goto __finally37;
 		}
 		rc = sqlite3_exec (self->priv->db, "COMMIT", NULL, NULL, NULL);
 		if (rc == SQLITE_OK) {
@@ -818,8 +816,8 @@ void rygel_media_db_update_object (Rygel
 			}
 		}
 	}
-	goto __finally41;
-	__catch41_g_error:
+	goto __finally37;
+	__catch37_g_error:
 	{
 		GError * _error_;
 		_error_ = _inner_error_;
@@ -830,12 +828,12 @@ void rygel_media_db_update_object (Rygel
 			_inner_error_ = _g_error_copy0 (_error_);
 			if (_inner_error_ != NULL) {
 				_g_error_free0 (_error_);
-				goto __finally41;
+				goto __finally37;
 			}
 			_g_error_free0 (_error_);
 		}
 	}
-	__finally41:
+	__finally37:
 	if (_inner_error_ != NULL) {
 		g_propagate_error (error, _inner_error_);
 		return;
@@ -1314,7 +1312,7 @@ static void rygel_media_db_add_uris (Ryg
 					return;
 				} else {
 					_sqlite3_finalize0 (statement);
-					g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
+					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
 					g_clear_error (&_inner_error_);
 					return;
 				}
@@ -1340,7 +1338,7 @@ static void rygel_media_db_add_uris (Ryg
 				return;
 			} else {
 				_sqlite3_finalize0 (statement);
-				g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
+				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
 				g_clear_error (&_inner_error_);
 				return;
 			}
@@ -1384,14 +1382,14 @@ static RygelMediaObject* rygel_media_db_
 			rygel_media_db_add_uris (self, obj, &_inner_error_);
 			if (_inner_error_ != NULL) {
 				if (_inner_error_->domain == RYGEL_MEDIA_DB_ERROR) {
-					goto __catch42_rygel_media_db_error;
+					goto __catch38_rygel_media_db_error;
 				}
-				goto __finally42;
+				goto __finally38;
 			}
 		}
 	}
-	goto __finally42;
-	__catch42_rygel_media_db_error:
+	goto __finally38;
+	__catch38_rygel_media_db_error:
 	{
 		GError * err;
 		err = _inner_error_;
@@ -1403,10 +1401,10 @@ static RygelMediaObject* rygel_media_db_
 			_g_error_free0 (err);
 		}
 	}
-	__finally42:
+	__finally38:
 	if (_inner_error_ != NULL) {
 		_g_object_unref0 (obj);
-		g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
+		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
 		g_clear_error (&_inner_error_);
 		return NULL;
 	}
@@ -1442,7 +1440,7 @@ RygelMediaObject* rygel_media_db_get_obj
 				} else {
 					_g_object_unref0 (obj);
 					_sqlite3_finalize0 (statement);
-					g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
+					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
 					g_clear_error (&_inner_error_);
 					return NULL;
 				}
@@ -1475,7 +1473,7 @@ RygelMediaObject* rygel_media_db_get_obj
 						_g_free0 (parent_id);
 						_g_object_unref0 (obj);
 						_sqlite3_finalize0 (statement);
-						g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
+						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
 						g_clear_error (&_inner_error_);
 						return NULL;
 					}
@@ -1504,7 +1502,7 @@ RygelMediaObject* rygel_media_db_get_obj
 			} else {
 				_g_object_unref0 (obj);
 				_sqlite3_finalize0 (statement);
-				g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
+				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
 				g_clear_error (&_inner_error_);
 				return NULL;
 			}
@@ -1530,7 +1528,7 @@ RygelMediaItem* rygel_media_db_get_item
 			g_propagate_error (error, _inner_error_);
 			return NULL;
 		} else {
-			g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
+			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
 			g_clear_error (&_inner_error_);
 			return NULL;
 		}
@@ -1549,7 +1547,7 @@ RygelMediaItem* rygel_media_db_get_item
 				return NULL;
 			} else {
 				_g_object_unref0 (obj);
-				g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
+				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
 				g_clear_error (&_inner_error_);
 				return NULL;
 			}
@@ -1575,7 +1573,7 @@ RygelMediaContainer* rygel_media_db_get_
 			g_propagate_error (error, _inner_error_);
 			return NULL;
 		} else {
-			g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
+			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
 			g_clear_error (&_inner_error_);
 			return NULL;
 		}
@@ -1594,7 +1592,7 @@ RygelMediaContainer* rygel_media_db_get_
 				return NULL;
 			} else {
 				_g_object_unref0 (obj);
-				g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
+				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
 				g_clear_error (&_inner_error_);
 				return NULL;
 			}
@@ -1658,7 +1656,7 @@ GeeArrayList* rygel_media_db_get_child_i
 				} else {
 					_g_object_unref0 (children);
 					_sqlite3_finalize0 (statement);
-					g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
+					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
 					g_clear_error (&_inner_error_);
 					return NULL;
 				}
@@ -1682,7 +1680,7 @@ GeeArrayList* rygel_media_db_get_child_i
 			} else {
 				_g_object_unref0 (children);
 				_sqlite3_finalize0 (statement);
-				g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
+				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
 				g_clear_error (&_inner_error_);
 				return NULL;
 			}
@@ -1719,7 +1717,7 @@ gint rygel_media_db_get_child_count (Ryg
 					return 0;
 				} else {
 					_sqlite3_finalize0 (statement);
-					g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
+					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
 					g_clear_error (&_inner_error_);
 					return 0;
 				}
@@ -1742,7 +1740,7 @@ gint rygel_media_db_get_child_count (Ryg
 				return 0;
 			} else {
 				_sqlite3_finalize0 (statement);
-				g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
+				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
 				g_clear_error (&_inner_error_);
 				return 0;
 			}
@@ -1779,7 +1777,7 @@ gboolean rygel_media_db_exists (RygelMed
 					return FALSE;
 				} else {
 					_sqlite3_finalize0 (statement);
-					g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
+					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
 					g_clear_error (&_inner_error_);
 					return FALSE;
 				}
@@ -1803,7 +1801,7 @@ gboolean rygel_media_db_exists (RygelMed
 				return FALSE;
 			} else {
 				_sqlite3_finalize0 (statement);
-				g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
+				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
 				g_clear_error (&_inner_error_);
 				return FALSE;
 			}
@@ -1829,7 +1827,7 @@ GeeArrayList* rygel_media_db_get_childre
 	g_return_val_if_fail (container_id != NULL, NULL);
 	_inner_error_ = NULL;
 	statement = NULL;
-	children = gee_array_list_new (RYGEL_TYPE_MEDIA_OBJECT, (GBoxedCopyFunc) g_object_ref, g_object_unref, g_direct_equal);
+	children = gee_array_list_new (RYGEL_TYPE_MEDIA_OBJECT, (GBoxedCopyFunc) g_object_ref, g_object_unref, NULL);
 	parent = NULL;
 	{
 		RygelMediaObject* _tmp0_;
@@ -1837,14 +1835,14 @@ GeeArrayList* rygel_media_db_get_childre
 		_tmp0_ = rygel_media_db_get_object (self, container_id, &_inner_error_);
 		if (_inner_error_ != NULL) {
 			if (_inner_error_->domain == RYGEL_MEDIA_DB_ERROR) {
-				goto __catch43_rygel_media_db_error;
+				goto __catch39_rygel_media_db_error;
 			}
-			goto __finally43;
+			goto __finally39;
 		}
 		parent = (_tmp1_ = RYGEL_MEDIA_CONTAINER (_tmp0_), _g_object_unref0 (parent), _tmp1_);
 	}
-	goto __finally43;
-	__catch43_rygel_media_db_error:
+	goto __finally39;
+	__catch39_rygel_media_db_error:
 	{
 		GError * err;
 		err = _inner_error_;
@@ -1858,12 +1856,12 @@ GeeArrayList* rygel_media_db_get_childre
 			return result;
 		}
 	}
-	__finally43:
+	__finally39:
 	if (_inner_error_ != NULL) {
 		_sqlite3_finalize0 (statement);
 		_g_object_unref0 (children);
 		_g_object_unref0 (parent);
-		g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
+		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
 		g_clear_error (&_inner_error_);
 		return NULL;
 	}
@@ -1887,7 +1885,7 @@ GeeArrayList* rygel_media_db_get_childre
 				_sqlite3_finalize0 (statement);
 				_g_object_unref0 (children);
 				_g_object_unref0 (parent);
-				g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
+				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
 				g_clear_error (&_inner_error_);
 				return NULL;
 			}
--- a/src/rygel/rygel-media-item.c
+++ b/src/rygel/rygel-media-item.c
@@ -28,7 +28,6 @@
 #include <stdlib.h>
 #include <string.h>
 #include <gee.h>
-#include <gst/gst.h>
 #include <libgupnp-av/gupnp-av.h>
 
 
@@ -85,7 +84,6 @@ typedef struct _RygelThumbnail RygelThum
 typedef struct _RygelThumbnailClass RygelThumbnailClass;
 #define _g_free0(var) (var = (g_free (var), NULL))
 #define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
-#define _gst_object_unref0(var) ((var == NULL) ? NULL : (var = (gst_object_unref (var), NULL)))
 
 #define RYGEL_TYPE_THUMBNAILER (rygel_thumbnailer_get_type ())
 #define RYGEL_THUMBNAILER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_THUMBNAILER, RygelThumbnailer))
@@ -98,16 +96,6 @@ typedef struct _RygelThumbnailer RygelTh
 typedef struct _RygelThumbnailerClass RygelThumbnailerClass;
 #define _rygel_icon_info_unref0(var) ((var == NULL) ? NULL : (var = (rygel_icon_info_unref (var), NULL)))
 #define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
-
-#define RYGEL_TYPE_TRANSCODER (rygel_transcoder_get_type ())
-#define RYGEL_TRANSCODER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_TRANSCODER, RygelTranscoder))
-#define RYGEL_TRANSCODER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_TRANSCODER, RygelTranscoderClass))
-#define RYGEL_IS_TRANSCODER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_TRANSCODER))
-#define RYGEL_IS_TRANSCODER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_TRANSCODER))
-#define RYGEL_TRANSCODER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_TRANSCODER, RygelTranscoderClass))
-
-typedef struct _RygelTranscoder RygelTranscoder;
-typedef struct _RygelTranscoderClass RygelTranscoderClass;
 typedef struct _RygelIconInfoPrivate RygelIconInfoPrivate;
 typedef struct _RygelThumbnailPrivate RygelThumbnailPrivate;
 
@@ -156,7 +144,6 @@ struct _RygelMediaItem {
 
 struct _RygelMediaItemClass {
 	RygelMediaObjectClass parent_class;
-	GstElement* (*create_stream_source) (RygelMediaItem* self);
 	gboolean (*should_stream) (RygelMediaItem* self);
 };
 
@@ -212,18 +199,12 @@ enum  {
 RygelMediaObject* rygel_media_object_construct (GType object_type);
 RygelMediaItem* rygel_media_item_new (const char* id, RygelMediaContainer* parent, const char* title, const char* upnp_class);
 RygelMediaItem* rygel_media_item_construct (GType object_type, const char* id, RygelMediaContainer* parent, const char* title, const char* upnp_class);
-static inline void _dynamic_set_tcp_timeout1 (GstElement* obj, gint64 value);
-GstElement* rygel_media_item_create_stream_source (RygelMediaItem* self);
-static GstElement* rygel_media_item_real_create_stream_source (RygelMediaItem* self);
 gboolean rygel_media_item_should_stream (RygelMediaItem* self);
 static gboolean rygel_media_item_real_should_stream (RygelMediaItem* self);
 GType rygel_thumbnailer_get_type (void);
 RygelThumbnailer* rygel_thumbnailer_get_default (void);
 RygelThumbnail* rygel_thumbnailer_get_thumbnail (RygelThumbnailer* self, const char* uri, GError** error);
 void rygel_media_item_add_uri (RygelMediaItem* self, const char* uri, RygelThumbnail* thumbnail);
-GType rygel_transcoder_get_type (void);
-guint rygel_transcoder_get_distance (RygelTranscoder* self, RygelMediaItem* item);
-gint rygel_media_item_compare_transcoders (RygelMediaItem* self, void* a, void* b);
 static char* rygel_media_item_get_protocol_for_uri (RygelMediaItem* self, const char* uri, GError** error);
 GUPnPDIDLLiteResource* rygel_media_item_add_resource (RygelMediaItem* self, GUPnPDIDLLiteItem* didl_item, const char* uri, const char* protocol, GError** error);
 GUPnPDIDLLiteResource* rygel_thumbnail_add_resource (RygelThumbnail* self, GUPnPDIDLLiteItem* didl_item, const char* protocol);
@@ -254,7 +235,7 @@ RygelMediaItem* rygel_media_item_constru
 	((RygelMediaObject*) self)->parent = parent;
 	((RygelMediaObject*) self)->title = (_tmp1_ = g_strdup (title), _g_free0 (((RygelMediaObject*) self)->title), _tmp1_);
 	self->upnp_class = (_tmp2_ = g_strdup (upnp_class), _g_free0 (self->upnp_class), _tmp2_);
-	self->thumbnails = (_tmp3_ = gee_array_list_new (RYGEL_TYPE_THUMBNAIL, (GBoxedCopyFunc) rygel_icon_info_ref, rygel_icon_info_unref, g_direct_equal), _g_object_unref0 (self->thumbnails), _tmp3_);
+	self->thumbnails = (_tmp3_ = gee_array_list_new (RYGEL_TYPE_THUMBNAIL, (GBoxedCopyFunc) rygel_icon_info_ref, rygel_icon_info_unref, NULL), _g_object_unref0 (self->thumbnails), _tmp3_);
 	return self;
 }
 
@@ -264,41 +245,6 @@ RygelMediaItem* rygel_media_item_new (co
 }
 
 
-static inline void _dynamic_set_tcp_timeout1 (GstElement* obj, gint64 value) {
-	g_object_set (obj, "tcp-timeout", value, NULL);
-}
-
-
-static GstElement* rygel_media_item_real_create_stream_source (RygelMediaItem* self) {
-	GstElement* result;
-	GstElement* src;
-	gboolean _tmp2_ = FALSE;
-	g_return_val_if_fail (self != NULL, NULL);
-	src = NULL;
-	if (gee_collection_get_size ((GeeCollection*) ((RygelMediaObject*) self)->uris) != 0) {
-		GstElement* _tmp1_;
-		char* _tmp0_;
-		src = (_tmp1_ = gst_element_make_from_uri (GST_URI_SRC, _tmp0_ = (char*) gee_abstract_list_get ((GeeAbstractList*) ((RygelMediaObject*) self)->uris, 0), NULL), _gst_object_unref0 (src), _tmp1_);
-		_g_free0 (_tmp0_);
-	}
-	if (src != NULL) {
-		_tmp2_ = _vala_strcmp0 (g_type_name (G_TYPE_FROM_INSTANCE ((GObject*) src)), "GstRTSPSrc") == 0;
-	} else {
-		_tmp2_ = FALSE;
-	}
-	if (_tmp2_) {
-		_dynamic_set_tcp_timeout1 (src, (gint64) 60000000);
-	}
-	result = src;
-	return result;
-}
-
-
-GstElement* rygel_media_item_create_stream_source (RygelMediaItem* self) {
-	return RYGEL_MEDIA_ITEM_GET_CLASS (self)->create_stream_source (self);
-}
-
-
 static gboolean rygel_media_item_real_should_stream (RygelMediaItem* self) {
 	gboolean result;
 	g_return_val_if_fail (self != NULL, FALSE);
@@ -338,14 +284,14 @@ void rygel_media_item_add_uri (RygelMedi
 				RygelThumbnail* thumb;
 				thumb = rygel_thumbnailer_get_thumbnail (thumbnailer, uri, &_inner_error_);
 				if (_inner_error_ != NULL) {
-					goto __catch33_g_error;
-					goto __finally33;
+					goto __catch29_g_error;
+					goto __finally29;
 				}
 				gee_abstract_collection_add ((GeeAbstractCollection*) self->thumbnails, thumb);
 				_rygel_icon_info_unref0 (thumb);
 			}
-			goto __finally33;
-			__catch33_g_error:
+			goto __finally29;
+			__catch29_g_error:
 			{
 				GError * err;
 				err = _inner_error_;
@@ -354,10 +300,10 @@ void rygel_media_item_add_uri (RygelMedi
 					_g_error_free0 (err);
 				}
 			}
-			__finally33:
+			__finally29:
 			if (_inner_error_ != NULL) {
 				_g_object_unref0 (thumbnailer);
-				g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
+				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
 				g_clear_error (&_inner_error_);
 				return;
 			}
@@ -367,25 +313,6 @@ void rygel_media_item_add_uri (RygelMedi
 }
 
 
-static gpointer _g_object_ref0 (gpointer self) {
-	return self ? g_object_ref (self) : NULL;
-}
-
-
-gint rygel_media_item_compare_transcoders (RygelMediaItem* self, void* a, void* b) {
-	gint result;
-	RygelTranscoder* transcoder1;
-	RygelTranscoder* transcoder2;
-	g_return_val_if_fail (self != NULL, 0);
-	transcoder1 = _g_object_ref0 (RYGEL_TRANSCODER (a));
-	transcoder2 = _g_object_ref0 (RYGEL_TRANSCODER (b));
-	result = ((gint) rygel_transcoder_get_distance (transcoder1, self)) - ((gint) rygel_transcoder_get_distance (transcoder2, self));
-	_g_object_unref0 (transcoder1);
-	_g_object_unref0 (transcoder2);
-	return result;
-}
-
-
 void rygel_media_item_add_resources (RygelMediaItem* self, GUPnPDIDLLiteItem* didl_item, gboolean allow_internal, GError** error) {
 	GError * _inner_error_;
 	g_return_if_fail (self != NULL);
@@ -548,7 +475,7 @@ static char* rygel_media_item_get_protoc
 				_g_free0 (scheme);
 				return result;
 			} else {
-				g_warning ("rygel-media-item.vala:223: Failed to probe protocol for URI %s. Assuming '%s'", uri, scheme);
+				g_warning ("rygel-media-item.vala:196: Failed to probe protocol for URI %s. Assuming '%s'", uri, scheme);
 				result = scheme;
 				return result;
 			}
@@ -560,7 +487,6 @@ static char* rygel_media_item_get_protoc
 
 static void rygel_media_item_class_init (RygelMediaItemClass * klass) {
 	rygel_media_item_parent_class = g_type_class_peek_parent (klass);
-	RYGEL_MEDIA_ITEM_CLASS (klass)->create_stream_source = rygel_media_item_real_create_stream_source;
 	RYGEL_MEDIA_ITEM_CLASS (klass)->should_stream = rygel_media_item_real_should_stream;
 	G_OBJECT_CLASS (klass)->finalize = rygel_media_item_finalize;
 }
--- a/src/rygel/rygel-media-object-search.c
+++ b/src/rygel/rygel-media-object-search.c
@@ -204,34 +204,36 @@ static void rygel_media_object_search_on
 		_tmp1_ = rygel_media_container_find_object_finish (container, res, &_inner_error_);
 		if (_inner_error_ != NULL) {
 			_g_object_unref0 (container);
-			goto __catch32_g_error;
-			goto __finally32;
+			goto __catch28_g_error;
+			goto __finally28;
 		}
 		self->media_object = (_tmp2_ = _tmp1_, _g_object_unref0 (self->media_object), _tmp2_);
 		if (self->media_object == NULL) {
-			gee_abstract_list_remove_at ((GeeAbstractList*) self->priv->containers, 0);
+			RygelMediaContainer* _tmp3_;
+			_tmp3_ = (RygelMediaContainer*) gee_abstract_list_remove_at ((GeeAbstractList*) self->priv->containers, 0);
+			_g_object_unref0 (_tmp3_);
 			rygel_state_machine_run ((RygelStateMachine*) self);
 		} else {
 			g_signal_emit_by_name ((RygelStateMachine*) self, "completed");
 		}
 		_g_object_unref0 (container);
 	}
-	goto __finally32;
-	__catch32_g_error:
+	goto __finally28;
+	__catch28_g_error:
 	{
 		GError * err;
 		err = _inner_error_;
 		_inner_error_ = NULL;
 		{
-			GError* _tmp3_;
-			self->error = (_tmp3_ = _g_error_copy0 (err), _g_error_free0 (self->error), _tmp3_);
+			GError* _tmp4_;
+			self->error = (_tmp4_ = _g_error_copy0 (err), _g_error_free0 (self->error), _tmp4_);
 			g_signal_emit_by_name ((RygelStateMachine*) self, "completed");
 			_g_error_free0 (err);
 		}
 	}
-	__finally32:
+	__finally28:
 	if (_inner_error_ != NULL) {
-		g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
+		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
 		g_clear_error (&_inner_error_);
 		return;
 	}
--- a/src/rygel/rygel-media-object.c
+++ b/src/rygel/rygel-media-object.c
@@ -98,7 +98,7 @@ static GObject * rygel_media_object_cons
 	self = RYGEL_MEDIA_OBJECT (obj);
 	{
 		GeeArrayList* _tmp0_;
-		self->uris = (_tmp0_ = gee_array_list_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, g_direct_equal), _g_object_unref0 (self->uris), _tmp0_);
+		self->uris = (_tmp0_ = gee_array_list_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, NULL), _g_object_unref0 (self->uris), _tmp0_);
 	}
 	return obj;
 }
--- a/src/rygel/rygel-meta-config.c
+++ b/src/rygel/rygel-meta-config.c
@@ -201,7 +201,7 @@ RygelMetaConfig* rygel_meta_config_const
 	RygelCmdlineConfig* _tmp1_;
 	_inner_error_ = NULL;
 	self = (RygelMetaConfig*) g_object_new (object_type, NULL);
-	self->priv->configs = (_tmp0_ = gee_array_list_new (RYGEL_TYPE_CONFIGURATION, (GBoxedCopyFunc) g_object_ref, g_object_unref, g_direct_equal), _g_object_unref0 (self->priv->configs), _tmp0_);
+	self->priv->configs = (_tmp0_ = gee_array_list_new (RYGEL_TYPE_CONFIGURATION, (GBoxedCopyFunc) g_object_ref, g_object_unref, NULL), _g_object_unref0 (self->priv->configs), _tmp0_);
 	gee_abstract_collection_add ((GeeAbstractCollection*) self->priv->configs, (RygelConfiguration*) (_tmp1_ = rygel_cmdline_config_get_default ()));
 	_g_object_unref0 (_tmp1_);
 	{
@@ -227,7 +227,7 @@ RygelMetaConfig* rygel_meta_config_const
 	}
 	__finally5:
 	if (_inner_error_ != NULL) {
-		g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
+		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
 		g_clear_error (&_inner_error_);
 		return NULL;
 	}
--- /dev/null
+++ b/src/rygel/rygel-network-device.c
@@ -0,0 +1,242 @@
+/*
+ * rygel-network-device.c
+ *   Helper methods to query network devices
+ *
+ * (C) Copyright 2010, Ubicom, Inc.
+ *
+ * This file is part of the Ubicom32 Rygel.
+ *
+ * This program is free software: you can redistribute
+ * it and/or modify it under the terms of the GNU Lesser General Public
+ * License (LGPL) as published by the Free Software Foundation, either version 2.1
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it
+ * will be useful, but WITHOUT ANY WARRANTY; without even the implied
+ * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+ * the GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program.  If not,
+ * see <http://www.gnu.org/licenses/>.
+ */
+
+#include <stdio.h>
+#include <string.h>
+#include <ctype.h>
+#include <netinet/in.h>
+#include <net/if.h>
+#include <ifaddrs.h>
+#include <sys/ioctl.h>
+#include <errno.h>
+#include <glib.h>
+#include "rygel-network-device.h"
+
+/*
+ * Returns the list of network device names
+ *
+ * Returns NULL in case of failure.
+ */
+GList *
+rygel_network_device_get_interface_list ()
+{
+    struct ifaddrs *ifa_list, *ifa;
+    GList *processed = NULL;
+
+    /*
+     * Get the linked list of network interfaces
+     */
+    if (getifaddrs (&ifa_list) != 0) {
+            g_warning ("Failed to retrieve list of network interfaces:%s\n",
+                       strerror (errno));
+
+            return NULL;
+    }
+
+    /*
+     * Create contexts for each up interface
+     */
+    for (ifa = ifa_list; ifa != NULL; ifa = ifa->ifa_next) {
+            if (ifa->ifa_addr == NULL ||
+                ifa->ifa_flags & IFF_LOOPBACK ||
+                g_list_find_custom (processed, ifa->ifa_name, (GCompareFunc) strcmp) != NULL) {
+                    continue;
+            }
+
+            char ip[INET6_ADDRSTRLEN];
+            struct sockaddr_in *s4;
+            struct sockaddr_in6 *s6;
+            const char *p = NULL;
+
+            switch (ifa->ifa_addr->sa_family) {
+            case AF_INET:
+                    s4 = (struct sockaddr_in *) ifa->ifa_addr;
+                    p = inet_ntop (AF_INET,
+                                   &s4->sin_addr, ip, sizeof (ip));
+                    break;
+            case AF_INET6:
+                    s6 = (struct sockaddr_in6 *) ifa->ifa_addr;
+                    p = inet_ntop (AF_INET6,
+                                   &s6->sin6_addr, ip, sizeof (ip));
+                    break;
+            default:
+                    continue; /* Unknown: ignore */
+            }
+
+            /*
+             * Ignore interfaces without name
+             */
+            if (p == NULL) {
+                continue;
+            }
+
+            processed = g_list_append (processed, g_strdup (ifa->ifa_name));
+    }
+
+    freeifaddrs (ifa_list);
+
+    return processed;
+}
+
+/*
+ * A wrapper for ioctl executions
+ *
+ * Returns 0 in case of success, -1 otherwise.
+ */
+static int
+execute_ioctl (const char *interface_name, int flag, struct ifreq *ifr)
+{
+    int fd;
+
+    fd = socket (AF_INET, SOCK_DGRAM, 0);
+    if (fd == -1) {
+        g_warning ("Failed to create socket:%s\n", strerror (errno));
+        close (fd);
+        return -1;
+    }
+
+    /* I want an IPv4 netmask */
+    ifr->ifr_addr.sa_family = AF_INET;
+
+    /* I want netmask attached to the interface */
+    strncpy (ifr->ifr_name, interface_name, IFNAMSIZ-1);
+
+    if (ioctl (fd, flag, ifr) == -1) {
+        g_warning ("ioctl operation(%d) failed:%s\n", flag, strerror (errno));
+        close (fd);
+        return -1;
+    }
+
+    close (fd);
+    return 0;
+}
+
+/*
+ * Returns the state of the network interface as either
+ * NM_DEVICE_STATE_UNKNOWN or NM_DEVICE_STATE_ACTIVATED
+ *
+ * Returns 0 in case of success, -1 otherwise.
+ */
+int
+rygel_network_device_get_state (const char *interface_name, NMDeviceState *state) {
+    struct ifreq ifr;
+
+    if (execute_ioctl (interface_name, SIOCGIFFLAGS, &ifr) == -1) {
+        return -1;
+    }
+
+    *state = (ifr.ifr_flags & IFF_UP) ? NM_DEVICE_STATE_ACTIVATED : NM_DEVICE_STATE_UNKNOWN;
+
+    return 0;
+}
+
+/*
+ * Returns the ip address of the network interface
+ *
+ * Returns 0 in case of success, -1 otherwise.
+ */
+int
+rygel_network_device_get_ip (const char *interface_name, char **ip_addr) {
+    struct ifreq ifr;
+
+    if (execute_ioctl (interface_name, SIOCGIFADDR, &ifr) == -1) {
+        return -1;
+    }
+
+    *ip_addr = g_strdup (inet_ntoa (((struct sockaddr_in *)&ifr.ifr_addr)->sin_addr));
+
+    return 0;
+}
+
+/*
+ * Returns the netmask of the network interface
+ *
+ * Returns 0 in case of success, -1 otherwise.
+ */
+int
+rygel_network_device_get_netmask (const char *interface_name, char **netmask) {
+    struct ifreq ifr;
+
+    if (execute_ioctl (interface_name, SIOCGIFNETMASK, &ifr) == -1) {
+        return -1;
+    }
+
+    *netmask = g_strdup (inet_ntoa (((struct sockaddr_in *)&ifr.ifr_addr)->sin_addr));
+
+    return 0;
+}
+
+/*
+ * Returns 1 if given Ralink device is connected, -1 at any failures.
+ *
+ * This command specific to Ralink drivers, connStatus is
+ * subcommand only works with Ralink wireless driver.
+ */
+int
+rygel_network_device_get_status(const char *interface_name, gboolean *status)
+{
+    if (!interface_name) {
+        g_warning("NULL interface name");
+        return -1;
+    }
+
+    if (!status) {
+        g_warning("NULL status pointer");
+        return -1;
+    }
+
+    /* Skip driver if not ralink (not checking for all of possibilities, just checking for ra[0-9]) */
+    if (strncmp(interface_name, "ra", 2) || !isdigit(interface_name[2])) {
+        return -1;
+    }
+
+    char cmd[32], line[32];
+    int ret = 0;
+    char *read;
+    FILE *fp;
+
+    /*
+     * Command to be executed
+     */
+    snprintf(cmd, 32, "iwpriv %s connStatus", interface_name);
+    fp = popen(cmd, "r");
+    if (fp < 0) {
+      ret = -1;
+      goto exit;
+    }
+
+    read = fgets(line, 32, fp);
+    if (!read) {
+	g_warning("cannot read command output. ('%s')", cmd);
+	ret = -1;
+	goto exit;
+    }
+
+    if (strstr(line, "Connected")) {
+	*status = TRUE;
+    }
+
+exit:
+    pclose(fp);
+    return ret;
+}
--- /dev/null
+++ b/src/rygel/rygel-network-device.h
@@ -0,0 +1,46 @@
+/*
+ * rygel-network-device.h
+ *   Helper methods to query network devices
+ *
+ * (C) Copyright 2010, Ubicom, Inc.
+ *
+ * This file is part of the Ubicom32 Rygel.
+ *
+ * This program is free software: you can redistribute
+ * it and/or modify it under the terms of the GNU Lesser General Public
+ * License (LGPL) as published by the Free Software Foundation, either version 2.1
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it
+ * will be useful, but WITHOUT ANY WARRANTY; without even the implied
+ * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+ * the GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program.  If not,
+ * see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef __RYGEL_NETWORK_DEVICE_H__
+#define __RYGEL_NETWORK_DEVICE_H__
+
+typedef enum {
+    NM_DEVICE_STATE_UNKNOWN,
+    NM_DEVICE_STATE_UNMANAGED,
+    NM_DEVICE_STATE_UNAVAILABLE,
+    NM_DEVICE_STATE_DISCONNECTED,
+    NM_DEVICE_STATE_PREPARE,
+    NM_DEVICE_STATE_CONFIG,
+    NM_DEVICE_STATE_NEED_AUTH,
+    NM_DEVICE_STATE_IP_CONFIG,
+    NM_DEVICE_STATE_ACTIVATED,
+    NM_DEVICE_STATE_FAILED
+} NMDeviceState;
+
+GList * rygel_network_device_get_interface_list ();
+int rygel_network_device_get_state (const char *interface, NMDeviceState *is_up);
+int rygel_network_device_get_ip (const char *interface, char **ip_addr);
+int rygel_network_device_get_netmask (const char *interface, char **netmask);
+int rygel_network_device_get_status(const char *interface_name, gboolean *status);
+
+#endif /* __RYGEL_NETWORK_DEVICE_H__ */
--- /dev/null
+++ b/src/rygel/rygel-network-device.vapi
@@ -0,0 +1,48 @@
+/*
+ * rygel-network-device.vapi
+ *   Helper methods to query network devices
+ *
+ * (C) Copyright 2010, Ubicom, Inc.
+ *
+ * This file is part of the Ubicom32 Rygel.
+ *
+ * This program is free software: you can redistribute
+ * it and/or modify it under the terms of the GNU Lesser General Public
+ * License (LGPL) as published by the Free Software Foundation, either version 2.1
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it
+ * will be useful, but WITHOUT ANY WARRANTY; without even the implied
+ * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+ * the GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program.  If not,
+ * see <http://www.gnu.org/licenses/>.
+ */
+
+[CCode (cprefix = "Rygel", lower_case_cprefix = "rygel_")]
+namespace Rygel {
+    [CCode (cheader_filename = "rygel-network-device.h")]
+    namespace NetworkDevice {
+        [CCode (cprefix = "", cname = "NMDeviceState", cheader_filename = "rygel-network-device.h")]
+        public enum NMDeviceState {
+            NM_DEVICE_STATE_UNKNOWN,
+            NM_DEVICE_STATE_UNMANAGED,
+            NM_DEVICE_STATE_UNAVAILABLE,
+            NM_DEVICE_STATE_DISCONNECTED,
+            NM_DEVICE_STATE_PREPARE,
+            NM_DEVICE_STATE_CONFIG,
+            NM_DEVICE_STATE_NEED_AUTH,
+            NM_DEVICE_STATE_IP_CONFIG,
+            NM_DEVICE_STATE_ACTIVATED,
+            NM_DEVICE_STATE_FAILED
+        }
+
+        public static GLib.List<string> get_interface_list ();
+        public static int get_state (string interface, NMDeviceState *state);
+        public static int get_ip (string interface, string **ip);
+        public static int get_netmask (string interface, string **netmask);
+	public static int get_status(string interface, bool *status);
+    }
+}
--- a/src/rygel/rygel-plugin-loader.c
+++ b/src/rygel/rygel-plugin-loader.c
@@ -153,7 +153,7 @@ RygelPluginLoader* rygel_plugin_loader_c
 	RygelPluginLoader * self;
 	GeeHashMap* _tmp0_;
 	self = (RygelPluginLoader*) g_object_new (object_type, NULL);
-	self->priv->plugin_hash = (_tmp0_ = gee_hash_map_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, RYGEL_TYPE_PLUGIN, (GBoxedCopyFunc) g_object_ref, g_object_unref, g_str_hash, g_str_equal, g_direct_equal), _g_object_unref0 (self->priv->plugin_hash), _tmp0_);
+	self->priv->plugin_hash = (_tmp0_ = gee_hash_map_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, RYGEL_TYPE_PLUGIN, (GBoxedCopyFunc) g_object_ref, g_object_unref, g_str_hash, g_str_equal, NULL), _g_object_unref0 (self->priv->plugin_hash), _tmp0_);
 	return self;
 }
 
@@ -165,16 +165,10 @@ RygelPluginLoader* rygel_plugin_loader_n
 
 void rygel_plugin_loader_load_plugins (RygelPluginLoader* self) {
 	GFile* dir;
-	gboolean _tmp0_ = FALSE;
 	g_return_if_fail (self != NULL);
 	g_assert (g_module_supported ());
 	dir = g_file_new_for_path (PLUGIN_DIR);
-	if (dir != NULL) {
-		_tmp0_ = rygel_plugin_loader_is_dir (dir);
-	} else {
-		_tmp0_ = FALSE;
-	}
-	g_assert (_tmp0_);
+	g_assert ((dir != NULL) && rygel_plugin_loader_is_dir (dir));
 	rygel_plugin_loader_load_modules_from_dir (self, dir);
 	_g_object_unref0 (dir);
 }
@@ -201,7 +195,7 @@ RygelPlugin* rygel_plugin_loader_get_plu
 GeeCollection* rygel_plugin_loader_list_plugins (RygelPluginLoader* self) {
 	GeeCollection* result;
 	g_return_val_if_fail (self != NULL, NULL);
-	result = gee_abstract_map_get_values ((GeeAbstractMap*) self->priv->plugin_hash);
+	result = gee_map_get_values ((GeeMap*) self->priv->plugin_hash);
 	return result;
 }
 
@@ -245,13 +239,13 @@ static void rygel_plugin_loader_on_child
 		GFileEnumerator* _tmp1_;
 		_tmp0_ = g_file_enumerate_children_finish (dir, res, &_inner_error_);
 		if (_inner_error_ != NULL) {
-			goto __catch29_g_error;
-			goto __finally29;
+			goto __catch25_g_error;
+			goto __finally25;
 		}
 		enumerator = (_tmp1_ = _tmp0_, _g_object_unref0 (enumerator), _tmp1_);
 	}
-	goto __finally29;
-	__catch29_g_error:
+	goto __finally25;
+	__catch25_g_error:
 	{
 		GError * _error_;
 		_error_ = _inner_error_;
@@ -266,11 +260,11 @@ static void rygel_plugin_loader_on_child
 			return;
 		}
 	}
-	__finally29:
+	__finally25:
 	if (_inner_error_ != NULL) {
 		_g_object_unref0 (dir);
 		_g_object_unref0 (enumerator);
-		g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
+		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
 		g_clear_error (&_inner_error_);
 		return;
 	}
@@ -302,13 +296,13 @@ static void rygel_plugin_loader_on_next_
 		GList* _tmp1_;
 		_tmp0_ = g_file_enumerator_next_files_finish (enumerator, res, &_inner_error_);
 		if (_inner_error_ != NULL) {
-			goto __catch30_g_error;
-			goto __finally30;
+			goto __catch26_g_error;
+			goto __finally26;
 		}
 		infos = (_tmp1_ = _tmp0_, __g_list_free_g_object_unref0 (infos), _tmp1_);
 	}
-	goto __finally30;
-	__catch30_g_error:
+	goto __finally26;
+	__catch26_g_error:
 	{
 		GError * _error_;
 		_error_ = _inner_error_;
@@ -324,12 +318,12 @@ static void rygel_plugin_loader_on_next_
 			return;
 		}
 	}
-	__finally30:
+	__finally26:
 	if (_inner_error_ != NULL) {
 		_g_object_unref0 (enumerator);
 		_g_object_unref0 (dir);
 		__g_list_free_g_object_unref0 (infos);
-		g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
+		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
 		g_clear_error (&_inner_error_);
 		return;
 	}
@@ -421,13 +415,13 @@ static gboolean rygel_plugin_loader_is_d
 		GFileInfo* _tmp1_;
 		_tmp0_ = g_file_query_info (file, G_FILE_ATTRIBUTE_STANDARD_TYPE, G_FILE_QUERY_INFO_NONE, NULL, &_inner_error_);
 		if (_inner_error_ != NULL) {
-			goto __catch31_g_error;
-			goto __finally31;
+			goto __catch27_g_error;
+			goto __finally27;
 		}
 		file_info = (_tmp1_ = _tmp0_, _g_object_unref0 (file_info), _tmp1_);
 	}
-	goto __finally31;
-	__catch31_g_error:
+	goto __finally27;
+	__catch27_g_error:
 	{
 		GError * _error_;
 		_error_ = _inner_error_;
@@ -442,10 +436,10 @@ static gboolean rygel_plugin_loader_is_d
 			return result;
 		}
 	}
-	__finally31:
+	__finally27:
 	if (_inner_error_ != NULL) {
 		_g_object_unref0 (file_info);
-		g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
+		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
 		g_clear_error (&_inner_error_);
 		return FALSE;
 	}
--- a/src/rygel/rygel-plugin.c
+++ b/src/rygel/rygel-plugin.c
@@ -136,7 +136,7 @@ void rygel_plugin_set_available (RygelPl
 RygelPlugin* rygel_plugin_new (const char* desc_path, const char* name, const char* title);
 RygelPlugin* rygel_plugin_construct (GType object_type, const char* desc_path, const char* name, const char* title);
 #define RYGEL_CONNECTION_MANAGER_UPNP_ID "urn:upnp-org:serviceId:ConnectionManager"
-#define RYGEL_CONNECTION_MANAGER_UPNP_TYPE "urn:schemas-upnp-org:service:ConnectionManager:2"
+#define RYGEL_CONNECTION_MANAGER_UPNP_TYPE "urn:schemas-upnp-org:service:ConnectionManager:1"
 #define RYGEL_CONNECTION_MANAGER_DESCRIPTION_PATH "xml/ConnectionManager.xml"
 GType rygel_connection_manager_get_type (void);
 RygelResourceInfo* rygel_resource_info_new (const char* upnp_id, const char* upnp_type, const char* description_path, GType type);
@@ -170,8 +170,8 @@ RygelPlugin* rygel_plugin_construct (GTy
 		char* _tmp3_;
 		self->title = (_tmp3_ = g_strdup (name), _g_free0 (self->title), _tmp3_);
 	}
-	self->resource_infos = (_tmp4_ = gee_array_list_new (RYGEL_TYPE_RESOURCE_INFO, (GBoxedCopyFunc) rygel_resource_info_ref, rygel_resource_info_unref, g_direct_equal), _g_object_unref0 (self->resource_infos), _tmp4_);
-	self->icon_infos = (_tmp5_ = gee_array_list_new (RYGEL_TYPE_ICON_INFO, (GBoxedCopyFunc) rygel_icon_info_ref, rygel_icon_info_unref, g_direct_equal), _g_object_unref0 (self->icon_infos), _tmp5_);
+	self->resource_infos = (_tmp4_ = gee_array_list_new (RYGEL_TYPE_RESOURCE_INFO, (GBoxedCopyFunc) rygel_resource_info_ref, rygel_resource_info_unref, NULL), _g_object_unref0 (self->resource_infos), _tmp4_);
+	self->icon_infos = (_tmp5_ = gee_array_list_new (RYGEL_TYPE_ICON_INFO, (GBoxedCopyFunc) rygel_icon_info_ref, rygel_icon_info_unref, NULL), _g_object_unref0 (self->icon_infos), _tmp5_);
 	return self;
 }
 
--- a/src/rygel/rygel-root-device-factory.c
+++ b/src/rygel/rygel-root-device-factory.c
@@ -33,6 +33,7 @@
 #include <gee.h>
 #include <libxml/tree.h>
 #include <cstuff.h>
+#include <rygel-network-device.h>
 #include <stdio.h>
 #include <libxml/parser.h>
 #include <gio/gio.h>
@@ -114,6 +115,17 @@ typedef struct _RygelIconInfoClass Rygel
 typedef struct _RygelRootDevice RygelRootDevice;
 typedef struct _RygelRootDeviceClass RygelRootDeviceClass;
 #define _g_regex_unref0(var) ((var == NULL) ? NULL : (var = (g_regex_unref (var), NULL)))
+
+#define RYGEL_TYPE_DBUS_SERVICE (rygel_dbus_service_get_type ())
+#define RYGEL_DBUS_SERVICE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_DBUS_SERVICE, RygelDBusService))
+#define RYGEL_DBUS_SERVICE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_DBUS_SERVICE, RygelDBusServiceClass))
+#define RYGEL_IS_DBUS_SERVICE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_DBUS_SERVICE))
+#define RYGEL_IS_DBUS_SERVICE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_DBUS_SERVICE))
+#define RYGEL_DBUS_SERVICE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_DBUS_SERVICE, RygelDBusServiceClass))
+
+typedef struct _RygelDBusService RygelDBusService;
+typedef struct _RygelDBusServiceClass RygelDBusServiceClass;
+#define __g_list_free_g_free0(var) ((var == NULL) ? NULL : (var = (_g_list_free_g_free (var), NULL)))
 typedef struct _RygelResourceInfoPrivate RygelResourceInfoPrivate;
 #define _rygel_resource_info_unref0(var) ((var == NULL) ? NULL : (var = (rygel_resource_info_unref (var), NULL)))
 #define _rygel_icon_info_unref0(var) ((var == NULL) ? NULL : (var = (rygel_icon_info_unref (var), NULL)))
@@ -266,9 +278,13 @@ static gboolean rygel_root_device_factor
 static void rygel_root_device_factory_prepare_desc_for_plugin (RygelRootDeviceFactory* self, GUPnPXMLDoc* doc, RygelPlugin* plugin);
 static void rygel_root_device_factory_save_modified_desc (RygelRootDeviceFactory* self, GUPnPXMLDoc* doc, const char* desc_path, GError** error);
 static void rygel_root_device_factory_set_friendly_name_and_udn (RygelRootDeviceFactory* self, xmlNode* device_element, const char* plugin_name, const char* plugin_title);
+static void rygel_root_device_factory_set_presentation_url (RygelRootDeviceFactory* self, xmlNode* device_element);
 static void rygel_root_device_factory_add_icons_to_desc (RygelRootDeviceFactory* self, xmlNode* device_element, RygelPlugin* plugin);
 static void rygel_root_device_factory_add_services_to_desc (RygelRootDeviceFactory* self, xmlNode* device_element, RygelPlugin* plugin);
 char* rygel_configuration_get_title (RygelConfiguration* self, const char* section, GError** error);
+GType rygel_dbus_service_get_type (void);
+RygelDBusService* rygel_dbus_service_get_default (void);
+static void _g_list_free_g_free (GList* self);
 static void rygel_root_device_factory_add_service_to_desc (RygelRootDeviceFactory* self, xmlNode* service_list_node, const char* plugin_name, RygelResourceInfo* resource_info);
 static void rygel_root_device_factory_add_icon_to_desc (RygelRootDeviceFactory* self, xmlNode* icon_list_node, RygelIconInfo* icon_info, RygelPlugin* plugin);
 static void rygel_root_device_factory_finalize (RygelRootDeviceFactory* obj);
@@ -301,7 +317,7 @@ RygelRootDeviceFactory* rygel_root_devic
 	rygel_root_device_factory_ensure_dir_exists (self, self->priv->desc_dir, &_inner_error_);
 	if (_inner_error_ != NULL) {
 		g_propagate_error (error, _inner_error_);
-		return;
+		return NULL;
 	}
 	return self;
 }
@@ -327,13 +343,13 @@ RygelRootDevice* rygel_root_device_facto
 		gboolean _tmp0_;
 		_tmp0_ = rygel_configuration_get_enabled (self->priv->config, plugin->name, &_inner_error_);
 		if (_inner_error_ != NULL) {
-			goto __catch47_g_error;
-			goto __finally47;
+			goto __catch42_g_error;
+			goto __finally42;
 		}
 		enabled = _tmp0_;
 	}
-	goto __finally47;
-	__catch47_g_error:
+	goto __finally42;
+	__catch42_g_error:
 	{
 		GError * err;
 		err = _inner_error_;
@@ -342,7 +358,7 @@ RygelRootDevice* rygel_root_device_facto
 			_g_error_free0 (err);
 		}
 	}
-	__finally47:
+	__finally42:
 	if (_inner_error_ != NULL) {
 		g_propagate_error (error, _inner_error_);
 		return NULL;
@@ -415,10 +431,11 @@ static void rygel_root_device_factory_pr
 	g_return_if_fail (plugin != NULL);
 	device_element = get_xml_element ((xmlNode*) doc->doc, "root", "device", NULL, NULL);
 	if (device_element == NULL) {
-		g_warning ("rygel-root-device-factory.vala:108: Element /root/device not found.");
+		g_warning ("rygel-root-device-factory.vala:109: Element /root/device not found.");
 		return;
 	}
 	rygel_root_device_factory_set_friendly_name_and_udn (self, device_element, plugin->name, plugin->title);
+	rygel_root_device_factory_set_presentation_url (self, device_element);
 	rygel_root_device_factory_add_icons_to_desc (self, device_element, plugin);
 	rygel_root_device_factory_add_services_to_desc (self, device_element, plugin);
 }
@@ -439,24 +456,24 @@ static char* string_replace (const char*
 		regex = (_tmp1_ = g_regex_new (_tmp0_ = g_regex_escape_string (old, -1), 0, 0, &_inner_error_), _g_free0 (_tmp0_), _tmp1_);
 		if (_inner_error_ != NULL) {
 			if (_inner_error_->domain == G_REGEX_ERROR) {
-				goto __catch49_g_regex_error;
+				goto __catch44_g_regex_error;
 			}
-			goto __finally49;
+			goto __finally44;
 		}
-		_tmp2_ = g_regex_replace_literal (regex, self, (glong) (-1), 0, replacement, 0, &_inner_error_);
+		_tmp2_ = g_regex_replace_literal (regex, self, (gssize) (-1), 0, replacement, 0, &_inner_error_);
 		if (_inner_error_ != NULL) {
 			_g_regex_unref0 (regex);
 			if (_inner_error_->domain == G_REGEX_ERROR) {
-				goto __catch49_g_regex_error;
+				goto __catch44_g_regex_error;
 			}
-			goto __finally49;
+			goto __finally44;
 		}
 		result = _tmp2_;
 		_g_regex_unref0 (regex);
 		return result;
 	}
-	goto __finally49;
-	__catch49_g_regex_error:
+	goto __finally44;
+	__catch44_g_regex_error:
 	{
 		GError * e;
 		e = _inner_error_;
@@ -466,9 +483,9 @@ static char* string_replace (const char*
 			_g_error_free0 (e);
 		}
 	}
-	__finally49:
+	__finally44:
 	if (_inner_error_ != NULL) {
-		g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
+		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
 		g_clear_error (&_inner_error_);
 		return NULL;
 	}
@@ -478,84 +495,160 @@ static char* string_replace (const char*
 static void rygel_root_device_factory_set_friendly_name_and_udn (RygelRootDeviceFactory* self, xmlNode* device_element, const char* plugin_name, const char* plugin_title) {
 	GError * _inner_error_;
 	xmlNode* element;
-	char* title;
-	char* _tmp3_;
-	char* _tmp4_;
-	char* _tmp5_;
+	char* friendlyname;
+	gboolean _tmp0_ = FALSE;
 	char* udn;
-	gboolean _tmp6_ = FALSE;
+	gboolean _tmp7_ = FALSE;
 	g_return_if_fail (self != NULL);
 	g_return_if_fail (plugin_name != NULL);
 	g_return_if_fail (plugin_title != NULL);
 	_inner_error_ = NULL;
 	element = get_xml_element (device_element, "friendlyName", NULL, NULL);
 	if (element == NULL) {
-		g_warning ("rygel-root-device-factory.vala:137: Element /root/device/friendlyName not found.");
+		g_warning ("rygel-root-device-factory.vala:141: Element /root/device/friendlyName not found.");
 		return;
 	}
-	title = NULL;
-	{
-		char* _tmp0_;
-		char* _tmp1_;
-		_tmp0_ = rygel_configuration_get_title (self->priv->config, plugin_name, &_inner_error_);
-		if (_inner_error_ != NULL) {
-			goto __catch48_g_error;
-			goto __finally48;
-		}
-		title = (_tmp1_ = _tmp0_, _g_free0 (title), _tmp1_);
+	friendlyname = xmlNodeGetContent (element);
+	if (friendlyname == NULL) {
+		_tmp0_ = TRUE;
+	} else {
+		_tmp0_ = _vala_strcmp0 (friendlyname, "") == 0;
 	}
-	goto __finally48;
-	__catch48_g_error:
-	{
-		GError * err;
-		err = _inner_error_;
-		_inner_error_ = NULL;
+	if (_tmp0_) {
+		char* title;
+		char* _tmp4_;
+		char* _tmp5_;
+		char* _tmp6_;
+		title = NULL;
 		{
+			char* _tmp1_;
 			char* _tmp2_;
-			title = (_tmp2_ = g_strdup (plugin_title), _g_free0 (title), _tmp2_);
-			_g_error_free0 (err);
+			_tmp1_ = rygel_configuration_get_title (self->priv->config, plugin_name, &_inner_error_);
+			if (_inner_error_ != NULL) {
+				goto __catch43_g_error;
+				goto __finally43;
+			}
+			title = (_tmp2_ = _tmp1_, _g_free0 (title), _tmp2_);
 		}
-	}
-	__finally48:
-	if (_inner_error_ != NULL) {
+		goto __finally43;
+		__catch43_g_error:
+		{
+			GError * err;
+			err = _inner_error_;
+			_inner_error_ = NULL;
+			{
+				char* _tmp3_;
+				title = (_tmp3_ = g_strdup (plugin_title), _g_free0 (title), _tmp3_);
+				_g_error_free0 (err);
+			}
+		}
+		__finally43:
+		if (_inner_error_ != NULL) {
+			_g_free0 (title);
+			_g_free0 (friendlyname);
+			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
+			g_clear_error (&_inner_error_);
+			return;
+		}
+		title = (_tmp4_ = string_replace (title, "@REALNAME@", g_get_real_name ()), _g_free0 (title), _tmp4_);
+		title = (_tmp5_ = string_replace (title, "@USERNAME@", g_get_user_name ()), _g_free0 (title), _tmp5_);
+		title = (_tmp6_ = string_replace (title, "@HOSTNAME@", g_get_host_name ()), _g_free0 (title), _tmp6_);
+		xmlNodeSetContent (element, title);
 		_g_free0 (title);
-		g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
-		g_clear_error (&_inner_error_);
-		return;
 	}
-	title = (_tmp3_ = string_replace (title, "@REALNAME@", g_get_real_name ()), _g_free0 (title), _tmp3_);
-	title = (_tmp4_ = string_replace (title, "@USERNAME@", g_get_user_name ()), _g_free0 (title), _tmp4_);
-	title = (_tmp5_ = string_replace (title, "@HOSTNAME@", g_get_host_name ()), _g_free0 (title), _tmp5_);
-	xmlNodeSetContent (element, title);
 	element = get_xml_element (device_element, "UDN", NULL);
 	if (element == NULL) {
-		g_warning ("rygel-root-device-factory.vala:158: Element /root/device/UDN not found.");
-		_g_free0 (title);
+		g_warning ("rygel-root-device-factory.vala:165: Element /root/device/UDN not found.");
+		_g_free0 (friendlyname);
 		return;
 	}
 	udn = xmlNodeGetContent (element);
 	if (udn == NULL) {
-		_tmp6_ = TRUE;
+		_tmp7_ = TRUE;
 	} else {
-		_tmp6_ = _vala_strcmp0 (udn, "") == 0;
+		_tmp7_ = _vala_strcmp0 (udn, "") == 0;
 	}
-	if (_tmp6_) {
-		char* _tmp7_;
-		udn = (_tmp7_ = generate_random_udn (), _g_free0 (udn), _tmp7_);
+	if (_tmp7_) {
+		char* _tmp8_;
+		RygelDBusService* dbus_service;
+		udn = (_tmp8_ = generate_random_udn (), _g_free0 (udn), _tmp8_);
 		xmlNodeSetContent (element, udn);
+		dbus_service = rygel_dbus_service_get_default ();
+		if (dbus_service == NULL) {
+			g_warning ("rygel-root-device-factory.vala:178: %p: DBus service instance not created.", self);
+			_g_object_unref0 (dbus_service);
+			_g_free0 (friendlyname);
+			_g_free0 (udn);
+			return;
+		}
+		g_signal_emit_by_name (dbus_service, "udn-changed", udn);
+		_g_object_unref0 (dbus_service);
 	}
-	_g_free0 (title);
+	_g_free0 (friendlyname);
 	_g_free0 (udn);
 }
 
 
+static void _g_list_free_g_free (GList* self) {
+	g_list_foreach (self, (GFunc) g_free, NULL);
+	g_list_free (self);
+}
+
+
+static void rygel_root_device_factory_set_presentation_url (RygelRootDeviceFactory* self, xmlNode* device_element) {
+	xmlNode* element;
+	char* presentation_url;
+	GList* interface_list;
+	char* interface_name;
+	char* ip;
+	gint ret;
+	char* _tmp0_;
+	char* _tmp1_;
+	char* new_presentation_url;
+	g_return_if_fail (self != NULL);
+	element = get_xml_element (device_element, "presentationURL", NULL, NULL);
+	if (element == NULL) {
+		g_warning ("rygel-root-device-factory.vala:190: Element /root/device/presentationURL not found.");
+		return;
+	}
+	presentation_url = xmlNodeGetContent (element);
+	interface_list = rygel_network_device_get_interface_list ();
+	if (interface_list == NULL) {
+		g_warning ("rygel-root-device-factory.vala:198: %p: Interface list is NULL.", self);
+		_g_free0 (presentation_url);
+		__g_list_free_g_free0 (interface_list);
+		return;
+	}
+	interface_name = g_strdup ((const char*) g_list_nth_data (interface_list, (guint) 0));
+	ip = g_strdup ("");
+	ret = rygel_network_device_get_ip (interface_name, &ip);
+	if (ret == (-1)) {
+		g_warning ("rygel-root-device-factory.vala:206: %p: Could not get IP address.", self);
+		_g_free0 (presentation_url);
+		__g_list_free_g_free0 (interface_list);
+		_g_free0 (interface_name);
+		_g_free0 (ip);
+		return;
+	}
+	new_presentation_url = (_tmp1_ = g_strconcat (_tmp0_ = g_strconcat ("http://", ip, NULL), "/", NULL), _g_free0 (_tmp0_), _tmp1_);
+	if (_vala_strcmp0 (presentation_url, new_presentation_url) != 0) {
+		xmlNodeSetContent (element, new_presentation_url);
+	}
+	_g_free0 (presentation_url);
+	__g_list_free_g_free0 (interface_list);
+	_g_free0 (interface_name);
+	_g_free0 (ip);
+	_g_free0 (new_presentation_url);
+}
+
+
 static void rygel_root_device_factory_add_services_to_desc (RygelRootDeviceFactory* self, xmlNode* device_element, RygelPlugin* plugin) {
 	xmlNode* service_list_node;
 	g_return_if_fail (self != NULL);
 	g_return_if_fail (plugin != NULL);
 	service_list_node = get_xml_element (device_element, "serviceList", NULL, NULL);
 	if (service_list_node == NULL) {
-		g_warning ("rygel-root-device-factory.vala:177: Element /root/device/serviceList not found.");
+		g_warning ("rygel-root-device-factory.vala:222: Element /root/device/serviceList not found.");
 		return;
 	}
 	xmlNodeSetContent (service_list_node, "");
@@ -618,7 +711,7 @@ static void rygel_root_device_factory_ad
 		_tmp0_ = gee_collection_get_size ((GeeCollection*) plugin->icon_infos) == 0;
 	}
 	if (_tmp0_) {
-		g_debug ("rygel-root-device-factory.vala:218: No icon provided by %s.", plugin->name);
+		g_debug ("rygel-root-device-factory.vala:263: No icon provided by %s.", plugin->name);
 		return;
 	}
 	icon_list_node = get_xml_element (device_element, "iconList", NULL, NULL);
--- a/src/rygel/rygel-root-device.c
+++ b/src/rygel/rygel-root-device.c
@@ -179,7 +179,7 @@ RygelRootDevice* rygel_root_device_const
 	g_value_set_string (&__params_it->value, description_dir);
 	__params_it++;
 	self = g_object_newv (object_type, __params_it - __params, __params);
-	self->services = (_tmp0_ = gee_array_list_new (GUPNP_TYPE_SERVICE_INFO, (GBoxedCopyFunc) g_object_ref, g_object_unref, g_direct_equal), _g_object_unref0 (self->services), _tmp0_);
+	self->services = (_tmp0_ = gee_array_list_new (GUPNP_TYPE_SERVICE_INFO, (GBoxedCopyFunc) g_object_ref, g_object_unref, NULL), _g_object_unref0 (self->services), _tmp0_);
 	{
 		GeeIterator* _info_it;
 		_info_it = gee_abstract_collection_iterator ((GeeAbstractCollection*) plugin->resource_infos);
--- a/src/rygel/rygel-simple-container.c
+++ b/src/rygel/rygel-simple-container.c
@@ -222,8 +222,8 @@ RygelSimpleContainer* rygel_simple_conta
 	g_return_val_if_fail (id != NULL, NULL);
 	g_return_val_if_fail (title != NULL, NULL);
 	self = (RygelSimpleContainer*) rygel_media_container_construct (object_type, id, parent, title, (guint) 0);
-	self->children = (_tmp0_ = gee_array_list_new (RYGEL_TYPE_MEDIA_OBJECT, (GBoxedCopyFunc) g_object_ref, g_object_unref, g_direct_equal), _g_object_unref0 (self->children), _tmp0_);
-	self->priv->searches = (_tmp1_ = gee_array_list_new (RYGEL_TYPE_MEDIA_OBJECT_SEARCH, (GBoxedCopyFunc) g_object_ref, g_object_unref, g_direct_equal), _g_object_unref0 (self->priv->searches), _tmp1_);
+	self->children = (_tmp0_ = gee_array_list_new (RYGEL_TYPE_MEDIA_OBJECT, (GBoxedCopyFunc) g_object_ref, g_object_unref, NULL), _g_object_unref0 (self->children), _tmp0_);
+	self->priv->searches = (_tmp1_ = gee_array_list_new (RYGEL_TYPE_MEDIA_OBJECT_SEARCH, (GBoxedCopyFunc) g_object_ref, g_object_unref, NULL), _g_object_unref0 (self->priv->searches), _tmp1_);
 	return self;
 }
 
@@ -337,7 +337,7 @@ static void rygel_simple_container_real_
 	} else {
 		GeeArrayList* containers;
 		RygelMediaObjectSearch* search;
-		containers = gee_array_list_new (RYGEL_TYPE_MEDIA_CONTAINER, (GBoxedCopyFunc) g_object_ref, g_object_unref, g_direct_equal);
+		containers = gee_array_list_new (RYGEL_TYPE_MEDIA_CONTAINER, (GBoxedCopyFunc) g_object_ref, g_object_unref, NULL);
 		{
 			GeeIterator* _tmp_it;
 			_tmp_it = gee_abstract_collection_iterator ((GeeAbstractCollection*) self->children);
--- a/src/rygel/rygel-thumbnailer.c
+++ b/src/rygel/rygel-thumbnailer.c
@@ -174,11 +174,11 @@ static RygelThumbnailer* rygel_thumbnail
 					g_propagate_error (error, _inner_error_);
 					_g_free0 (dir);
 					_g_object_unref0 (file);
-					return;
+					return NULL;
 				} else {
 					_g_free0 (dir);
 					_g_object_unref0 (file);
-					g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
+					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
 					g_clear_error (&_inner_error_);
 					return NULL;
 				}
@@ -229,26 +229,26 @@ RygelThumbnailer* rygel_thumbnailer_get_
 			_tmp0_ = rygel_thumbnailer_new (&_inner_error_);
 			if (_inner_error_ != NULL) {
 				if (_inner_error_->domain == THUMBNAILER_ERROR) {
-					goto __catch34_thumbnailer_error;
+					goto __catch30_thumbnailer_error;
 				}
-				goto __finally34;
+				goto __finally30;
 			}
 			rygel_thumbnailer_thumbnailer = (_tmp1_ = _tmp0_, _g_object_unref0 (rygel_thumbnailer_thumbnailer), _tmp1_);
 		}
-		goto __finally34;
-		__catch34_thumbnailer_error:
+		goto __finally30;
+		__catch30_thumbnailer_error:
 		{
 			GError * err;
 			err = _inner_error_;
 			_inner_error_ = NULL;
 			{
-				g_warning ("rygel-thumbnailer.vala:81: No thumbnailer available: %s", err->message);
+				g_warning ("rygel-thumbnailer.vala:80: No thumbnailer available: %s", err->message);
 				_g_error_free0 (err);
 			}
 		}
-		__finally34:
+		__finally30:
 		if (_inner_error_ != NULL) {
-			g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
+			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
 			g_clear_error (&_inner_error_);
 			return NULL;
 		}
--- a/src/rygel/rygel-user-config.c
+++ b/src/rygel/rygel-user-config.c
@@ -177,8 +177,8 @@ static gint rygel_user_config_real_get_i
 static GeeArrayList* rygel_user_config_real_get_int_list (RygelConfiguration* base, const char* section, const char* key, GError** error);
 static gboolean rygel_user_config_real_get_bool (RygelConfiguration* base, const char* section, const char* key, GError** error);
 void rygel_user_config_set_string_list (RygelUserConfig* self, const char* section, const char* key, GeeArrayList* str_list);
-void _dynamic_StartServiceByName0 (DBusGProxy* self, const char* param1, guint32 param2, guint32* param3, GError** error);
-void _dynamic_Shutdown1 (DBusGProxy* self, GError** error);
+static void _dynamic_StartServiceByName0 (DBusGProxy* self, const char* param1, guint32 param2, guint32* param3, GError** error);
+static void _dynamic_Shutdown1 (DBusGProxy* self, GError** error);
 static void rygel_user_config_finalize (GObject* obj);
 static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
 static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);
@@ -210,7 +210,7 @@ void rygel_user_config_set_upnp_enabled
 	_inner_error_ = NULL;
 	_tmp0_ = rygel_configuration_get_upnp_enabled ((RygelConfiguration*) self, &_inner_error_);
 	if (_inner_error_ != NULL) {
-		g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
+		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
 		g_clear_error (&_inner_error_);
 		return;
 	}
@@ -429,7 +429,7 @@ RygelUserConfig* rygel_user_config_const
 		g_propagate_error (error, _inner_error_);
 		dirs = (_vala_array_free (dirs, dirs_length1, (GDestroyNotify) g_free), NULL);
 		_g_free0 (path);
-		return;
+		return NULL;
 	}
 	g_debug ("rygel-user-config.vala:148: Loaded user configuration from file '%s'", path);
 	{
@@ -463,7 +463,7 @@ RygelUserConfig* rygel_user_config_const
 		g_propagate_error (error, _inner_error_);
 		dirs = (_vala_array_free (dirs, dirs_length1, (GDestroyNotify) g_free), NULL);
 		_g_free0 (path);
-		return;
+		return NULL;
 	}
 	dirs = (_vala_array_free (dirs, dirs_length1, (GDestroyNotify) g_free), NULL);
 	_g_free0 (path);
@@ -487,7 +487,7 @@ void rygel_user_config_save (RygelUserCo
 	path = g_build_filename (g_get_user_config_dir (), RYGEL_USER_CONFIG_CONFIG_FILE, NULL);
 	data = g_key_file_to_data (self->key_file, &length, NULL);
 	{
-		g_file_set_contents (path, data, (glong) length, &_inner_error_);
+		g_file_set_contents (path, data, (gssize) ((glong) length), &_inner_error_);
 		if (_inner_error_ != NULL) {
 			if (_inner_error_->domain == G_FILE_ERROR) {
 				goto __catch1_g_file_error;
@@ -510,7 +510,7 @@ void rygel_user_config_save (RygelUserCo
 	if (_inner_error_ != NULL) {
 		_g_free0 (path);
 		_g_free0 (data);
-		g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
+		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
 		g_clear_error (&_inner_error_);
 		return;
 	}
@@ -602,7 +602,7 @@ static GeeArrayList* rygel_user_config_r
 	g_return_val_if_fail (section != NULL, NULL);
 	g_return_val_if_fail (key != NULL, NULL);
 	_inner_error_ = NULL;
-	str_list = gee_array_list_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, g_direct_equal);
+	str_list = gee_array_list_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, NULL);
 	strings = (_tmp1_ = g_key_file_get_string_list (self->key_file, section, key, &_tmp0_, &_inner_error_), strings_length1 = _tmp0_, strings_size = strings_length1, _tmp1_);
 	if (_inner_error_ != NULL) {
 		g_propagate_error (error, _inner_error_);
@@ -682,7 +682,7 @@ static GeeArrayList* rygel_user_config_r
 	g_return_val_if_fail (section != NULL, NULL);
 	g_return_val_if_fail (key != NULL, NULL);
 	_inner_error_ = NULL;
-	int_list = gee_array_list_new (G_TYPE_INT, NULL, NULL, g_direct_equal);
+	int_list = gee_array_list_new (G_TYPE_INT, NULL, NULL, NULL);
 	ints = (_tmp1_ = g_key_file_get_integer_list (self->key_file, section, key, &_tmp0_, &_inner_error_), ints_length1 = _tmp0_, ints_size = ints_length1, _tmp1_);
 	if (_inner_error_ != NULL) {
 		g_propagate_error (error, _inner_error_);
@@ -790,7 +790,7 @@ void rygel_user_config_set_bool (RygelUs
 }
 
 
-void _dynamic_StartServiceByName0 (DBusGProxy* self, const char* param1, guint32 param2, guint32* param3, GError** error) {
+static void _dynamic_StartServiceByName0 (DBusGProxy* self, const char* param1, guint32 param2, guint32* param3, GError** error) {
 	dbus_g_proxy_call (self, "StartServiceByName", error, G_TYPE_STRING, param1, G_TYPE_UINT, param2, G_TYPE_INVALID, G_TYPE_UINT, param3, G_TYPE_INVALID);
 	if (*error) {
 		return;
@@ -798,7 +798,7 @@ void _dynamic_StartServiceByName0 (DBusG
 }
 
 
-void _dynamic_Shutdown1 (DBusGProxy* self, GError** error) {
+static void _dynamic_Shutdown1 (DBusGProxy* self, GError** error) {
 	dbus_g_proxy_call (self, "Shutdown", error, G_TYPE_INVALID, G_TYPE_INVALID);
 	if (*error) {
 		return;
@@ -910,7 +910,7 @@ static void rygel_user_config_enable_upn
 	if (_inner_error_ != NULL) {
 		_g_free0 (dest_path);
 		_g_object_unref0 (dest);
-		g_critical ("file %s: line %d: uncaught error: %s", __FILE__, __LINE__, _inner_error_->message);
+		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
 		g_clear_error (&_inner_error_);
 		return;
 	}
--- a/src/rygel/rygel.h
+++ b/src/rygel/rygel.h
@@ -11,7 +11,6 @@
 #include <gee.h>
 #include <libgupnp/gupnp.h>
 #include <gio/gio.h>
-#include <gst/gst.h>
 #include <dbus/dbus-glib-lowlevel.h>
 #include <dbus/dbus-glib.h>
 
@@ -92,16 +91,6 @@ typedef struct _RygelMediaObjectClass Ry
 typedef struct _RygelMediaContainer RygelMediaContainer;
 typedef struct _RygelMediaContainerClass RygelMediaContainerClass;
 
-#define RYGEL_TYPE_TRANSCODE_MANAGER (rygel_transcode_manager_get_type ())
-#define RYGEL_TRANSCODE_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_TRANSCODE_MANAGER, RygelTranscodeManager))
-#define RYGEL_TRANSCODE_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_TRANSCODE_MANAGER, RygelTranscodeManagerClass))
-#define RYGEL_IS_TRANSCODE_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_TRANSCODE_MANAGER))
-#define RYGEL_IS_TRANSCODE_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_TRANSCODE_MANAGER))
-#define RYGEL_TRANSCODE_MANAGER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_TRANSCODE_MANAGER, RygelTranscodeManagerClass))
-
-typedef struct _RygelTranscodeManager RygelTranscodeManager;
-typedef struct _RygelTranscodeManagerClass RygelTranscodeManagerClass;
-
 #define RYGEL_TYPE_HTTP_SERVER (rygel_http_server_get_type ())
 #define RYGEL_HTTP_SERVER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_HTTP_SERVER, RygelHTTPServer))
 #define RYGEL_HTTP_SERVER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_HTTP_SERVER, RygelHTTPServerClass))
@@ -244,17 +233,6 @@ typedef struct _RygelMediaDBPrivate Ryge
 typedef struct _RygelMediaDBObjectFactory RygelMediaDBObjectFactory;
 typedef struct _RygelMediaDBObjectFactoryClass RygelMediaDBObjectFactoryClass;
 
-#define RYGEL_TYPE_METADATA_EXTRACTOR (rygel_metadata_extractor_get_type ())
-#define RYGEL_METADATA_EXTRACTOR(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_METADATA_EXTRACTOR, RygelMetadataExtractor))
-#define RYGEL_METADATA_EXTRACTOR_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_METADATA_EXTRACTOR, RygelMetadataExtractorClass))
-#define RYGEL_IS_METADATA_EXTRACTOR(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_METADATA_EXTRACTOR))
-#define RYGEL_IS_METADATA_EXTRACTOR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_METADATA_EXTRACTOR))
-#define RYGEL_METADATA_EXTRACTOR_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_METADATA_EXTRACTOR, RygelMetadataExtractorClass))
-
-typedef struct _RygelMetadataExtractor RygelMetadataExtractor;
-typedef struct _RygelMetadataExtractorClass RygelMetadataExtractorClass;
-typedef struct _RygelMetadataExtractorPrivate RygelMetadataExtractorPrivate;
-
 #define RYGEL_TYPE_MEDIA_DB_CONTAINER (rygel_media_db_container_get_type ())
 #define RYGEL_MEDIA_DB_CONTAINER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_MEDIA_DB_CONTAINER, RygelMediaDBContainer))
 #define RYGEL_MEDIA_DB_CONTAINER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_MEDIA_DB_CONTAINER, RygelMediaDBContainerClass))
@@ -278,6 +256,28 @@ typedef struct _RygelLogHandler RygelLog
 typedef struct _RygelLogHandlerClass RygelLogHandlerClass;
 typedef struct _RygelLogHandlerPrivate RygelLogHandlerPrivate;
 
+#define RYGEL_TYPE_NETWORK_MANAGER_SERVICE (rygel_network_manager_service_get_type ())
+#define RYGEL_NETWORK_MANAGER_SERVICE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_NETWORK_MANAGER_SERVICE, RygelNetworkManagerService))
+#define RYGEL_NETWORK_MANAGER_SERVICE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_NETWORK_MANAGER_SERVICE, RygelNetworkManagerServiceClass))
+#define RYGEL_IS_NETWORK_MANAGER_SERVICE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_NETWORK_MANAGER_SERVICE))
+#define RYGEL_IS_NETWORK_MANAGER_SERVICE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_NETWORK_MANAGER_SERVICE))
+#define RYGEL_NETWORK_MANAGER_SERVICE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_NETWORK_MANAGER_SERVICE, RygelNetworkManagerServiceClass))
+
+typedef struct _RygelNetworkManagerService RygelNetworkManagerService;
+typedef struct _RygelNetworkManagerServiceClass RygelNetworkManagerServiceClass;
+typedef struct _RygelNetworkManagerServicePrivate RygelNetworkManagerServicePrivate;
+
+#define RYGEL_TYPE_NETWORK_MANAGER_DEVICE (rygel_network_manager_device_get_type ())
+#define RYGEL_NETWORK_MANAGER_DEVICE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_NETWORK_MANAGER_DEVICE, RygelNetworkManagerDevice))
+#define RYGEL_NETWORK_MANAGER_DEVICE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_NETWORK_MANAGER_DEVICE, RygelNetworkManagerDeviceClass))
+#define RYGEL_IS_NETWORK_MANAGER_DEVICE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_NETWORK_MANAGER_DEVICE))
+#define RYGEL_IS_NETWORK_MANAGER_DEVICE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_NETWORK_MANAGER_DEVICE))
+#define RYGEL_NETWORK_MANAGER_DEVICE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_NETWORK_MANAGER_DEVICE, RygelNetworkManagerDeviceClass))
+
+typedef struct _RygelNetworkManagerDevice RygelNetworkManagerDevice;
+typedef struct _RygelNetworkManagerDeviceClass RygelNetworkManagerDeviceClass;
+typedef struct _RygelNetworkManagerDevicePrivate RygelNetworkManagerDevicePrivate;
+
 #define RYGEL_TYPE_DBUS_SERVICE (rygel_dbus_service_get_type ())
 #define RYGEL_DBUS_SERVICE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_DBUS_SERVICE, RygelDBusService))
 #define RYGEL_DBUS_SERVICE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_DBUS_SERVICE, RygelDBusServiceClass))
@@ -289,16 +289,6 @@ typedef struct _RygelDBusService RygelDB
 typedef struct _RygelDBusServiceClass RygelDBusServiceClass;
 typedef struct _RygelDBusServicePrivate RygelDBusServicePrivate;
 
-#define RYGEL_TYPE_MAIN (rygel_main_get_type ())
-#define RYGEL_MAIN(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_MAIN, RygelMain))
-#define RYGEL_MAIN_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_MAIN, RygelMainClass))
-#define RYGEL_IS_MAIN(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_MAIN))
-#define RYGEL_IS_MAIN_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_MAIN))
-#define RYGEL_MAIN_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_MAIN, RygelMainClass))
-
-typedef struct _RygelMain RygelMain;
-typedef struct _RygelMainClass RygelMainClass;
-
 #define RYGEL_TYPE_ROOT_DEVICE (rygel_root_device_get_type ())
 #define RYGEL_ROOT_DEVICE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_ROOT_DEVICE, RygelRootDevice))
 #define RYGEL_ROOT_DEVICE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_ROOT_DEVICE, RygelRootDeviceClass))
@@ -320,6 +310,16 @@ typedef struct _RygelRootDevicePrivate R
 typedef struct _RygelRootDeviceFactory RygelRootDeviceFactory;
 typedef struct _RygelRootDeviceFactoryClass RygelRootDeviceFactoryClass;
 typedef struct _RygelRootDeviceFactoryPrivate RygelRootDeviceFactoryPrivate;
+
+#define RYGEL_TYPE_MAIN (rygel_main_get_type ())
+#define RYGEL_MAIN(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_MAIN, RygelMain))
+#define RYGEL_MAIN_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_MAIN, RygelMainClass))
+#define RYGEL_IS_MAIN(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_MAIN))
+#define RYGEL_IS_MAIN_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_MAIN))
+#define RYGEL_MAIN_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_MAIN, RygelMainClass))
+
+typedef struct _RygelMain RygelMain;
+typedef struct _RygelMainClass RygelMainClass;
 typedef struct _RygelMainPrivate RygelMainPrivate;
 
 typedef enum  {
@@ -420,6 +420,7 @@ struct _RygelConnectionManager {
 
 struct _RygelConnectionManagerClass {
 	GUPnPServiceClass parent_class;
+	void (*get_current_connection_info_cb) (RygelConnectionManager* self, RygelConnectionManager* cm, GUPnPServiceAction* action);
 };
 
 struct _RygelStateMachineIface {
@@ -565,7 +566,6 @@ struct _RygelMediaItem {
 
 struct _RygelMediaItemClass {
 	RygelMediaObjectClass parent_class;
-	GstElement* (*create_stream_source) (RygelMediaItem* self);
 	gboolean (*should_stream) (RygelMediaItem* self);
 };
 
@@ -600,15 +600,6 @@ struct _RygelMediaDBClass {
 	GObjectClass parent_class;
 };
 
-struct _RygelMetadataExtractor {
-	GObject parent_instance;
-	RygelMetadataExtractorPrivate * priv;
-};
-
-struct _RygelMetadataExtractorClass {
-	GObjectClass parent_class;
-};
-
 struct _RygelMediaDBContainer {
 	RygelMediaContainer parent_instance;
 	RygelMediaDBContainerPrivate * priv;
@@ -640,6 +631,24 @@ struct _RygelLogHandlerClass {
 	GObjectClass parent_class;
 };
 
+struct _RygelNetworkManagerService {
+	GObject parent_instance;
+	RygelNetworkManagerServicePrivate * priv;
+};
+
+struct _RygelNetworkManagerServiceClass {
+	GObjectClass parent_class;
+};
+
+struct _RygelNetworkManagerDevice {
+	GObject parent_instance;
+	RygelNetworkManagerDevicePrivate * priv;
+};
+
+struct _RygelNetworkManagerDeviceClass {
+	GObjectClass parent_class;
+};
+
 struct _RygelDBusService {
 	GObject parent_instance;
 	RygelDBusServicePrivate * priv;
@@ -744,7 +753,6 @@ GQuark rygel_content_directory_error_qua
 GType rygel_content_directory_get_type (void);
 GType rygel_media_object_get_type (void);
 GType rygel_media_container_get_type (void);
-GType rygel_transcode_manager_get_type (void);
 GType rygel_http_server_get_type (void);
 #define RYGEL_CONTENT_DIRECTORY_UPNP_ID "urn:upnp-org:serviceId:ContentDirectory"
 #define RYGEL_CONTENT_DIRECTORY_UPNP_TYPE "urn:schemas-upnp-org:service:ContentDirectory:2"
@@ -754,8 +762,9 @@ RygelContentDirectory* rygel_content_dir
 RygelContentDirectory* rygel_content_directory_construct (GType object_type);
 GType rygel_connection_manager_get_type (void);
 #define RYGEL_CONNECTION_MANAGER_UPNP_ID "urn:upnp-org:serviceId:ConnectionManager"
-#define RYGEL_CONNECTION_MANAGER_UPNP_TYPE "urn:schemas-upnp-org:service:ConnectionManager:2"
+#define RYGEL_CONNECTION_MANAGER_UPNP_TYPE "urn:schemas-upnp-org:service:ConnectionManager:1"
 #define RYGEL_CONNECTION_MANAGER_DESCRIPTION_PATH "xml/ConnectionManager.xml"
+void rygel_connection_manager_get_current_connection_info_cb (RygelConnectionManager* self, RygelConnectionManager* cm, GUPnPServiceAction* action);
 RygelConnectionManager* rygel_connection_manager_new (void);
 RygelConnectionManager* rygel_connection_manager_construct (GType object_type);
 char* rygel_connection_manager_get_source_protocol_info (RygelConnectionManager* self);
@@ -823,7 +832,6 @@ GType rygel_thumbnail_get_type (void);
 #define RYGEL_MEDIA_ITEM_MUSIC_CLASS "object.item.audioItem.musicTrack"
 RygelMediaItem* rygel_media_item_new (const char* id, RygelMediaContainer* parent, const char* title, const char* upnp_class);
 RygelMediaItem* rygel_media_item_construct (GType object_type, const char* id, RygelMediaContainer* parent, const char* title, const char* upnp_class);
-GstElement* rygel_media_item_create_stream_source (RygelMediaItem* self);
 gboolean rygel_media_item_should_stream (RygelMediaItem* self);
 void rygel_media_item_add_uri (RygelMediaItem* self, const char* uri, RygelThumbnail* thumbnail);
 RygelThumbnail* rygel_thumbnail_new (const char* mime_type, const char* dlna_profile);
@@ -847,19 +855,6 @@ GeeArrayList* rygel_media_db_get_child_i
 gint rygel_media_db_get_child_count (RygelMediaDB* self, const char* container_id, GError** error);
 gboolean rygel_media_db_exists (RygelMediaDB* self, const char* object_id, gint64* timestamp, GError** error);
 GeeArrayList* rygel_media_db_get_children (RygelMediaDB* self, const char* container_id, glong offset, glong max_count);
-GType rygel_metadata_extractor_get_type (void);
-#define RYGEL_METADATA_EXTRACTOR_TAG_RYGEL_SIZE "rygel-size"
-#define RYGEL_METADATA_EXTRACTOR_TAG_RYGEL_DURATION "rygel-duration"
-#define RYGEL_METADATA_EXTRACTOR_TAG_RYGEL_MIME "rygel-mime"
-#define RYGEL_METADATA_EXTRACTOR_TAG_RYGEL_CHANNELS "rygel-channels"
-#define RYGEL_METADATA_EXTRACTOR_TAG_RYGEL_RATE "rygel-rate"
-#define RYGEL_METADATA_EXTRACTOR_TAG_RYGEL_WIDTH "rygel-width"
-#define RYGEL_METADATA_EXTRACTOR_TAG_RYGEL_HEIGHT "rygel-height"
-#define RYGEL_METADATA_EXTRACTOR_TAG_RYGEL_DEPTH "rygel-depth"
-#define RYGEL_METADATA_EXTRACTOR_TAG_RYGEL_MTIME "rygel-mtime"
-RygelMetadataExtractor* rygel_metadata_extractor_new (void);
-RygelMetadataExtractor* rygel_metadata_extractor_construct (GType object_type);
-void rygel_metadata_extractor_extract (RygelMetadataExtractor* self, GFile* file);
 GType rygel_media_db_container_get_type (void);
 RygelMediaDBContainer* rygel_media_db_container_new (RygelMediaDB* media_db, const char* id, const char* title);
 RygelMediaDBContainer* rygel_media_db_container_construct (GType object_type, RygelMediaDB* media_db, const char* id, const char* title);
@@ -869,11 +864,21 @@ RygelMediaDBObjectFactory* rygel_media_d
 RygelMediaDBObjectFactory* rygel_media_db_object_factory_construct (GType object_type);
 GType rygel_log_handler_get_type (void);
 RygelLogHandler* rygel_log_handler_get_default (void);
+GType rygel_network_manager_service_get_type (void);
+RygelNetworkManagerService* rygel_network_manager_service_new (GError** error);
+RygelNetworkManagerService* rygel_network_manager_service_construct (GType object_type, GError** error);
+char** rygel_network_manager_service_GetDevices (RygelNetworkManagerService* self, int* result_length1);
+GType rygel_network_manager_device_get_type (void);
+RygelNetworkManagerDevice* rygel_network_manager_device_new (const char* interface_name);
+RygelNetworkManagerDevice* rygel_network_manager_device_construct (GType object_type, const char* interface_name);
+guint rygel_network_manager_device_get_State (RygelNetworkManagerDevice* self);
+void rygel_network_manager_device_set_State (RygelNetworkManagerDevice* self, guint value);
+const char* rygel_network_manager_device_get_Interface (RygelNetworkManagerDevice* self);
+void rygel_network_manager_device_set_Interface (RygelNetworkManagerDevice* self, const char* value);
 GType rygel_dbus_service_get_type (void);
-GType rygel_main_get_type (void);
-RygelDBusService* rygel_dbus_service_new (RygelMain* main, GError** error);
-RygelDBusService* rygel_dbus_service_construct (GType object_type, RygelMain* main, GError** error);
+RygelDBusService* rygel_dbus_service_get_default (void);
 void rygel_dbus_service_Shutdown (RygelDBusService* self);
+gint rygel_dbus_service_ChangeFriendlyName (RygelDBusService* self, const char* friendlyname);
 GType rygel_root_device_get_type (void);
 RygelRootDevice* rygel_root_device_new (GUPnPContext* context, RygelPlugin* plugin, GUPnPXMLDoc* description_doc, const char* description_path, const char* description_dir);
 RygelRootDevice* rygel_root_device_construct (GType object_type, GUPnPContext* context, RygelPlugin* plugin, GUPnPXMLDoc* description_doc, const char* description_path, const char* description_dir);
@@ -887,7 +892,10 @@ GType rygel_root_device_factory_get_type
 RygelRootDeviceFactory* rygel_root_device_factory_new (GUPnPContext* context, GError** error);
 RygelRootDeviceFactory* rygel_root_device_factory_construct (GType object_type, GUPnPContext* context, GError** error);
 RygelRootDevice* rygel_root_device_factory_create (RygelRootDeviceFactory* self, RygelPlugin* plugin, GError** error);
+GType rygel_main_get_type (void);
+RygelMain* rygel_main_get_default (void);
 void rygel_main_exit (RygelMain* self, gint exit_code);
+RygelRootDevice* rygel_main_get_root_device_by_desc_path (RygelMain* self, const char* device_desc_path);
 
 
 G_END_DECLS
--- /dev/null
+++ b/vapi/dbus-glib-1.vapi
@@ -0,0 +1,165 @@
+/* dbus-glib-1.vala
+ *
+ * Copyright (C) 2007-2009  Jürg Billeter
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA
+ *
+ * Author:
+ * 	Jürg Billeter <j@bitron.ch>
+ */
+
+[CCode (cheader_filename = "dbus/dbus-glib-lowlevel.h,dbus/dbus-glib.h")]
+namespace DBus {
+	[CCode (cprefix = "DBUS_BUS_")]
+	public enum BusType {
+		SESSION,
+		SYSTEM,
+		STARTER
+	}
+
+	namespace RawBus {
+		[CCode (cname = "dbus_bus_get")]
+		public static RawConnection get (BusType type, ref RawError error);
+	}
+
+	[CCode (ref_function = "dbus_connection_ref", unref_function = "dbus_connection_unref", cname = "DBusConnection")]
+	public class RawConnection {
+		[CCode (cname = "dbus_connection_setup_with_g_main")]
+		public void setup_with_main (GLib.MainContext? context = null);
+		[CCode (cname = "dbus_connection_get_g_connection")]
+		public Connection get_g_connection ();
+		[CCode (cname = "dbus_connection_register_g_object")]
+		public void register_object (string at_path, GLib.Object object);
+	}
+
+	[CCode (cname = "DBusError", cprefix = "dbus_error_", destroy_function = "dbus_error_free")]
+	public struct RawError {
+		public string name;
+		public string message;
+
+		public RawError ();
+		public bool has_name (string name);
+		public bool is_set ();
+	}
+
+	[DBus (name = "org.freedesktop.DBus.Error")]
+	[CCode (cname = "DBusGError", lower_case_csuffix = "gerror", cprefix = "DBUS_GERROR_")]
+	public errordomain Error {
+		FAILED,
+		NO_MEMORY,
+		SERVICE_UNKNOWN,
+		NAME_HAS_NO_OWNER,
+		NO_REPLY,
+		[DBus (name = "IOError")]
+		IO_ERROR,
+		BAD_ADDRESS,
+		NOT_SUPPORTED,
+		LIMITS_EXCEEDED,
+		ACCESS_DENIED,
+		AUTH_FAILED,
+		NO_SERVER,
+		TIMEOUT,
+		NO_NETWORK,
+		ADDRESS_IN_USE,
+		DISCONNECTED,
+		INVALID_ARGS,
+		FILE_NOT_FOUND,
+		FILE_EXISTS,
+		UNKNOWN_METHOD,
+		TIMED_OUT,
+		MATCH_RULE_NOT_FOUND,
+		MATCH_RULE_INVALID,
+		[DBus (name = "Spawn.ExecFailed")]
+		SPAWN_EXEC_FAILED,
+		[DBus (name = "Spawn.ForkFailed")]
+		SPAWN_FORK_FAILED,
+		[DBus (name = "Spawn.ChildExited")]
+		SPAWN_CHILD_EXITED,
+		[DBus (name = "Spawn.ChildSignaled")]
+		SPAWN_CHILD_SIGNALED,
+		[DBus (name = "Spawn.Failed")]
+		SPAWN_FAILED,
+		UNIX_PROCESS_ID_UNKNOWN,
+		INVALID_SIGNATURE,
+		INVALID_FILE_CONTENT,
+		[DBus (name = "SELinuxSecurityContextUnknown")]
+		SELINUX_SECURITY_CONTEXT_UNKNOWN,
+		REMOTE_EXCEPTION
+	}
+
+	public struct Bus {
+		[CCode (cname = "dbus_g_bus_get")]
+		public static Connection get (BusType type) throws Error;
+	}
+
+	[Compact]
+	[CCode (ref_function = "dbus_g_connection_ref", unref_function = "dbus_g_connection_unref", cname = "DBusGConnection")]
+	public class Connection {
+		[CCode (cname = "dbus_g_proxy_new_for_name")]
+		public Object get_object (string name, string path, string? interface_ = null);
+		[CCode (cname = "dbus_g_proxy_new_from_type")]
+		public GLib.Object get_object_from_type (string name, string path, string interface_, GLib.Type type);
+		[CCode (cname = "dbus_g_connection_register_g_object")]
+		public void register_object (string at_path, GLib.Object object);
+		[CCode (cname = "dbus_g_connection_lookup_g_object")]
+		public weak GLib.Object lookup_object (string at_path);
+		[CCode (cname = "dbus_g_connection_get_connection")]
+		public RawConnection get_connection ();
+	}
+
+	[CCode (cname = "DBusGProxy", lower_case_csuffix = "g_proxy")]
+	public class Object : GLib.Object {
+		public bool call (string method, out GLib.Error error, GLib.Type first_arg_type, ...);
+		public weak ProxyCall begin_call (string method, ProxyCallNotify notify, GLib.DestroyNotify destroy, GLib.Type first_arg_type, ...);
+		public bool end_call (ProxyCall call, out GLib.Error error, GLib.Type first_arg_type, ...);
+		public void cancel_call (ProxyCall call);
+		public weak string get_path ();
+		public weak string get_bus_name ();
+		public weak string get_interface ();
+	}
+
+	[CCode (cname = "char", const_cname = "const char", copy_function = "g_strdup", free_function = "g_free", cheader_filename = "stdlib.h,string.h,glib.h", type_id = "DBUS_TYPE_G_OBJECT_PATH", marshaller_type_name = "STRING", get_value_function = "g_value_get_string", set_value_function = "g_value_set_string", type_signature = "o")]
+	public class ObjectPath : string {
+		[CCode (cname = "g_strdup")]
+		public ObjectPath (string path);
+	}
+
+	[CCode (cname = "char", const_cname = "const char", copy_function = "g_strdup", free_function = "g_free", cheader_filename = "stdlib.h,string.h,glib.h", type_id = "DBUS_TYPE_G_OBJECT_PATH", marshaller_type_name = "STRING", get_value_function = "g_value_get_string", set_value_function = "g_value_set_string")]
+	public class BusName : string {
+		[CCode (cname = "g_strdup")]
+		public BusName (string bus_name);
+	}
+
+	[CCode (cname = "DBusGProxyCallNotify")]
+	public delegate void ProxyCallNotify (Object obj, ProxyCall call_id);
+
+	[CCode (cname = "DBusGProxyCall")]
+	public class ProxyCall {
+	}
+
+	[Flags]
+	public enum NameFlag {
+		ALLOW_REPLACEMENT,
+		REPLACE_EXISTING,
+		DO_NOT_QUEUE
+	}
+
+	public enum RequestNameReply {
+		PRIMARY_OWNER,
+		IN_QUEUE,
+		EXISTS,
+		ALREADY_OWNER
+	}
+}
--- /dev/null
+++ b/vapi/gee-1.0.vapi
@@ -0,0 +1,411 @@
+/* gee-1.0.vapi generated by valac, do not modify. */
+
+[CCode (cprefix = "Gee", lower_case_cprefix = "gee_")]
+namespace Gee {
+	[CCode (cprefix = "GeeFunctions", lower_case_cprefix = "gee_functions_")]
+	namespace Functions {
+		[CCode (cheader_filename = "gee.h")]
+		public static GLib.CompareFunc get_compare_func_for (GLib.Type t);
+		[CCode (cheader_filename = "gee.h")]
+		public static GLib.EqualFunc get_equal_func_for (GLib.Type t);
+		[CCode (cheader_filename = "gee.h")]
+		public static GLib.HashFunc get_hash_func_for (GLib.Type t);
+	}
+	[CCode (cheader_filename = "gee.h")]
+	public abstract class AbstractCollection<G> : GLib.Object, Gee.Iterable<G>, Gee.Collection<G> {
+		public AbstractCollection ();
+		public abstract bool add (G item);
+		public virtual bool add_all (Gee.Collection<G> collection);
+		public abstract void clear ();
+		public abstract bool contains (G item);
+		public virtual bool contains_all (Gee.Collection<G> collection);
+		public abstract Gee.Iterator<G> iterator ();
+		public abstract bool remove (G item);
+		public virtual bool remove_all (Gee.Collection<G> collection);
+		public virtual bool retain_all (Gee.Collection<G> collection);
+		public virtual G[] to_array ();
+		public virtual bool is_empty { get; }
+		public virtual Gee.Collection<G> read_only_view { owned get; }
+		public abstract int size { get; }
+	}
+	[CCode (cheader_filename = "gee.h")]
+	public abstract class AbstractList<G> : Gee.AbstractCollection<G>, Gee.List<G> {
+		public AbstractList ();
+		public virtual G first ();
+		public abstract G @get (int index);
+		public abstract int index_of (G item);
+		public abstract void insert (int index, G item);
+		public virtual void insert_all (int index, Gee.Collection<G> collection);
+		public virtual G last ();
+		public abstract Gee.ListIterator<G> list_iterator ();
+		public abstract G remove_at (int index);
+		public abstract void @set (int index, G item);
+		public abstract Gee.List<G>? slice (int start, int stop);
+		public virtual Gee.List<G> read_only_view { owned get; }
+	}
+	[CCode (cheader_filename = "gee.h")]
+	public abstract class AbstractMap<K,V> : GLib.Object, Gee.Iterable<Gee.Map.Entry<K,V>>, Gee.Map<K,V> {
+		public AbstractMap ();
+		public abstract void clear ();
+		public abstract V @get (K key);
+		public abstract bool has (K key, V value);
+		public virtual bool has_all (Gee.Map<K,V> map);
+		public abstract bool has_key (K key);
+		public abstract Gee.MapIterator<K,V> map_iterator ();
+		public abstract void @set (K key, V value);
+		public virtual void set_all (Gee.Map<K,V> map);
+		public abstract bool unset (K key, out V value = null);
+		public virtual bool unset_all (Gee.Map<K,V> map);
+		public abstract Gee.Set<Gee.Map.Entry<K,V>> entries { owned get; }
+		public virtual bool is_empty { get; }
+		public abstract Gee.Set<K> keys { owned get; }
+		public virtual Gee.Map<K,V> read_only_view { owned get; }
+		public abstract int size { get; }
+		public abstract Gee.Collection<V> values { owned get; }
+	}
+	[CCode (cheader_filename = "gee.h")]
+	public abstract class AbstractMultiMap<K,V> : GLib.Object, Gee.MultiMap<K,V> {
+		protected Gee.Map<K,Gee.Collection<V>> _storage_map;
+		public AbstractMultiMap (Gee.Map<K,Gee.Collection<V>> storage_map);
+		protected abstract Gee.MultiSet<K> create_multi_key_set ();
+		protected abstract Gee.Collection<V> create_value_storage ();
+		protected abstract GLib.EqualFunc get_value_equal_func ();
+	}
+	[CCode (cheader_filename = "gee.h")]
+	public abstract class AbstractMultiSet<G> : Gee.AbstractCollection<G>, Gee.MultiSet<G> {
+		protected Gee.Map<G,int> _storage_map;
+		public AbstractMultiSet (Gee.Map<G,int> storage_map);
+		public override bool add (G item);
+		public override void clear ();
+		public override bool contains (G item);
+		public override Gee.Iterator<G> iterator ();
+		public override bool remove (G item);
+		public override int size { get; }
+	}
+	[CCode (cheader_filename = "gee.h")]
+	public abstract class AbstractQueue<G> : Gee.AbstractCollection<G>, Gee.Queue<G> {
+		public AbstractQueue ();
+		public abstract int drain (Gee.Collection<G> recipient, int amount = -1);
+		public abstract bool offer (G element);
+		public abstract G peek ();
+		public abstract G poll ();
+		public abstract int capacity { get; }
+		public abstract bool is_full { get; }
+		public abstract int remaining_capacity { get; }
+	}
+	[CCode (cheader_filename = "gee.h")]
+	public abstract class AbstractSet<G> : Gee.AbstractCollection<G>, Gee.Set<G> {
+		public AbstractSet ();
+		public virtual Gee.Set<G> read_only_view { owned get; }
+	}
+	[CCode (cheader_filename = "gee.h")]
+	public class ArrayList<G> : Gee.AbstractList<G> {
+		public ArrayList (GLib.EqualFunc? equal_func = null);
+		public override bool add (G item);
+		public override bool add_all (Gee.Collection<G> collection);
+		public override void clear ();
+		public override bool contains (G item);
+		public override G @get (int index);
+		public override int index_of (G item);
+		public override void insert (int index, G item);
+		public override Gee.Iterator<G> iterator ();
+		public override Gee.ListIterator<G> list_iterator ();
+		public override bool remove (G item);
+		public override G remove_at (int index);
+		public override void @set (int index, G item);
+		public override Gee.List<G>? slice (int start, int stop);
+		public GLib.EqualFunc equal_func { get; set; }
+		public override int size { get; }
+	}
+	[CCode (cheader_filename = "gee.h")]
+	public class HashMap<K,V> : Gee.AbstractMap<K,V> {
+		public HashMap (GLib.HashFunc? key_hash_func = null, GLib.EqualFunc? key_equal_func = null, GLib.EqualFunc? value_equal_func = null);
+		public override void clear ();
+		public override V @get (K key);
+		public override bool has (K key, V value);
+		public override bool has_key (K key);
+		public override Gee.MapIterator<K,V> map_iterator ();
+		public override void @set (K key, V value);
+		public override bool unset (K key, out V value = null);
+		public override Gee.Set<Gee.Map.Entry<K,V>> entries { owned get; }
+		public GLib.EqualFunc key_equal_func { get; set; }
+		public GLib.HashFunc key_hash_func { get; set; }
+		public override Gee.Set<K> keys { owned get; }
+		public override int size { get; }
+		public GLib.EqualFunc value_equal_func { get; set; }
+		public override Gee.Collection<V> values { owned get; }
+	}
+	[CCode (cheader_filename = "gee.h")]
+	public class HashMultiMap<K,V> : Gee.AbstractMultiMap<K,V> {
+		public HashMultiMap (GLib.HashFunc? key_hash_func = null, GLib.EqualFunc? key_equal_func = null, GLib.HashFunc? value_hash_func = null, GLib.EqualFunc? value_equal_func = null);
+		protected override Gee.MultiSet<K> create_multi_key_set ();
+		protected override Gee.Collection<V> create_value_storage ();
+		protected override GLib.EqualFunc get_value_equal_func ();
+		public GLib.EqualFunc key_equal_func { get; }
+		public GLib.HashFunc key_hash_func { get; }
+		public GLib.EqualFunc value_equal_func { get; set; }
+		public GLib.HashFunc value_hash_func { get; set; }
+	}
+	[CCode (cheader_filename = "gee.h")]
+	public class HashMultiSet<G> : Gee.AbstractMultiSet<G> {
+		public HashMultiSet (GLib.HashFunc? hash_func = null, GLib.EqualFunc? equal_func = null);
+		public GLib.EqualFunc equal_func { get; }
+		public GLib.HashFunc hash_func { get; }
+	}
+	[CCode (cheader_filename = "gee.h")]
+	public class HashSet<G> : Gee.AbstractSet<G> {
+		public HashSet (GLib.HashFunc? hash_func = null, GLib.EqualFunc? equal_func = null);
+		public override bool add (G key);
+		public override void clear ();
+		public override bool contains (G key);
+		public override Gee.Iterator<G> iterator ();
+		public override bool remove (G key);
+		public GLib.EqualFunc equal_func { get; set; }
+		public GLib.HashFunc hash_func { get; set; }
+		public override int size { get; }
+	}
+	[CCode (cheader_filename = "gee.h")]
+	public class LinkedList<G> : Gee.AbstractList<G>, Gee.Queue<G>, Gee.Deque<G> {
+		public LinkedList (GLib.EqualFunc? equal_func = null);
+		public override bool add (G item);
+		public override void clear ();
+		public override bool contains (G item);
+		public override G first ();
+		public override G @get (int index);
+		public override int index_of (G item);
+		public override void insert (int index, G item);
+		public override Gee.Iterator<G> iterator ();
+		public override G last ();
+		public override Gee.ListIterator<G> list_iterator ();
+		public override bool remove (G item);
+		public override G remove_at (int index);
+		public override void @set (int index, G item);
+		public override Gee.List<G>? slice (int start, int stop);
+		public GLib.EqualFunc equal_func { get; set; }
+		public override int size { get; }
+	}
+	[CCode (cheader_filename = "gee.h")]
+	public class PriorityQueue<G> : Gee.AbstractQueue<G> {
+		public PriorityQueue (GLib.CompareFunc? compare_func = null);
+		public override bool add (G item);
+		public override void clear ();
+		public override bool contains (G item);
+		public override int drain (Gee.Collection<G> recipient, int amount = -1);
+		public override Gee.Iterator<G> iterator ();
+		public override bool offer (G element);
+		public override G peek ();
+		public override G poll ();
+		public override bool remove (G item);
+		public override int capacity { get; }
+		public GLib.CompareFunc compare_func { get; set; }
+		public override bool is_full { get; }
+		public override int remaining_capacity { get; }
+		public override int size { get; }
+	}
+	[CCode (cheader_filename = "gee.h")]
+	public class TreeMap<K,V> : Gee.AbstractMap<K,V> {
+		public TreeMap (GLib.CompareFunc? key_compare_func = null, GLib.EqualFunc? value_equal_func = null);
+		public override void clear ();
+		public override V @get (K key);
+		public override bool has (K key, V value);
+		public override bool has_key (K key);
+		public override Gee.MapIterator<K,V> map_iterator ();
+		public override void @set (K key, V value);
+		public override bool unset (K key, out V value = null);
+		public override Gee.Set<Gee.Map.Entry<K,V>> entries { owned get; }
+		public GLib.CompareFunc key_compare_func { get; set; }
+		public override Gee.Set<K> keys { owned get; }
+		public override int size { get; }
+		public GLib.EqualFunc value_equal_func { get; set; }
+		public override Gee.Collection<V> values { owned get; }
+	}
+	[CCode (cheader_filename = "gee.h")]
+	public class TreeMultiMap<K,V> : Gee.AbstractMultiMap<K,V> {
+		public TreeMultiMap (GLib.CompareFunc? key_compare_func = null, GLib.CompareFunc? value_compare_func = null);
+		protected override Gee.MultiSet<K> create_multi_key_set ();
+		protected override Gee.Collection<V> create_value_storage ();
+		protected override GLib.EqualFunc get_value_equal_func ();
+		public GLib.CompareFunc key_compare_func { get; }
+		public GLib.CompareFunc value_compare_func { get; set; }
+	}
+	[CCode (cheader_filename = "gee.h")]
+	public class TreeMultiSet<G> : Gee.AbstractMultiSet<G> {
+		public TreeMultiSet (GLib.CompareFunc? compare_func = null);
+		public GLib.CompareFunc compare_func { get; }
+	}
+	[CCode (cheader_filename = "gee.h")]
+	public class TreeSet<G> : Gee.AbstractSet<G>, Gee.SortedSet<G> {
+		public TreeSet (GLib.CompareFunc? compare_func = null);
+		public override bool add (G item);
+		public override void clear ();
+		public override bool contains (G item);
+		public override Gee.Iterator<G> iterator ();
+		public override bool remove (G item);
+		public GLib.CompareFunc compare_func { get; set; }
+		public override int size { get; }
+	}
+	[CCode (cheader_filename = "gee.h")]
+	public interface BidirIterator<G> : Gee.Iterator<G> {
+		public abstract bool has_previous ();
+		public abstract bool last ();
+		public abstract bool previous ();
+	}
+	[CCode (cheader_filename = "gee.h")]
+	public interface Collection<G> : Gee.Iterable<G> {
+		public abstract bool add (G item);
+		public abstract bool add_all (Gee.Collection<G> collection);
+		public abstract void clear ();
+		public abstract bool contains (G item);
+		public abstract bool contains_all (Gee.Collection<G> collection);
+		public static Gee.Collection<G> empty<G> ();
+		public abstract bool remove (G item);
+		public abstract bool remove_all (Gee.Collection<G> collection);
+		public abstract bool retain_all (Gee.Collection<G> collection);
+		public abstract G[] to_array ();
+		public abstract bool is_empty { get; }
+		public abstract Gee.Collection<G> read_only_view { owned get; }
+		public abstract int size { get; }
+	}
+	[CCode (cheader_filename = "gee.h")]
+	public interface Comparable<G> : GLib.Object {
+		public abstract int compare_to (G object);
+	}
+	[CCode (cheader_filename = "gee.h")]
+	public interface Deque<G> : Gee.Queue<G> {
+		public abstract int drain_head (Gee.Collection<G> recipient, int amount = -1);
+		public abstract int drain_tail (Gee.Collection<G> recipient, int amount = -1);
+		public abstract bool offer_head (G element);
+		public abstract bool offer_tail (G element);
+		public abstract G peek_head ();
+		public abstract G peek_tail ();
+		public abstract G poll_head ();
+		public abstract G poll_tail ();
+	}
+	[CCode (cheader_filename = "gee.h")]
+	public interface Iterable<G> : GLib.Object {
+		public abstract Gee.Iterator<G> iterator ();
+		public abstract GLib.Type element_type { get; }
+	}
+	[CCode (cheader_filename = "gee.h")]
+	public interface Iterator<G> : GLib.Object {
+		public abstract bool first ();
+		public abstract G @get ();
+		public abstract bool has_next ();
+		public abstract bool next ();
+		public abstract void remove ();
+	}
+	[CCode (cheader_filename = "gee.h")]
+	public interface List<G> : Gee.Collection<G> {
+		public static Gee.List<G> empty<G> ();
+		public abstract G first ();
+		public abstract G @get (int index);
+		public abstract int index_of (G item);
+		public abstract void insert (int index, G item);
+		public abstract void insert_all (int index, Gee.Collection<G> collection);
+		public abstract G last ();
+		public abstract Gee.ListIterator<G> list_iterator ();
+		public abstract G remove_at (int index);
+		public abstract void @set (int index, G item);
+		public abstract Gee.List<G>? slice (int start, int stop);
+		public abstract void sort (GLib.CompareFunc? compare_func = null);
+		public abstract Gee.List<G> read_only_view { owned get; }
+	}
+	[CCode (cheader_filename = "gee.h")]
+	public interface ListIterator<G> : Gee.BidirIterator<G> {
+		public abstract void add (G item);
+		public abstract int index ();
+		public abstract void insert (G item);
+		public abstract void @set (G item);
+	}
+	[CCode (cheader_filename = "gee.h")]
+	public interface Map<K,V> : GLib.Object, Gee.Iterable<Gee.Map.Entry<K,V>> {
+		[CCode (cheader_filename = "gee.h")]
+		public abstract class Entry<K,V> : GLib.Object {
+			public Entry ();
+			public abstract K key { get; }
+			public abstract V value { get; set; }
+		}
+		public abstract void clear ();
+		public abstract bool contains (K key);
+		public abstract bool contains_all (Gee.Map<K,V> map);
+		public static Gee.Map<K,V> empty<K,V> ();
+		public abstract V @get (K key);
+		public abstract bool has (K key, V value);
+		public abstract bool has_all (Gee.Map<K,V> map);
+		public abstract bool has_key (K key);
+		public abstract Gee.MapIterator<K,V> map_iterator ();
+		public abstract bool remove (K key, out V value = null);
+		public abstract bool remove_all (Gee.Map<K,V> map);
+		public abstract void @set (K key, V value);
+		public abstract void set_all (Gee.Map<K,V> map);
+		public abstract bool unset (K key, out V value = null);
+		public abstract bool unset_all (Gee.Map<K,V> map);
+		public abstract Gee.Set<Gee.Map.Entry<K,V>> entries { owned get; }
+		public abstract bool is_empty { get; }
+		public abstract GLib.Type key_type { get; }
+		public abstract Gee.Set<K> keys { owned get; }
+		public abstract Gee.Map<K,V> read_only_view { owned get; }
+		public abstract int size { get; }
+		public abstract GLib.Type value_type { get; }
+		public abstract Gee.Collection<V> values { owned get; }
+	}
+	[CCode (cheader_filename = "gee.h")]
+	public interface MapIterator<K,V> : GLib.Object {
+		public abstract bool first ();
+		public abstract K get_key ();
+		public abstract V get_value ();
+		public abstract bool has_next ();
+		public abstract bool next ();
+		public abstract void set_value (V value);
+		public abstract void unset ();
+	}
+	[CCode (cheader_filename = "gee.h")]
+	public interface MultiMap<K,V> : GLib.Object {
+		public abstract void clear ();
+		public abstract bool contains (K key);
+		public abstract Gee.Collection<V> @get (K key);
+		public abstract Gee.MultiSet<K> get_all_keys ();
+		public abstract Gee.Set<K> get_keys ();
+		public abstract Gee.Collection<V> get_values ();
+		public abstract bool remove (K key, V value);
+		public abstract bool remove_all (K key);
+		public abstract void @set (K key, V value);
+		public abstract int size { get; }
+	}
+	[CCode (cheader_filename = "gee.h")]
+	public interface MultiSet<G> : Gee.Collection<G> {
+		public abstract int count (G item);
+	}
+	[CCode (cheader_filename = "gee.h")]
+	public interface Queue<G> : Gee.Collection<G> {
+		public const int UNBOUNDED_CAPACITY;
+		public abstract int drain (Gee.Collection<G> recipient, int amount = -1);
+		public abstract bool offer (G element);
+		public abstract G peek ();
+		public abstract G poll ();
+		public abstract int capacity { get; }
+		public abstract bool is_full { get; }
+		public abstract int remaining_capacity { get; }
+	}
+	[CCode (cheader_filename = "gee.h")]
+	public interface Set<G> : Gee.Collection<G> {
+		public static Gee.Set<G> empty<G> ();
+		public abstract Gee.Set<G> read_only_view { owned get; }
+	}
+	[CCode (cheader_filename = "gee.h")]
+	public interface SortedSet<G> : Gee.Set<G> {
+		public abstract Gee.BidirIterator<G> bidir_iterator ();
+		public abstract G ceil (G element);
+		public abstract G first ();
+		public abstract G floor (G element);
+		public abstract Gee.SortedSet<G> head_set (G before);
+		public abstract G higher (G element);
+		public abstract Gee.BidirIterator<G>? iterator_at (G element);
+		public abstract G last ();
+		public abstract G lower (G element);
+		public abstract Gee.SortedSet<G> sub_set (G from, G to);
+		public abstract Gee.SortedSet<G> tail_set (G after);
+	}
+	[CCode (cheader_filename = "gee.h")]
+	public static int direct_compare (void* _val1, void* _val2);
+}
--- /dev/null
+++ b/vapi/gssdp-1.0.vapi
@@ -0,0 +1,50 @@
+/* gssdp-1.0.vapi generated by vapigen, do not modify. */
+
+[CCode (cprefix = "GSSDP", lower_case_cprefix = "gssdp_")]
+namespace GSSDP {
+	[CCode (cheader_filename = "libgssdp/gssdp.h")]
+	public class Client : GLib.Object {
+		[CCode (has_construct_function = false)]
+		public Client.full (GLib.MainContext main_context, string host_ip) throws GLib.Error;
+		public unowned string get_host_ip ();
+		[CCode (has_construct_function = false)]
+		public Client (GLib.MainContext? main_context, string? @interface) throws GLib.Error;
+		[NoAccessorMethod]
+		public bool active { get; set; }
+		public string host_ip { get; }
+		public string @interface { get; construct; }
+		public void* main_context { get; construct; }
+		public string server_id { get; set; }
+	}
+	[CCode (cheader_filename = "libgssdp/gssdp.h")]
+	public class ResourceBrowser : GLib.Object {
+		[CCode (has_construct_function = false)]
+		public ResourceBrowser (GSSDP.Client client, string target);
+		public bool active { get; set; }
+		public GSSDP.Client client { get; construct; }
+		public uint mx { get; set; }
+		public string target { get; set; }
+		public signal void resource_available (string usn, GLib.List<string> locations);
+		public virtual signal void resource_unavailable (string usn);
+	}
+	[CCode (cheader_filename = "libgssdp/gssdp.h")]
+	public class ResourceGroup : GLib.Object {
+		public uint add_resource (string target, string usn, GLib.List locations);
+		public uint add_resource_simple (string target, string usn, string location);
+		[CCode (has_construct_function = false)]
+		public ResourceGroup (GSSDP.Client client);
+		public void remove_resource (uint resource_id);
+		public bool available { get; set; }
+		public GSSDP.Client client { get; construct; }
+		public uint max_age { get; set; }
+		public uint message_delay { get; set; }
+	}
+	[CCode (cprefix = "GSSDP_ERROR_", cheader_filename = "libgssdp/gssdp.h")]
+	public errordomain Error {
+		FAILED,
+	}
+	[CCode (cheader_filename = "libgssdp/gssdp.h")]
+	public const string ALL_RESOURCES;
+	[CCode (cheader_filename = "libgssdp/gssdp.h")]
+	public static GLib.Quark error_quark ();
+}
--- /dev/null
+++ b/vapi/gupnp-1.0.deps
@@ -0,0 +1,4 @@
+gssdp-1.0
+libsoup-2.4
+gio-2.0
+libxml-2.0
--- /dev/null
+++ b/vapi/gupnp-1.0.vapi
@@ -0,0 +1,284 @@
+/* gupnp-1.0.vapi generated by vapigen, do not modify. */
+
+[CCode (cprefix = "GUPnP", lower_case_cprefix = "gupnp_")]
+namespace GUPnP {
+	[CCode (cheader_filename = "libgupnp/gupnp.h")]
+	public class Context : GSSDP.Client {
+		public void host_path (string local_path, string server_path);
+		[CCode (has_construct_function = false)]
+		public Context (GLib.MainContext? main_context, string? @interface, uint port) throws GLib.Error;
+		public void unhost_path (string server_path);
+		public uint port { get; construct; }
+		public Soup.Server server { get; }
+		public Soup.Session session { get; }
+		public uint subscription_timeout { get; construct; }
+	}
+	[CCode (cheader_filename = "libgupnp/gupnp.h")]
+	public class ContextManager : GLib.Object {
+		public void manage_control_point (GUPnP.ControlPoint control_point);
+		public void manage_root_device (GUPnP.RootDevice root_device);
+		[CCode (has_construct_function = false)]
+		public ContextManager (GLib.MainContext? main_context, uint port);
+		public GUPnP.ContextManager context_manager { construct; }
+		[NoAccessorMethod]
+		public void* main_context { get; construct; }
+		[NoAccessorMethod]
+		public uint port { get; construct; }
+		public virtual signal void context_available (GUPnP.Context p0);
+		public virtual signal void context_unavailable (GUPnP.Context p0);
+	}
+	[CCode (cheader_filename = "libgupnp/gupnp.h")]
+	public class ControlPoint : GSSDP.ResourceBrowser {
+		[CCode (has_construct_function = false)]
+		public ControlPoint.full (GUPnP.Context context, GUPnP.ResourceFactory factory, string target);
+		public unowned GUPnP.Context get_context ();
+		public unowned GLib.List<GUPnP.DeviceProxy> list_device_proxies ();
+		public unowned GLib.List<GUPnP.ServiceProxy> list_service_proxies ();
+		[CCode (has_construct_function = false)]
+		public ControlPoint (GUPnP.Context context, string target);
+		public GUPnP.ResourceFactory resource_factory { get; construct; }
+		public virtual signal void device_proxy_available (GUPnP.DeviceProxy proxy);
+		public virtual signal void device_proxy_unavailable (GUPnP.DeviceProxy proxy);
+		public virtual signal void service_proxy_available (GUPnP.ServiceProxy proxy);
+		public virtual signal void service_proxy_unavailable (GUPnP.ServiceProxy proxy);
+	}
+	[CCode (cheader_filename = "libgupnp/gupnp.h")]
+	public class Device : GUPnP.DeviceInfo {
+		[NoAccessorMethod]
+		public GUPnP.RootDevice root_device { owned get; construct; }
+	}
+	[CCode (cheader_filename = "libgupnp/gupnp.h")]
+	public class DeviceInfo : GLib.Object {
+		public string get_description_value (string element);
+		public virtual GUPnP.DeviceInfo? get_device (string type);
+		public unowned string get_device_type ();
+		public string get_friendly_name ();
+		public string get_icon_url (string requested_mime_type, int requested_depth, int requested_width, int requested_height, bool prefer_bigger, out unowned string mime_type, out int depth, out int width, out int height);
+		public string get_manufacturer ();
+		public string get_manufacturer_url ();
+		public string get_model_description ();
+		public string get_model_name ();
+		public string get_model_number ();
+		public string get_model_url ();
+		public string get_presentation_url ();
+		public string get_serial_number ();
+		public virtual GUPnP.ServiceInfo? get_service (string type);
+		public string get_upc ();
+		public GLib.List<string> list_device_types ();
+		public GLib.List<GUPnP.DeviceInfo> list_devices ();
+		public GLib.List<string> list_dlna_capabilities ();
+		public GLib.List<string> list_service_types ();
+		public GLib.List<GUPnP.ServiceInfo> list_services ();
+		[CCode (has_construct_function = false)]
+		public DeviceInfo ();
+		public GUPnP.Context context { get; construct; }
+		public string device_type { get; construct; }
+		public string location { get; construct; }
+		public GUPnP.ResourceFactory resource_factory { get; construct; }
+		public string udn { get; construct; }
+		public Soup.URI url_base { get; construct; }
+	}
+	[CCode (cheader_filename = "libgupnp/gupnp.h")]
+	public class DeviceProxy : GUPnP.DeviceInfo {
+	}
+	[CCode (cheader_filename = "libgupnp/gupnp.h")]
+	public class ResourceFactory : GLib.Object {
+		public static unowned GUPnP.ResourceFactory get_default ();
+		[CCode (has_construct_function = false)]
+		public ResourceFactory ();
+		public void register_resource_proxy_type (string upnp_type, GLib.Type type);
+		public void register_resource_type (string upnp_type, GLib.Type type);
+		public bool unregister_resource_proxy_type (string upnp_type);
+		public bool unregister_resource_type (string upnp_type);
+	}
+	[CCode (cheader_filename = "libgupnp/gupnp.h")]
+	public class RootDevice : GUPnP.Device {
+		[CCode (has_construct_function = false)]
+		public RootDevice.full (GUPnP.Context context, GUPnP.ResourceFactory factory, GUPnP.XMLDoc description_doc, string description_path, string description_dir);
+		public unowned string get_description_dir ();
+		public unowned string get_description_path ();
+		[CCode (has_construct_function = false)]
+		public RootDevice (GUPnP.Context context, string description_path, string description_dir);
+		public bool available { get; set; }
+		public string description_dir { get; construct; }
+		public GUPnP.XMLDoc description_doc { construct; }
+		public string description_path { get; construct; }
+	}
+	[CCode (cheader_filename = "libgupnp/gupnp.h")]
+	public class Service : GUPnP.ServiceInfo {
+		public void freeze_notify ();
+		[CCode (has_construct_function = false)]
+		public Service ();
+		public void notify (...);
+		public void notify_value (string variable, GLib.Value value);
+		public void thaw_notify ();
+		[NoAccessorMethod]
+		public GUPnP.RootDevice root_device { owned get; construct; }
+		public virtual signal void action_invoked (owned GUPnP.ServiceAction action);
+		public virtual signal void notify_failed (GLib.List<Soup.URI> callback_urls, GLib.Error reason);
+		public virtual signal void query_variable (string variable, ref GLib.Value value);
+	}
+	[CCode (ref_function = "", unref_function = "", cheader_filename = "libgupnp/gupnp.h")]
+	public class ServiceAction {
+		public void @get (...);
+		public GLib.List<string> get_locales ();
+		public Soup.Message<string> get_message ();
+		public unowned string get_name ();
+		public void get_value (string argument, ref GLib.Value value);
+		public void @return ();
+		public void return_error (uint error_code, string? error_description);
+		public void @set (...);
+		public void set_value (string argument, ref GLib.Value value);
+	}
+	[Compact]
+	[CCode (cheader_filename = "libgupnp/gupnp.h")]
+	public class ServiceActionArgInfo {
+		public GUPnP.ServiceActionArgDirection direction;
+		public weak string name;
+		public weak string related_state_variable;
+		public bool retval;
+	}
+	[CCode (ref_function = "gupnp_service_action_info_ref", unref_function = "gupnp_service_action_info_unref", cheader_filename = "libgupnp/gupnp.h")]
+	public class ServiceActionInfo {
+		public weak GLib.List<GUPnP.ServiceActionArgInfo> arguments;
+		public weak string name;
+		[CCode (has_construct_function = false)]
+		public ServiceActionInfo ();
+	}
+	[CCode (cheader_filename = "libgupnp/gupnp.h")]
+	public class ServiceInfo : GLib.Object {
+		public string get_control_url ();
+		public string get_event_subscription_url ();
+		public string get_id ();
+		public GUPnP.ServiceIntrospection? get_introspection () throws GLib.Error;
+		public void get_introspection_async (GUPnP.ServiceIntrospectionCallback callback);
+		public string get_scpd_url ();
+		[CCode (has_construct_function = false)]
+		public ServiceInfo ();
+		public GUPnP.Context context { get; construct; }
+		public string location { get; construct; }
+		public string service_type { get; construct; }
+		public string udn { get; construct; }
+		public Soup.URI url_base { get; construct; }
+	}
+	[CCode (cheader_filename = "libgupnp/gupnp.h")]
+	public class ServiceIntrospection : GLib.Object {
+		public unowned GUPnP.ServiceActionInfo get_action (string action_name);
+		public unowned GUPnP.ServiceStateVariableInfo get_state_variable (string variable_name);
+		public unowned GLib.List<string> list_action_names ();
+		public unowned GLib.List<GUPnP.ServiceActionInfo> list_actions ();
+		public unowned GLib.List<string> list_state_variable_names ();
+		public unowned GLib.List<GUPnP.ServiceStateVariableInfo> list_state_variables ();
+	}
+	[CCode (cheader_filename = "libgupnp/gupnp.h")]
+	public class ServiceProxy : GUPnP.ServiceInfo {
+		public bool add_notify (string variable, GLib.Type type, GUPnP.ServiceProxyNotifyCallback callback);
+		public unowned GUPnP.ServiceProxyAction begin_action (string action, GUPnP.ServiceProxyActionCallback callback, ...);
+		public unowned GUPnP.ServiceProxyAction begin_action_hash (string action, GUPnP.ServiceProxyActionCallback callback, GLib.HashTable hash);
+		public void cancel_action (GUPnP.ServiceProxyAction action);
+		public bool end_action (GUPnP.ServiceProxyAction action, ...) throws GLib.Error;
+		public bool end_action_hash (GUPnP.ServiceProxyAction action, GLib.HashTable hash) throws GLib.Error;
+		[CCode (has_construct_function = false)]
+		public ServiceProxy ();
+		public bool remove_notify (string variable, GUPnP.ServiceProxyNotifyCallback callback);
+		public bool send_action (string action, ...) throws GLib.Error;
+		public bool send_action_hash (string action, GLib.HashTable in_hash, ref unowned GLib.HashTable out_hash) throws GLib.Error;
+		public bool subscribed { get; set; }
+		public virtual signal void subscription_lost (GLib.Error reason);
+	}
+	[Compact]
+	[CCode (cheader_filename = "libgupnp/gupnp.h")]
+	public class ServiceProxyAction {
+	}
+	[CCode (ref_function = "gupnp_service_state_variable_info_ref", unref_function = "gupnp_service_state_variable_info_unref", cheader_filename = "libgupnp/gupnp.h")]
+	public class ServiceStateVariableInfo {
+		public weak GLib.List<string> allowed_values;
+		public GLib.Value default_value;
+		public bool is_numeric;
+		public GLib.Value maximum;
+		public GLib.Value minimum;
+		public weak string name;
+		public bool send_events;
+		public GLib.Value step;
+		public GLib.Type type;
+		[CCode (has_construct_function = false)]
+		public ServiceStateVariableInfo ();
+	}
+	[CCode (cheader_filename = "libgupnp/gupnp.h")]
+	public class XMLDoc : GLib.Object {
+		public weak Xml.Doc doc;
+		[CCode (has_construct_function = false)]
+		public XMLDoc.from_path (string path) throws GLib.Error;
+		[CCode (has_construct_function = false)]
+		public XMLDoc (Xml.Doc xml_doc);
+	}
+	[CCode (type_id = "GUPNP_TYPE_BIN_BASE64", cheader_filename = "libgupnp/gupnp.h")]
+	public struct BinBase64 {
+	}
+	[CCode (type_id = "GUPNP_TYPE_BIN_HEX", cheader_filename = "libgupnp/gupnp.h")]
+	public struct BinHex {
+	}
+	[CCode (type_id = "GUPNP_TYPE_DATE", cheader_filename = "libgupnp/gupnp.h")]
+	public struct Date {
+	}
+	[CCode (type_id = "GUPNP_TYPE_DATE_TIME", cheader_filename = "libgupnp/gupnp.h")]
+	public struct DateTime {
+	}
+	[CCode (type_id = "GUPNP_TYPE_DATE_TIME_TZ", cheader_filename = "libgupnp/gupnp.h")]
+	public struct DateTimeTZ {
+	}
+	[CCode (type_id = "GUPNP_TYPE_TIME", cheader_filename = "libgupnp/gupnp.h")]
+	public struct Time {
+	}
+	[CCode (type_id = "GUPNP_TYPE_TIME_TZ", cheader_filename = "libgupnp/gupnp.h")]
+	public struct TimeTZ {
+	}
+	[CCode (type_id = "GUPNP_TYPE_URI", cheader_filename = "libgupnp/gupnp.h")]
+	public struct URI {
+	}
+	[CCode (type_id = "GUPNP_TYPE_UUID", cheader_filename = "libgupnp/gupnp.h")]
+	public struct UUID {
+	}
+	[CCode (cprefix = "GUPNP_SERVICE_ACTION_ARG_DIRECTION_", has_type_id = "0", cheader_filename = "libgupnp/gupnp.h")]
+	public enum ServiceActionArgDirection {
+		IN,
+		OUT
+	}
+	[CCode (cprefix = "GUPNP_XML_ERROR_", has_type_id = "0", cheader_filename = "libgupnp/gupnp.h")]
+	public enum XMLError {
+		PARSE,
+		NO_NODE,
+		EMPTY_NODE,
+		OTHER
+	}
+	[CCode (cprefix = "GUPNP_CONTROL_ERROR_", cheader_filename = "libgupnp/gupnp.h")]
+	public errordomain ControlError {
+		INVALID_ACTION,
+		INVALID_ARGS,
+		OUT_OF_SYNC,
+		ACTION_FAILED,
+	}
+	[CCode (cprefix = "GUPNP_EVENTING_ERROR_", cheader_filename = "libgupnp/gupnp.h")]
+	public errordomain EventingError {
+		SUBSCRIPTION_FAILED,
+		SUBSCRIPTION_LOST,
+		NOTIFY_FAILED,
+	}
+	[CCode (cprefix = "GUPNP_SERVER_ERROR_", cheader_filename = "libgupnp/gupnp.h")]
+	public errordomain ServerError {
+		INTERNAL_SERVER_ERROR,
+		NOT_FOUND,
+		NOT_IMPLEMENTED,
+		INVALID_RESPONSE,
+		INVALID_URL,
+		OTHER,
+	}
+	[CCode (cheader_filename = "libgupnp/gupnp.h")]
+	public delegate void ServiceIntrospectionCallback (GUPnP.ServiceInfo info, GUPnP.ServiceIntrospection introspection, GLib.Error error);
+	[CCode (cheader_filename = "libgupnp/gupnp.h")]
+	public delegate void ServiceProxyActionCallback (GUPnP.ServiceProxy proxy, GUPnP.ServiceProxyAction action);
+	[CCode (cheader_filename = "libgupnp/gupnp.h")]
+	public delegate void ServiceProxyNotifyCallback (GUPnP.ServiceProxy proxy, string variable, GLib.Value value);
+	[CCode (cheader_filename = "libgupnp/gupnp.h")]
+	public static GLib.Quark xml_error_quark ();
+}
--- /dev/null
+++ b/vapi/gupnp-av-1.0.deps
@@ -0,0 +1,6 @@
+gupnp-1.0
+gssdp-1.0
+libxml-2.0
+libsoup-2.4
+glib-2.0
+gio-2.0
--- /dev/null
+++ b/vapi/gupnp-av-1.0.vapi
@@ -0,0 +1,181 @@
+/* gupnp-av-1.0.vapi generated by vapigen, do not modify. */
+
+[CCode (cprefix = "GUPnP", lower_case_cprefix = "gupnp_")]
+namespace GUPnP {
+	[CCode (cheader_filename = "libgupnp-av/gupnp-av.h")]
+	public class DIDLLiteContainer : GUPnP.DIDLLiteObject {
+		public uint child_count { get; set; }
+		public bool searchable { get; set; }
+	}
+	[CCode (cheader_filename = "libgupnp-av/gupnp-av.h")]
+	public class DIDLLiteDescriptor : GLib.Object {
+		public string content { get; set; }
+		public string id { get; set; }
+		public string metadata_type { get; set; }
+		public string name_space { get; set; }
+		public GUPnP.XMLDoc xml_doc { construct; }
+		public void* xml_node { get; construct; }
+	}
+	[CCode (cheader_filename = "libgupnp-av/gupnp-av.h")]
+	public class DIDLLiteItem : GUPnP.DIDLLiteObject {
+		public string ref_id { get; set; }
+	}
+	[CCode (cheader_filename = "libgupnp-av/gupnp-av.h")]
+	public class DIDLLiteObject : GLib.Object {
+		public GUPnP.DIDLLiteDescriptor add_descriptor ();
+		public GUPnP.DIDLLiteResource add_resource ();
+		public GUPnP.DIDLLiteResource get_compat_resource (string sink_protocol_info, bool lenient);
+		public unowned GLib.List get_properties (string name);
+		public GLib.List<GUPnP.DIDLLiteResource> get_resources ();
+		public string album { get; set; }
+		public string album_art { get; set; }
+		public string artist { get; set; }
+		public string author { get; set; }
+		public string creator { get; set; }
+		public string date { get; set; }
+		public string description { get; set; }
+		public string genre { get; set; }
+		public string id { get; set; }
+		public string parent_id { get; set; }
+		public bool restricted { get; set; }
+		public string title { get; set; }
+		public int track_number { get; set; }
+		public string upnp_class { get; set; }
+		public string write_status { get; set; }
+		public GUPnP.XMLDoc xml_doc { construct; }
+		public void* xml_node { get; construct; }
+	}
+	[CCode (cheader_filename = "libgupnp-av/gupnp-av.h")]
+	public class DIDLLiteParser : GLib.Object {
+		public void* gupnp_reserved;
+		[CCode (has_construct_function = false)]
+		public DIDLLiteParser ();
+		public bool parse_didl (string didl) throws GLib.Error;
+		public virtual signal void container_available (GUPnP.DIDLLiteContainer container);
+		public virtual signal void item_available (GUPnP.DIDLLiteItem item);
+		public virtual signal void object_available (GUPnP.DIDLLiteObject object);
+	}
+	[CCode (cheader_filename = "libgupnp-av/gupnp-av.h")]
+	public class DIDLLiteResource : GLib.Object {
+		public int audio_channels { get; set; }
+		public int bitrate { get; set; }
+		public int bits_per_sample { get; set; }
+		public int color_depth { get; set; }
+		public long duration { get; set; }
+		public int height { get; set; }
+		public string import_uri { get; set; }
+		public string protection { get; set; }
+		public GUPnP.ProtocolInfo protocol_info { get; set; }
+		public int sample_freq { get; set; }
+		public long size { get; set; }
+		public string uri { get; set; }
+		public int width { get; set; }
+		public GUPnP.XMLDoc xml_doc { construct; }
+		public void* xml_node { get; construct; }
+	}
+	[CCode (cheader_filename = "libgupnp-av/gupnp-av.h")]
+	public class DIDLLiteWriter : GLib.Object {
+		public const string NAMESPACE_DC;
+		public const string NAMESPACE_UPNP;
+		public GUPnP.DIDLLiteContainer add_container ();
+		public GUPnP.DIDLLiteDescriptor add_descriptor ();
+		public GUPnP.DIDLLiteItem add_item ();
+		public void filter (string filter);
+		public string get_string ();
+		public unowned Xml.Node get_xml_node ();
+		[CCode (has_construct_function = false)]
+		public DIDLLiteWriter (string? language);
+		public string language { get; construct; }
+		public void* xml_node { get; }
+	}
+	[CCode (cheader_filename = "libgupnp-av/gupnp-av.h")]
+	public class LastChangeParser : GLib.Object {
+		[CCode (has_construct_function = false)]
+		public LastChangeParser ();
+		public bool parse_last_change (uint instance_id, string last_change_xml, ...) throws GLib.Error;
+	}
+	[CCode (cheader_filename = "libgupnp-av/gupnp-av.h")]
+	public class ProtocolInfo : GLib.Object {
+		[CCode (has_construct_function = false)]
+		public ProtocolInfo.from_string (string protocol_info) throws GLib.Error;
+		public bool is_compatible (GUPnP.ProtocolInfo info2);
+		[CCode (has_construct_function = false)]
+		public ProtocolInfo ();
+		public string to_string ();
+		public GUPnP.DLNAConversion dlna_conversion { get; set; }
+		public GUPnP.DLNAFlags dlna_flags { get; set; }
+		public GUPnP.DLNAOperation dlna_operation { get; set; }
+		public string dlna_profile { get; set; }
+		public string mime_type { get; set; }
+		public string network { get; set; }
+		[CCode (array_length = false, array_null_terminated = true)]
+		public string[] play_speeds { get; set; }
+		public string protocol { get; set; }
+	}
+	[CCode (cheader_filename = "libgupnp-av/gupnp-av.h")]
+	public class SearchCriteriaParser : GLib.Object {
+		public static GLib.Quark error_quark ();
+		[CCode (has_construct_function = false)]
+		public SearchCriteriaParser ();
+		public bool parse_text (string text) throws GLib.Error;
+		public virtual signal void begin_parens ();
+		public virtual signal void conjunction ();
+		public virtual signal void disjunction ();
+		public virtual signal void end_parens ();
+		public signal bool expression (string property, uint op, string value, GLib.Error error);
+	}
+	[CCode (cprefix = "GUPNP_DLNA_CONVERSION_", cheader_filename = "libgupnp-av/gupnp-av.h")]
+	[Flags]
+	public enum DLNAConversion {
+		NONE,
+		TRANSCODED
+	}
+	[CCode (cprefix = "GUPNP_DLNA_FLAGS_", cheader_filename = "libgupnp-av/gupnp-av.h")]
+	[Flags]
+	public enum DLNAFlags {
+		NONE,
+		SENDER_PACED,
+		TIME_BASED_SEEK,
+		BYTE_BASED_SEEK,
+		PLAY_CONTAINER,
+		S0_INCREASE,
+		SN_INCREASE,
+		RTSP_PAUSE,
+		STREAMING_TRANSFER_MODE,
+		INTERACTIVE_TRANSFER_MODE,
+		BACKGROUND_TRANSFER_MODE,
+		CONNECTION_STALL,
+		DLNA_V15
+	}
+	[CCode (cprefix = "GUPNP_DLNA_OPERATION_", cheader_filename = "libgupnp-av/gupnp-av.h")]
+	[Flags]
+	public enum DLNAOperation {
+		NONE,
+		RANGE,
+		TIMESEEK
+	}
+	[CCode (cprefix = "GUPNP_PROTOCOL_ERROR_", has_type_id = "0", cheader_filename = "libgupnp-av/gupnp-av.h")]
+	public enum ProtocolError {
+		INVALID_SYNTAX,
+		OTHER
+	}
+	[CCode (cprefix = "GUPNP_SEARCH_CRITERIA_OP_", has_type_id = "0", cheader_filename = "libgupnp-av/gupnp-av.h")]
+	public enum SearchCriteriaOp {
+		EQ,
+		NEQ,
+		LESS,
+		LEQ,
+		GREATER,
+		GEQ,
+		CONTAINS,
+		DOES_NOT_CONTAIN,
+		DERIVED_FROM,
+		EXISTS
+	}
+	[CCode (cprefix = "GUPNP_SEARCH_CRITERIA_PARSER_ERROR_", cheader_filename = "libgupnp-av/gupnp-av.h")]
+	public errordomain SearchCriteriaParserError {
+		FAILED,
+	}
+	[CCode (cheader_filename = "libgupnp-av/gupnp-av.h")]
+	public static GLib.Quark protocol_error_quark ();
+}
--- /dev/null
+++ b/vapi/sqlite3.vapi
@@ -0,0 +1,207 @@
+/* sqlite3.vala
+ *
+ * Copyright (C) 2007 Jürg Billeter
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA
+ *
+ * Author:
+ * 	Jürg Billeter <j@bitron.ch>
+ */
+
+[CCode (lower_case_cprefix = "sqlite3_", cheader_filename = "sqlite3.h")]
+namespace Sqlite {
+	/* Database Connection Handle */
+	[Compact]
+	[CCode (free_function = "sqlite3_close", cname = "sqlite3", cprefix = "sqlite3_")]
+	public class Database {
+		public int busy_timeout (int ms);
+		public int changes ();
+		public int exec (string sql, Callback? sqlite3_callback = null, out string errmsg = null);
+		public int extended_result_codes (int onoff);
+		public int get_autocommit ();
+		public void interrupt ();
+		public int64 last_insert_rowid ();
+		public int total_changes ();
+
+		public int complete (string sql);
+		public int get_table (string sql, [CCode (array_length = false)] out weak string[] resultp, out int nrow, out int ncolumn, out string errmsg);
+		public static void free_table ([CCode (array_length = false)] string[] result);
+		public static int open (string filename, out Database db);
+		public static int open_v2 (string filename, out Database db, int flags = OPEN_READWRITE | OPEN_CREATE, string? zVfs = null);
+		public int errcode ();
+		public weak string errmsg ();
+		public int prepare (string sql, int n_bytes, out Statement stmt, out string tail = null);
+		public int prepare_v2 (string sql, int n_bytes, out Statement stmt, out string tail = null);
+		public void trace (TraceCallback? xtrace);
+		public void profile (ProfileCallback? xprofile);
+		public void commit_hook (CommitCallback? commit_hook);
+		public void rollback_hook (RollbackCallback? rollback_hook);
+	}
+
+	[CCode (instance_pos = 0)]
+	public delegate void TraceCallback (string message);
+	[CCode (instance_pos = 0)]
+	public delegate void ProfileCallback (string sql, uint64 time);
+	public delegate int CommitCallback ();
+	public delegate void RollbackCallback ();
+
+	/* Dynamically Typed Value Object */
+	[Compact]
+	[CCode (cname = "sqlite3_value")]
+	public class Value {
+		[CCode (cname = "sqlite3_value_blob")]
+		public void* to_blob ();
+		[CCode (cname = "sqlite3_value_bytes")]
+		public int to_bytes ();
+		[CCode (cname = "sqlite3_value_double")]
+		public double to_double ();
+		[CCode (cname = "sqlite3_value_int")]
+		public int to_int ();
+		[CCode (cname = "sqlite3_value_int64")]
+		public int64 to_int64 ();
+		[CCode (cname = "sqlite3_value_text")]
+		public weak string to_text ();
+		[CCode (cname = "sqlite3_value_type")]
+		public int to_type ();
+		[CCode (cname = "sqlite3_value_numeric_type")]
+		public int to_numeric_type ();
+	}
+
+	[CCode (cname = "sqlite3_callback", instance_pos = 0)]
+	public delegate int Callback (int n_columns, [CCode (array_length = false)] string[] values, [CCode (array_length = false)] string[] column_names);
+
+	[CCode (cname = "SQLITE_OK")]
+	public const int OK;
+	[CCode (cname = "SQLITE_ERROR")]
+	public const int ERROR;
+	[CCode (cname = "SQLITE_INTERNAL")]
+	public const int INTERNAL;
+	[CCode (cname = "SQLITE_PERM")]
+	public const int PERM;
+	[CCode (cname = "SQLITE_ABORT")]
+	public const int ABORT;
+	[CCode (cname = "SQLITE_BUSY")]
+	public const int BUSY;
+	[CCode (cname = "SQLITE_LOCKED")]
+	public const int LOCKED;
+	[CCode (cname = "SQLITE_NOMEM")]
+	public const int NOMEM;
+	[CCode (cname = "SQLITE_READONLY")]
+	public const int READONLY;
+	[CCode (cname = "SQLITE_INTERRUPT")]
+	public const int INTERRUPT;
+	[CCode (cname = "SQLITE_IOERR")]
+	public const int IOERR;
+	[CCode (cname = "SQLITE_CORRUPT")]
+	public const int CORRUPT;
+	[CCode (cname = "SQLITE_NOTFOUND")]
+	public const int NOTFOUND;
+	[CCode (cname = "SQLITE_FULL")]
+	public const int FULL;
+	[CCode (cname = "SQLITE_CANTOPEN")]
+	public const int CANTOPEN;
+	[CCode (cname = "SQLITE_PROTOCOL")]
+	public const int PROTOCOL;
+	[CCode (cname = "SQLITE_EMPTY")]
+	public const int EMPTY;
+	[CCode (cname = "SQLITE_SCHEMA")]
+	public const int SCHEMA;
+	[CCode (cname = "SQLITE_TOOBIG")]
+	public const int TOOBIG;
+	[CCode (cname = "SQLITE_CONSTRAINT")]
+	public const int CONSTRAINT;
+	[CCode (cname = "SQLITE_MISMATCH")]
+	public const int MISMATCH;
+	[CCode (cname = "SQLITE_MISUSE")]
+	public const int MISUSE;
+	[CCode (cname = "SQLITE_NOLFS")]
+	public const int NOLFS;
+	[CCode (cname = "SQLITE_AUTH")]
+	public const int AUTH;
+	[CCode (cname = "SQLITE_FORMAT")]
+	public const int FORMAT;
+	[CCode (cname = "SQLITE_RANGE")]
+	public const int RANGE;
+	[CCode (cname = "SQLITE_NOTADB")]
+	public const int NOTADB;
+	[CCode (cname = "SQLITE_ROW")]
+	public const int ROW;
+	[CCode (cname = "SQLITE_DONE")]
+	public const int DONE;
+	[CCode (cname = "SQLITE_OPEN_READONLY")]
+	public const int OPEN_READONLY;
+	[CCode (cname = "SQLITE_OPEN_READWRITE")]
+	public const int OPEN_READWRITE;
+	[CCode (cname = "SQLITE_OPEN_CREATE")]
+	public const int OPEN_CREATE;
+	[CCode (cname = "SQLITE_INTEGER")]
+	public const int INTEGER;
+	[CCode (cname = "SQLITE_FLOAT")]
+	public const int FLOAT;
+	[CCode (cname = "SQLITE_BLOB")]
+	public const int BLOB;
+	[CCode (cname = "SQLITE_NULL")]
+	public const int NULL;
+	[CCode (cname = "SQLITE3_TEXT")]
+	public const int TEXT;
+	[CCode (cname = "SQLITE_MUTEX_FAST")]
+	public const int MUTEX_FAST;
+	[CCode (cname = "SQLITE_MUTEX_RECURSIVE")]
+	public const int MUTEX_RECURSIVE;
+
+	/* SQL Statement Object */
+	[Compact]
+	[CCode (free_function = "sqlite3_finalize", cname = "sqlite3_stmt", cprefix = "sqlite3_")]
+	public class Statement {
+		public int bind_parameter_count ();
+		public int bind_parameter_index (string name);
+		public weak string bind_parameter_name (int index);
+		public int clear_bindings ();
+		public int column_count ();
+		public int data_count ();
+		public weak Database db_handle ();
+		public int reset ();
+		public int step ();
+		public int bind_blob (int index, void* value, int n, GLib.DestroyNotify destroy_notify);
+		public int bind_double (int index, double value);
+		public int bind_int (int index, int value);
+		public int bind_int64 (int index, int64 value);
+		public int bind_null (int index);
+		public int bind_text (int index, owned string value, int n = -1, GLib.DestroyNotify destroy_notify = GLib.g_free);
+		public int bind_value (int index, Value value);
+		public int bind_zeroblob (int index, int n);
+		public void* column_blob (int col);
+		public int column_bytes (int col);
+		public double column_double (int col);
+		public int column_int (int col);
+		public int64 column_int64 (int col);
+		public weak string column_text (int col);
+		public int column_type (int col);
+		public weak Value column_value (int col);
+		public weak string column_name (int index);
+		public weak string sql ();
+	}
+
+	[Compact]
+	[CCode (cname = "sqlite3_mutex")]
+	public class Mutex {
+		[CCode (cname = "sqlite3_mutex_alloc")]
+		public Mutex (int mutex_type = MUTEX_RECURSIVE);
+		public void enter ();
+		public int @try ();
+		public void leave ();
+	}
+}
+
