diff -uNr a/libgupnp/gupnp-root-device.c b/libgupnp/gupnp-root-device.c
--- a/libgupnp/gupnp-root-device.c	2012-12-17 17:32:30.913281593 +0800
+++ b/libgupnp/gupnp-root-device.c	2012-12-17 17:35:49.357607689 +0800
@@ -47,6 +47,9 @@
         char  *description_path;
         char  *description_dir;
         char  *relative_location;
+
+        gboolean acl_enable;
+        GHashTable *acl;
 };
 
 enum {
@@ -68,6 +71,7 @@
         g_free (device->priv->description_path);
         g_free (device->priv->description_dir);
         g_free (device->priv->relative_location);
+        g_hash_table_destroy(device->priv->acl);
 
         /* Call super */
         object_class = G_OBJECT_CLASS (gupnp_root_device_parent_class);
@@ -455,6 +459,8 @@
 
         fill_resource_group (element, location, device->priv->group);
 
+        device->priv->acl = g_hash_table_new_full(g_str_hash, g_str_equal, g_free, g_free);
+
  DONE:
         /* Cleanup */
         g_free (location);
@@ -698,3 +704,103 @@
 
         return root_device->priv->description_dir;
 }
+
+/**
+ * gupnp_root_device_acl_permit:
+ * @root_device: A #GUPnPRootDevice
+ * @ip: ip address of control point which is allowed to control this device
+ * @live_time: live time of this permited ip address
+ *
+ * Allow a control point to control @root_device.
+ **/
+void
+gupnp_root_device_acl_permit (GUPnPRootDevice *root_device, char *ip, guint live_time)
+{
+        GTimeVal *timeout;
+
+        g_return_if_fail (GUPNP_IS_ROOT_DEVICE (root_device));
+
+        if(!root_device->priv->acl_enable)
+        {
+            /*no need to add acl entry when acl is disabled*/
+            return;
+        }
+
+        timeout = (GTimeVal *)g_hash_table_lookup ( root_device->priv->acl, ip);
+        if(timeout)
+        {
+            g_get_current_time(timeout);
+            timeout->tv_sec += live_time;
+            return;
+        }
+        else
+        {
+            timeout = g_new(GTimeVal, 1);
+            if(!timeout)
+                return;
+
+            g_get_current_time(timeout);
+            timeout->tv_sec += live_time;
+            g_hash_table_insert ( root_device->priv->acl, g_strdup(ip), (gpointer)timeout);
+        }
+}
+
+static gboolean acl_check_timeout(gpointer key, gpointer value, gpointer user_data)
+{
+    GTimeVal now, *timeout;
+
+    if(NULL != user_data)
+    {
+        /*flush all entry*/
+        return TRUE;
+    }
+
+    timeout = (GTimeVal *)value;
+    g_get_current_time(&now);
+
+    return (now.tv_sec > timeout->tv_sec);
+}
+
+/**
+ * gupnp_root_device_acl_is_permit:
+ * @root_device: A #GUPnPRootDevice
+ * @ip: ip address of control point which is allowed to control this device
+ *
+ * Return value: whether is a control point allowed to control @root_device.
+ **/
+gboolean
+gupnp_root_device_acl_is_permit (GUPnPRootDevice *root_device, char *ip)
+{
+        g_return_val_if_fail (GUPNP_IS_ROOT_DEVICE (root_device), FALSE);
+
+        if(!root_device->priv->acl_enable)
+        {
+            /*always permit controling when acl is disabled*/
+            return TRUE;
+        }
+
+        g_hash_table_foreach_remove(root_device->priv->acl, acl_check_timeout, NULL);
+
+        return (NULL != g_hash_table_lookup ( root_device->priv->acl, ip));
+}
+
+/**
+ * gupnp_root_device_acl_enable:
+ * @root_device: A #GUPnPRootDevice
+ * @enable: enable or disable acl
+ *
+ * enable or disable acl on @root_device.
+ **/
+void
+gupnp_root_device_acl_enable (GUPnPRootDevice *root_device, gboolean enable)
+{
+        g_return_if_fail (GUPNP_IS_ROOT_DEVICE (root_device));
+
+        root_device->priv->acl_enable = enable;
+        if(!enable)
+        {
+            /*flush all entry when disable acl*/
+            g_hash_table_foreach_remove(root_device->priv->acl, acl_check_timeout, (gpointer)1);
+        }
+}
+
diff -uNr a/libgupnp/gupnp-root-device.h b/libgupnp/gupnp-root-device.h
--- a/libgupnp/gupnp-root-device.h	2012-12-17 17:32:34.689531738 +0800
+++ b/libgupnp/gupnp-root-device.h	2012-12-17 17:27:22.829281973 +0800
@@ -110,6 +110,15 @@
 gupnp_root_device_get_description_dir
                                   (GUPnPRootDevice      *root_device);
 
+void
+gupnp_root_device_acl_enable (GUPnPRootDevice *root_device, gboolean enable);
+
+void
+gupnp_root_device_acl_permit (GUPnPRootDevice *root_device, char *ip, guint live_time);
+
+gboolean
+gupnp_root_device_acl_is_permit (GUPnPRootDevice *root_device, char *ip);
+
 G_END_DECLS
 
 #endif /* __GUPNP_ROOT_DEVICE_H__ */
diff -uNr a/libgupnp/gupnp-service.c b/libgupnp/gupnp-service.c
--- a/libgupnp/gupnp-service.c	2012-12-17 17:32:14.673281550 +0800
+++ b/libgupnp/gupnp-service.c	2012-12-17 17:27:22.829281973 +0800
@@ -196,6 +196,8 @@
         xmlNode      *node;
 
         GString      *response_str;
+
+	char         *remote_ip;
 };
 
 GUPnPServiceAction *
@@ -217,6 +219,7 @@
 
         if (g_atomic_int_dec_and_test (&action->ref_count)) {
                 g_free (action->name);
+		g_free (action->remote_ip);
                 g_object_unref (action->msg);
                 g_object_unref (action->context);
                 g_object_unref (action->doc);
@@ -759,6 +762,23 @@
         return g_object_ref (action->msg);
 }
 
+/**
+ * gupnp_service_action_get_remote_ip:
+ * @action: A #GUPnPServiceAction
+ *
+ * Get the #SoupMessage associated with @action. Mainly intended for
+ * applications to be able to read HTTP headers received from clients.
+ *
+ * Return value: ip address of remote control point
+ **/
+const char *
+gupnp_service_action_get_remote_ip (GUPnPServiceAction *action)
+{
+	g_return_val_if_fail (action != NULL, NULL);
+
+        return action->remote_ip;
+}
+
 static void
 gupnp_service_init (GUPnPService *service)
 {
@@ -956,6 +976,7 @@
 
         action->ref_count    = 1;
         action->name         = g_strdup (action_name);
+	action->remote_ip    = g_strdup (soup_client_context_get_host(soup_client));
         action->msg          = g_object_ref (msg);
         action->doc          = gupnp_xml_doc_new(doc);
         action->node         = action_node;
@@ -966,6 +987,23 @@
         /* Tell soup server that response is not ready yet */
         soup_server_pause_message (server, msg);
 
+        if(!gupnp_root_device_acl_is_permit(service->priv->root_device, (char *)soup_client_context_get_host(soup_client)))
+        {
+            /*only UserAuthentication and IsAuthenticated are allowed before control point was authenticated*/
+            if((strcmp(action_name, "UserAuthentication") != 0) 
+                && (strcmp(action_name, "IsAuthenticated") != 0))
+            {
+                gupnp_service_action_return_error(action, 606, "Action not Authorized");
+
+                return;
+            }
+        }
+        else
+        {
+            /*update live time to 1 day if authenticated*/
+            gupnp_root_device_acl_permit(service->priv->root_device, (char *)soup_client_context_get_host(soup_client), 24*3600);
+        }
+
         /* QueryStateVariable? */
         if (strcmp (action_name, "QueryStateVariable") == 0)
                 query_state_variable (service, action);
diff -uNr a/libgupnp/gupnp-service.h b/libgupnp/gupnp-service.h
--- a/libgupnp/gupnp-service.h	2012-12-17 17:32:19.169781964 +0800
+++ b/libgupnp/gupnp-service.h	2012-12-17 17:27:22.829281973 +0800
@@ -161,6 +161,9 @@
 SoupMessage *
 gupnp_service_action_get_message  (GUPnPServiceAction *action);
 
+const char *
+gupnp_service_action_get_remote_ip (GUPnPServiceAction *action);
+
 void
 gupnp_service_notify              (GUPnPService *service,
                                    ...) G_GNUC_NULL_TERMINATED;
