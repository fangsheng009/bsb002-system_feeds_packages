diff -Nur a/Makefile b/Makefile
--- a/Makefile	2012-01-30 14:03:16.496911234 +0800
+++ b/Makefile	2012-01-31 11:09:12.914573168 +0800
@@ -1,40 +1,70 @@
-# $Id: Makefile 2 2007-09-01 10:00:28Z lo $
-# 
-# if you want to compile against a compiled but not installed xyssl sourcetree
-# XYSSL_SOURCE=/path/to/xyssl-src
-
-DSTROOT=/usr/local
-BINDIR=$(DSTROOT)/bin
-
-CC=gcc
-LD=gcc
-
-CFLAGS=-g -Wall
-LIBS=-lxyssl
-
-ifneq ($(XYSSL_SOURCE),)
-	CPPFLAGS+=-I$(XYSSL_SOURCE)/include
-	LDFLAGS+=-L$(XYSSL_SOURCE)/library
+# Makefile for xrelay, a SSL tunneling interface.
+#
+# TODO: there is no need for this to be a separate program any more.
+# It should be turned into a library instead.
+#
+# PRE-REQUISITE: Run ../Makefile the first time or if a sibling
+# directory has a change.
+
+# Shared Makefile stuff, place at BEGINNING of this Makefile
+# Makefile.defs needs GWTOP defined!
+ifndef STAGING_DIR
+GWTOP = ../..
+else
+GWTOP = $(STAGING_DIR)/usr/include
 endif
+include $(GWTOP)/Makefile.defs
 
-# source files
-OBJS=xrelayd.o
+# OPTIONS -----------------------------------------------------------------
 
-xrelayd: $(OBJS)
-	$(LD) $(OBJS) $(LDFLAGS) $(LIBS) -o $@
 
-%.o: %.c
-	$(CC) $(CPPFLAGS) $(CFLAGS) -c $<
+# LISTS ------------------------------------------------------------------
+
+# What we build by default:
+# Required by Makefile.rules
+ALL=xrelay
+
+# For each C file needed for xrelay, list the object file:
+PROGRAM_OBJS = \
+	xrelayd.o
+
+# OBJS is needed by Makefile.rules to properly make header files,
+# dependency files, etc.
+# Required by Makefile.rules
+OBJS = \
+    $(PROGRAM_OBJS)
+
+# List libraries needed
+LIBS += \
+	-lpolarssl
+
+# Note: libath.mk won't be found during "make clean", thus the "-" in -include
+-include $(GWINCLUDE)/libath.mk
+
+# RULES ---------------------------------------------------------------
+
+# Making default targets:
+all: local install
+	@echo Done in `pwd`
+	
+local: $(ALL)
+	@echo Made outputs in `pwd`
+
+# Doing installation (see comments at top of this file)
+install: local
+	@echo Installed outputs from `pwd`
+
+# Making our specific program
+xrelay :  $(PROGRAM_OBJS)
+	$(CC) $(CFLAGS) -o xrelay $(PROGRAM_OBJS) \
+                -Xlinker --start-group $(LIBS) -Xlinker --end-group
+
+
+# Remove all generated files
+clean: default_clean	# from Makefile.rules
+
+# END --------------------------------------------------------------------
+
+# Shared Makefile stuff, place at END of this Makefile
+include $(GWTOP)/Makefile.rules
 
-install: xrelayd
-	mkdir -p $(DSTROOT)
-	install -m0755 xrelayd $(BINDIR)
-
-.PHONY: uninstall
-uninstall:
-	rm -f $(BINDIR)/xrelayd
-
-.PHONY: clean
-clean:
-	rm -f *.o
-	rm -f xrelayd
diff -Nur a/xrelayd.c b/xrelayd.c
--- a/xrelayd.c	2012-01-30 14:03:16.496911234 +0800
+++ b/xrelayd.c	2012-01-30 14:04:31.632912022 +0800
@@ -1,4 +1,23 @@
-/* $Id: xrelayd.c 24 2007-12-25 13:35:53Z lo $
+/* xrelay -- secure tunnelling program
+*       Based upon xrelayd.c from:
+*               wget http://znerol.ch/files/xrelayd-0.2.1pre2.tar.gz
+*               See license below (BSD style).
+*       Requires polarssl library (BSD)
+*
+* The original xyrelayd program was intended to be used as either a
+* server or client, and as such it accepted connections for multiple
+* sessions.
+* This program, by contrast, supports only a single client;
+* it is intended to be connected by socketpair with the client,
+* with the socketpair directed to file descriptor 0.
+* Each invocation of this program immediately produces a new SSL/TSL connection
+* to the host given with the -r flag on the command line,
+* and terminates when that connection terminates or when file descriptor 0
+* is closed.
+*/
+
+/* Original header: */
+/* $Id: //depot/sw/branches/9.4_staging/apps/gateway/libath/xrelay/xrelayMain.c#1 $
  *
  * Copyright (c) 2007, Lorenz Schori <lo@znerol.ch>
  * All rights reserved.
@@ -28,6 +47,14 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+/* Added by Ted for Atheros: (but it doesn't save much to disable...) */
+#define OPTION_KEYGEN() 1
+#define OPTION_LOADKEYS() 1
+/* ---------- */
+/* Atheros issues:
+*       use of SSL_VERIFY_NONE -- i think this means that server
+*               certificate checking is skipped.
+*/
 
 #ifndef _CRT_SECURE_NO_DEPRECATE
 #define _CRT_SECURE_NO_DEPRECATE 1
@@ -52,22 +79,27 @@
 #include <sys/stat.h>
 #include <sys/ioctl.h>
 
+#if 0   /* original */
 #define SYSLOG_NAMES
 #include <syslog.h>
+#else
+#define	LOG_EMERG 0
+#define	LOG_ALERT 1
+#define	LOG_CRIT 2
+#define	LOG_ERR	3
+#define	LOG_WARNING 4
+#define	LOG_NOTICE 5
+#define	LOG_INFO 6
+#define	LOG_DEBUG 7
+#endif
 
-/* xassl includes */
-#include <xyssl/config.h>
-#include <xyssl/havege.h>
-#include <xyssl/certs.h>
-#include <xyssl/x509.h>
-#include <xyssl/ssl.h>
-#include <xyssl/net.h>
-
-// FIXME. implement some sort of DDOS prevention
-#define MAXCONNCOUNT 16
-
-// FIXME. configurable?
-#define RUNNING_DIR "/"
+/* polarssl includes */
+#include <polarssl/config.h>
+#include <polarssl/havege.h>
+#include <polarssl/certs.h>
+#include <polarssl/x509.h>
+#include <polarssl/ssl.h>
+#include <polarssl/net.h>
 
 #define DEFAULT_CERT_SUBJECT "CN='localhost'"
 #define DEFAULT_CERT_TIMESPAN 31536000
@@ -91,14 +123,14 @@
  */
 int xrly_ciphers[] =
 {
-#if defined(XYSSL_AES_C)
+#if defined(POLARSSL_AES_C)
     SSL_RSA_AES_128_SHA,
     SSL_RSA_AES_256_SHA,
 #endif
-#if defined(XYSSL_DES_C)
+#if defined(POLARSSL_DES_C)
     SSL_RSA_DES_168_SHA,
 #endif
-#if defined(XYSSL_ARC4_C)
+#if defined(POLARSSL_ARC4_C)
     SSL_RSA_RC4_128_SHA,
     SSL_RSA_RC4_128_MD5,
 #endif
@@ -108,43 +140,16 @@
 /* key generation */
 #define EXPONENT 65537
 
-int             servermode = 1;
 char            *dst_host = "localhost";
 int             dst_port    = 0;
-int             nosysl=0;
-int             nofork=0;
-int             quit=0;
-char*           pidfile=NULL;
 int loglevel = LOG_NOTICE;
 
-void sigchld_handler(int s)
-{
-        while(waitpid(-1, NULL, WNOHANG) > 0);
-}
-
-void kill_handler(int s)
-{
-    char* signame="unknown";
-    switch(s) {
-        case SIGQUIT    : signame="QUIT"; break;
-        case SIGHUP     : signame="HUP"; break;
-        case SIGTERM    : signame="TERM"; break;
-    }
-    NLOG("Caugth %s signal. Terminate",signame);
-    quit=1;
-}
-
 void usage(int status)
 {
-    fprintf(stderr, "usage: [-c] [-v] [-d localip:port] [-r remoteip:port]\n\n"
+    fprintf(stderr, "usage: [-r remoteip:port]\n\n"
                     "    -A      Server certificate file (may change to CA file in future) \n"
                     "    -p      private key and certificate chain PEM file name\n"
-                    "    -c      client mode. remote is ssl, local plain\n"
-                    "    -v      validate certificate\n"
-                    "    -d      listen locally on this [host:]port\n"
                     "    -r      connect to remote machine on [host:]port\n"
-                    "    -P      pidfile\n"
-                    "    -f      foreground mode\n"
                     "    -D      syslog level (0...7)\n"
                     "\n"
                     "  Options for private key and x509 certificate generation\n"
@@ -155,6 +160,7 @@
     exit(status);
 }
 
+#if 0   /* original */
 void
 getprio(int pri, char *res, int reslen)
 {
@@ -168,71 +174,31 @@
     else
         snprintf(res, reslen, "%s", c_pri->c_name);
 }
+#endif
 
 void dolog(int prio, const char *fmt, ...)
 {
     va_list ap;
+    #if 0       /* original */
     char    logprio[20];
+    #endif
 
-    if(nosysl && prio <= loglevel) {
+    if(prio <= loglevel) {
         time_t  ct=time(NULL);
         char*   cs=ctime(&ct);
         
+        #if 0   /* original */
         getprio(prio,logprio,sizeof(logprio));
         fprintf(stderr,"[%-6s] ",logprio);
+        #else
+        fprintf(stderr,"XRLY [Level %d] ",prio);
+        #endif
         fprintf(stderr,"%.15s xrelayd[%.4d] ",&cs[4],getpid());
         va_start(ap, fmt);
         (void) vfprintf(stderr, fmt, ap);
         va_end(ap);
         fprintf(stderr,"\n");
     }
-    else {
-        va_start(ap, fmt);
-        vsyslog(prio, fmt, ap);
-        va_end(ap);
-    }
-}
-
-void daemonize()
-{
-    int i,lfp;
-    char str[10];
-    
-    if(getppid()==1) return; /* already a daemon */
-    
-    i=fork();
-    if (i<0) exit(1); /* fork error */
-    if (i>0) exit(0); /* parent exits */
-    
-    /* child (daemon) continues */
-    setsid(); /* obtain a new process group */
-    close(0);
-    close(1);
-    close(2);
-    i=open("/dev/null",O_RDWR); dup(i); dup(i); /* handle standart I/O */
-    umask(027); /* set newly created file permissions */
-    chdir(RUNNING_DIR); /* change running directory */
-
-    if(pidfile) {
-        lfp=open(pidfile,O_RDWR|O_CREAT,0640);
-
-        if (lfp<0) exit(1); /* can not open */
-
-        if (lockf(lfp,F_TLOCK,0)<0) exit(0); /* can not lock */
-
-        /* first instance continues */
-        sprintf(str,"%d\n",getpid());
-
-        write(lfp,str,strlen(str)); /* record pid to lockfile */
-    }
-
-    signal(SIGCHLD,sigchld_handler); /* ignore child */
-    signal(SIGTSTP,SIG_IGN); /* ignore tty signals */
-    signal(SIGTTOU,SIG_IGN);
-    signal(SIGTTIN,SIG_IGN);
-    signal(SIGQUIT,kill_handler); /* catch hangup signal */
-    signal(SIGHUP,kill_handler); /* catch hangup signal */
-    signal(SIGTERM,kill_handler); /* catch kill signal */
 }
 
 int handle_sockres(char* op, char* conn,int res)
@@ -240,16 +206,16 @@
     if(res>0) return 0;
     
     switch( res ) {
-        case XYSSL_ERR_NET_TRY_AGAIN:
+        case POLARSSL_ERR_NET_TRY_AGAIN:
             DLOG( "%s operation on %s connection would block",op,conn);
         case 0:
             return 0;
             
-        case XYSSL_ERR_SSL_PEER_CLOSE_NOTIFY:
+        case POLARSSL_ERR_SSL_PEER_CLOSE_NOTIFY:
             ILOG( "%s connection closed by peer during %s operation",conn,op);
             break;
 
-        case XYSSL_ERR_NET_CONN_RESET:
+        case POLARSSL_ERR_NET_CONN_RESET:
             ILOG( "%s connection was reset by peer during %s operation",conn,op);
             break;
             
@@ -334,35 +300,44 @@
     return( 0 );
 }
 
-inline int proxy_send_all( int (*f_send)(void *, unsigned char *, int),
+typedef int (*proxy_send_all_cb)(void *, unsigned char *, int);
+inline int proxy_send_all( 
+    proxy_send_all_cb f_send,
+    //was: int (*f_send)(void *, unsigned char *, int),
                            void *ctx, unsigned char *buf, int len, int *eof)
 {
     int     ret=0;
     while(len) {
         if ((ret = f_send(ctx,buf,len)) <= 0) {
-            if( ret == XYSSL_ERR_NET_TRY_AGAIN ) continue;
+            if( ret == POLARSSL_ERR_NET_TRY_AGAIN ) continue;
             break;
         }
         len-=ret;
         buf+=ret;
     }
-    *eof |= (ret == XYSSL_ERR_NET_CONN_RESET);
+    *eof |= (ret == POLARSSL_ERR_NET_CONN_RESET);
     return ret;
 }
 
-inline int proxy_recv_available( int (*f_recv)(void *, unsigned char *, int),
+typedef int (*proxy_recv_available_cb)(void *, unsigned char *, int);
+inline int proxy_recv_available( 
+        proxy_recv_available_cb f_recv,
+        //was: int (*f_recv)(void *, unsigned char *, int),
                                  void *ctx, unsigned char *buf, int len, int *eof)
 {
     int     ret=0;
     ret = f_recv(ctx,buf,len);
-    *eof |= (ret == XYSSL_ERR_NET_CONN_RESET);
+    *eof |= (ret == POLARSSL_ERR_NET_CONN_RESET);
     return ret;
 }
-
+void xrelay_print(void * cookie,int level,char* msg)
+{
+	fprintf(stderr,msg);
+}
 void proxy_connection(
-    int client_fd, unsigned char client_ip[4], char* srv_host, int srv_port,
-    x509_cert *cert, rsa_context *key, int sslserver
-) {
+    int client_fd, char* srv_host, int srv_port,
+    x509_cert *cert, rsa_context *key)
+{
     int     ret;
     
     /*
@@ -386,19 +361,26 @@
     }
     
     /* setup endpoint */
-    ssl_set_endpoint( &ssl, sslserver );
+    ssl_set_endpoint( &ssl, 0 );
     
     /* FIXME: verify hook for client connections. */
-    ssl_set_authmode( &ssl, SSL_VERIFY_NONE );
-
+	if(cert)
+	{
+    	ssl_set_authmode( &ssl, SSL_VERIFY_REQUIRED);
+	}
+	else
+	{
+    	ssl_set_authmode( &ssl, SSL_VERIFY_NONE);
+	}
+    //ssl_set_dbg(&ssl,xrelay_print,NULL);
     /* random number generation */
     havege_state hs;
     havege_init( &hs );
     ssl_set_rng( &ssl, havege_rand, &hs );
     
     /* io */
-    int     *ssl_fd = sslserver ? &client_fd : &server_fd;
-    int     *plain_fd = sslserver ? &server_fd : &client_fd;
+    int     *ssl_fd = &server_fd;
+    int     *plain_fd = &client_fd;
     ssl_set_bio( &ssl, net_recv, ssl_fd,
                        net_send, ssl_fd );
     
@@ -406,7 +388,7 @@
     ssl_set_ciphers( &ssl, xrly_ciphers );
     
     if(cert && key) {
-        ssl_set_ca_chain( &ssl, cert->next, NULL );
+        ssl_set_ca_chain( &ssl, cert, NULL );
         ssl_set_own_cert( &ssl, cert, key );
     }
     
@@ -415,8 +397,14 @@
     ssl_set_scb( &ssl, my_get_session, my_set_session );
     ssl_set_session( &ssl, 1, 0, &ssn );
     
-    ILOG("Initialized SSL for %s mode",sslserver ? "server" : "client");
-    
+    ILOG("Initialized SSL for client mode");
+	if(cert)
+	{
+    	if(ssl_handshake(&ssl))
+		{
+			return;
+		}
+	}
     /*
      *  disable nagle algorithm
      */ 
@@ -429,20 +417,7 @@
     /*
      *  Handshake & Co
      */
-    if(sslserver) {
-        ILOG("Performing ssl handshake");
-        while( ( ret = ssl_handshake( &ssl ) ) != 0 ) {
-            if( ret != XYSSL_ERR_NET_TRY_AGAIN ) {
-                ELOG("SSL handshake failed: %08x", ret);
-                return;
-            }
-        }
-        ILOG("Handshake succeded");
-    }
-    
-    NLOG("Connected %s client %d.%d.%d.%d to %s server %s:%d",
-        sslserver ? "ssl" : "plain", client_ip[0],client_ip[1],client_ip[2],client_ip[3],
-        sslserver ? "plain" : "ssl", srv_host, srv_port);
+    NLOG("Connected plain client  to ssl server %s:%d", srv_host, srv_port);
     
     /*
      *  Proxy stuff
@@ -459,7 +434,7 @@
     net_set_nonblock(*plain_fd);
     net_set_nonblock(*ssl_fd);
     
-    int done=0,rret,wret;
+    int done=0,rret=0,wret=0;
     
     while(!done) {
         FD_ZERO(&rs);
@@ -485,11 +460,11 @@
             DLOG("ssl fd is set");
             do {
                 DLOG("trying to read from ssl fd %d",*ssl_fd);
-                if((rret = proxy_recv_available(ssl_read, &ssl, buf, sizeof(buf), &done)) < 0) break;
+                if((rret = proxy_recv_available((proxy_recv_available_cb)ssl_read, &ssl, buf, sizeof(buf), &done)) < 0) break;
                 DLOG("read: %d bytes",rret);
                 
                 DLOG("trying to write on plain fd %d",*plain_fd);
-                if((wret = proxy_send_all(net_send, (void*)plain_fd, buf, rret, &done)) < 0) break;
+                if((wret = proxy_send_all((proxy_send_all_cb)net_send, (void*)plain_fd, buf, rret, &done)) < 0) break;
                 DLOG("write: plain complete");
             } while(rret > 0 && rret == wret);
             
@@ -504,11 +479,11 @@
             DLOG("plain fd is set");
             do {
                 DLOG("trying to read from plain fd %d",*plain_fd);
-                if((rret = proxy_recv_available(net_recv, plain_fd, buf, sizeof(buf), &done)) < 0) break;
+                if((rret = proxy_recv_available((proxy_recv_available_cb)net_recv, plain_fd, buf, sizeof(buf), &done)) < 0) break;
                 DLOG("read: %d bytes",rret);
                 
                 DLOG("trying to write on ssl fd %d",*ssl_fd);
-                if((wret = proxy_send_all(ssl_write, (void*)&ssl, buf, rret, &done)) < 0) break;
+                if((wret = proxy_send_all((proxy_send_all_cb)ssl_write, (void*)&ssl, buf, rret, &done)) < 0) break;
                 DLOG("write: ssl complete");
             } while(rret > 0 && rret == wret);
             
@@ -524,30 +499,23 @@
     ssl_free( &ssl );
     memset( &ssl, 0, sizeof( ssl ) );
     
-    net_close(client_fd);
-    ILOG("Closed %s connection from %d.%d.%d.%d",client_fd==*ssl_fd ? "ssl" : "plain",
-        client_ip[0],client_ip[1],client_ip[2],client_ip[3]);
     net_close(server_fd);
-    ILOG("Closed %s connection to %s:%d",server_fd==*ssl_fd ? "ssl" : "plain",srv_host,srv_port);
+    ILOG("Closed ssl connection to %s:%d",srv_host,srv_port);
     
-    NLOG("Closed connection between %s client %d.%d.%d.%d and %s server %s:%d",
-        sslserver ? "ssl" : "plain", client_ip[0],client_ip[1],client_ip[2],client_ip[3],
-        sslserver ? "plain" : "ssl", srv_host, srv_port);
+    NLOG("Closed connection between plain client and ssl server %s:%d",
+        "ssl", srv_host, srv_port);
 }
 
 int main(int argc, char** argv)
 {
+    int             client_fd = 0/*STDIN (should be a socketpair)*/;
     // options
-    char            *srv_host = NULL;
-    int             srv_port = 0;
     char            *keyfile = NULL; //"privkeySrv.pem";
     char            *certfile = NULL; //"certSrv.pem";
     // int             vlevel = 0;
     char            *cpos;
     int             c,intarg,tmpport,genstuff=0,exitaftergen=0,keysize=1024;
     char            *cert_subject=DEFAULT_CERT_SUBJECT;
-    time_t          cert_notbefore=time(NULL);
-    time_t          cert_notafter=0;
     int             cert_timespan=DEFAULT_CERT_TIMESPAN;
 
     // return code
@@ -560,27 +528,6 @@
         }
 
         switch (c) {
-            case 'c':
-                // client mode
-                servermode=0;
-                break;
-            
-            case 'd':
-                // daemon mode [host:]port
-                cpos = NULL;
-                tmpport = 0;
-                if((cpos = strchr(optarg,':'))) {               
-                    *cpos = '\0';
-                    if(optarg && optarg[0])
-                        srv_host = optarg;
-                    optarg = ++cpos;
-                }
-                if(optarg && optarg[0]) {
-                    tmpport = (int)strtol(optarg, (char **)NULL, 0);
-                    if(tmpport) srv_port = tmpport;
-                }
-                break;
-            
             case 'r':
                 // remote [host:]port
                 cpos = NULL;
@@ -607,33 +554,6 @@
                 certfile = optarg;
                 break;
             
-            case 'v':
-                // veryfication level
-                if(optarg && optarg[0]) {
-/*
-                    vlevel = (int)strtol(optarg, (char **)NULL, 0);
-                    if(vlevel == 1 ) {
-                        cervalidator = certChecker;
-                    }
-                    else if(vlevel > 3 || vlevel < 0) {
-                        fprintf(stderr,"-v takes whole numbers between 0 and 3");
-                        exit(2);
-                    }
-*/
-                }
-                break;
-            
-            case 'P':
-                // create a pidfile
-                pidfile=optarg;
-                break;
-                
-            case 'f':
-                // run in foreground.
-                nofork=1;
-                nosysl=1;
-                break;
-                
             case 'o':
                 // append logmessages to a file instead of stdout/syslog
                 break;
@@ -690,7 +610,7 @@
         }
     }
     
-    if(!srv_port || !dst_port) {
+    if(!dst_port) {
         if(genstuff) {
             exitaftergen=1;
         }
@@ -699,176 +619,61 @@
         }
     }
 
-/* install handlers */
-    signal(SIGCHLD,sigchld_handler); /* ignore child */
-    signal(SIGQUIT,kill_handler); /* catch hangup signal */
-    signal(SIGHUP,kill_handler); /* catch hangup signal */
-    signal(SIGTERM,kill_handler); /* catch kill signal */
-    
-    if(!nosysl) {
-        openlog("xrelayd", LOG_PID, LOG_DAEMON);
-        setlogmask(LOG_UPTO(loglevel));
-    }
-    
-    x509_cert       cert;
-    rsa_context     key;
-    havege_state    hs;
+    x509_cert       cert,* pcert =NULL;
+    rsa_context     key,* pkey =NULL;
     int             ret;
     
     // key
-    if(genstuff && servermode) {
-        // generate key if desired
-        ILOG("Generating private key");
-        havege_init( &hs );
-        rsa_init( &key, RSA_PKCS_V15, 0, havege_rand, &hs );
-        ret = rsa_gen_key( &key, keysize, EXPONENT);
-        if(ret) {
-            ELOG("Failed to generate private key: %08x",ret);
-            goto fail;
-        }
-        if(keyfile) {
-            // write out PEM-keyfile here
-            x509write_keyfile(&key, keyfile, X509_OUTPUT_PEM); 
-        }
-    }
-    else if(keyfile) {
+    if(keyfile) {
+        #if OPTION_LOADKEYS()
         ILOG("Loading the private key");
         ret = x509parse_keyfile(&key, keyfile, NULL);
         if(ret) {
             ELOG("Failed to load private key: %08x, %s",ret,strerror(errno));
             goto fail;
         }
-    }
-    else if(servermode){
-        ELOG("A private key is required in server mode");
-        usage(1);
+		pkey = &key;
+        #else  // if OPTION_LOADKEYS()
+        ELOG("Not compiled for key/cert loading.");
+        goto fail;
+        #endif  // if OPTION_LOADKEYS()
     }
     
     // cert
     memset(&cert, 0, sizeof(x509_cert));
-    x509_raw raw_cert;
-    char    notbefore[24],notafter[24];
-
-    if(genstuff && servermode) {
-        // generate self signed certificate
-        ILOG("Generating x509 certificate");
-        x509write_init_raw(&raw_cert);
-
-        x509write_add_pubkey(&raw_cert,&key);
-        x509write_add_subject(&raw_cert,cert_subject);
-        x509write_add_issuer(&raw_cert,cert_subject);
-        
-        struct tm *tm;
-        tm=gmtime(&cert_notbefore);
-        strftime(notbefore,sizeof(notbefore),"%Y-%m-%d %H:%M:%S %Z",tm);
 
-        if(!cert_notafter) {
-            cert_notafter=cert_notbefore + cert_timespan;
-        }
-        tm=gmtime(&cert_notafter);
-        strftime(notafter,sizeof(notafter),"%Y-%m-%d %H:%M:%S %Z",tm);
-        
-        x509write_add_validity(&raw_cert,notbefore,notafter); 
-        x509write_create_selfsign(&raw_cert,&key);
-        
-        if(certfile) {
-            // write cert in PEM format
-            x509write_crtfile(&raw_cert, certfile, X509_OUTPUT_PEM);       
-        }
-        
-        // convert raw to cert.
-        x509parse_crt(&cert, raw_cert.raw.data, raw_cert.raw.len);
-        
-        x509write_free_raw(&raw_cert);
-    }
-    else if(certfile) {
+    if(certfile) {
+        #if OPTION_LOADKEYS()
         ILOG("Loading the server certificate");
         ret = x509parse_crtfile(&cert, certfile);
         if(ret) {
             ELOG("Failed to load server certificate: %08x, %s",ret,strerror(errno));
             goto fail;
         }
-    }
-    else if(servermode){
-        ELOG("A certificate is required in server mode");
-        usage(1);
+		pcert = & cert;
+        #else  // if OPTION_LOADKEYS()
+        ELOG("Not compiled for key/cert loading.");
+        goto fail;
+        #endif  // if OPTION_LOADKEYS()
     }
     
     if(exitaftergen) {
         goto succeed;
     }
 
-    // go to background
-    if(!nofork) {
-        daemonize();
-    }
-    
-    // open listening socket
-    int             srv_fd, client_fd;
-    ret = net_bind( &srv_fd, srv_host, srv_port );
-    if(ret) {
-        ELOG("Failed to open server port %d: %08x, %s",srv_port,ret,strerror(errno));
-        goto fail;
-    }
-    
-    /*
-     *  Main connection loop
-     */
-    unsigned char   client_ip[4];
-    fd_set rs;
-    
-    NLOG("Listening for %s connections on server port %d",servermode ? "ssl" : "plain",srv_port);
-    while (!quit) {
-        FD_ZERO(&rs);
-        FD_SET(srv_fd, &rs);
-        
-        if((ret = select(srv_fd+1,&rs,NULL,NULL,NULL))<0) {
-            continue;
-        }
-        
-        ret = net_accept( srv_fd, &client_fd, client_ip );
-        if(ret) {
-            ELOG("Failed to accept client on server port %d: %08x, %s",srv_port,ret,strerror(errno));
-            goto fail;
-        }
-        
-        ILOG("Got %s connection from %d.%d.%d.%d on server port %d",servermode ? "ssl" : "plain",
-            client_ip[0],client_ip[1],client_ip[2],client_ip[3],srv_port);
-        
-        /*
-         *  fork
-         */
-        
-        if((ret=fork()) < 0) {
-            // we got an error while forking. terminate.
-            ELOG("fork() failed: %s (%d)",strerror(errno),errno);
-            break;
-        }
-        else if(ret == 0) {
-            // child
-            close(srv_fd);
-            proxy_connection(client_fd,client_ip,dst_host,dst_port,&cert,&key,servermode);
-            exit(0);
-        }
-        // parent
-        close(client_fd);
-    }
+    /* In this program, we immediately do one connection and then
+    *  terminate when that connection is broken (or if fd 0 is closed).
+    */
+    proxy_connection(client_fd,dst_host,dst_port,pcert,&key);
 
 succeed: 
     status=0;
     
 fail:
-    if(srv_port) {
-        NLOG("Closing server port %d",srv_port);
-        net_close(srv_fd);
-    }
-
+    #if OPTION_LOADKEYS()       // not required anyway since we're exiting
     x509_free( &cert );
     rsa_free( &key );
-    
-    if(!nosysl) {
-        closelog();
-    }
+    #endif      // OPTION_LOADKEYS()
     
     NLOG("Terminated with status %d",status);
     exit(status);
